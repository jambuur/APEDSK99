*====================================
*
* TI DISK CONTROLLER ROM   >4000-5FFF
* 
* initial commented disassembly by Thierry Nouspikel
* (see http://www.unige.ch/medecine/nouspikel/ti99/titechpages.htm)
*
* adapted for APEDSK99 by Jochen Buur
* github.com/jambuur/APEDSK99
*
*
*====================================

RDINT	EQU	>5FEA			issue read interrupt (R6 counter) 
CRURD	EQU	>5FEC			APEDSK: we don't seem to need emulated 8 CRU input bits
CRUWRI	EQU	>5FEE			emulated 8 CRU output bits
RSTAT	EQU	>5FF0			read FD1771 Status register
RTRACK	EQU	>5FF2			read FD1771 Track register
RSECTR	EQU	>5FF4			read FD1771 Sector register
RDATA	EQU	>5FF6			read FD1771 Data register
WCOMND	EQU	>5FF8			write FD1771 Command register
WTRACK	EQU	>5FFA			write FD1771 Track register
WSECTR	EQU	>5FFC			write FD1771 Sector register
WDATA	EQU	>5FFE			write FD1771 Data register

	AORG	>4000

DSRDTA	BYTE	>AA			standard header mark
	BYTE	>02			version 2
	DATA	>0000			no programs
	DATA	PWRUP			power-up chain ptr
	DATA	>0000			programs chain ptr (none)
	DATA	DSR01			DSR chain ptr
	DATA	SUB01			subprograms chain ptr
	DATA	>0000			ISR chain ptr (none)
	DATA	>0000			
					
SUB01	DATA	SUB02			link to next subprogram
	DATA	ESUB01			address of that one
	DATA	>0110			subprogram name: >10 (sector R/W)
SUB02	DATA	SUB03			
	DATA	ESUB02			
	DATA	>0111			subprogram >11 (format disk)
SUB03	DATA	SUB04			
	DATA	ESUB03			
	DATA	>0112			subprogram >12 (file un/protect)
SUB04	DATA	SUB05			
	DATA	ESUB04			
	DATA	>0113			subprogram >13 (file rename)
SUB05	DATA	SUB06			
	DATA	ESUB05			
	DATA	>0114			subprogram >14 (file direct input)
SUB06	DATA	SUB07			
	DATA	ESUB06			
	DATA	>0115			subprogram >15 (file direct output)
SUB07	DATA	SUB08			
	DATA	ESUB07			
	DATA	>0116			subprogram >16 (number of files)
SUB08	DATA	>0000			no more
	DATA	ESUB08			
	BYTE	>05			
	TEXT	'FILES'			same as >16, called from Basic
					
PWRUP	DATA	>0000			power-up chain (no more)
	DATA	EPWRUP			address of power-up routine
	DATA	>0000			no name
					
DSR01	DATA	DSR02			DSR chain
	DATA	EDSR01			address of DSR
	BYTE	>03			name size
	TEXT	'DSK'			DSR name
DSR02	DATA	DSR03			
	DATA	EDSR02			
	BYTE	>04			
	TEXT	'DSK1'			
	EVEN				
DSR03	DATA	DSR04			
	DATA	EDSR03			
	BYTE	>04			
	TEXT	'DSK2'			
	EVEN				
DSR04	DATA	>0000			no more
	DATA	EDSR04			
	BYTE	>04			
	TEXT	'DSK3'			
	EVEN				

*=====================================
* Power-up routine
*=====================================					
EPWRUP	MOV	R12,R7			Dhr. F.G. Kaal check: are we powering up CRU >1000 peripheral?
	CI	R7,>1000
	JNE	NOCRU	

	MOV	R11,R7			save return address
	STWP	R9			get workspace (should be >83E0)
	AI	R9,-224			point to top of scratch-pad mem (>8300)
	MOV	@>0070(R9),R0		highest free address in vdp mem (>8370)
	MOV	R0,R2			save it
	AI	R0,-2088		we'll need >828 bytes
	MOV	R0,@>0070(R9)		update address
	INC	R0			
	BL	@VDPSET			set VDP address
	LI	R1,2088			
H001	CLR	@-2(R15)		clear these >828 bytes
	DEC	R1			
	JNE	H001			
	BL	@VDPSET			set VDP address (same)
	LI	R3,>AA03			
	MOVB	R3,@-2(R15)		write buffer ID mark
	NOP				
	MOVB	R2,@-2(R15)		write old highest free address
	SWPB	R2			
	MOVB	R2,@-2(R15)			
	NOP				
	MOVB	R12,@-2(R15)		APEDSK: write CRU base of disk controller; not necessary but it ups VDP address
	SWPB	R3			
	MOVB	R3,@-2(R15)		write number of files (3)
	BL	@PRPRTN			preparation routine
	BL	@CALSUB			call subroutine
	DATA	RSTDRV			reset all drives
	CLR	@>0054(R9)		name length = 0 for power-up
	BLWP	@>005A(R9)		retrieve R7 (saved by PRPRTN)
	DATA	>0011			put it into R11
	MOV	@K001,@>006C(R9)	???
NOCRU	B	*R11			return
					
K001	DATA	>0404			
					
VDPSET	ORI	R0,>4000		set VDP for a write
	SWPB	R0			
	MOVB	R0,*R15			pass address
	SWPB	R0			
	MOVB	R0,*R15			
	B	*R11			

*---------------------------------------
* Sector read/write
*---------------------------------------					
*SECRW1	LI	R4,10			try ten times. APEDSK: no need to retry
SECRW1	MOVB	@K002,@>0050(R9)	no error
*SECRW2	MOVB	@K002,@>0050(R9)	no error
	BL	@SELDRV			select drive
	BL	@LASTRK			point to # of last track
	CLR	R0			
	MOVB	@-1026(R15),R0		get # of last track accessed
*	CI	R0,>D700		inverted
	CI	R0,>2800		APEDSK: none of this inverting databus rubbish
	JH	H002			too high: drive was reset
	BL	@SKTRK0			seek track 0
*	SETO	R0			
	CLR	R0			APEDSK: none of this inverting databus rubbish
H002	MOVB	R0,@WTRACK		place >00 in track register
	MOV	@>004A(R9),R1		sector #
*	SBZ	7			side 0
	SZCB	@SIDE01,@CRUWRI		APEDSK: side 0 
	CLR	R7			
	CI	R1,>02D0		max 720 (DS/SD)
	JHE	H003			error 7
	CI	R1,>0168		on which side is it?
	JL	H004			0-359: on side 0 
	AI	R1,-719			on side 1: sector # grow from in to out
	ABS	R1			719 - sector #
	CLR	R0			
	DIV	@K003,R0		sect/track (=9)
	AI	R1,-8			invert: 8=0, 0=8, 7=1, etc
	ABS	R1			
*	SBO	7			side 1
	SOCB	@SIDE01,@CRUWRI		APEDSK: side 1
	LI	R7,>0100		side number = >01
	JMP	H005			
H004	CI	R1,>0001		is it sector 0 or 1?
	JH	H006			no
	BL	@SKTRK0			yes: seek track 0
H006	CLR	R0			
	DIV	@K003,R0		R0=track #, R1=sector #
H005	SWPB	R0			
*	INV	R0			APEDSK: none of this inverted databus rubbish		
	BL	@VDPWRI			set VDP to write
	MOVB	R0,@-2(R15)		save # of last track accessed
	MOVB	R0,@WDATA		pass to data register
	SWPB	R1			
*	INV	R1			APEDSK: none of this inverted databus rubbish
	MOVB	R1,@WSECTR		pass new sector # to sector register
*	CB	R0,@RTRACK		new track # same as current?
*	JEQ	H007			yes
*	JEQ	H013			APEDSK: no need to check if side is correct
	BL	@SNDCMD			send command
*	DATA	>E100			seek h=1 V=1 r1r0=10
	DATA	>1E00			APEDSK: seek h=1 V=1 r1r0=10
*	BL	@WTCPT1			APEDSK not relevant: wait for command completion
*	SLA	R0,13			test seek error bit
*	JOC	H008			try again, then error 11
*H007	LI	R6,5			APEDSK: H007 slightly re-arranged to sync proper ID byte read
*	MOV 	R6,@RDINT		APEDSK: interrupt Arduino for read operation
*	BL	@SNDCMD			send command
*	DATA	>3F00			read ID E=0
*	DATA	>C000			APEDSK: read ID E=0 
*	SBO	2			enable hold
*	MOVB	@RDATA,R0		skip track #
*	DEC	@RDINT		
*	MOVB	@RDATA,R5		side #
*	INV	R5			APEDSK: none of this inverted databus rubbish
*H009	MOVB	@RDATA,R0		skip next 4 bytes
*	DEC	R6			
*	DEC	@RDINT			APEDSK: read interrupt
*	JNE	H009			
*	BL	@WTCPT2			SBZ 2, wait for command completion
*	BL	@WTCPT1			APEDSK not relevant: no need to wait for command completion and error check
*	SLA	R0,13			test status bits
*	JOC	H010			not found: try again, then error 21
*	JLT	H011			crc error: try again, then error 22
*	SLA	R0,2			
*	JOC	H012			lost data: try again, then error 23
*	CB	R7,R5			side # matches?
*	JEQ	H013			yes: sector found, now access it
					
*	BL	@ERROR1			no: error 6
*	DATA	>0600			
*H008	BL	@ERROR2			gracefull error 11
*	DATA	>1100			
H003	BL	@ERROR1			error 7
	DATA	>0700			
*H010	BL	@ERROR2			gracefull error 21
*	DATA	>2100			
*H011	BL	@ERROR2			gracefull error 22
*	DATA	>2200			
*H012	BL	@ERROR2			gracefull error 23
*	DATA	>2300			
					
H013	MOVB	R1,@WSECTR		load sector register
	MOV	@>004E(R9),R2		data buffer address
	MOVB	@>004D(R9),R0		read or write ?
	JEQ	H014			write
	BL	@VDPWRI			read FD = write to VDP buffer
H015	LI	R6,256			APEDSK: slightly re-arranged H015 to sync reading sector bytes
	MOV	R6,@RDINT		APEDSK: 256 bytes / sector 
	BL	@SNDCMD			send command
*	DATA	>7700			read sector m=0 S=1 E=0 C=0
	DATA	>8800			APEDSK: read sector m=0 S=1 E=0 C=0
	SETO	R5			
*	SBO	2	
*	MOVB	@>004D(R9),R0		read or write?
*	JNE	H016			read
*	CLR	R0			write: now we must verify
*H017	MOVB	@RDATA,R0		get a byte from FDC 
*	AB	@-1026(R15),R0		compare with byte in data buffer
*	CI	R0,>FF00		
*	JNE	H018			mismatch
*	SZCB	@RDATA,R0		again
*	SB	@-1026(R15),R0			
*	JNE	H018			mismatch
*	DECT	R6			
*	DEC	R6			APEDSK:
*	JNE	H017			next byte
*	JMP	H019			done
H016	MOVB	@RDATA,R0		get 1 byte from FDC
*	INV	R0			APEDSK: none of that inverted databus rubbish
	MOVB	R0,@-2(R15)		save it to VDP
*	MOVB	@RDATA,R0		again
*	INV	R0			APEDSK: none of that inverted databus rubbish
*	MOVB	R0,@-2(R15)			
*	DECT	R6			
	DEC	@RDINT			APEDSK:
	JNE	H016			next byte
H019	CLR	R5			clear flag
*H018	BL	@WTCPT2			SBZ 2, wait for command completion
*	BL	@WTCPT1			APEDSK: no need to wait for command completion
*	SLA	R0,13			test status bits
*	JOC	H020			not found: try again, then error 21
*	JLT	H021			crc error: try again, then error 22
*	MOV	R5,R5			
*	JNE	H022			try again, then error 28
*	SLA	R0,2			
*	JOC	H023			lost data: try again, then error 23
	B	@RTURN1			return
					
*H020	BL	@ERROR2			gracefull error 21
*	DATA	>2100			
					
*H021	BL	@ERROR2			gracefull error 22
*	DATA	>2200			
*H023	BL	@ERROR2			gracefull error 23
*	DATA	>2300			
*H022	BL	@ERROR2			gracefull error 28
*	DATA	>2800			
					
H014	BL	@VDPRD			write to FD = read from VDP buffer
	BL	@SNDCMD			send command
*	DATA	>5700			write sector m=0 S=1 E=0 C=0 a=0
	DATA	>A800			APEDSK: write sector m=0 S=1 E=0 C=0 a=0
	LI	R6,256			256 bytes / sector
*	SBO	2			enable holds
H024	MOVB	@-1026(R15),R0		get a byte from data buffer
*	INV	R0			APEDSK: none of this inverting databus rubbish
	MOVB	R0,@WDATA		pass it to data register
*	MOVB	@-1026(R15),R0		again
*	INV	R0			APEDSK: none of this inverting databus rubbish
*	MOVB	R0,@WDATA			
*	DECT	R6			
	DEC	R6			APEDSK:
	JNE	H024			next
*	BL	@WTCPT2			SBZ 2, wait for command completion
	BL	@WTCPT1			APEDSK: no need to wait for command completion
	SLA	R0,11			test status bits
	JOC	ERROR3			write protect: error 34
*	SLA	R0,2			
*	JOC	H025			not found: try again, then error 31
*	SLA	R0,2			
*	JOC	H026			lost data: try again, then error 33
*	BL	@VDPRD			now, set VDP to read
*	JMP	H015			and verify sector
	JMP	H019			APEDSK: no need to verify		
					
ERROR3	BL	@ERROR1			error 34
	DATA	>3400			
*H025	BL	@ERROR2			gracefull error 31
*	DATA	>3100			
*H026	BL	@ERROR2			gracefull error 33
*	DATA	>3300			

*---------------------------------------
* Format disk
*---------------------------------------					
FMTDSK	CLR	@>004A(R9)		called by subprogram >11
	MOVB	@>004C(R9),R8		DSR version + drive #
	SRL	R8,12			keep version only
	JEQ	H027			0: standard format
	C	R8,@K002			
	JEQ	H027			1: needs DSR version 2 (this one)
	BL	@ERROR1			2: needs another version
	DATA	>0700			returns with error 7
					
H027	SZCB	@K004,@>004C(R9)	clear DSR version flags
	CB	@>0051(R9),@K005	double sided?
	JNE	H028			no
	SETO	@>004A(R9)		yes: set flag
H028	MOVB	@K002,@>0050(R9)	no error
	BL	@SELDRV			select drive
	BL	@SKTRK0			seek track 0
	CLR	R3			init track counter
H030	MOV	@>004A(R9),@>004A(R9)	check # of sides flag
	JEQ	H029			single-side
*	SBO	7			set CRU bit for side 1
	SOCB	@SIDE01,@CRUWRI		APEDSK: set CRU bit for side 1
	LI	R7,>0100		value for side 1 in sector ID
	BL	@FMTTRK			format one track
*H029	SBZ	7			set CRU bit for side 0
H029	SZCB	@SIDE01,@CRUWRI		APEDSK: set CRU bit for side 0
	CLR	R7			>00 = value for side 0 in sector ID
	BL	@FMTTRK			format one track
	BL	@SNDCMD			send command
*	DATA	>A500			step-in (T=1, h=1, V=0, r0r1=10)
	DATA	>5A00			APEDSK: step-in (T=1, h=1, V=0, r0r1=10)
*	BL	@WTCPT1			APEDSK not relevant: wait for command completion and error check
	AI	R3,>0100		one more track
	CB	R3,@>004D(R9)		all done?
	JNE	H030			no: format next one
	MOV	@>004A(R9),@>004A(R9)	check # of sides
	JEQ	H031			single-side
*	SBO	7			
	SOCB	@SIDE01,@CRUWRI		APEDSK: select side 1
*	LI	R4,10			try 10 times
READID	BL	@SKTRK0			seek track 0
	MOV	@>004E(R9),R2		data buffer address
	BL	@VDPWRI			set VDP to write
	LI	R6,5			read 6 bytes (APEDSK: first will be available as part of @SNDCMD 
	MOV	R6,@RDINT		APEDSK: slightly re-arranged READID/H032 to sync ID byte reads
	BL	@SNDCMD			send command
*	DATA	>3F00			read ID (E=0)
	DATA	>C000			APEDSK: read ID (E=0)
*	SBO	2			enable wait states
H032	MOVB	@RDATA,R0		read data register
*	INV	R0			APEDSK: none of that inverted databus rubbish
	MOVB	R0,@-2(R15)		write it to data buffer
*	MOVB	@RDATA,R0		again, why write this twice ?
*	INV	R0			APEDSK: none of that inverted databus rubbish
*	MOVB	R0,@-2(R15)			
*	DECT	R6			
	DEC	@RDINT			APEDSK: generate interrupt for next read
	JNE	H032			
*	BL	@WTCPT2			SBZ 2 then wait for command completion
*	BL	@WTCPT1			APEDSK: no need to wait for command completion
*	SLA	R0,13			check status bits
*	JOC	H033			not found
*	JLT	H034			CRC error
*	SLA	R0,2			
*	JOC	H035			lost data
	MOV	@>004E(R9),R2		address of data buffer
	INC	R2			skip track #
	BL	@VDPRD			set VDP to read from it
	CLR	R0			
	MOVB	@-1026(R15),R0		read one byte
	JEQ	H031			side 0
	MOVB	@>004D(R9),R0		side 1: get tracks/side
	SLA	R0,1			times two (since 2 sides)
	JMP	H036			
H031	MOVB	@K006,@>0051(R9)	error code 1
	MOVB	@>004D(R9),R0		get # of tracks
H036	SRL	R0,8			make it a word
	MPY	@K003,R0		times # of sectors per track
	MOV	R1,@>004A(R9)		pass total # of sectors per disk
	MOVB	@K007,@>004D(R9)	pass # of sectors per track
	B	@RTURN1			return
					
*	BL	@ERROR2			try again, or error >21
*	DATA	>2101			
*H034	BL	@ERROR2			try again, or error >22
*	DATA	>2201			
*H035	BL	@ERROR2			try again, or error >23
*	DATA	>2301			
					
FMTTRK	MOV	R11,R8			format a track
	MOV	@>004E(R9),R2		
	BL	@VDPWRI			set VDP to write to data buffer
*	LI	R6,22			write 22 sync bytes >00
	CLR	R2			sector counter
*	JMP	H037			
*H038	LI	R6,6			write 6 sync bytes >00
*H037	MOVB	@K002,@-2(R15)			
*	DEC	R6			
*	JNE	H037			
*	MOVB	@K015,@-2(R15)		write >FE (will be ID mark)
*	NOP				
*	MOVB	R3,@-2(R15)		write track #
*	NOP				
*	MOVB	R7,@-2(R15)		write side #
*	MOVB	R3,R0			track number
*	SRL	R0,8			make it a word
*	SWPB	R7			
*	MPY	@K008(R7),R0		times >00 for side 1, >06 for side 0
*	SWPB	R7			
*	A	R2,R1			add # of sectors prepared
*	DIV	@K003,R0		divide by sectors/track
*	MOVB	@K009(R1),@-2(R15)	sector #, according to interlacing pattern
*	LI	R6,-20			write 20 times
*H039	MOVB	@K010(R6),@-2(R15)	code for a CRC
*	INC	R6			
*	JNE	H039			one more
	LI	R0,>E5E5		data to put in empty sectors
H038	BL	@VDPRPW			write it 256 times
	DATA	256			
*	MOVB	@K010,@-2(R15)		write code to CRC
*	SETO	R0			>FF filler bytes
*	BL	@VDPRPW			write it 45 times
*	DATA	45			
	INC	R2			# of sectors prepared
	CI	R2,R9			
	JNE	H038			one more
*	BL	@VDPRPW			write 231 more >FF at end of track
*	DATA	231			
					
*	LI	R4,3			try 3 times
H040	MOVB	@>004E(R9),R2		top of data buffer
	BL	@VDPRD			set VDP to read from it
	BL	@SNDCMD			send command
*	DATA	>0B00			write track (E=1)
	DATA	>F400			APEDSK: write track (E=1)
*	LI	R6,3235			3235 bytes to write
	LI	R6,2304			APEDSK: 9*256 = 2304 bytes to write
*	SBO	2			enable wait states
H041	MOVB	@-1026(R15),R0		read one byte from buffer
*	INV	R0			APEDSK: none of this inverting databus rubbish
	MOVB	R0,@WDATA		send it to data register
*	MOVB	@-1026(R15),R0		why on earth is it done like that???
*	INV	R0			APEDSK: none of this inverting databus rubbish
*	MOVB	R0,@WDATA		send next byte
*	DECT	R6			
	DEC	R6			APEDSK:
	JGT	H041			next (pair of bytes) byte
*	BL	@WTCPT2			SBZ 2, then wait for command completion
	BL	@WTCPT1			APEDSK: no need to wait for command completion
	SLA	R0,11			check write protect bit
	JNC	H042			
	B	@ERROR3			error code >34 ??
H042	SLA	R0,4			test lost data bit
*	JNC	H043			ok: return
*	DEC	R4			shall we try again?
*	JNE	H040			yes
*	BL	@ERROR1			no: error code >33
*	DATA	>3300			
H043	B	*R8			return
					
VDPRPW	MOV	*R11+,R6		VDP repeated write
H044	MOVB	R0,@-2(R15)
	DEC	R6			byte in R0
	JNE	H044			number of repeats in data word
	B	*R11			

*WTCPT2	SBZ	2			wait for command completion				
WTCPT1	MOVB	@RSTAT,R0		get status. APEDSK: Not Ready bit set when SD DSK file is unavailable
*	INV	R0			APEDSK: none of that inverted databus rubbish
	JLT	ERROR4			drive not ready
*	SRC	R0,9			
*	JOC	WTCPT1			FDC busy: keep waiting. APEDSK: no busy condition
	B	*R11			
ERROR4	BL	@ERROR1			exit with error code 6, reseting all drives
	DATA	>0600			
					
SELDRV	MOV	R11,R7			select a drive
	MOV	@>0058(R9),R2
	AI	R2,-10			point to drive info
	BL	@VDPRD			set VDP to read
	MOVB	@-1026(R15),R0		get # of last drive accessed
	CLR	R5			clear flag
	CB	R0,@>004C(R9)		same as the one to be formatted?
	JEQ	H055			yes
	SETO	R5			no: set flag
H055	CLR	R0			
	MOVB	@>004C(R9),R0		get drive #
	JEQ	H056			can't be >00: error #7
	BL	@VDPWRI			set VDP to write, address in R2
	MOVB	R0,@-2(R15)		modify last drive accessed
	SWPB	R0			
	CI	R0,>0003			
	JH	H056			drive number can't be higher than 3: error #7
*	LI	R2,>0080			
*	SLA	R2,0			proper drive selection bit: >01 >02 or >04
*	AI	R12,8			CRU address of drive selection bits (4-6)
	MOV	R5,R5			test same drive flag
	JEQ	H057			
*	LDCR	@K011,3			deselect all drives
	SZCB	@DSDRVS,@CRUWRI		APEDSK: deselect all drives + side
*	AI	R12,-6			selection bits are echoed in CRU bits 1-3
*	STCR	R0,3			load CRU bits 2-4
*	MOVB	@CRURD,R0		APEDSK: read drive selection bits etc
*	SRA	R0,4			APEDSK: preserve drive selection bits (HLD bit 0 always 0)
*	AI	R12,6			back to bits 4-6
*	CZC	R2,R0			echoed properly? HELP
*	JEQ	H057			yes: go on	
*	CLR	R0			
*	MOV	@>0058(R9),R2		point to drive info
*	AI	R2,-10			
*	BL	@VDPWRI			set VDP to write to address in R2
*	MOVB	R0,@-2(R15)		clear last drive accessed
*	AI	R12,-8			back to CRU base
*	BL	@ERROR1			exit with device error
*	BYTE	>06			
*K011	BYTE	>00			
					
*H057	LDCR	R2,3			select drive
H057	SWPB	R0			APEDSK: drive # back in MSB
	SLA	R0,1			APEDSK: bit 7 is side select
	SOCB	R0,@CRUWRI		APEDSK: select drive
*	AI	R12,-8			back to cru base
*	MOV	R5,R5			test same drive flag
*	JEQ	H058			same: return
*	LI	R0,3000			different: wait while drive gets ready
*H059	SRC	R5,4			APEDSK: we don't need to wait for no drive
*	SRC	R5,4			
*	DEC	R0			
*	JNE	H059			keep waiting
H058	B	*R7			
					
H056	BL	@ERROR1			exit with error #7
	DATA	>0700			
					
SKTRK0	MOV	R11,R8			seek track 0
	BL	@SNDCMD
*	DATA	>F500			send restore command (h=1, V=0, r0r1=10)
	DATA	>0A00			APEDSK: send restore command (h=1, V=0, r0r1=10)
*	BL	@WTCPT1			APEDSK not relevant: wait for command completion
*	BL	@CKTRK0			APEDSK not relevant: test if track 0 reached, error it not
	BL	@LASTRK			set VDP to read last track #
	BL	@VDPWRI			set VDP to write at same address
	MOVB	@K012,@-2(R15)		set last track # as >FF for this drive
	B	*R8			
					
*CKTRK0	MOVB	@RSTAT,R0		check if track 0 reached
*	INV	R0			APEDSK: none of that inverted databus rubbish
*	SLA	R0,6			test the track 0 bit
*	JOC	H060			
*	B	@ERROR3			exit with error code 6, reseting all drives
*H060	B	*R11			

*RSTDRV	AI	R12,8			reset all drives
RSTDRV	SZCB 	@DSDRVS,@CRUWRI		APEDSK: reset all drives including side
*	LDCR	@K002,4			no drive selected
*	AI	R12,-8			
*	SBZ	1			motor strobe
*	SBO	1			
	MOVB	@K013,@WCOMND		send Force interrupt with no interrupt flag set
	MOV	@>0058(R9),R2		ptr to VIB buffer
	AI	R2,-10			now points to drive info buffer
	BL	@VDPWRI			set VDP to write to address in R2
	LI	R0,4			
H061	MOVB	R0,@-2(R15)		write four >00 (i.e. clear drive info)
	DEC	R0			
	JNE	H061			
*	BL	@WTCPT2			test status, reset drives if not ready
*	BL	@WTCPT1			APEDSK: no need to wait for command completion and error check
	MOVB	@K002,@>0050(R9)	no error
	B	@RTURN1			get return address from stack
					
*ERROR2	DEC	R4			gracefull error
*	JEQ	ERROR1			no more tries: error
ERROR2	JMP	ERROR1			APEDSK
*	MOV	*R11,R11		try again: get data word
*	SRC	R11,1			test return flag
*	JNC	H062			
*	B	@READID			back to read ID in format routine
*H062	CI	R4,5			
*	JH	H063			
*	BL	@SKTRK0			last 5 tries: seek track 0
*H063	B	@SECRW2			back to sector r/w routine
*H063	B	@SECRW1			back to sector r/w routine
					
ERROR1	MOV	*R11,R0			exit with error
	MOVB	R0,@>0050(R9)		place err code in >8350
	CI	R0,>0600		check if device error
	JNE	H064			no: exit
	BL	@SNDCMD			yes: reset drives
*K013	DATA	>2F00			send force interrupt, no ints
K013	DATA	>D000			APEDSK: send force interrupt, no ints (abort command)
*H065	MOVB	@RSTAT,R0		get status APEDSK: no need to test for "drive busy"
*	SRC	R0,9			test busy flag
*	JNC	H065			wait until done (inverted)
*	JOC	H065			APEDSK: wait until done
H064	B	@RTURN1			return to caller (address from stack)
					
SNDCMD	MOV	*R11+,R0		send command to FDC from data word
*	MOVB	@RSTAT,R6		get status APEDSK: no need to test for "drive busy" 
*	SLA	R6,1			test ready bit
*	SBZ	1			strobe motor. APEDSK: we don't have to strobe anything
*	SBO	1			
*	JOC	H066			ready (inverted)
*	JNC	H066			APEDSK: ready
*	JMP	SNDCMD			APEDSK: not ready, test again
*	LI	R6,30000		wait a long time
*H067	SRC	R5,4			
*	SRC	R5,4			
*	DEC	R6			
*	JNE	H067			
H066	MOVB	R0,@WCOMND		send command
*	SBO	3			signal head loaded (HLT pin) APEDSK: we don't have to load anything
*	SRC	R5,8			kill time. APEDSK: we don't have to kill anything
*	SRC	R5,8			APEDSK: we don't have to kill anything
	B	*R11			
					
LASTRK	CLR	R0			get last track # for this drive
	MOVB	@>004C(R9),R0		get drive #
	JEQ	H068			can't be 0
	SWPB	R0			
	CI	R0,3			
	JH	H068			can't be higher than 3
	MOV	@>0058(R9),R2			
	AI	R2,-10			point to last drive accessed
	A	R0,R2			point to last track for this drive
	B	@VDPRD			prepare VDP to read from address in R2
					
H068	BL	@ERROR1			exit with error code 7
	DATA	>0700			
					
VDPWRI	ORI	R2,>4000		set VDP address to write
	ANDI	R2,>7FFF		not to a register
	JMP	H069			
VDPRD	ANDI	R2,>3FFF		set VDP address to read
H069	SWPB	R2			
	MOVB	R2,*R15			write address
	SWPB	R2			
	MOVB	R2,*R15			
	ANDI	R2,>3FFF			
	B	*R11			
					
K002	BYTE	>00			
K006	BYTE	>01			
K003	BYTE	>00			sectors per track
K007	BYTE	>09			
	BYTE	>00			
*K008	BYTE	>06			
*	DATA	>0003			
K004	BYTE	>F0			
*K015 	BYTE	>FE			
*	DATA	>01F7			
*	DATA	>FFFF			
*	DATA	>FFFF			
K012	DATA	>FFFF			
	DATA	>FFFF			
	DATA	>FFFF			
	DATA	>FF00			
	DATA	>0000			
	DATA	>0000			
	DATA	>00FB			
*K010	BYTE	>F7			code for CRC
*K009	BYTE	0,7,5,3,1,8,6,4		sector interlace pattern
K005	BYTE	2			
	
	EVEN
				
CALSUB	DECT	@>0066(R9)		call subroutine, return address in stack
	MOV	@>0066(R9),R10
	BLWP	@>005A(R9)		set VDP to write to address in R10
	DATA	>0143			
	MOV	*R11+,R10		get next data word
	SWPB	R11			write return address to VDP
	MOVB	R11,@-2(R15)			
	SWPB	R11			
	MOVB	R11,@-2(R15)			
	B	*R10			branch to address in data word
					
RTURN1	MOV	@>0066(R9),R11		get return address from VDP stack
	BLWP	@>005A(R9)		
	DATA	>0162			set VDP to read from address in R11
	MOVB	@-1026(R15),R11			
	SWPB	R11			
	MOVB	@-1026(R15),R11			
	INCT	@>0066(R9)			
	B	*R11			

*---------------------------------------
* Custom routines, dealing with VDP memory
* Format is >pppr where r is routine number (0-3)
* and ppp contains parameters
* The workspace it >8300. Called by BLWP @>005A(9).
*---------------------------------------					
ECUSTM	MOV	R13,R10			save wregs ptr
	MOV	*R14+,R8		get next data word
	MOV	R8,R9			save it
	SRL	R9,4			keep parameter
	ANDI	R8,3			four possible operations
	A	R8,R8			make it a word ptr
	MOV	@>001E(13),R11		get old R15, i.e. VDP port (>8C02)
	MOV	@VECRTN(8),R8		get vector for operation
	B	*R8			branch to it
					
VECRTN	DATA	SVRVDP			save registers to VDP stack
	DATA	RVRVDP			retrieve registers
	DATA	SVDPRD			set VDP address to read
	DATA	SVDPWR			set VDP address to write
					
SVRVDP	AI	R10,22			0: save registers in VDP mem
H072	SRL	R9,1			start with R12
	JNC	H070			bits in >ppp tell which register to save (R0-R11)
	DECT	R12			previous address in VDP stack (grows down)
	MOV	*R10,R8			get register contents
	SWPB	R12			set VDP address to write
	MOVB	R12,*R11		R12 is >8366: VDP stack ptr
	SWPB	R12			
	ORI	R12,>4000			
	MOVB	R12,*R11			
	SWPB	R8			save register to VDP mem
	MOVB	R8,@-2(R11)			
	SWPB	R8			
	MOVB	R8,@-2(R11)			
	MOV	R9,R9			more to come?
	JEQ	H071			no:return
H070	DECT	R10			point to previous register
	JMP	H072			
					
RVRVDP	SLA	R9,4			1: retrieve registers from VDP mem
H074	SLA	R9,1			each bit tells whether to load
	JNC	H073			don't retrieve that one
	SWPB	R12			set VDP address to read
	MOVB	R12,*R11		R12 is >8366: VDP stack ptr
	SWPB	R12			
	ANDI	R12,>3FFF			
	MOVB	R12,*R11			
	NOP				
	MOVB	@-1026(R11),R8		get a 2-byte value from VDP
	SWPB	R8			
	MOVB	@-1026(R11),R8			
	MOV	R8,*R10			save it to register
	INCT	R12			increment ptr (stack grows downwards)
	MOV	R9,R9			more to come?
	JEQ	H071			no: return
H073	INCT	R10			next register
	JMP	H074			
H071	RTWP				
					
SVDPWR	A	R13,R9			2: set VDP for a write
	MOV	*R9,R8			
	ORI	R8,>4000		get address from reg in >..p2 (*2)
	JMP	H075			
					
SVDPRD	A	R13,R9			3: set VDP for a read
	MOV	*R9,R8
	ANDI	R8,>3FFF		get register from reg in >..p3 (*2)
H075	SWPB	R8			set VDP address
	MOVB	R8,*R11			
	SWPB	R8			
	MOVB	R8,*R11			
	RTWP				

*---------------------------------------
* Preparation subroutine
* Sets up the 4 custom subroutines
* Gets a few pointers to VDP buffers
*  >8358: copy of VIB  >8366: VDP stack ptr (grows down from drive info)
*  >8354: PAB          >8356: ptr to end-of-buffer
*---------------------------------------					
PRPFDO	INCT	R7			stop scanning upon return
PRPRTN	MOV	R11,R10			save return address
	STWP	R9			get workspace (should be >83E0)
	AI	R9,-224			top of scratch/pad mem (>8300)
	LI	R0,ECUSTM		entry to 4 custom routines
	MOV	R0,@>005C(R9)		put it in >835C
	MOV	R9,R0			
	AI	R0,>004E		workspace for these four (>834E)
	MOV	R0,@>005A(R9)		put it in >835A
					
	MOV	@>0070(R9),R8		highest free address in VDP mem
H076	INCT	R8			point to end-of-buffer word
	BL	@VPDR2B			read 2 bytes from VDP address R8, into R0
	MOV	R8,R2			save current R8
	MOV	R0,R8			get end-of-buffer word
*					APEDSK: we don't need to check for additional controllers
	MOVB	@-1026(R15),R1		get CRU of controller that reserved this mem				
*	CB	R12,R1			same as ours?
*	JNE	H076			no: use end-of-buffer to link to next buffer
	AI	R8,-266			yes: point to volume information block
	MOV	R8,@>0058(R9)		save it in >8358
	AI	R8,-10			point to disk drive info (drive #, last tracks)
	MOV	R8,@>0066(R9)		save in >8366: VDP stack ptr (DECT before writing)
	BLWP	@>005A(R9)		save R7 (return address)
	DATA	>0100			
	MOV	@>0056(R9),R7		ptr to PAB: end of DSR name
	MOV	R7,R3			save it
	S	@>0054(R9),R7		start of DSR name
	MOV	R2,@>0056(R9)		>8356: ptr to end-of-buffer word in VDP mem
	DEC	R7			point to name length byte
	CLR	R2			
	BLWP	@>005A(R9)		set VDP to read from address in R2
	DATA	>00E2			
	MOVB	@-1026(R15),R2		get name length byte
	SWPB	R2			make it a word
	S	@>0054(R9),R2		minus DSR name size: lenght of .parameters
	AI	R7,-9			point to top of PAB
	MOV	R7,@>0054(R9)		save it in >8354
	B	*R10			
					
CRFIL1	BL	@CALSUB			create file
	DATA	FNDFDR			find a FDR in disk
CRFIL2	MOV	R4,R4			found?
	JNE	CRFIL3			no
	BL	@CALSUB			yes: delete old file
	DATA	FFSVIB			free file sector in VIB bitmap
	JMP	H077			clear its FDR
					
CRFIL3	BL	@INSFDR			new file: insert a FDR in sector 1
	SETO	R1			
	BL	@CALSUB			call subroutine
	DATA	FFSBMP			find a free sector in VIB bitmap
	MOV	R0,R0			found?
	JNE	H078			yes: # in R0
	BL	@ERROR5			no: update data, then return with error
	DATA	>8000			memory full
					
H078	BLWP	@>005A(R9)		set VDP to write
	DATA	>0103			address in R8
	MOVB	R0,@-2(R15)		write sector # for FDR in sector 1
	SWPB	R0			
	MOVB	R0,@-2(R15)			
	SWPB	R0			
	MOV	@>0056(R9),R1		ptr to FDR in VDP buffers
	AI	R1,-4			ptr to sector # for FDR
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0023			address in R1
	MOVB	R0,@-2(R15)		write sector # for FDR in VDP buffer
	SWPB	R0			
	MOVB	R0,@-2(R15)			
	AI	R1,3			ptr to drive #
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0023			address in R1
	MOVB	R5,@-2(R15)		write drive # before FDR in VDP buffer
	CLR	R2			code for write
	INC	R1			
	BL	@CALSUB			call subroutine
	DATA	WRISR1			write sector 1
	MOV	@>0058(R9),R5		ptr to VIB in VDP buffers
	CLR	R4			sector 0
	BL	@CALSUB			call subroutine
	DATA	RWSEC0			write VIB to sector 0
	MOV	R5,R3			copy filename from compare buffer to FDR
	AI	R3,257			ptr to file compare buffer
	LI	R2,10			10 chars per filename
H079	BLWP	@>005A(R9)		set VDP to read
	DATA	>0062			address in R3
	MOVB	@-1026(R15),R0		get 1 char
	INC	R3			increment source ptr
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0023			address in R1
	MOVB	R0,@-2(R15)		copy 1 char
	INC	R1			increment destination ptr
	DEC	R2			# of chars in R2
	JNE	H079			next
H077	MOV	@>0056(R9),R1		FDR ptr
	AI	R1,10			skip filename
	LI	R2,246			remaining bytes in FDR
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0023			address in R1
H080	MOVB	R2,@-2(R15)		write >00
	DEC	R2			clear remainder of new FDR
	JNE	H080			next byte
	JMP	H081			write FDR to disk return to caller
					
H082	MOV	@>0056(R9),R5		check if FDR must be updated
	BLWP	@>005A(R9)		set VDP to read
	DATA	>00A2			address in R5
	MOVB	@-1026(R15),R4		get filename in file ctrl block
	JLT	H083			flag: FDR was modified, update it
	JMP	H084			
H083	ANDI	R4,>7F00		clear flag bit
	BLWP	@>005A(R9)		st VDP to write
	DATA	>00A3			address in R5
	MOVB	R4,@-2(R15)		write back filename without flag bit
H081	CLR	R2			code for write
	B	@WRFDR			write FDR to disk
H084	B	@RTURN1			return to caller
					
UPDFDR	BL	@CALSUB			update FDR + data
	DATA	UPDBF			update data buffer if necessary
	BL	@CALSUB			call subroutine
	DATA	H082			update FDR if necessary
CLRFBT	MOV	@>0056(R9),R5			
	CLR	R6			
	BLWP	@>005A(R9)		set VDP to write
	DATA	>00A3			address in R5
	MOVB	R5,@-2(R15)		clr first byte of filename in FDR
	B	@RWVIB			
					
UPDBF	MOV	@>0056(R9),R4		check if data buffer must be updated
	DEC	R4			
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0082			address in R4
	MOVB	@-1026(R15),R1		get drive #
	JLT	H085			flag: must be updated
	JMP	H086			no need to update: return
H085	ANDI	R1,>7F00		erase flag
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0083			address in R4
	MOVB	R1,@-2(R15)		write back drive # without flag
	AI	R4,-5			point to current logical record offset
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0082			address in R4
	MOVB	@-1026(R15),R3		get current logical record offset
	SWPB	R3			
	MOVB	@-1026(R15),R3			
	SWPB	R3			
	MOV	R4,R7			
	AI	R7,262			point to data buffer area
	JMP	WROFSC			
H086	B	@RTURN1			return to caller
					
FFSVIB	MOV	@>0056(R9),R2		free file sectors in VIB bitmap
	AI	R2,12			
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0042			address in R2
	MOVB	@-1026(R15),R0		get file status byte from FDR
	ANDI	R0,>0800		write protected?
	JEQ	H087			no
	BL	@ERROR5			update data if needed, the return with error
	DATA	>2000			write protected
					
H087	MOV	@>0056(R9),R8		get ptr to FDR
	AI	R8,28			point to clusters list
	SETO	R4			previous offset
H089	BL	@DECDCI			decode cluster info: sector in R1, offset in R2
	AI	R8,3			next cluster ptr
	MOV	R1,R1			
	JEQ	H088			sector 0 = no more clusters
	MOV	R2,R0			total offset
	S	R4,R2			minus previous cluster offset = cluster size
	MOV	R0,R4			new previous cluster offset
	BL	@CALSUB			call subroutine
	DATA	FRSCB1			free sectors in bitmap (from R1, # in R2)
	MOV	R8,R1			
	S	@>0056(R9),R1			
	CI	R1,>0100		end of FDR reached?
	JNE	H089			not yet
H088	B	@RTURN1			return to caller
					
RDOFSC	BL	@FDR2B1			read a sector from offset in file
	DATA	14			get # of sectors
	C	R0,R3			is desired sector in file?
	JH	H090			yes
	BL	@ERROR5			no: update data, then return with error
	DATA	>A000			past end-of-file
H090	BL	@CALSUB			call subroutine
	DATA	FSCTOF			find sector from cluster list
	A	R1,R4			put sector in R4
	SETO	R2			code for read
H091	MOV	R7,R5			buffer ptr
	B	@RWSEC0			read/write sector
					
WROFSC	BLWP	@>005A(R9)		write sector to offset in file offset in R3
	DATA	>8100			save R0 and R7
	BL	@CALSUB			call subroutine
	DATA	APSCTS			append enough sectors to reach that offset
	BLWP	@>005A(R9)		retrieve R0 and R7
	DATA	>8101			
	CLR	R2			code for write
	JMP	H091			write sector
					
APSCTS	BL	@FDR2B1			append sector(s) to a file to get offset in R3
	DATA	14			get # of sect from FDR
					
	C	R0,R3			is desired sector in file?
	JH	H092			yes: find it and return
	MOV	R0,R0			
	JEQ	H093			empty file
	DEC	R0			last sector #
H093	MOV	R3,R5			save desired sector offset
	MOV	R0,R3			last sector in file
	BL	@CALSUB			call subroutine
	DATA	FSCTOF			find sector # from offset in file
	BLWP	@>005A(R9)		save R1 (sector #)
	DATA	>4000			
	A	R4,R1			# of last sector in cluster
	MOV	R5,R4			offset of desired sector
H095	BL	@CALSUB			call subroutine
	DATA	FFSBMP			find free sector in bitmap, starting from R1
	MOV	R0,R0			found?
	JNE	H094			yes: # in R0
	MOV	R2,R5			no: save # of sectors
	BL	@ADDSEC			update FDR
	JMP	H096			return with memory full
					
H094	MOV	R1,R1			
	JEQ	H097			empty cluster
	INC	R1			one more sector in cluster
	C	R0,R1			same as the one found in bitmap?
	JEQ	H098			yes: just increase cluster size
	BLWP	@>005A(R9)		no: retrieve R1 (sector #)
	DATA	>4001			
	BLWP	@>005A(R9)		save R0 + R2
	DATA	>A000			
	BL	@UPDCLI			update current cluster info
	BLWP	@>005A(R9)		retrieve R0 + R2
	DATA	>A001			
	AI	R8,3			ptr to next cluster info
	MOV	R8,R1			
	S	@>0056(R9),R1		current FDR size
	CI	R1,>0100		room enough?
	JNE	H099			yes
	BL	@CALSUB			no: call subroutine
	DATA	FFSBM			free sector in bitmap
H096	B	@ERROR6			return with memory full
					
H099	MOV	R0,R1			new sector #
	BLWP	@>005A(R9)		save R1
	DATA	>4000			
H098	JMP	H100			make a new cluster
					
H097	BLWP	@>005A(R9)		retrieve R1
	DATA	>4001			
	BLWP	@>005A(R9)		save R0
	DATA	>8000			
	SETO	R2			empty file: start from offset 0
H100	MOV	R0,R1			sector #
	INC	R2			increment cluster size
	C	R2,R4			enough?
	JNE	H095			no: get one more sector
	MOV	R4,R5			
	BL	@ADDSEC			add sector to FDR
	JMP	H101			done
					
H092	BL	@CALSUB			call subroutine
	DATA	FSCTOF			find a sector from offset in file
	A	R1,R4			last sector in cluster
H101	B	@RTURN1			return to caller
					
ADDSEC	MOV	R11,R10			add sector to FDR
	MOV	R1,R4			
	BLWP	@>005A(R9)		retrieve R1
	DATA	>4001			
	MOV	R1,R1			sector #
	JEQ	H102			none: return
	BL	@UPDCLI			write info for R1 cluster
	MOV	@>0056(R9),R2		pointer to FDR
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0042			address in R2
	MOVB	@-1026(R15),R1		first char of filename
	ORI	R1,>8000		flag
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0043			address in R2
	MOVB	R1,@-2(R15)			
	AI	R2,14			ptr to # of sectors
	INC	R5			new # of sectors
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0043			address in R2
	MOVB	R5,@-2(R15)		update # of sectors
	SWPB	R5			
	MOVB	R5,@-2(R15)			
H102	B	*R10			
					
FSCTOF	MOV	@>0056(R9),R8		find sector from offset in file
	AI	R8,28			cluster list
	MOV	R3,R4			desired sector offset is in R3
H105	BL	@DECDCI			decode info: sector in R1, offset in R2
	C	R2,R3			reached yet?
	JLT	H103			no
	JMP	H104			yes: return
H103	AI	R8,3			point to next cluster info
	MOV	R3,R4			
	S	R2,R4			
	DEC	R4			size of the desired cluster (if it's the next)
	JMP	H105			keep trying
H104	B	@RTURN1			return to caller

*---------------------------------
* Opcode 7: Delete
* ----------------
* PAB 0: >07
*     1:            <--- error code
*   2-3:
*     4:
*     5:
*   6-7:
*     8:
*---------------------------------					
DELETE	BL	@CALSUB			delete file
	DATA	FFFDRV			find file FDR in VDP buffers
	MOV	R4,R4			found?
	JEQ	H106			yes
	BL	@CALSUB			no: call subroutine
	DATA	FFDRDK			find FDR on disk
	MOV	R4,R4			found?
	JEQ	H107			yes
	B	@RTURN1			no: return to caller
					
H106	INC	R1			FDR found, point to it
	MOV	R1,@>0056(R9)		save it for other routines
	BL	@CALSUB			call subroutine
	DATA	RDSEC1			read sector 1
	BL	@FDR2B1			read 2 bytes from VDP at >8356+offset
	DATA	-4			i.e. get sector # of FRD in R0
	MOV	R0,R3			save it for later
	MOV	R5,R8			ptr to top of sector 1
H108	BL	@VPDR2B			read 2 bytes from VDP at R8 into R0
	INCT	R8			next FDR ptr in sector 1
	C	R0,R3			is this the one we want?
	JNE	H108			not yet
	DECT	R8			yes: point back to it
H107	BLWP	@>005A(R9)		save R8
	DATA	>0080			
	BL	@CALSUB			call subroutine
	DATA	FFSVIB			free file sectors in VIB bitmap
	BLWP	@>005A(R9)		retrieve R8
	DATA	>0081			
	BL	@RMFPTR			remove FDR ptr from sector 1
	CLR	R2			code for write
	BL	@CALSUB			call subroutine
	DATA	WRISR1			write sector 1
	BL	@FDR2B1			get 2 bytes from VDP at >8356+offset in R0
	DATA	-4			i.e. sector # of FDR
	BL	@CALSUB			call subroutine
	DATA	FFSBM			free sector in R0 in VIB bitmap
	B	@CLRFBT			clear 1rst byte of filename in VDP

* Sector 1 contains an alphabetically sorted list of FDR pointers
* Each pointer is 2 bytes long and contains the sector # of this FDR
* The list must end with a >0000 mark. Thus there can be 127 files at most
RMFPTR	MOV	@>0056(R9),R5		remove FDR ptr from sector 1
	AI	R5,256			
	MOV	R5,R3			pointer to data buffer
	AI	R3,256			point to next ctrl block
	MOV	R8,R2			shift up FDR list, erasing FDR pointed by R8
	INCT	R2			point to next FDR ptr in sector 1
H109	BLWP	@>005A(R9)		set VDP to read
	DATA	>0042			address in R2
	MOVB	@-1026(R15),R0		get 1 byte
	INC	R2			inc source ptr
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0103			address in R8
	MOVB	R0,@-2(R15)		copy 1 byte
	INC	R8			inc dest pointer
	C	R2,R3			done?
	JNE	H109			not yet
	B	*R11			
					
INSFDR	MOV	R11,R10			insert a FDR in sector 1
	MOV	R8,R1			
	BL	@FDR2B1			get 2 bytes from VDP at >8356+offset
	DATA	508			i.e. last FDR slot in sector 1 (list ends with 0)
	MOV	R0,R0			
	JEQ	H110			
	B	@ERROR6			memory full error
H110	DEC	R8			previous byte
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0102			address in R8
	MOVB	@-1026(R15),R0		get 1 byte
	INCT	R8			
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0103			address in R8
	MOVB	R0,@-2(R15)		copy byte two bytes further down
	DECT	R8			
	C	R8,R1			done ?
	JNE	H110			not yet
	B	*R10			
					
CMPFN	MOV	@>0058(R9),R2		compare filenames
	AI	R2,256			
H111	BLWP	@>005A(R9)		set VDP to read
	DATA	>0022			address in R1 (ptr to filename)
	MOVB	@-1026(R15),R0		get 1 char
	ANDI	R0,>7FFF		clear flag (on drive #)
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0042			address in R2 (filename compare buffer)
	MOVB	@-1026(R15),R3		get 1 char
	CB	R0,R3			compare chars
	JNE	H112			mismatch
	INC	R1			match: increment pointers
	INC	R2			
	DEC	R4			
	JNE	H111			next char
H112	B	*R11			if complete match: ret with EQ set
					
PABR2B	MOV	@>0054(R9),R8		get two bytes from PAB
	JMP	FDR2B2			
					
FDR2B1	MOV	@>0056(R9),R8		get two bytes from FDR
FDR2B2	A	*R11+,R8		offset in data word
					
VPDR2B	BLWP	@>005A(R9)		get two byte from VDP at R8
	DATA	>0102			set VDP to read at R8
	MOVB	@-1026(R15),R0		get two bytes of data
	SWPB	R0			
	MOVB	@-1026(R15),R0			
	SRC	R0,8			why not swpb ?
	B	*R11			
					
FDSKDR	MOV	@>0058(R9),R1		find disk from name (ptr in R3)
	AI	R1,256			
	BL	@CPCKFN			copy filename from VDP at R3 to compare buffer
	BLWP	@>005A(R9)		save R2 + R3
	DATA	>3000			
	MOV	R0,R0			last char copied
	JLT	H113			flagged
	JMP	H114			
H113	MOV	R0,R6			
	ANDI	R6,>0300			
	JEQ	ERROR7			return with file error
	JMP	H115			return to caller
H114	CLR	R6			don't read any drive
	BL	@CALSUB			call subroutine
	DATA	RWVIB			save current VIB
H116	AI	R6,>0100		next drive
	SETO	R7			error flags
	SETO	R2			code for read
	CLR	R4			sector 0
	BL	@CALSUB			call subroutine
	DATA	RDSEC1			read sector 0
	MOV	R7,R7			ok?
	JNE	H118			no: try next drive
	LI	R4,10			yes: diskname size
	MOV	@>0058(R9),R1		VIB ptr
	BLWP	@>005A(R9)		save R1-R3
	DATA	>7000			
	BL	@CMPFN			compare names (ptr in R1 + compare buffer)
	BLWP	@>005A(R9)			
	DATA	>7001			retrieve R1-R3
	MOV	R4,R4			name matched?
	JNE	H118			no: try next drive
	MOV	R6,R0			drive #
	ORI	R0,>8000		add update flag
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0063			address in R3
	MOVB	R0,@-2(R15)		copy drive+flag before diskname in source
	DEC	R5			before sector 0 copy
	BLWP	@>005A(R9)		set VDP to write
	DATA	>00A3			address in R5
	MOVB	R5,@-2(R15)		copy drive # before VIB
	JMP	H115			done
					
H118	CI	R6,>0300		did we do all drives?
	JNE	H116			no: try next on
	JMP	ERROR7			return with file error
					
H115	BLWP	@>005A(R9)		retrieve R2 + R3
	DATA	>3001			
	B	@RTURN1			return to caller
					
CPCKFN	DEC	R2			
	JH	H119			
ERROR7	BL	@RETERR			return with error
	DATA	>E000			file error
					
H119	LI	R0,>2000		copy (+check) filename in VDP from R3 to R1 (space)
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0023			address in R1
	LI	R8,10			10 chars per filename
H120	MOVB	R0,@-2(R15)		fill filename with spaces
	DEC	R8			
	JNE	H120			
	LI	R8,11			11 chars countring drive #
H122	INC	R3			increment source ptr
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0062			address in R3
	MOVB	@-1026(R15),R0		get a char
	JEQ	ERROR7			>00: return with file error
	JLT	H121			flag bit set
	CI	R0,>2E00			
	JEQ	H121			'.'
	DEC	R8			
	JEQ	ERROR7			name to long: return with file error
	CI	R0,>2000			
	JEQ	ERROR7			name can't contain spaces: file error again
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0023			address in R1
	MOVB	R0,@-2(R15)		copy 1 char
	INC	R1			increment destination pointer
	DEC	R2			more?
	JNE	H122			yes
H121	CI	R8,>000B		name can't be 0 chars long
	JEQ	ERROR7			else return with file error
	B	*R11			
					
K014	DATA	>AA00			
					
ERROR5	MOV	R11,R0			update data, then error
	MOV	@>0056(R9),R3		
	DEC	R3			see what >8356 is pointing at
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0062			address in R3
	MOVB	@-1026(R15),R2		get 1 byte
	CB	R2,@K014		is it >AA (disk buffer area mark)
	JEQ	H123			yes: announce error (code in data word)
	BLWP	@>005A(R9)		no: >8356 points to a FDR. Save R0
	DATA	>8000			
	BL	@CALSUB			call subroutine
	DATA	UPDFDR			update FRD and data buffer if needed
	BLWP	@>005A(R9)		retrieve R0
	DATA	>8001			
H123	MOV	R0,R11			
					
RETERR	MOV	@>0054(R9),R1		annouce error
	JEQ	H124			no PAB
	INC	R1			for DSRs: ptr to status byte
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0022			address in R2
	MOVB	@-1026(R15),R2		get file status byte
	SOC	*R11+,R2		add error code
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0023			address in R2
	MOVB	R2,@-2(R15)		write back status byte
	JMP	H125			
H124	MOV	*R11+,@>0050(R9)	for subs: error code in >8350
H125	MOV	@>0058(R9),R8		get stack ptr
	AI	R8,-12			point back to initial caller
	MOV	R8,@>0066(R9)		update pointer
	B	@RTURN1			return to caller
					
RWVIB	BLWP	@>005A(R9)		read VIB (drive # in R6)
	DATA	>3000			save R2 + R3
	MOV	@>0058(R9),R5		pointer to VIB in ctrl block
	DEC	R5			ptr to drive #
	BLWP	@>005A(R9)		set VDP for read
	DATA	>00A2			address in R5
	MOVB	@-1026(R15),R2		get drive #
	MOV	R2,R3			
	CLR	R4			sector 0 for VIB
	ANDI	R2,>0300		clear flag (>80 = update data)
	CB	R2,R6			wanted drive?
	JEQ	H126			yes: return
	MOV	R3,R3			no: shall we update VIB?
	JLT	H127			yes
	JMP	H128			no
H127	BLWP	@>005A(R9)		set VDP to write
	DATA	>00A3			address in R5
	MOVB	R4,@-2(R15)		clr drive #
	INC	R5			point back to VIB buffer
	BL	@CALSUB			call subroutine
	DATA	RWSEC2			write sector 0 to old drive (in R2)
	DEC	R5			point to drive #
H128	SETO	R2			flag for read
	MOVB	R5,R2			add wanted drive
	JEQ	H129			none
	INC	R5			point at VIB buffer
	BL	@CALSUB			call subroutine
	DATA	RDSEC1			read sector (in R4) to buffer (in R5)
	DEC	R5			point at drive #
H129	BLWP	@>005A(R9)		set VDP to write
	DATA	>00A3			address in R5
	MOVB	R5,@-2(R15)		write drive # in control block, before FDR
H126	INC	R5			point back to FDR
	BLWP	@>005A(R9)			
	DATA	>3001			retrieve R2 + R3 from stack
	B	@RTURN1			branch to address on stack
					
RDSEC1	SETO	R2			read sector 1
WRISR1	LI	R4,1
	LI	R5,>0100		into data buffer area of current ctrl block
	JMP	RDFDR1			
					
WRFDR	BL	@FDR2B1			read FDR
	DATA	-4			-------- get sector # of FDR from control block
					
RDFDR2	MOV	R0,R4			sector read/write
	CLR	R5
RDFDR1	A	@>0056(R9),R5		point to FDR or data buffer
RWSEC0	CLR	R7			
RWSEC1	MOVB	R5,R2			add drive # for r/w flag
RWSEC2	BLWP	@>005A(R9)		save R0-R8
	DATA	>FF80			
	MOV	R4,@>004A(R9)		sector #
	MOV	R2,@>004C(R9)		drive | r/w flag
	MOV	R5,@>004E(R9)		buffer ptr
	BL	@CALSUB			call subroutine
	DATA	SECRW1			sector read/write
	BLWP	@>005A(R9)		retrieve R0-R8
	DATA	>FF81			
	MOVB	@>0050(R9),R7		get error code | flags
	SWPB	R7			
	JEQ	H130			
	MOV	R7,R7			
	JGT	H131			
	JMP	H132			
H131	ANDI	R7,>00FF			
	CI	R7,>0034			
	JNE	H133			
	BL	@ERROR5			
	DATA	>2000			write protected
H133	BL	@ERROR5			
	DATA	>C000			device error
H132	MOVB	@>004D(R9),@>004D(R9)	read or write?
	JEQ	H131			write
H130	ANDI	R7,>00FF			
	B	@RTURN1			return to caller
					
FFFDRV	MOV	@>0058(R9),R1		save filename in compare buffer and find its FDR
	AI	R1,256			
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0023			address in R1: filename compare buffer
	MOVB	R5,@-2(R15)		write drive #
	INC	R1			
	BL	@CPCKFN			copy (+ check) filename from R3 to R1
	MOV	R2,R2			all chars copied (or was there a . or a >00
	JEQ	FFDRVB			
H136	B	@ERROR7			return with file error
					
FFDRVB	MOV	@>0056(R9),R1		find filename in buffered FDRs
	AI	R1,3			
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0022			address in R1
	MOVB	@-1026(R15),R2		get # of files
	SRL	R2,8			make it a word
	MOV	R2,R3			save it
	AI	R1,6			ptr to drive #
H134	LI	R4,11			compare 11 bytes (drive + filename)
	BLWP	@>005A(R9)		save R1-R3
	DATA	>7000			
	BL	@CMPFN			compare with name in compare buffer
	BLWP	@>005A(R9)		retrieve R1-R3
	DATA	>7001			
	MOV	R4,R4			fully compared?
	JEQ	H135			yes: done
	AI	R1,518			move to next FDR in VDP mem
	DEC	R2			
	JNE	H134			next file
H135	B	@RTURN1			return to caller (R4=0 if successfull)
					
FNDFDR	BL	@CALSUB			
	DATA	FFFDRV			save name in comp buffer, find FDR in VDP buffers
					
FFDROD	MOV	R4,R4			find FDR on disk (from filename)
	JEQ	H136			file error
FFDRDK	MOV	@>0056(R9),R5		ptr to top of disk buffer in VDP mem
	AI	R5,10			ptr to drive # in first file control block
H138	BLWP	@>005A(R9)		set VDP to read
	DATA	>00A2			address in R5
	MOVB	@-1026(R15),R2		get drive #
	JEQ	H137			free control block found
	AI	R5,518			ptr to file control block
	DEC	R3			
	JNE	H138			more files ?
ERROR6	BL	@ERROR5			no:
	DATA	>8000			memory full
					
H137	MOV	R5,@>0056(R9)		save ptr to free ctrl block (drive #)
	BL	@CALSUB			call subroutine
	DATA	RWSEC1			read sector 1
FFDRFN	MOV	@>0056(R9),R8		entry point if sector 1 already read
	AI	R8,382			point to middle of sector 1
	LI	R2,64			distance: start with 1/4 sector
H139	SETO	R4			
	BL	@VPDR2B			read 2 bytes in R0 from VDP address in R8
	MOV	R0,R0			
	JEQ	H140			no file here: move up
	BLWP	@>005A(R9)		save R2
	DATA	>2000			
	SETO	R2			code for read
	BL	@CALSUB			call subroutine
	DATA	RDFDR2			read FDR, sector # in R0
	MOV	R5,R1			RDFDR2 sets R5 as FDR ptr
	AI	R5,-4			point to sector # of FDR in ctrl block
	BLWP	@>005A(R9)		set VDP to write
	DATA	>00A3			address in R5
	MOVB	R4,@-2(R15)		RDFDR2 puts sector # in R4
	SWPB	R4			copy it to ctrl block
	MOVB	R4,@-2(R15)			
	MOV	R1,R5			FDR ptr
	DEC	R1			now point to drive #
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0023			address in R1
	MOVB	R5,@-2(R15)		save drive #
	LI	R4,11			size to compare (drive # + filename)
	BL	@CMPFN			compare filenames
	BLWP	@>005A(R9)		retrieve R2
	DATA	>2001			
	JEQ	H141			compared ok: return
	BLWP	@>005A(R9)		set VDP to write
	DATA	>00A3			address in R5
	MOVB	R4,@-2(R15)		remaining chars to compare
	C	R0,R3			what kind of mismatch occured?
	JH	H140			too far down the alphabet
	A	R2,R8			too far up: move half-way down
	MOV	R2,R2			
	JNE	H142			then divide distance by 2
	INCT	R8			already checked: reset EQ
H141	B	@RTURN1			return (from stack)
					
H140	S	R2,R8			move half-way up
	MOV	R2,R2			
	JEQ	H141			can't: already checked
H142	SRL	R2,2			divide distance by 2
	A	R2,R2			but keep it even
	JMP	H139			

* The cluster info list is located in the FDR, bytes >1C to >FF
* A cluster info consists in 3 bytes, i.e 6 nibbles
* 3 nibbles specify the beginning sector for that cluster, and
* 3 nibbles specify the total file offset in sectors, including this cluster.
* The nibbles are arranged as EG SB OF, to be combined as BEG OFS
DECDCI	MOV	R11,R10			decode cluster info
	BL	@VPDR2B			read 2 bytes VDP at R8 in R0
	SWPB	R0			
	MOVB	@-1026(R15),R2		get third byte from cluster list
	MOV	R0,R1			
	ANDI	R1,>0FFF		start sector in R1
	SZC	R1,R0			remove it from R0
	SRL	R2,8			
	SOC	R0,R2			combine offset nibbles
	SRC	R2,12			offset in R2
	B	*R10			
					
UPDCLI	SRC	R2,4			write info for 1 cluster
	MOV	R2,R0			
	ANDI	R0,>F000		sector in R1, offset in R2
	SOC	R0,R1			copy nibble 3 of offset before nibble 1 of sector
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0103			address in R8
	SWPB	R1			write cluster info
	MOVB	R1,@-2(R15)		as 3 bytes
	SWPB	R1			
	MOVB	R1,@-2(R15)			
	SWPB	R2			
	MOVB	R2,@-2(R15)			
	B	*R11			

* The sector bitmap is located in the VIB (i.e. sector 0) at bytes >38 to >FF
* In each byte a bit defines a sector, from right to left: "0"=free, "1"=used					
FFSBMP	BLWP	@>005A(R9)		find a free sector in bitmap
	DATA	>7800			
	BL	@CALSUB			call subroutine
	DATA	RWVIB			load VIB for drive in R6
	MOV	R1,1			first sector specified in R1 ?
	JNE	H143			yes
	LI	R1,33			no: start with sector 34
H143	INC	R1			
	MOV	R1,R0			
	SRL	R1,3			div by 8 since 8 sect/byte in bitmap
	LI	R2,>00FF			
	ANDI	R0,>0007		bit number in bitmap byte
	JEQ	H144			
	SLA	R2,0			get that bit
H144	MOV	R1,R3			byte #
	A	R5,R3			add VIB ptr
	AI	R3,56			ptr to sector in bitmap
	CI	R1,>00C8		end of VIB?
	JLT	H145			no
	CLR	R1			yes: top of bitmap
H145	A	R5,1			
	AI	R1,56			make another bitmap ptr
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0022			address in R1
H146	SETO	R0			
	MOVB	@-1026(R15),R0		get bitmap byte
	MOV	R0,R4			save it
	SOC	R2,R0			mask previous sectors
	CLR	R2			
	INC	R0			get 1 more sector
	JNE	H147			ok
	INC	R1			byte full: try next
	MOV	R1,R0			
	AI	R0,-256			won't change if byte # became >100
	C	R0,R5			still in VIB?
	JNE	H148			yes
	AI	R1,-200			no: to top of bitmap
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0022			address in R1
H148	C	R1,R3			are we back to where we started?
	JNE	H146			no: seach that byte for a free sector
	MOV	R4,R0			get original byte
	INC	R0			try sectors just before ours (no mask this time)
	JEQ	H149			full: return with EQ
H147	DEC	R0			restore original byte
	MOV	R0,2			
	CLR	R0			bit counter
	SWPB	R2			
H150	INC	R0			increment bit count
	SRC	R2,1			find first 0 bit from the right
	JOC	H150			not yet
	LI	R2,>0080			
	SLA	R2,0			make a mask for that bit
	DEC	R0			bit # (0-7)
	SOC	R2,R4			mark sector as used in bitmap byte
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0023			address in R1
	MOVB	R4,@-2(R15)		update bitmap
	AI	R1,-56			
	S	R5,R1			byte # in bitmap
	SLA	R1,3			times 8 (8 sect per byte)
	SOC	R0,R1			add bit #: = sector #
	MOV	R1,R0			save it
					
H151	DEC	R5			point to drive #
	BLWP	@>005A(R9)		set VDP to read
	DATA	>00A2			address in R5
	MOVB	@-1026(R15),R1		get drive #
	ORI	R1,>8000		add flag: update VIB
	BLWP	@>005A(R9)		set VDP to write
	DATA	>00A3			address in R5
	MOVB	R1,@-2(R15)		write back flagged drive #
	INC	R5			point to VIB (& return with NEQ)
H149	BLWP	@>005A(R9)		retrieve R1-R4
	DATA	>7801			
	B	@RTURN1			return to caller
					
FFSBM	MOV	R0,R1			free sector(s) in bitmap
	LI	R2,1			1 sector only
FRSCB1	BLWP	@>005A(R9)		entry point if more than 1 sector
	DATA	>7800			save R1-R4
	BL	@CALSUB			call subroutine
	DATA	RWVIB			load VIB for drive in R6
	MOV	R1,R0			sector #
	ANDI	R0,>0007		bit in bitmap byte (8 per byte)
	SRL	R1,3			byte in bitmap
	A	R5,R1			add VIB buffer
	AI	R1,56			add bitmap offset in VIB
	MOV	R0,R3			
	NEG	R0			
	AI	R0,8			change 0-7 into 8-1
	LI	R4,>00FF		mask to erase
	C	R2,R0			how many to erase?
	JLT	H152			less than in that byte
	JMP	H153			
					
H152	LI	R0,8			free sectors in first byte
	S	R2,R0			
	SRC	R4,0			adjust mask
	MOV	R3,R0			original bit # of starting sector
	JEQ	H154			(JB: this possibly needs to be JMP >4FFE)
	SLA	R4,0			don't erase before starting sector
H154	JMP	H155			
					
A4FFE	SRL	R9,3			what the heck is that??? (JB: see above comment) 
					
H155	SWPB	R4			
	JMP	H158			goto erase last byte
					
H153	SRC	R4,0			adjust mask
H156	S	R0,R2			that many will be freed
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0022			address in R1
	MOVB	@-1026(R15),R0		get bitmap byte
	SZC	R4,R0			mark sectors as free
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0023			address in R1
	MOVB	R0,@-2(R15)		write it back
	LI	R4,>FF00		clear full byte
	INC	R1			next byte
	LI	R0,8			i.e. 8 sectors
	C	R2,R0			how many more setors?
	JLT	H157			less than 8
	JMP	H156			8 or more: next byte
					
H157	MOV	R2,R0			remaining sectors
	LI	R4,>00FF			
	SLA	R4,0			coin mask
H158	BLWP	@>005A(R9)		set VDP to read
	DATA	>0022			address in R1
	MOVB	@-1026(R15),R0		get bitmap byte
	SZC	R4,R0			mark sectors as free
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0023			address in R1
	MOVB	R0,@-2(R15)		write it back
	JMP	H151			done: flag drive # and return

*===================================
* DSR entry points
*===================================					
EDSR01	MOV	R11,R7			DSK
	BL	@PRPFDO			--- prepare file operations
	BL	@CALSUB			call subroutine
	DATA	FDSKDR			find disk in drive (name ptr in R3)
	JMP	H159			
					
EDSR02	LI	R6,>0100		DSK1
	JMP	H160			----
					
EDSR03	LI	R6,>0200		DSK2
	JMP	H160			----
					
EDSR04	LI	R6,>0300		DSK3
					
H160	MOV	R11,R7			save return address
	BL	@PRPFDO			prepare file operations
H159	MOV	@>0054(R9),R0		PAB ptr
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0002			address in R0
	MOVB	@-1026(R15),R1		get opcode
	SRL	R1,8			
	CI	R1,>0009		check range
	JH	ERROR8			illegal opcode
	CI	R2,>0001		filename lenght (including . )
	JNE	H161			no filename: dir
	AI	R1,10			only allow open, close and read
	CI	R1,>000C			
	JH	ERROR8			others are illegal
H161	A	R1,R1			make it a word ptr
	MOV	@OPCVEC(1),R1		get vector
	B	*R1			branch to it
					
OPCVEC	DATA	OPEN			open
	DATA	CLOSE			close
	DATA	READ			read
	DATA	READ			write
	DATA	RWIND1			rewind
	DATA	LOAD			load
	DATA	SAVE			save
	DATA	DELETE			delete
	DATA	RETERR			scratch record: return with bad attribute error
	DATA	STATUS			status
					
	DATA	OPNDIR			open directory
	DATA	CLSDIR			close directory
	DATA	RDDIR			read directory
					
ERROR8	BL	@ERROR5			return with error
	DATA	>6000			illegal opcode

*---------------------------------
* Opcode 0: Open
* --------------
* PAB 0: >00
*     1: file type  <--- error code
*   2-3:
*     4: record length
*     5:
*   6-7: # of records (if output)
*     8:
*---------------------------------					
OPEN	CLR	R0			
	MOVB	@-1026(R15),R0		get file attributes
	BLWP	@>005A(R9)			
	DATA	>8000			save R0
	ANDI	R0,>1600		keep fix/var and access mode
	CI	R0,>0600			
	JNE	H162			
ERROR9	BL	@ERROR5			dis/fix, open as append: return with error
	DATA	>4000			bad attribute
					
H162	JLE	H163			
	MOV	R0,R1			var
	BL	@PABR2B			get 2 bytes from PAB into R0
	DATA	4			rec len and char count
	CI	R0,>FF00		is rec len 255?
	JHE	ERROR9			yes: bad attribute
	MOV	R1,R0			retrieve attributes
	ANDI	R0,>0600			keep only access mode
					
H163	CI	R0,>0200			is it output?
	JNE	H164			no
	BL	@CALSUB			call subroutine
	DATA	CRFIL1			create file
H165	BL	@PRFDRS			coin status byte in FDR style
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0083			address in R4: status byte in FDR buffer
	MOVB	R2,@-2(R15)		write file status in FDR
	MOV	@>0054(R9),R3		PAB ptr
	AI	R3,4			ptr to rec len
	CLR	R5			
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0062			address in R3
	MOVB	@-1026(R15),R5		get record length
	JNE	H166			
	LI	R5,>5000		>00: default it 80
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0063			address in R3
	MOVB	R5,@-2(R15)		write default rec len
H166	AI	R4,5			point to rec len byte in FDR
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0083			address in R4
	MOVB	R5,@-2(R15)		write rec len in FDR buffer
	LI	R1,256			256 bytes/sector
	MOV	R2,R2			var or dis?
	JLT	H167			var
	JMP	H168			dis
H167	A	R1,R5			var: rec len +1
	DEC	R1			254 bytes only (needs size byte)
H168	SWPB	R5			make it a word
	CLR	R0			
	DIV	R5,R0			how many times in 254/255 bytes?
	AI	R4,-4			point to # of rec/sect in FDR
	MOV	R0,R1			save result for later
	SWPB	R0			
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0083			address in R4
	MOVB	R0,@-2(R15)		write # of rec/sect in FDR
	MOV	@>0056(R9),R8		point to filename in FDR
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0102			address in R8
	MOVB	@-1026(R15),R0		get first char
	ORI	R0,>8000		flag it: update FDR before leaving
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0103			address in R8
	MOVB	R0,@-2(R15)		write it back
	BLWP	@>005A(R9)			
	DATA	>8001			retrieve R0 (access mode)
	BL	@PABR2B			get 2 bytes from PAB into R0
	DATA	6			required size in records
	MOV	R0,R4			
	JEQ	H169			no size specified
	JLT	ERROR9			return with bad attribute error
	A	R1,R4			round up to record size
	DEC	R4			
	CLR	R3			
	DIV	R1,R3			how many sectors will this be?
	DEC	R3			offset start from 0
	BL	@CALSUB			call subroutine
	DATA	APSCTS			add sectors to FDR to match offset in R3
H169	B	@RWIND2			initialise file control block and return to caller
					
H164	BLWP	@>005A(R9)		not output
	DATA	>8000			save R0
	BL	@CALSUB			call subroutine
	DATA	FNDFDR			find FDR on disk
	BLWP	@>005A(R9)			
	DATA	>8001			retrieve R0 (access mode)
	MOV	R4,R4			found FDR?
	JEQ	H170			yes
	CI	R0,>0400		no: is file open as input?
	JEQ	H171			yes: must exist
	BL	@CALSUB			no: call subroutine
	DATA	CRFIL3			create file
	JMP	H165			
					
H171	B	@ERROR9			return with bad attribute error
					
H170	MOV	R0,R7			save access mode
	BL	@PRFDRS			prepare status byte for FDR
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0082			address in R4 (status byte in FDR)
	MOVB	@-1026(R15),R0		get current file status
	MOV	R0,R3			save it
	ANDI	R3,>0800		is file write protected?
	JEQ	H172			no
	CI	R7,>0400		yes: is it open as input?
	JEQ	H172			no
	BL	@ERROR5			yes: return with error
	DATA	>2000			write protected
					
H172	ANDI	R0,>8300		keep only file type bits (V/F, D/I, Prg/Data)
	XOR	R2,R0			compare with new (coined by PRFDRS)
	JNE	H171			different: bad attribute
	MOV	@>0054(R9),R3		PAB ptr
	AI	R3,4			ptr to rec len in PAB
	AI	R4,5			ptr to rec len in FDR
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0082			address in R4
	MOVB	@-1026(R15),R0		get rec len from FDR
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0062			address in R3
	MOVB	@-1026(R15),R2		get rec len from PAB
	JEQ	H173			0 = keep current one
	CB	R0,R2			are they identical?
	JNE	H171			no: bad attribute
H173	BLWP	@>005A(R9)		set VDP to write
	DATA	>0063			address in R3
	MOVB	R0,@-2(R15)		update rec len in PAB (in case it was 0)
	BLWP	@>005A(R9)		retrieve R0 (open mode)
	DATA	>8001			
	ANDI	R0,>0600		keep only access mode
	CLR	R2			
	SETO	R3			
	CI	R0,>0600		is it append
	JNE	H174			no
	MOV	@>0056(R9),R4		yes: get FDR ptr
	MOV	R4,R7			save it
	AI	R4,14			ptr to # of sectors
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0082			address in R4
	MOVB	@-1026(R15),R3		get # of sectors in file
	SWPB	R3			
	MOVB	@-1026(R15),R3			
	SWPB	R3			
	MOVB	@-1026(R15),R2		get eof offset
	DEC	R3			offset starts from 0
	JLT	H174			file is empty (0 sectors)
	BLWP	@>005A(R9)			
	DATA	>3000			save R2 + R3
	AI	R7,256			ptr to data buffer area for this file
	BL	@CALSUB			call subroutine
	DATA	RDOFSC			read a sector, from offset in R3
	BLWP	@>005A(R9)			
	DATA	>3001			retrieve R2 + R3
H174	BL	@UPDFCB			update current record offset in file ctrl block
	B	@RTURN1			return to caller
					
PRFDRS	BLWP	@>005A(R9)		prepare file status byte for FDR
	DATA	>8001			access mode in R0
	BLWP	@>005A(R9)			
	DATA	>8000			save it back
	LI	R2,2			int in FDR status byte
	MOV	@>0056(R9),R4		FDR pointer
	SLA	R0,4			fix or var?
	JNC	H175			fix
	LI	R2,>0082		int var in FDR
	MOV	R0,R0			dis or int?
H175	JLT	H176			int
	DECT	R2			dis: remove the int from FDR status
H176	AI	R4,12			point at file status byte in FDR
	SWPB	R2			
	B	*R11			
					
UPDFCB	MOV	@>0056(R9),R4		update sect + rec offsets in file control block
	AI	R4,-6			
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0083			address in R4
	MOVB	R3,@-2(R15)		write current sect offset
	SWPB	R3			
	MOVB	R3,@-2(R15)			
	AI	R4,4			point to logical rec offset (for var files)
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0083			address in R4
	MOVB	R2,@-2(R15)		write record offset
	B	*R11			

*----------------------------------
* Opcode 1: Close
* --------------
* PAB 0: >01
*     1:           <--- error code
*   2-3:
*     4:
*     5:
*   6-7:
*     8:
*----------------------------------					
CLOSE	BL	@CALSUB			call subroutine
	DATA	FFDRVP			find file FDR
	B	@UPDFDR			update FDR + data area, get VIB, return to caller

*----------------------------------
* Opcode 2: Read
* --------------
* PAB 0: >02
*     1: file type <--- error code
*   2-3: data buffer address in VDP mem
*     4:
*     5: bytes read
*   6-7: record #
*     8:
*
* Logical records organisation whithin sectors
*
* Fixed records (e.g. rec length = 6)
* 11 11 11 11 11 11 22 22 22 22 22 22 33 33 33 33 33 33 xx xx xx
* Where 11=data for record 1, 22=record 2, 33=record 3, xx=junk bytes
*
* Variable records:
* sz 11 11 11 11 11 11 11 sz 22 22 22 22 22 sz 33 33 FF xx xx xx
* Where sz=record size, 11,22,33=record data, FF=end-of-sector mark, xx=junk
*----------------------------------					
READ	BL	@CALSUB			call subroutine
	DATA	FFDRVP			find FDR in VDP buffers, get status from PAB
	ANDI	R0,>0200		what type of access?
	JEQ	H177			update or input: ok
H179	B	@ERROR8			append or output: error illegal opcode
H177	BL	@RFDRST			get status byte in R0, from FDR
	JLT	H178			var
	BL	@RRNPAB			fix: get rec # compare to # of recs/file
	JL	H180			ok: in file
H181	BL	@ERROR5			update data and return with error
	DATA	>A000			eof reached
H180	BL	@CALSUB			call subroutine
	DATA	RRFDR			load record from disk into FDR data buffer area
	JMP	H182			
					
H178	BL	@CALSUB			var: call subroutine
	DATA	RRSEC			load proper sector, point to rec in it
	JMP	H181			skipped if ok: return with eof reached
					
	INC	R2			next byte in data buffer
	A	R4,R0			add rec size to offset
	INC	R0			room for end-of-sector mark
	MOV	@>0056(R9),R5		FDR ptr
	DECT	R5			point to var record offset in sector
	SWPB	R0			
	BLWP	@>005A(R9)		set VDP to write
	DATA	>00A3			address in R5
	MOVB	R0,@-2(R15)		update var record offset in sector
	MOV	R4,R0			save # of bytes to be read
H182	MOV	@>0054(R9),R4		PAB ptr
	AI	R4,5			point to char count
	SWPB	R0			
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0083			address in R4
	MOVB	R0,@-2(R15)		write # of char to be read
	SWPB	R0			make it a word
					
WFDRPB	MOV	R0,R0			check it
	JEQ	H183			none: return
H184	BLWP	@>005A(R9)		set VDP to read
	DATA	>0042			address in R2
	MOVB	@-1026(R15),R3		read 1 byte from FDR data buffer area
	INC	R2			increment source ptr
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0023			address in R1
	MOVB	R3,@-2(R15)		write the byte in PAB data buffer
	INC	R1			increment destination ptr
	DEC	R0			more to read?
	JNE	H184			yes
H183	B	@RTURN1			return to caller
					
RRSEC	BL	@RCOFCB			load sector, point to record in it
	MOV	R3,R3			sector offset
	JLT	H185			-1: top of file
	JMP	H186			in file
H185	MOV	R3,R0			
	INC	R0			next sector
	C	R0,R2			compare to # of sect/file
	JEQ	H183			end-of-file reached: return to caller (JMP to err)
	BL	@CALSUB			call subroutine
	DATA	UPDBF			update data buffer, if needed
	MOV	R0,R3			desired offset
	CLR	R5			
	BL	@UCOFCB			update sect + rec offsets in control block
	AI	R7,256			point to data buffer area (R7 set by UCOFCB)
	BL	@CALSUB			call subroutine
	DATA	RDOFSC			read a sector, from offset in file (in R3)
	CLR	R0			
	JMP	H187			
					
H186	MOV	R0,R0			in file: test var rec offset (from RCOFCB)
	JNE	H187			inside sector
	C	R0,R2			at beg of sector
	JEQ	H183			file is empty: return
H187	MOV	R0,R2			FDR data buffer will be added to R2 by AFDRPT
	BL	@CALSUB			call subroutine
	DATA	AFDRPT			R2=byte in FDR data buf, R1=top of PAB data buf
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0042			address in R2
	MOVB	@-1026(R15),R4		get first byte (rec length)
	SRL	R4,8			make it a word
	MOV	R0,R0			var rec offset
	JEQ	H188			
	CI	R4,>00FF		is it >FF (end of sector mark) ?
	JNE	H188			no
	BL	@RCOFCB			yes: get sect + rec offsets from control block
	JMP	H185			try again with next sector
					
H188	BLWP	@>005A(R9)			
	DATA	>0011			retrieve return address from stack in R11
	INCT	R11			skip the JMP to eof reached error
	B	*R11			

*------------------------------------
* Opcode 3: Write
* --------------
* PAB 0: >03
*     1: file type <--- error code
*   2-3: data buffer address in VDP mem
*     4:
*     5: bytes to write
*   6-7: record #
*     8:
*------------------------------------					
WRITE	BL	@CALSUB			call subroutine
	DATA	FFDRVP			find FDR in VDP buffers
	ANDI	R0,>0600		keep only access mode
	CI	R0,>0400		is it input
	JEQ	H179			yes: return with error illegal opcode
	BL	@RFDRST			get file status byte from FDR
	JLT	H189			var
					
	BL	@RRNPAB			fix: get rec # from PAB, sect # in R0
	JL	H190			less that total rec/file
	BLWP	@>005A(R9)		past eof: expand file
	DATA	>D800			save R0, R1, R3, R4
	MOV	R0,R3			desired sector offset
	BL	@CALSUB			call subroutine
	DATA	APSCTS			append enough sectors to reach offset in R3
	BLWP	@>005A(R9)			
	DATA	>D801			restore R0, R1, R3, R4
	BL	@URFFDR			update # of rec/file in FDR
					
H190	BL	@CALSUB			in file: call subroutine
	DATA	RRFDR			fetch rec from disk into FDR data buffer area
	JMP	H191			set update data flag, write data, return
					
H189	BL	@RCOFCB			var: R2=sect/file R3=sect offset R0=rec offset
	MOV	R3,R3			sector offset in file
	JLT	H192			-1: top of file
	JMP	H193			in file
H192	BLWP	@>005A(R9)		next sector loop
	DATA	>3000			save R2 + R3
	BL	@CALSUB			call subroutine
	DATA	UPDBF			update data buffer if needed
	BLWP	@>005A(R9)			
	DATA	>3001			retrieve R2 + R3
	INC	R3			next sector
	CLR	R0			init char offset in sector
					
H193	C	R3,R2			did we reach last sector?
	JNE	H194			no
	BLWP	@>005A(R9)		yes: expand file
	DATA	>9000			save R0 + R4
	BL	@CALSUB			call subroutine
	DATA	APSCTS			get last sector then append sectors to reach R3
	BLWP	@>005A(R9)			
	DATA	>9001			retrieve R0 + R4
					
H194	MOV	@>0054(R9),R5		PAB ptr
	AI	R5,5			point to char count
	BLWP	@>005A(R9)		set VDP to read
	DATA	>00A2			address in R5
	MOVB	@-1026(R15),R4		get # of chars to write
	SRL	R4,8			make it a word
	MOV	R4,R5			
	A	R0,R5			add current char offset in sector
	INC	R5			make room for size byte
	CI	R5,>00FF		past end of sector?
	JH	H192			yes: not enough room, try next sector
	SETO	R2			ok: rec will fit in sector
	MOV	@>0056(R9),R1		FDR ptr
	A	R5,R1			past-last-byte offset
	AI	R1,256			ptr to data buffer area
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0023			address in R1
	MOVB	R2,@-2(R15)		write end-of-sect mark to FDR data buffer area
	BLWP	@>005A(R9)			
	DATA	>8000			save R0 (current byte offset in sector)
	MOV	R3,R0			
	BL	@UCOFCB			update sect + rec offsets in control block
	AI	R1,18			point to eof offset in FDR (R1 modified by UCOFCB)
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0023			address in R1
	MOVB	R5,@-2(R15)		update eof offset in last sector, in FDR
	BL	@URFFDR			update # of rec/file in FDR
	BLWP	@>005A(R9)			
	DATA	>2001			retrieve old R0 in R2 (current byte offset)
	MOV	R4,R0			record size
	BL	@CALSUB			call subroutine
	DATA	AFDRPT			get FDR data buffer in R2, PAB data buffer in R1
	SWPB	R4			
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0043			address in R2
	MOVB	R4,@-2(R15)		write size byte to FDR data buffer
	INC	R2			increment dest pointer
					
H191	MOV	R2,R3			invert source and dest
	MOV	R1,R2			so we can use the same read-write loop
	MOV	R3,R1			than the read opcode
	MOV	@>0056(R9),R4		FDR ptr
	DEC	R4			pointer to drive # for that file
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0082			address in R4
	MOVB	@-1026(R15),R5		get drive #
	ORI	R5,>8000		add update data area flag
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0083			address in R4
	MOVB	R5,@-2(R15)		write back flagged byte
	B	@WFDRPB			to read-write loop
					
FFDRVP	BL	@CALSUB			find FDR in VDP buffer
	DATA	FFFDRV			find file FDR
	MOV	R4,R4			found?
	JEQ	AFPGPF			yes
	BL	@ERROR5			no: return with error
	DATA	>E000			file error
AFPGPF	INC	R1			point to filename in FDR
	MOV	R1,@>0056(R9)		new FDR ptr
	MOV	@>0054(R9),R4		get PAB ptr
	INC	R4			point to status byte
	CLR	R0			
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0082			address in R4
	MOVB	@-1026(R15),R0		get file status
	B	@RTURN1			return to caller
					
RFDRST	MOV	@>0056(R9),R4		get status byte from FDR
	AI	R4,12			point to status byte
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0082			address in R4
	MOVB	@-1026(R15),R0		read status byte
	B	*R11			
					
RRNPAB	MOVB	@-1026(R15),R5		get record # from PAB, check if valid
	SRL	R5,8			
	JNE	H195			get # of rec/sector from FDR
	LI	R5,256			0: default to 256
H195	MOV	@>0054(R9),R3		PAB ptr
	AI	R3,6			point to rec #
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0062			address in R3
	MOVB	@-1026(R15),R1		get record # from PAB
	SWPB	R1			
	MOVB	@-1026(R15),R1			
	SWPB	R1			
	MOV	R1,R0			save it
	JLT	H196			too big
	JMP	H197			ok
H196	BL	@ERROR5			update data then return with error
	DATA	>8000			memory full
H197	INC	R0			next record
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0063			address in R3
	MOVB	R0,@-2(R15)		write back # of future record
	SWPB	R0			
	MOVB	R0,@-2(R15)			
	CLR	R0			
	MOV	R1,R3			save # of desired rec
	DIV	R5,R0			divide by # of rec/sector = sect # in R0
RNFISE	MOV	@>0056(R9),R2		FDR ptr
	AI	R2,18			point to total # of rec (# of sectors for var)
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0042			address in R2
	MOVB	@-1026(R15),R2		get total # of recs/file (sect/file for var)
	SWPB	R2			
	MOVB	@-1026(R15),R2		remember: bytes are swapped
	C	R3,R2			compare with desired record (ignored by var)
	B	*R11			
					
RRFDR	BLWP	@>005A(R9)		fetch record into FDR data buffer area
	DATA	>4000			save R1
	AI	R4,-18			ptr to top of control block
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0082			address in R4
	MOVB	@-1026(R15),R5		get current sector offset in file
	SWPB	R5			
	MOVB	@-1026(R15),R5			
	SRC	R5,8			
	JLT	H198			-1: top of file
	C	R5,R0			compare with desired offset (from RRNPAB)
	JEQ	H199			same
	BL	@CALSUB			call subroutine
	DATA	UPDBF			update data buffer if needed
H198	MOV	R0,R3			desired sector offset in file
	BL	@UCOFCB			update sect + rec offsets in control block
	AI	R7,256			point to data buffer area (R7 set by UCOFCB)
	BL	@CALSUB			call subroutine
	DATA	RDOFSC			read a sector from offset in file (in R3)
H199	BLWP	@>005A(R9)			
	DATA	>4001			retrieve R1
	MOV	@>0056(R9),R3		FDR ptr
	AI	R3,17			point to record length
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0062			address in R3
	MOVB	@-1026(R15),R0		get rec length in bytes
	SRL	R0,8			make it a word
	MPY	R0,R1			calc file offset in bytes
AFDRPT	A	@>0056(R9),R2		add FDR ptr
	AI	R2,256			point inside data buffer area
	MOV	@>0054(R9),R3		PAB ptr
	INCT	R3			point to data buffer address
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0062			address in R3
	MOVB	@-1026(R15),R1		get PAB data buffer address
	SWPB	R1			
	MOVB	@-1026(R15),R1			
	SWPB	R1			
	B	@RTURN1			return
					
UCOFCB	MOV	@>0056(R9),R7		update sect + rec offsets in control block
	MOV	R7,R1			FDR ptr
	AI	R1,-6			top of file control block
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0023			address in R1
	MOVB	R0,@-2(R15)		current sector offset in file
	SWPB	R0			
	MOVB	R0,@-2(R15)			
	AI	R1,4			point to var rec offset in sector
	SWPB	R5			
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0023			address in R1
	MOVB	R5,@-2(R15)		first free byte in current sector
	B	*R11			
					
URFFDR	MOV	@>0056(R9),R2		update # of rec/file in FDR
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0042			address in R2 (FDR ptr)
	MOVB	@-1026(R15),R10		get first char of filename
	ORI	R10,>8000		set was modified flag
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0043			address in R2
	MOVB	R10,@-2(R15)		write flagged char back
	AI	R2,18			point to # of recs/file in FDR
	INC	R3			one more
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0043			address in R2
	SWPB	R3			update # of recs/file
	MOVB	R3,@-2(R15)			
	SWPB	R3			
	MOVB	R3,@-2(R15)			
	B	*R11			
					
RCOFCB	MOV	@>0056(R9),R8		get rec offset, compare sect with total
	MOV	R8,R4			FDR ptr
	AI	R4,256			point to data buffer area
	DECT	R8			point to var record offset
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0102			address in R8
	MOVB	@-1026(R15),R2		get var rec offset in current sector
	SRL	R2,8			make it a word
	MOV	R11,R10			save return point
	BL	@FDR2B2			get 2 bytes from FDR (at R8-4) into R0
	DATA	-4			current sector offset in file
	MOV	R0,R3			save it
	MOV	R10,R11			restore return point
	MOV	R2,R0			var record offset
	B	@RNFISE			get # of sect/file from FDR, return

*------------------------------------
* Opcode 4: Rewind
* --------------
* PAB 0: >04
*     1: file type <--- error code
*   2-3:
*     4:
*     5:
*   6-7: record #  <--- >0000 if sequential
*     8:
*------------------------------------					
RWIND1	BL	@CALSUB			call subroutine
	DATA	FFDRVP			find FDR in VDP buffers, read status from PAB
	BLWP	@>005A(R9)			
	DATA	>8000			save R0 (status from PAB)
	ANDI	R0,>0600		keep only access mode
	JEQ	H200			update is ok
	CI	R0,>0400		is it input?
	JEQ	H200			yes: ok
	B	@ERROR8			output or append: return with illegal opcode
H200	BL	@CALSUB			call subroutine
	DATA	UPDBF			update data buffer if needed
	BLWP	@>005A(R9)			
	DATA	>8001			retrieve R0 (status from PAB)
	ANDI	R0,>0100		sequential or reloc?
	JNE	H201			reloc: don't do anything, return
					
RWIND2	CLR	R2			rewind file: record offset = 0
	SETO	R3			current record = -1 (none)
	BL	@UPDFCB			update file control block
	CLR	R0			record 0
	MOV	@>0054(R9),R8		get PAB ptr
	AI	R8,6			point to record #
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0103			address in R8
	MOVB	R0,@-2(R15)		write record #
	NOP				
	MOVB	R0,@-2(R15)			
H201	B	@RTURN1			return to caller

*------------------------------------
* Opcode 5: Load
* --------------
* PAB 0: >05
*     1: file type  <--- error code
*   2-3: data buffer address in VDP mem
*     4:
*     5:
*   6-7: maximum # of bytes (size of buffer)
*     8:
*------------------------------------					
LOAD	BL	@CALSUB			call subroutine
	DATA	FNDFDR			find FDR on disk
	MOV	R4,R4			found?
	JEQ	H203			yes
H202	BL	@ERROR5			no: return with error
	DATA	>E000			file error
H203	BL	@FDR2B1			get 2 bytes from FDR into R0
	DATA	12			file status byte
	ANDI	R0,>0100		is it program?
	JEQ	H202			no: file error
	INCT	R8			point to # of sect/file in FDR
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0102			address in R8
	MOVB	@-1026(R15),R1		get # of sectors in file
	SWPB	R1			
	MOVB	@-1026(R15),R1			
	SRC	R1,8			
	JEQ	H202			0=empty file: return with file error
	BL	@RBANB			get data buffer address in R7, # of sectors in R2
	INCT	R8			point to eof offset in FDR
	CLR	R4			
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0102			address in R8
	MOVB	@-1026(R15),R4		get # of bytes in last sector
	C	R1,R2			compare # of sect with max in PAB
	JH	H202			file is too big: return with file error
	JNE	H204			file is smaller
	C	R0,R4			same # of sect: check bytes in last sector
	JL	H202			file is too big: file error
H204	CLR	R3			sector offset in file
	SWPB	R4			
H206	DEC	R1			next sector
	JEQ	H205			done
	BLWP	@>005A(R9)			
	DATA	>D900			save R0, R1, R3, R4, R7
	BL	@CALSUB			call subroutine
	DATA	RDOFSC			read a sector from offset in R3
	BLWP	@>005A(R9)		restore R0, R1, R3, R4, R7
	DATA	>D901			
	INC	R3			next sector
	AI	R7,256			256 bytes further in PAB buffer
	JMP	H206			keep going
					
H205	MOV	R4,R4			
	JNE	H207			
	BL	@CALSUB			call subroutine
	DATA	RDOFSC			read a sector from offset in R3
	JMP	H208			done
					
H207	MOV	R7,R5			save PAB data buffer ptr
	MOV	@>0056(R9),R7		FDR ptr
	AI	R7,256			point to FDR data area
	BLWP	@>005A(R9)			
	DATA	>0D00			save R4, R5, R7
	BL	@CALSUB			call subroutine
	DATA	RDOFSC			read a sector from offset in R3
	BLWP	@>005A(R9)		restore R4 in R0, R5 in R1, R7 in R2
	DATA	>E001			
	BL	@CALSUB			call subroutine
	DATA	WFDRPB			write bytes from FDR data buffer to PAB data buf
H208	B	@UPDFDR			update FDR, data buffer, VIB and return to caller

*------------------------------------
* Opcode 6: Save
* --------------
* PAB 0: >06
*     1: file type  <--- error code
*   2-3: data buffer address in VDP mem
*     4:
*     5:
*   6-7: # of bytes to save
*     8:
*------------------------------------					
SAVE	BL	@CALSUB			call subroutine
	DATA	CRFIL1			create file
	BL	@RBANB			get PAB buffer ptr + # of bytes
	CLR	R3			sector offset 0
H209	BLWP	@>005A(R9)			
	DATA	>B100			save R0, R2, R3, R7
	BL	@CALSUB			call subroutine
	DATA	WROFSC			write sector to offset in R3
	BLWP	@>005A(R9)			
	DATA	>B101			retrieve R0, R2, R3, R7
	INC	R3			next sector
	AI	R7,256			256 bytes further in PAB data buffer
	DEC	R2			next sector
	JNE	H209			more to do
					
	MOV	@>0056(R9),R1		FDR ptr
	AI	R1,12			point to file status byte
	LI	R2,>0100		value for program file
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0023			address in R1
	MOVB	R2,@-2(R15)		write file status byte in FDR
	AI	R1,4			point to eof offset byte in FDR
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0023			address in R1
	MOVB	R0,@-2(R15)		# of bytes in last sector
	B	@UPDFDR			update FDR, data buffer, VIB then return to caller
					
RBANB	MOV	@>0054(R9),R0		get buffer address + # of bytes
	INCT	R0			data buffer in PAB
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0002			address in R0
	MOVB	@-1026(R15),R7		get data buffer address
	SWPB	R7			
	MOVB	@-1026(R15),R7			
	SWPB	R7			
	AI	R0,4			point to # of bytes to transfer
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0002			address in R0
	MOVB	@-1026(R15),R2		get # of bytes to be transfered
	SRL	R2,8			make it # of sectors (256 bytes each)
	CLR	R0			
	MOVB	@-1026(R15),R0		see if one more is needed
	JEQ	H210			no
	INC	R2			yes: one more sector
H210	B	*R11			

*-------------------------------------
* Opcode 9: Status
* --------------
* PAB 0: >09
*     1:
*   2-3:
*     4:
*     5:
*   6-7: record #
*     8:           <--- file status
*
* Status bits, returned in PAB byte 8:
* >80: file not found
* >40: file is protected
* >20:
* >10: internal (else display or program)
* >08: program file
* >04: variable (else fixed or program)
* >02: memory full
* >01: end-of-file reached
*-------------------------------------					
STATUS	BL	@CALSUB			call subroutine
	DATA	FFFDRV			save filename in comp buf, then find FDR in VDP
A57FA	MOV	R4,R4			found?
	JEQ	H211			yes
					
	BL	@CALSUB			no: call subroutine
	DATA	FFDRDK			find FDR on disk
	LI	R0,>8000		value for file not found
	MOV	R4,R4			found?
	JNE	H212			no: return with that value
	MOV	@>0056(R9),R1		yes: ptr to FDR
	CLR	R2			
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0023			address in R1
	MOVB	R2,@-2(R15)		invalidate that FDR (file not open)
	JMP	H213			transfer FDR status to PAB status byte
					
H211	BL	@CALSUB			file is open: call subroutine
	DATA	AFPGPF			adjust FDR ptr, get PAB file type into R4
	BL	@RFDRST			get status byte from FDR
	JLT	H214			var
	JMP	H215			fix
					
H214	BL	@CALSUB			var: call subroutine
	DATA	RRSEC			load wanted sector, point to wanted rec in buffer
	JMP	H216			out of range
	CLR	R2			ok: clear flag
	JMP	H213			copy status byte from FDR into PAB, return
					
H215	MOVB	@-1026(R15),R5		fix: get rec/sect byte
	SRL	R5,8			make it a word
	JNE	H217			
	LI	R5,>0100		00 (program files) means 256
H217	BL	@PABR2B			get 2 bytes from PAB into R0
	DATA	6			# of wanted record
	MOV	R0,R3			save it
	JLT	H218			too big: set memory full bit in PAB status byte
	BL	@RNFISE			get # recs/file into R2, comp with R3
	CLR	R2			
	JL	H213			in file: copy file type bits, return
	DIV	R5,R2			how many sectors do we need?
	MOV	R2,R3			save result
					
H216	BL	@FDR2B1			get 2 bytes from FDR into R0
	DATA	14			# of sectors/file
	INC	R3			plus 1 sector for FDR
	LI	R2,>0100		value for eof reached in PAB status
	S	R0,R3			are there enough sectors in file for these recs?
	JGT	H219			
	JMP	H213			yes: we reached the eof
H219	BL	@CALSUB			call subroutine
	DATA	RWVIB			load VIB (sector 0)
	MOV	R3,R4			number of sectors that will be needed
	MOV	R5,R8			VIB ptr
	AI	R8,10			skip 10 bytes (required by CFSVIB)
	BL	@CFSVIB			count free sectors in bitmap, into R3
	LI	R2,>0100		value for eof reached
	C	R3,R4			are there that many free sectors?
	JHE	H213			yes
H218	LI	R2,>0200		value for memory full
					
H213	BL	@FDR2B1			get 2 bytes from FDR into R0
	DATA	12			file status byte
	ANDI	R0,>8F00		mask irrelevant bits
	JGT	H220			
	ORI	R0,>0080		var: put var bit in PAB status style
H220	SLA	R0,3			get rid of var bit in FDR style
	SOCB	R2,R0			add eof and mem full bits
					
H212	MOV	@>0054(R9),R1		PAB ptr
	AI	R1,8			point to bias/status return byte
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0023			address in R1
	MOVB	R0,@-2(R15)		write file status to PAB
	B	@RTURN1			return to caller

*---------------------------------
* Disk directory access
* ---------------------
* The directory is accessed by omiting the filename in the DSR name: "DSK1."
* It must be opened for input only, as an Int/Fix 38 file.
* It consists in upto 128 records, the first one contains the disk informations,
* the others the informations for upto 127 files (in alphabetical order).
* Each record consists in an ascii string and three floating point numbers.
*
* Record 0 contains:
* - Diskname (an ascii string of upto 10 chars).
* - The number zero.
* - The number of sectors on disk.
* - The number of free sectors on disk.
*
* Other records contain:
* - Filename (an ascii string of upto 10 chars).
* - Filetype: 1=D/F, 2=D/V, 3=I/F, 4=I/V, 5=Prog, 0=end of directory.
*   If the file is protected, this number is negative (-1=D/F, etc).
* - File size in sectors (including the FDR itself).
* - File record length (0 for programs).
*---------------------------------
 
*---------------------------------
* Open disk directory pseudo-file
*---------------------------------					
OPNDIR	MOVB	@-1026(R15),R0		get file type from PAB
	ANDI	R0,>1E00		mask irrelavant bits (rel/seq)
	CI	R0,>0C00		is it int/fix in output mode?
	JEQ	H221			yes
H223	BL	@RETERR			return with error
	DATA	>4000			bad attributes
H221	BL	@PABR2B			get 2 bytes from PAB into R0
	DATA	4			rec length
	SRL	R0,8			make it a word
	JEQ	H222			>00= default: set it to 38
	CI	R0,>0026		is it 38?
	JNE	H223			no: return with bad attributes error
H222	LI	R0,>2600		set rec len to 38
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0103			address in R8 (from PABR2B)
	MOVB	R0,@-2(R15)		write rec len to PAB
					
	CLR	R7			
	BL	@FNDRV			find matching drive in file control blocks
	DATA	H224			go there if not found
ERRR10	BL	@ERROR5			update data then return with error
	DATA	>E000			file error
H224	MOV	R7,R7			did we find a free slot?
	JNE	H225			yes
	BL	@RETERR			no: return with error
	DATA	>8000			memory full
H225	BLWP	@>005A(R9)		set VDP to write
	DATA	>00E3			address in R7
	MOVB	R3,@-2(R15)		write drive #
	SWPB	R3			
	MOVB	R3,@-2(R15)		and a space as filename (illegal, indicates dir)
	B	@RTURN1			return to caller

*---------------------------------
* Close disk directory
*---------------------------------					
CLSDIR	BL	@FNDRV			find matching drive in file control blocks
	DATA	ERRR10			go there if not found: return with file error
	CLR	R0			
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0103			address in R8
	MOVB	R0,@-2(R15)		clear drive #
	B	@RTURN1			return to caller

*---------------------------------
* Read a record from disk directory
*---------------------------------					
RDDIR	BL	@FNDRV			find matching drive in file control blocks
	DATA	ERRR10			go ther it not found: return with file error
	INC	R8			
	MOV	R8,R5			save ptr to FDR
	BL	@PABR2B			get 2 bytes from PAB into R0
	DATA	6			record #
	MOV	R0,R2			save it
	INC	R2			
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0103			address in R8
	MOVB	R2,@-2(R15)		write record number in FDR
	SWPB	R2			after first char of filename!
	MOVB	R2,@-2(R15)			
	SLA	R0,1			since two byte per file ptr
	MOVB	R0,R0			is rec # greater than 128?
	JEQ	H226			no
	BL	@ERROR5			yes: update data then return with error
	DATA	>A000			past eof
H226	SETO	R2			code for read
	MOV	R0,R4			record #
	JEQ	H227			0=disk parameters
	LI	R4,1			sector #1
	BL	@CALSUB			call subroutine
	DATA	RWSEC0			read sector into buffer in R5
	MOV	R5,R8			buffer ptr
	AI	R5,255			point to data buffer area in this ctrl block
	DECT	R0			don't count record 0
	A	R0,R8			point to desired file ptr
	BL	@VPDR2B			get two byte from VDP at R8 into R0
	MOV	R0,R4			sector where that FDR is to be found
	JEQ	H228			no more
	BL	@CALSUB			call subroutine
	DATA	RWSEC0			read FDR sector into data buffer area
	BL	@FDR2B1			get 2 bytes from FDR into R0
	DATA	270			# of sect/file
	MOV	R0,R6			save it to output file size
	INC	R6			include the FDR itself
	MOVB	@-1026(R15),R3		ignore eof offset
	LI	R2,>0A00		10 chars per filename
	MOVB	@-1026(R15),R3		get rec length
	SRL	R3,8			make it a word
	DECT	R8			point to status byte in FDR
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0102			address in R8
	MOVB	@-1026(R15),R0		get file status byte
	MOV	R0,R7			
	ANDI	R0,>0800		keep only write protected bit
	SZCB	R0,R7			clear write protected bit (if it was set)
	SRL	R7,8			make it a word
	INC	R7			types are numbered from 1
	CI	R7,>0002		is it a program file?
	JNE	H229			no
	AI	R7,3			yes: make it type 5
H229	CI	R7,>0008		is it var?
	JL	H230			no
	AI	R7,-127			yes: add 1 and clear var bit
H230	SLA	R0,4			write protect bit will be >80
	SOC	R0,R7			add it to file type
	JMP	H231			
					
H228	CLR	R2			no more files: filename size = 0
	CLR	R6			file size = 0
	CLR	R3			rec length = 0
	CLR	R7			type = 0
H231	JMP	H232			output that
					
H227	AI	R5,255			disk info: point to data buffer area in ctrl block
	BL	@CALSUB			call subroutine
	DATA	RWSEC0			read sector 0
	BL	@FDR2B1			get 2 bytes from FDR into R0
	DATA	266			# of sectors on disk
	MOV	R0,R6			duplicate it
	DECT	R6			minus directory itself (sect 0 + 1)
	BL	@CFSVIB			count free sectors in bitmap, result in R3
	CLR	R7			filetype is not used
	LI	R2,>0A00		diskname is 10 chars
					
H232	BL	@PABR2B			get 2 bytes from PAB into R0
	DATA	R2			data buffer address
	MOV	R0,R8			duplicate it
	INC	R8			skip first byte
	SRL	R2,8			filename length (or diskname)
	JEQ	H233			0: skip filename copying
	CLR	R1			
H234	BLWP	@>005A(R9)		set VDP to read
	DATA	>00A2			address in R5 (FDR ptr)
	MOVB	@-1026(R15),R1		get 1 char from filename in FDR
	CI	R1,>2000		is it a space?
	JEQ	H235			yes: end of name
	BLWP	@>005A(R9)		no: set VDP to write
	DATA	>0103			address in R8 (PAB data buffer ptr)
	MOVB	R1,@-2(R15)		copy char in PAB data buffer
	INC	R5			increment source ptr
	INC	R8			increment destination ptr
	DEC	R2			next char
	JNE	H234			
H235	NEG	R2			number of trailing spaces
	AI	R2,10			number of chars in filename
	SWPB	R2			
H233	BLWP	@>005A(R9)		set VDP to write
	DATA	>0003			address in R0 (beg of PAB data buffer)
	MOVB	R2,@-2(R15)		write string length byte
					
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0103			address in R8
	MOV	R7,R1			file type + protection
	BL	@INT2FP			make it a float number
	MOV	R6,R1			file size in sectors, including FDR
	BL	@INT2FP			make it a float number
	MOV	R3,R1			record length
	BL	@INT2FP			make it a float number
	MOV	@>0054(R9),R8		get PAB ptr
	AI	R8,5			point to character count
	LI	R0,>2600		always 38 bytes
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0103			address in R8
	MOVB	R0,@-2(R15)		write # of characters in record
	B	@RTURN1			return to caller
					
CFSVIB	AI	R8,46			count free sectors in VIB bitmap
	LI	R2,200			bitmap size
	CLR	R3			free sectors counter
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0102			address in R8
H236	MOVB	@-1026(R15),R1		get a byte from bitmap
	AI	R1,256			
	SRL	R1,8			
	JEQ	H237			was >FF: no free sectors, next byte
	DEC	R1			was it >00?
	JNE	H238			no: count bits
	AI	R3,8			yes: 8 more free sectors
	JMP	H237			next byte
H238	LI	R0,8			8 bits per byte
H239	SRL	R1,1			test a bit
	JOC	H240			was 1: sector is used
	INC	R3			was 0: one more free sector
H240	DEC	R0			next bit in byte
	JNE	H239			more to come
H237	DEC	R2			next bitmap byte
	JNE	H236			more to come
	B	*R11			
					
FNDRV	MOV	*R11+,R10		find drive in file control blocks
	MOV	R11,R5			save 2 returns
	MOV	@>0056(R9),R8		top of mem word in VDP buffers header
	AI	R8,3			point to max # of files
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0102			address in R8
	MOVB	@-1026(R15),R2		get # of files
	SRA	R2,8			make it a word
	AI	R8,6			point to drive # in file ctrl block
	LI	R3,>0020		filename begin with space (illegal: flag for dir)
	MOVB	R5,R3			add drive #
H241	BL	@VPDR2B			read 2 bytes from VDP at R8 into R0
	C	R3,R0			match with that control block?
	JEQ	H242			yes
	ANDI	R0,>00FF		keep only first char of filename
	JNE	H243			valid filename: a FDR is loaded here
	MOV	R8,R7			this space is free: save ptr
H243	AI	R8,518			point to next file control block
	DEC	R2			next file
	JNE	H241			more to come
	B	*R10			not found: return to address passed in data word
H242	INC	R8			drive matches: point to FDR
	MOV	R8,@>0056(R9)		save ptr
	B	*R5			return to caller after data word

*--------------------------------------
* Floating point format
* ---------------------
* Float numbers are 8 bytes long: EE 12 34 56 78 9A BC
* EE is the exponent in radix 100 (not in radix 10 as usual!). It is biased
* by 64: >40=0, 41=1 (i.e *100), >42=2 (i.e * 10,000) >3F= -1 (i.e /100), etc
*
* 12 ... BC are the mantissa in binary coded decimal: each byte encodes two
* decimal digits from 00 to 99
*
* For negative numbers, the first word is negated
* For zero, the first word is >0000 the others are irrelevant
*
* Examples: 40 08 00 00 00 00 00 00 is 8.0
*           41 02 37 00 00 00 00 00 is 255.0 (>37 hex = 55 decimal)
*           BF F8 00 00 00 00 00 00 is -8.0
*           43 01 02 03 04 05 06 07 is 1020304.050607
*--------------------------------------					
INT2FP	LI	R2,>0800		write an integer in floating point format
	MOVB	R2,@-2(R15)		size=8
	MOV	R1,R5			integer is in R1: save it for sign processing
	ANDI	R1,>7FFF		clear sign bit
	CI	R1,100			is it less than 100?
	JL	H244			yes
	CLR	R0			100 or over
	LI	R4,100			
	DIV	R4,R0			divide by 100
	ORI	R0,>4100		add exponent 2 to hundreths
	JMP	H245			
					
H244	MOV	R1,R0			is it 0?
	JEQ	H246			yes: exponent is 0
	ORI	R0,>4000		no: add exponent 1
H246	CLR	R1			next digits will be 0
					
H245	MOV	R5,R5			test sign bit
	JLT	H247			negative
	JMP	H248			positive or zero
H247	NEG	R0			negate first word
H248	MOVB	R0,@-2(R15)		write exponent to VDP at preset address
	SWPB	R0			
	MOVB	R0,@-2(R15)		write first first 2 digits (or hundreths)
	SWPB	R1			
	MOVB	R1,@-2(R15)		write last 2 digits (if any)
	LI	R2,5			the remaining bytes are all 0 with integers
H249	MOVB	R2,@-2(R15)		write 0 to VDP
	DEC	R2			next byte
	JNE	H249			more to do
	B	*R11			

*---------------------------------------
* Subprogram >10: sector R/W
* --------------
* >834A: (n/a)      <--- sector #
* >834C: drive #
* >834D: R/W code (write if >00)
* >834E: VDP buffer
* >8350: sector #   <--- error code
*---------------------------------------					
ESUB01	MOV	R11,R7			
	BL	@PRPFDO			prepare disk operations
	MOV	@>0050(R9),@>004A(R9)	copy sector #
	B	@SECRW1			

*---------------------------------------
* Subprogram >11: format disk
* --------------					
ESUB02	MOV	R11,R7			
	BL	@PRPFDO			prepare disk operations
	B	@FMTDSK			

*---------------------------------------
* Subprogram >12: file (un)protect
* --------------
* >834C: drive #
* >834D: protect code (>00 unprotect)
* >834E: ptr to filename
* >8350: (n/a)      <--- error code
*---------------------------------------				
ESUB03	MOV	R11,R7			
	BL	@PRPFDO			prepare disk operations
	MOVB	@>004D(R9),R0		get protection code
	ANDI	R0,>0800		keep the bit that will be needed
	BLWP	@>005A(R9)		save R0 on stack
	DATA	>8000			
	MOV	@>004E(R9),R0		get pointer to filename
	BL	@CALSUB			call subroutine
	DATA	RFDRVB			load FDR in VDP buffer
	BLWP	@>005A(R9)		retrieve old R0, in R2
	DATA	>2001			
	BL	@FDR2B1			read two bytes in R0 from top of FDR + offset
	DATA	12			file status byte
	ANDI	R0,>F700		clear protection flag
	SOCB	R2,R0			set it if needed
	BLWP	@>005A(R9)		set VDP for write
	DATA	>0103			address in R8
	MOVB	R0,@-2(R15)		write back file status to FDR
					
UWFLVB	MOV	@>0056(R9),R8		FDR address in VDP mem
	BLWP	@>005A(R9)		set VDP for read
	DATA	>0102			address in R8
	MOVB	@-1026(R15),R0		get drive # in ctrl block
	ORI	R0,>8000		flag it
	BLWP	@>005A(R9)		set VDP for write
	DATA	>0103			address in R8
	MOVB	R0,@-2(R15)		write it back
	B	@UPDFDR			update FDR, load VIB

*---------------------------------
* Subprogram >13: file rename
* --------------
* >834C: drive #
* >834E: ptr to new name
* >8350: ptr to old name <--- error code
*---------------------------------					
ESUB04	MOV	R11,R7			
	BL	@PRPFDO			prepare disk operations
	MOV	@>004E(R9),R0		get ptr to new filename
	BLWP	@>005A(R9)		save R0 on stack
	DATA	>8000			
	MOV	@>0050(R9),R0		get ptr to old filename
	BL	@CALSUB			call subroutine
	DATA	RFDRVB			put FDR in VDP buffer
	BL	@RMFPTR			remove FDR ptr from sector 1
	BL	@FDR2B1			get 2 bytes from FDR
	DATA	12			file status byte
	ANDI	R0,>0800		protected?
	JEQ	H250			no
	BL	@ERROR5			yes: return with error
	DATA	>2000			write protected
H250	BL	@FDR2B1			get 2 bytes from FDR
	DATA	-4			sector # of FDR
	MOV	R0,R1			
	BLWP	@>005A(R9)		retrieve R0 from stack
	DATA	>8001			ptr to new filename
	BLWP	@>005A(R9)		save R1 on stack
	DATA	>4000			sector # of FDR
	BL	@UFNCB			write drive # and filename in compare buffer
	BL	@CALSUB			call subroutine
	DATA	FFDRFN			find FDR from filename
	MOV	R4,R4			found?
	JEQ	H251			yes: return with file error (name already exist)
	BL	@INSFDR			insert a FDR in sector 1
	BLWP	@>005A(R9)		retrieve sect # of FDR in R4
	DATA	>0801			
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0103			address in R8
	MOVB	R4,@-2(R15)		write sector # of FDR
	SWPB	R4			
	MOVB	R4,@-2(R15)			
	SWPB	R4			sector #
	SETO	R2			code for read
	CLR	R5			buffer offset: VDP at >8356
	BL	@CALSUB			call subroutine
	DATA	RDFDR1			read FDR
	MOV	R5,R1			
	MOV	@>0058(R9),R0			
	AI	R0,257			
	DEC	R1			
	BL	@CFNFDR			copy filename in compare buffer to FDR
	CLR	R2			code for write
	BL	@CALSUB			call subroutine
	DATA	RWSEC0			write FDR (with new name in it)
	BL	@CALSUB			call subroutine
	DATA	WRISR1			write sector 1 (with new FDR ptr in it)
	MOV	@>0056(R9),R1		FDR ptr
	BLWP	@>005A(R9)		prepare VDP to write
	DATA	>0023			address in R1
	MOVB	R4,@-2(R15)		clear first char of FDR in buffer
	B	@RTURN1			return to caller
					
RFDRVB	CLR	R6			put FDR in VDP buffer
	MOVB	@>004C(R9),R6		get drive #
	BL	@UFNCB			update filename compare buffer
	BL	@CALSUB			call subroutine
	DATA	FFDRVB			look if FDR already in VDP buffer
	BL	@CALSUB			call subroutine
	DATA	FFDROD			file FDR on disk
	MOV	R4,R4			found?
	JEQ	H252			yes
H251	BL	@RETERR			no: return with error code in >8350
	DATA	>E000			file error
H252	B	@RTURN1			return to caller

*-------------------------------------
* Subprogram >14: file raw read
* --------------
* >834C: drive #                          <--- >00
* >834D: # of sectors (>00=get file info) <--- sectors read
* >834E: ptr to filename
* >8350: file info buffer (>83xx)         <--- error code
*                              |
* >83xx  : VDP buffer       <--'
* >83xx+2: first sector # (total # of sect when get file info)
* >83xx+4: status flag
* >83xx+5: recs/sector
* >83xx+6: eof offset
* >83xx+7: rec size
* >83xx+8: # of recs
*-------------------------------------					
ESUB05	MOV	R11,R7			
	BL	@PRPFDO			prepare disk operations
	BL	@RFNPTR			load filename and ptrs
	BL	@FFFDR			find file FDR, load some info
	MOV	R2,R2			# of sectors to read
	JEQ	H253			>00: get file info
	S	R3,R0			sectors in file - first sector to read
	JGT	H254			in file
	CLR	R2			past eof
	JMP	H255			
H254	C	R2,R0			sectors past first one vs sectors to load
	JL	H256			
	MOV	R0,R2			load what's left
H256	BLWP	@>005A(R9)			
	DATA	>2000			save R2
H257	BLWP	@>005A(R9)			
	DATA	>3100			save R2, R3, R7
	BL	@CALSUB			call subroutine
	DATA	RDOFSC			read sector from offset in file
	BLWP	@>005A(R9)			
	DATA	>3101			retrieve R2, R3, R7
	INC	R3			next sector
	AI	R7,256			increment VDP buffer ptr by 256 bytes
	DEC	R2			more to do?
	JNE	H257			yes
H258	BLWP	@>005A(R9)			
	DATA	>2001			retrieve R2 (# of sectors read)
H255	MOV	R2,@>004C(R9)		update # of sectors in parameters
	JMP	H259			
					
H253	MOV	R0,*R4+			get file info: sectors in file
	DECT	R8			
	INCT	R2			copy 2 bytes (status + recs/sector)
	BL	@VDP2SP			from VDP at R8 to file info structure
	LI	R2,4			copy 4 bytes
	A	R2,R8			
	BL	@VDP2SP			eof offset, rec len, # of recs (or # of sect)
H259	BL	@CALSUB			call subroutine
	DATA	UPDFDR			updata FDR (+ data) if needed, read VIB
	CLR	@>0050(R9)		clear error flag
	B	@RTURN1			return to caller

*--------------------------------------
* Subprogram >15: file raw write
* --------------
* >834C: drive #                                  <--- >00
* >834D: # of sectors (>00=create file from info) <--- # of sectors written
* >834E: ptr to filename
* >8350: file info buffer (>83xx)                 <--- error code
*                              |
* >83xx  : VDP buffer       <--'
* >83xx+2: first sector # (total # of sectors when creating file)
* >83xx+4: status flag
* >83xx+5: recs/sector
* >83xx+6: eof offset
* >83xx+7: rec size
* >83xx+8: # of recs
*--------------------------------------					
ESUB06	MOV	R11,R7			
	BL	@PRPFDO			prepare disk operations
	BL	@RFNPTR			load drive + filename, + a few info
	JEQ	H260			sectors to write=0: create file
	BL	@FFFDR			find file FDR
	BLWP	@>005A(R9)			
	DATA	>2000			save R2 (# of sectors to write)
H261	BLWP	@>005A(R9)			
	DATA	>3100			save R2, R3, R7
	BL	@CALSUB			call subroutine
	DATA	WROFSC			write sector from offset in file
	BLWP	@>005A(R9)			
	DATA	>3101			retrieve R2, R3, R7
	INC	R3			next sector
	AI	R7,256			increment VDP ptr by 256 bytes
	DEC	R2			more to do?
	JNE	H261			yes
	JMP	H258			update # of sectors written, in param. Then return
					
H260	BL	@CALSUB			create file
	DATA	FFDRVB			find file FDR in VDP buffers
	BL	@CALSUB			call subroutine
	DATA	FFDROD			find file FDR on disk
	BL	@CALSUB			call subroutine
	DATA	CRFIL2			create file
	BLWP	@>005A(R9)			
	DATA	>0801			retrieve R4 (file info ptr)
	MOV	@>0056(R9),R8		FDR ptr
	INCT	R4			skip 2 bytes
	MOV	*R4+,R3			# of sector to create
	AI	R8,10			skip filename
	BL	@SP2VDP			write 2 bytes in VDP at R8+2
	DATA	2			i.e. status + recs/sector
	BL	@SP2VDP			write 4 bytes in VDP at new R8+4
	DATA	4			i.e. eof offset, rec len, # of recs (or # of
	DEC	R3			offset = # of sectors-1 (starts from 0)
	JLT	H262			create an empty file, FDR only
	BL	@CALSUB			
	DATA	APSCTS			append enough sectors to reach offset
H262	B	@UWFLVB			modify FDR, write it, load VIB, return

*---------------------------------------
* Subprogram FILES: number of files
*---------------------------------------					
ESUB08	MOV	R11,R7			
	BL	@PRPFDO			prepare disk operation
	MOV	@>002C(R9),R8		ptr to next basic token
	AI	R8,7			skip FILES
	BL	@VPDR2B			get next two bytes in R0
	CI	R0,>C801		>C8=unquoted string, size=1 char
	JNE	H263			return (with error) if different
	INCT	R8			increment pointer
	BL	@VPDR2B			get next two bytes
	SWPB	R0			
	AI	R0,>49D0		substact >B630: # of files >B6=closed parenthesis
	CI	R0,>0009		only 9 files allowed in Basic !
	JH	H263			return with error if more
	SWPB	R0			
	MOVB	R0,@>004C(R9)		put new # of files in scratch-pad memory
	BL	@CALSUB			call subroutine
	DATA	PESB07			subprogram >16 (private entry point)
	MOVB	@>0050(R9),@>0050(R9)	test result
	JNE	H263			error
	MOV	@>002C(R9),R8		ok: get ptr to Basic token
	AI	R8,12			skip the whole statement
	MOV	R8,@>002C(R9)		update ptr
	SZCB	@>0042(R9),@>0042(R9)	clear current token
H263	B	@RTURN1			return to caller (i.e. Basic)

*---------------------------------------
* Subprogram >16: number of files
* --------------
* >834C: # of files
* >8350: (n/a)      <--- error code
*---------------------------------------					
ESUB07	MOV	R11,R7			entry point from assembly
	BL	@PRPFDO			prepare disk operations
PESB07	CLR	R0			entry point from call files
	MOVB	@>004C(R9),R0		get # of files
	JEQ	H264			return with error
	MOV	@>0056(R9),R8		ptr to end of buffer word
	AI	R8,3			point to # of files byte
	CLR	R3			
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0102			address in R8
	MOVB	@-1026(R15),R3		get current # of files
	LI	R5,518			size of 1 file control block
	CB	R0,R3			compare required with current
	JEQ	H265			same: return with no error
	JLE	H266			less
	MOV	R0,R6			more files needed
	CI	R0,>1000		maximum is 16
	JH	H264			return with error
	S	R3,R0			how many to add
	SRL	R0,8			make it a word
	MPY	R5,R0			# of bytes to add
	MOV	R1,R4			result in R0:R1
	NEG	R4			
	MOV	@>0070(R9),R2		highest free address in VDP mem
	MOV	R2,R0			
	S	R1,R0			what it would become
	CI	R0,>0800		is there room enough for VDP?
	JLT	H264			no: return with error
	MOV	R0,R1			ok: new base
H267	INC	R2			increment source ptr
	INC	R0			increment destination ptr
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0042			address in R2
	MOVB	@-1026(R15),R3		get a byte
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0003			address in R0
	MOVB	R3,@-2(R15)		copy a byte
	C	R2,R8			did we copy the whole header?
	JNE	H267			not yet
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0003			address in R0
	MOVB	R5,@-2(R15)		new # of files
	CLR	R6			
	S	R0,R2			
H268	MOVB	R5,@-2(R15)		clear byte
	DEC	R2			
	JNE	H268			
	JMP	H269			
					
H266	BLWP	@>005A(R9)		less files needed
	DATA	>0103			set VDP to write to address in R8
	MOVB	R0,@-2(R15)		new # of files in buffer header
	S	R0,R3			how many to remove
	SRL	R3,8			make it a word
	MPY	R5,R3			# of bytes to remove
	MOV	R4,R1			result in R3:R4
	A	R8,R1			new address for buffer header
	MOV	@>0070(R9),R2		highest free address in VDP mem
H270	BLWP	@>005A(R9)		set VDP to read
	DATA	>0102			address in R8
	MOVB	@-1026(R15),R0		read a byte
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0023			address in R1
	MOVB	R0,@-2(R15)		write byte back
	DEC	R1			decrement destination ptr
	DEC	R8			decrement source ptr
	C	R8,R2			did we copy the whole header?
	JNE	H270			not yet
					
H269	MOV	R1,@>0070(R9)		new first free address
*	MOV	R1,R8			
*H271	INCT	R8			point to end of buffer word
*	BL	@VPDR2B			read it in R0
*	MOVB	@-1026(R15),R1		get CRU base byte
*	CB	R12,R1			same as current controller?
*	JEQ	H265			yes: return with no error
*	A	R4,R0			no: coin address of next buffer
*	BLWP	@>005A(R9)		set VDP to write
*	DATA	>0103			address in R8
*	MOVB	R0,@-2(R15)		write new end of buffer word
*	MOV	R0,R8			and make it new address
*	SWPB	R0			
*	MOVB	R0,@-2(R15)			
*	JMP	H271			now, try again
					
H265	CLR	@>0050(R9)		clear error flag
	JMP	H272			
H264	SETO	@>0050(R9)		set error flag
H272	B	@RTURN1			return to caller
					
UFNCB	CLR	@>0054(R9)		write drive # and filename in compare buffer
	MOV	@>0058(R9),R1		
	AI	R1,256			ptr to filename compare buffer
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0023			address in R1
	MOVB	R5,@-2(R15)		write drive #
CFNFDR	LI	R2,10			filename must be exactly 10 chars
H273	INC	R1			next char in compare buffer
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0002			address in R0
	MOVB	@-1026(R15),R3		get 1 char from filename
	INC	R0			next char in provided filename
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0023			address in R1
	MOVB	R3,@-2(R15)		write 1 char to compare buffer
	DEC	R2			
	JNE	H273			next char
	B	*R11			
					
RFNPTR	MOV	R11,R10			load compare buffer and ptrs
	CLR	R6			
	MOVB	@>004C(R9),R6		drive #
	MOV	@>004E(R9),R0		ptr to filename
	BL	@UFNCB			write them in compare buffer
	MOVB	@>0050(R9),R4		file info structure ptr
	SRL	R4,8			
	A	R9,R4			make it a PAB address
	MOVB	@>004D(R9),R0		# of sectors (>00=get file info)
	BLWP	@>005A(R9)			
	DATA	>0800			save R4
	SRL	R0,8			
	B	*R10			EQ set for get file info
					
FFFDR	BLWP	@>005A(R9)		find file FDR
	DATA	>8010			save R0 + R11
	BL	@CALSUB			call subroutine
	DATA	FFDRVB			find file FDR in VDP buffers
	BL	@CALSUB			call subroutine
	DATA	FFDROD			find FDR on disk
	MOV	R4,R4			found ?
	JEQ	H274			yes
	BL	@ERROR5			no: return with error
	DATA	>E000			file error
H274	BL	@FDR2B1			get two bytes from FDR into R0
	DATA	14			# of sectors in file
	BLWP	@>005A(R9)			
	DATA	>2011			retrieve R0 in R2 (# of sect to read), and R11
	BLWP	@>005A(R9)			
	DATA	>0801			retrieve R4 (ptr to file info structure)
	MOV	*R4+,R7			VDP buffer
	MOV	*R4,R3			first sector
	B	*R11			
					
VDP2SP	BLWP	@>005A(R9)		copy VDP bytes to scratch-pad
	DATA	>0102			read from VDP at R8
H275	MOVB	@-1026(R15),*R4+	read bytes into scratch-pad at R4
	DEC	R2			# of byte in R2
	JNE	H275			next byte
	B	*R11			
					
SP2VDP	MOV	*R11+,R2		copy scratch-pad bytes to VDP
	A	R2,R8			
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0103			address in R8 + offset in data word
H276	MOVB	*R4+,@-2(R15)		write byte from scratch-pad at R4
	DEC	R2			# of bytes in R2, was in data word
	JNE	H276			next byte
	B	*R11	
*-----------------------------------------
* APEDSK constants
*-----------------------------------------
DSDRVS	DATA	>0F00			deselect all drives + side (set bits 7,6,5 and 4 in MSB CRUWRI to 0)	
SIDE01	DATA	>0100			floppy side select

*-----------------------------------------
*
* The remaining bytes (>5xxx to >5FE9) all contain >00
* Word >5FEA maps to the read counter (to generate interrupts when reading data) 
* Bytes >5FEC to >5FEE map to the CRU emulation registers
* Bytes >5FF0 to >5FFE map to the FDC emulation registers
*
*-----------------------------------------					
	END				
					
