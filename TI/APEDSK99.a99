*===============================================================================================================
* TI DISK CONTROLLER ROM   >4000-5FFF
* 
* initial commented disassembly by Thierry Nouspikel
* (see http://www.unige.ch/medecine/nouspikel/ti99/titechpages.htm)
*
* and
* 
* Monty Schmidt's book: TI Technical Drive
*
* adapted for APEDSK99 by Jochen Buur
* github.com/jambuur/APEDSK99
*
* v12r: support for Double Density / 80 tracks (max 1440 AU's)
*================================================================================================================
DSKPRM	EQU     >5FB4                   per DSKx: Mbyte #sectors, Lbyte #sectors, #sectors/track, #tracks, #sides
CALLST  EQU	>5FC6                   CALL() execution status: finished, still active, error
LSTDRV	EQU	>5FC7			remember last drive accessed for LDSK without argument
CALLBF	EQU	>5FC8			2-way buffer for TI BASIC CALL's (1 screen line, 32 characters)
ACOMND	EQU	>5FE8			APEDSK99-specific Command register
RDINT	EQU	>5FEA			issue read interrupt (R6 counter) 
CRUWRI	EQU	>5FEE			emulated 8 CRU output bits
RSTAT	EQU	>5FF0			read FD1771 Status register
RDATA	EQU	>5FF6			read FD1771 Data register
WCOMND	EQU	>5FF8			write FD1771 Command register
WSECTR	EQU	>5FFC			write FD1771 Sector register
WDATA	EQU	>5FFE			write FD1771 Data register
*
XML14	EQU	>164E			ROM address for XML >14
XML16	EQU	>15D6			ROM address for XML >16
*
*!!! CHECK GROM ADDRESS CONTENTS, NEEDS TO BE >0F5C; UNCOMMENT RELEVANT LINE (different GROM 0 versions)
*
*XML5C	EQU	>1039			GROM address for XML >5C; GROM v2.2 consoles
*XML5C	EQU	>1058			GROM address for XML >5C; GROM - Heiner Martin version
XML5C	EQU	>105C			GROM address for XML >5C; GROM - different pointers to character blocks
*
GPLINT	EQU	>006A			jump to GROM interpreter for SCROLL / HONK
XMLRTN	EQU	>2244 			jump to GROM interpreter for RTN (after executing XML >14 / >16 routine)
SCROLL	EQU	>56CD			GROM address for scroll routine
*
*!!! CHECK GROM ADDRESS CONTENTS, NEEDS TO BE >BF58; UNCOMMENT RELEVANT LINE (different GROM 0 versions)
*
*HONK	EQU	>03AF			GROM address for "bad tone"; GROM v2.2 consoles
*HONK	EQU	>03D3			GROM address for "bad tone"; GROM - Heiner Martin version
HONK	EQU	>03D6			GROM address for "bad tone"; GROM - different pointers to character blocks
*
	AORG	>4000
*
	BYTE	>AA			standard header mark
	BYTE	>02			version 2
	DATA	>0000			no programs
	DATA	PWRUP			power-up chain ptr
	DATA	>0000			programs chain ptr (none)
	DATA	DSR01			DSR chain ptr
	DATA	SUB01			subprograms chain ptr
	DATA	>0000			ISR chain ptr (none)
	DATA	>0000			
*					
SUB01	DATA	SUB02			link to next subprogram
	DATA	ESUB01			address of that one
	DATA	>0110			subprogram name: >10 (sector R/W)
SUB02	DATA	SUB03			
	DATA	ESUB02			
	DATA	>0111			subprogram >11 (format disk)
SUB03	DATA	SUB04			
	DATA	ESUB03			
	DATA	>0112			subprogram >12 (file un/protect)
SUB04	DATA	SUB05			
	DATA	ESUB04			
NTPFAT	DATA	>0113			subprogram >13 (file rename); doubles as FAT update flag
*
RTN5C	DATA	>0000			save GPL return address (needs to be @>4028 for XML >5C!)
PATTBL	DATA	>0400			TI BASIC VDP RAM address for Pattern Table; change before calling ALOW from assembly
*
SUB05	DATA	SUB06			
	DATA	ESUB05			
	DATA	>0114			subprogram >14 (file direct input)		
SUB06	DATA	SUB07			
	DATA	ESUB06			
	DATA	>0115			subprogram >15 (file direct output)
SUB07	DATA	SUB08			
	DATA	ESUB07			
	DATA	>0116			subprogram >16 (number of files)
SUB08	DATA	SUB09			
	DATA	ESUB08			
	BYTE	>05			
	TEXT	'FILES'			same as >16, called from Basic
*
SUB09	DATA	SUB10
	DATA	PDSK
	BYTE	>04
	TEXT	'PDSK'			Protect DSKx (apply adhesive tab)
	EVEN
SUB10	DATA	SUB11			
	DATA	UDSK
	BYTE	>04
	TEXT	'UDSK'			Un-protect DSKx (remove adhesive tab)
	EVEN
SUB11	DATA 	SUB12
	DATA	LDSK
	BYTE	>04
	TEXT	'LDSK'			List files on DSKx
	EVEN
SUB12	DATA	SUB13
	DATA	MDSK
	BYTE	>04
	TEXT	'MDSK'			Map DOAD to DSKx
	EVEN
SUB13	DATA	SUB14
	DATA 	NDSK
	BYTE	>04
	TEXT	'NDSK'
	EVEN
SUB14	DATA	SUB15
	DATA	RDSK
	BYTE	>04
	TEXT	'RDSK'			Remove DOAD from SD card
	EVEN
SUB15	DATA	SUB16
	DATA	FGET
	BYTE	>04
	TEXT	'FGET'			Load DOAD from FTP server
	EVEN
SUB16	DATA	SUB17
	DATA	FPUT
	BYTE	>04
	TEXT	'FPUT'			Save DOAD to FTP server
	EVEN
SUB17	DATA	SUB18
	DATA	ADSR
	BYTE	>04
	TEXT	'ADSR'			APEDSK99 load DSR
	EVEN
SUB18	DATA	SUB19
	DATA	NDIR
	BYTE	>04
	TEXT	'NDIR'
	EVEN
SUB19	DATA	SUB20
	DATA	SDSK
	BYTE	>04
	TEXT	'SDSK'			Show DOAD mapping for DSKx
	EVEN
SUB20	DATA	SUB21
	DATA	SDIR
	BYTE	>04
	TEXT	'SDIR'			List DOAD files on SD card
	EVEN
SUB21	DATA	SUB22
	DATA	AHLP
	BYTE	>04
	TEXT	'AHLP'			APEDSK99 CALL help screen
	EVEN
SUB22	DATA	SUB23
	DATA	ALOW
	BYTE	>04
	TEXT	'ALOW'			Load real lower case characters
	EVEN
SUB23	DATA	SUB24
	DATA	ARST
	BYTE	>04
	TEXT	'ARST'			APEDSK99 Reset
	EVEN
SUB24	DATA	>0000
	DATA	TIME
	BYTE	>04
	TEXT	'TIME'			NTP date/time display / assign to NTP$
	EVEN
*
PWRUP	DATA	>0000			power-up chain (no more)
	DATA	EPWRUP			address of power-up routine
	DATA	>0000			no name
*					
DSR01	DATA	DSR02			DSR chain
	DATA	EDSR01			address of DSR
	BYTE	>03			name size
	TEXT	'DSK'			DSR name
DSR02	DATA	DSR03			
	DATA	EDSR02			
	BYTE	>04			
	TEXT	'DSK1'			
	EVEN				
DSR03	DATA	DSR04			
	DATA	EDSR03			
	BYTE	>04			
	TEXT	'DSK2'			
	EVEN				
DSR04	DATA	>0000			no more
	DATA	EDSR04			
	BYTE	>04			
	TEXT	'DSK3'			
	EVEN		
*
*=====================================
* Power-up routine
*=====================================						
*
EPWRUP	CI	R12,>1000		Dhr. F.G. Kaal check: are we powering up 1st CRU (>1000) peripheral?
	JNE	NOCRU			nope; return
*
	MOV	R11,R7			yes; save return address
	STWP	R9			get workspace (should be >83E0)
	AI	R9,-224			point to top of scratch-pad mem (>8300)
	MOV	@>0070(R9),R2		highest free address in vdp mem (>8370)
	MOV	R2,R0			save it
	AI	R2,-2088		we'll need >828 bytes
	MOV	R2,@>0070(R9)		update address
	INC	R2
	BL	@VDPWRI			set VDP address
	LI	R1,2088			
H001	CLR	@-2(R15)		clear these >828 bytes
	DEC	R1			
	JNE	H001			
	BL	@VDPWRI			set VDP address (same)
	LI	R3,>AA03			
	MOVB	R3,@-2(R15)		write buffer ID mark
	NOP				
	MOVB	R0,@-2(R15)		write old highest free address
	SWPB 	R0
	MOVB 	R0,@-2(R15)
	NOP				
	MOVB	R12,@-2(R15)		write CRU address (>1000 for APEDSK99)
	SWPB	R3			
	MOVB	R3,@-2(R15)		write number of files (3)
	BL	@PRPRTN			preparation routine
	BL	@CALSUB			call subroutine
	DATA	RSTDRV			reset all drives
	CLR	@>0054(R9)		name length = 0 for power-up
	BLWP	@>005A(R9)		retrieve R7 (saved by PRPRTN)
	DATA	>0011			put it into R11
	MOV	@K001,@>006C(R9)	???
NOCRU	B	*R11			return
*				
K001	DATA	>0404			
*
*---------------------------------------
* Sector read/write
*---------------------------------------					
*
SECRW1	MOVB	@K002,@>0050(R9)	APEDSK99: no error
	BL	@SELDRV			select drive
*
	MOV	@>004A(R9),R1		sector #
	CI	R1,>05A0		APEDSK99: max 1440 (DS/DD/40T or DS/SD/80T)?
	JL	H005			APEDSK99: yes; sector# within range
	BL	@ERROR1			APEDSK99: no -> "device error"
	DATA 	>0600	

H005	MOV	R1,@WSECTR		APEDSK99: sector# to FD1771 write sector register (16bits)
*
H013	MOV	@>004E(R9),R2		data buffer address
	MOVB	@>004D(R9),R0		read or write ?
	JEQ	H014			write
	BL	@VDPWRI			read FD = write to VDP buffer
H015	LI	R6,256			APEDSK99: re-arranged H015 to sync reading sector bytes
	MOV	R6,@RDINT		APEDSK99: interrupt Arduino for read operation 
	BL	@SNDCMD			send command
	DATA	>8800			APEDSK99: read sector
*
H016	MOVB	@RDATA,R0		get 1 byte from FDC
	MOVB	R0,@-2(R15)		save it to VDP
	DEC	@RDINT			APEDSK99: interrupt Arduino for read operation
	JNE	H016			next byte
*
H019	B	@RTURN1			return

*	
H014	BL	@VDPRD			write to FD = read from VDP buffer
	LI	R6,256			256 bytes to write
*
* APEDSK99: the first byte to be written needs to be in the data register before the write command is given
*
	MOVB	@-1026(R15),R0		APEDSK99: get a byte from data buffer
	MOVB	R0,@WDATA		APEDSK99: write first byte to data register
	BL	@SNDCMD			send command
	DATA	>A800			APEDSK99: write sector
*
H024	MOVB	@-1026(R15),R0		get a byte from data buffer
	MOVB	R0,@WDATA		pass it to data register
	DEC	R6			
	JNE	H024			next byte
*
	BL	@WTCPT1			APEDSK99: check for Write Protect
	SLA	R0,2			APEDSK99: WP bit in Carry
	JOC	ERROR3			write protect: error 34
	JMP	H019			APEDSK99: no need to verify		
*					
ERROR3	BL	@ERROR1			error 34 (Write Protect)
	DATA	>3400			
*
*--------------------------------------------------------------------
* Format disk - APEDSK99: we don't do any physical formatting anymore
*--------------------------------------------------------------------
*
FMTDSK	CLR	@>004A(R9)		called by subprogram >11
*					
H027	SZCB	@K004,@>004C(R9)	clear DSR version flags
*
	BL	@SELDRV			select drive
*
	MOVB	@>004D(R9),R0		APEDSK99: get # of tracks
	CB	@>0051(R9),@K005	APEDSK99: double sided?
	JNE	H036			APEDSK99: single-side
*
	SLA	R0,1			times two (since 2 sides)
*
H036	SRL	R0,8			APEDSK99: make it a byte
	LI	R6,9			APEDSK99: start with single density
	CB	@>0050(R9),@K005	APEDSK99: double density required?
	JNE	H037			APEDSK99: no, leave R6 alone
	SLA	R6,1			APEDSK99: yes, R6*2
*		
H037	MPY	R6,R0			APEDSK99: #sectors/track * #tracks
	CI 	R1,>05A0		APEDSK99: >1440 sectors?
	JLE	H038			APEDSK99: nope; continue
	BL	@ERROR1			APEDSK99: yes; "device error"
	DATA 	>0600	
*
H038	MOV	R1,@>004A(R9)		pass total # of sectors per disk
	SWPB 	R6
	MOVB 	R6,@>004D(R9)		APEDSK99: pass # of sectors per track
	MOVB	@K002,@>0050(R9)	no error
*
	BL	@NTPDT			APEDSK99: update DOAD FAT time/date
*
	B	@RTURN1			return
*					
					
VDPRPW	MOV	*R11+,R6		VDP repeated write
H044	MOVB	R0,@-2(R15)
	DEC	R6			byte in R0
	JNE	H044			number of repeats in data word
	B	*R11			
*
WTCPT1	MOVB	@RSTAT,R0		get status. APEDSK99: Not Ready >80 / Write Protect >40
	JLT	ERROR4			drive not ready. APEDSK99: Not Ready set when DOAD file is unavailable
	B	*R11			
*
ERROR4	BL	@ERROR1			exit with error code 6, reseting all drives
	DATA	>0600			
*					
SELDRV	MOV	R11,R7			select a drive
	MOV	@>0058(R9),R2
	AI	R2,-10			point to drive info
H055	CLR	R0			
	MOVB	@>004C(R9),R0		get drive #
	JEQ	H056			can't be >00: error #7
	CI	R0,>0300			
	JH	H056			drive number can't be higher than 3: error #7
	BL	@VDPWRI			set VDP to write, address in R2
	MOVB	R0,@-2(R15)		modify last drive accessed		
*
H057	SLA	R0,1			APEDSK99: bit 0 is side select, 1-3 is drive #
	MOVB	R0,@CRUWRI		APEDSK99: select drive
H058	B	*R7			
*					
H056	BL	@ERROR1			exit with error #7
	DATA	>0700			
*					
RSTDRV	SZCB 	@DSDRVS,@CRUWRI		APEDSK99: reset all drives including side
	MOVB	@K013,@WCOMND		send Force Interrupt with no interrupt flag set
	MOV	@>0058(R9),R2		ptr to VIB buffer
	AI	R2,-10			now points to drive info buffer
	BL	@VDPWRI			set VDP to write to address in R2
	LI	R0,4			
H061	MOVB	R0,@-2(R15)		write four >00 (i.e. clear drive info)
	DEC	R0			
	JNE	H061			
	MOVB	@K002,@>0050(R9)	no error
	B	@RTURN1			get return address from stack
*					
ERROR1	MOV	*R11,R0			exit with error
	MOVB	R0,@>0050(R9)		place err code in >8350
	CI	R0,>0600		check if device error
	JNE	H064			no: exit
	BL	@SNDCMD			yes: reset drives
*
K013	DATA	>0000			APEDSK99: send Restore command
*
H064	B	@RTURN1			return to caller (address from stack)
*				
SNDCMD	MOV	*R11+,R0		send command to FDC from data word
H066	MOVB	R0,@WCOMND		send command
	B	*R11			
*					
LASTRK	CLR	R0			get last track # for this drive
	MOVB	@>004C(R9),R0		get drive #
	JEQ	H068			can't be 0
	SWPB	R0			
	CI	R0,3			
	JH	H068			can't be higher than 3
	MOV	@>0058(R9),R2			
	AI	R2,-10			point to last drive accessed
	A	R0,R2			point to last track for this drive
	B	@VDPRD			prepare VDP to read from address in R2
*					
H068	BL	@ERROR1			exit with error code 7
	DATA	>0700			
*					
VDPWRI	ORI	R2,>4000		set VDP address to write
	ANDI	R2,>7FFF		not to a register
	JMP	H069			
VDPRD	ANDI	R2,>3FFF		set VDP address to read
H069	SWPB	R2			
	MOVB	R2,*R15			write address
	SWPB	R2			
	MOVB	R2,*R15			
	ANDI	R2,>3FFF			
	B	*R11			
*					
K002	BYTE	>00			
K007	BYTE	>09						
K004	BYTE	>F0			
K005	BYTE	2
DSDRVS	BYTE	>0F			APEDSK99: deselect all drives + side (reset CRUWRI bits 7,6,5 and 4)			
*
	EVEN
*				
CALSUB	DECT	@>0066(R9)		call subroutine, return address in stack
	MOV	@>0066(R9),R10
	BLWP	@>005A(R9)		set VDP to write to address in R10
	DATA	>0143			
	MOV	*R11+,R10		get next data word
	SWPB	R11			write return address to VDP
	MOVB	R11,@-2(R15)			
	SWPB	R11			
	MOVB	R11,@-2(R15)			
	B	*R10			branch to address in data word
*				
RTURN1	MOV	@>0066(R9),R11		get return address from VDP stack
	BLWP	@>005A(R9)		
	DATA	>0162			set VDP to read from address in R11
	MOVB	@-1026(R15),R11			
	SWPB	R11			
	MOVB	@-1026(R15),R11			
	INCT	@>0066(R9)			
	B	*R11			
*
*---------------------------------------
* Custom routines, dealing with VDP memory
* Format is >pppr where r is routine number (0-3)
* and ppp contains parameters
* The workspace it >8300. Called by BLWP @>005A(9).
*---------------------------------------					
*
ECUSTM	MOV	R13,R10			save wregs ptr
	MOV	*R14+,R8		get next data word
	MOV	R8,R9			save it
	SRL	R9,4			keep parameter
	ANDI	R8,3			four possible operations
	A	R8,R8			make it a word ptr
	MOV	@>001E(R13),R11		get old R15, i.e. VDP port (>8C02)
	MOV	@VECRTN(R8),R8		get vector for operation
	B	*R8			branch to it
*					
VECRTN	DATA	SVRVDP			save registers to VDP stack
	DATA	RVRVDP			retrieve registers
	DATA	SVDPRD			set VDP address to read
	DATA	SVDPWR			set VDP address to write
*					
SVRVDP	AI	R10,22			0: save registers in VDP mem
H072	SRL	R9,1			start with R12
	JNC	H070			bits in >ppp tell which register to save (R0-R11)
	DECT	R12			previous address in VDP stack (grows down)
	MOV	*R10,R8			get register contents
	SWPB	R12			set VDP address to write
	MOVB	R12,*R11		R12 is >8366: VDP stack ptr
	SWPB	R12			
	ORI	R12,>4000			
	MOVB	R12,*R11			
	SWPB	R8			save register to VDP mem
	MOVB	R8,@-2(R11)			
	SWPB	R8			
	MOVB	R8,@-2(R11)			
	MOV	R9,R9			more to come?
	JEQ	H071			no:return
H070	DECT	R10			point to previous register
	JMP	H072			
*				
RVRVDP	SLA	R9,4			1: retrieve registers from VDP mem
H074	SLA	R9,1			each bit tells whether to load
	JNC	H073			don't retrieve that one
	SWPB	R12			set VDP address to read
	MOVB	R12,*R11		R12 is >8366: VDP stack ptr
	SWPB	R12			
	ANDI	R12,>3FFF			
	MOVB	R12,*R11			
	NOP				
	MOVB	@-1026(R11),R8		get a 2-byte value from VDP
	SWPB	R8			
	MOVB	@-1026(R11),R8			
	MOV	R8,*R10			save it to register
	INCT	R12			increment ptr (stack grows downwards)
	MOV	R9,R9			more to come?
	JEQ	H071			no: return
H073	INCT	R10			next register
	JMP	H074			
H071	RTWP				
*					
SVDPWR	A	R13,R9			2: set VDP for a write
	MOV	*R9,R8			
	ORI	R8,>4000		get address from reg in >..p2 (*2)
	JMP	H075			
*					
SVDPRD	A	R13,R9			3: set VDP for a read
	MOV	*R9,R8
	ANDI	R8,>3FFF		get register from reg in >..p3 (*2)
H075	SWPB	R8			set VDP address
	MOVB	R8,*R11			
	SWPB	R8			
	MOVB	R8,*R11			
	RTWP				
*
*---------------------------------------
* Preparation subroutine
* Sets up the 4 custom subroutines
* Gets a few pointers to VDP buffers
*  >8358: copy of VIB  >8366: VDP stack ptr (grows down from drive info)
*  >8354: PAB          >8356: ptr to end-of-buffer
*---------------------------------------					
*
PRPFDO	INCT	R7			stop scanning upon return
PRPRTN	MOV	R11,R10			save return address
	STWP	R9			get workspace (should be >83E0)
	AI	R9,-224			top of scratch/pad mem (>8300)
	LI	R0,ECUSTM		entry to 4 custom routines
	MOV	R0,@>005C(R9)		put it in >835C
	MOV	R9,R0			
	AI	R0,>004E		workspace for these four (>834E)
	MOV	R0,@>005A(R9)		put it in >835A
*					
	MOV	@>0070(R9),R8		highest free address in VDP mem
H076	INCT	R8			point to end-of-buffer word
	BL	@VDPR2B			read 2 bytes from VDP address R8, into R0
	MOV	R8,R2			save current R8
	MOV	R0,R8			get end-of-buffer word
	AI	R8,-266			yes: point to volume information block
	MOV	R8,@>0058(R9)		save it in >8358
	AI	R8,-10			point to disk drive info (drive #, last tracks)
	MOV	R8,@>0066(R9)		save in >8366: VDP stack ptr (DECT before writing)
	BLWP	@>005A(R9)		save R7 (return address)
	DATA	>0100			
	MOV	@>0056(R9),R7		ptr to PAB: end of DSR name
	MOV	R7,R3			save it
	S	@>0054(R9),R7		start of DSR name
	MOV	R2,@>0056(R9)		>8356: ptr to end-of-buffer word in VDP mem
	DEC	R7			point to name length byte
	CLR	R2			
	BLWP	@>005A(R9)		set VDP to read from address in R2
	DATA	>00E2			
	MOVB	@-1026(R15),R2		get name length byte
	SWPB	R2			make it a word
	S	@>0054(R9),R2		minus DSR name size: lenght of .parameters
	AI	R7,-9			point to top of PAB
	MOV	R7,@>0054(R9)		save it in >8354
	B	*R10			
*				
CRFIL1	BL	@CALSUB			create file
	DATA	FNDFDR			find a FDR in disk
CRFIL2	MOV	R4,R4			found?
	JNE	CRFIL3			no
	BL	@CALSUB			yes: delete old file
	DATA	FFSVIB			free file sector in VIB bitmap
	JMP	H077			clear its FDR
*				
CRFIL3	BL	@INSFDR			new file: insert a FDR in sector 1
	SETO	R1			
	BL	@CALSUB			call subroutine
	DATA	FFSBMP			find a free sector in VIB bitmap
	MOV	R0,R0			found?
	JNE	H078			yes: # in R0
	BL	@ERROR5			no: update data, then return with error
	DATA	>8000			memory full
*				
H078	BLWP	@>005A(R9)		set VDP to write
	DATA	>0103			address in R8
	MOVB	R0,@-2(R15)		write sector # for FDR in sector 1
	SWPB	R0			
	MOVB	R0,@-2(R15)			
	SWPB	R0			
	MOV	@>0056(R9),R1		ptr to FDR in VDP buffers
	AI	R1,-4			ptr to sector # for FDR
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0023			address in R1
	MOVB	R0,@-2(R15)		write sector # for FDR in VDP buffer
	SWPB	R0			
	MOVB	R0,@-2(R15)			
	AI	R1,3			ptr to drive #
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0023			address in R1
	MOVB	R6,@-2(R15)		write drive # before FDR in VDP buffer
	CLR	R2			code for write
	INC	R1			
	BL	@CALSUB			call subroutine
	DATA	WRSEC1			write sector 1
	MOV	@>0058(R9),R5		ptr to VIB in VDP buffers
	CLR	R4			sector 0
	BL	@CALSUB			call subroutine
	DATA	RWSEC			write VIB to sector 0
	MOV	R5,R3			copy filename from compare buffer to FDR
	AI	R3,257			ptr to file compare buffer
	LI	R2,10			10 chars per filename
H079	BLWP	@>005A(R9)		set VDP to read
	DATA	>0062			address in R3
	MOVB	@-1026(R15),R0		get 1 char
	INC	R3			increment source ptr
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0023			address in R1
	MOVB	R0,@-2(R15)		copy 1 char
	INC	R1			increment destination ptr
	DEC	R2			# of chars in R2
	JNE	H079			next
*
H077	BL	@NTPDT			APEDSK99: update DOAD FAT time/date
*
	MOV	@>0056(R9),R1		FDR ptr
	AI	R1,10			skip filename
	LI	R2,246			remaining bytes in FDR
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0023			address in R1
H080	MOVB	R2,@-2(R15)		write >00
	DEC	R2			clear remainder of new FDR
	JNE	H080			next byte
	JMP	H081			write FDR to disk return to caller
*					
H082	MOV	@>0056(R9),R5		check if FDR must be updated
	BLWP	@>005A(R9)		set VDP to read
	DATA	>00A2			address in R5
	MOVB	@-1026(R15),R4		get filename in file ctrl block
	JLT	H083			flag: FDR was modified, update it
	JMP	H084			
H083	ANDI	R4,>7F00		clear flag bit
	BLWP	@>005A(R9)		st VDP to write
	DATA	>00A3			address in R5
	MOVB	R4,@-2(R15)		write back filename without flag bit
H081	CLR	R2			code for write
	B	@WRFDR			write FDR to disk
H084	B	@RTURN1			return to caller
*				
UPDFDR	BL	@CALSUB			update FDR + data
	DATA	UPDBF			update data buffer if necessary
	BL	@CALSUB			call subroutine
	DATA	H082			update FDR if necessary
CLRFBT	MOV	@>0056(R9),R5			
	CLR	R6			
	BLWP	@>005A(R9)		set VDP to write
	DATA	>00A3			address in R5
	MOVB	R6,@-2(R15)		clr first byte of filename in FDR
	B	@RWVIB			
*					
UPDBF	MOV	@>0056(R9),R4		check if data buffer must be updated
	DEC	R4			
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0082			address in R4
	MOVB	@-1026(R15),R1		get drive #
	JLT	H085			flag: must be updated
	JMP	H086			no need to update: return
H085	ANDI	R1,>7F00		erase flag
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0083			address in R4
	MOVB	R1,@-2(R15)		write back drive # without flag
	AI	R4,-5			point to current logical record offset
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0082			address in R4
	MOVB	@-1026(R15),R3		get current logical record offset
	SWPB	R3			
	MOVB	@-1026(R15),R3			
	SWPB	R3			
	MOV	R4,R7			
	AI	R7,262			point to data buffer area
	JMP	WROFSC			
H086	B	@RTURN1			return to caller
*				
FFSVIB	MOV	@>0056(R9),R2		free file sectors in VIB bitmap
	AI	R2,12			
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0042			address in R2
	MOVB	@-1026(R15),R0		get file status byte from FDR
	ANDI	R0,>0800		write protected?
	JEQ	H087			no
	BL	@ERROR5			update data if needed, the return with error
	DATA	>2000			write protected
*					
H087	MOV	@>0056(R9),R8		get ptr to FDR
	AI	R8,28			point to clusters list
	SETO	R4			previous offset
H089	BL	@DECDCI			decode cluster info: sector in R1, offset in R2
	AI	R8,3			next cluster ptr
	MOV	R1,R1			
	JEQ	H088			sector 0 = no more clusters
	MOV	R2,R0			total offset
	S	R4,R2			minus previous cluster offset = cluster size
	MOV	R0,R4			new previous cluster offset
	BL	@CALSUB			call subroutine
	DATA	FRSCB1			free sectors in bitmap (from R1, # in R2)
	MOV	R8,R1			
	S	@>0056(R9),R1			
	CI	R1,>0100		end of FDR reached?
	JNE	H089			not yet
H088	B	@RTURN1			return to caller
*					
RDOFSC	BL	@FDR2B1			read a sector from offset in file
	DATA	14			get # of sectors
	C	R0,R3			is desired sector in file?
	JH	H090			yes
	BL	@ERROR5			no: update data, then return with error
	DATA	>A000			past end-of-file
H090	BL	@CALSUB			call subroutine
	DATA	FSCTOF			find sector from cluster list
	A	R1,R4			put sector in R4
	SETO	R2			code for read
H091	MOV	R7,R5			buffer ptr
	B	@RWSEC			read/write sector
*					
WROFSC	BLWP	@>005A(R9)		write sector to offset in file offset in R3
	DATA	>8100			save R0 and R7
	BL	@CALSUB			call subroutine
	DATA	APSCTS			append enough sectors to reach that offset
	BLWP	@>005A(R9)		retrieve R0 and R7
	DATA	>8101			
	CLR	R2			code for write
	JMP	H091			write sector
*				
APSCTS	BL	@FDR2B1			append sector(s) to a file to get offset in R3
	DATA	14			get # of sect from FDR
*					
	C	R0,R3			is desired sector in file?
	JH	H092			yes: find it and return
	MOV	R0,R0			
	JEQ	H093			empty file
	DEC	R0			last sector #
H093	MOV	R3,R5			save desired sector offset
	MOV	R0,R3			last sector in file
	BL	@CALSUB			call subroutine
	DATA	FSCTOF			find sector # from offset in file
	BLWP	@>005A(R9)		save R1 (sector #)
	DATA	>4000			
	A	R4,R1			# of last sector in cluster
	MOV	R5,R4			offset of desired sector
H095	BL	@CALSUB			call subroutine
	DATA	FFSBMP			find free sector in bitmap, starting from R1
	MOV	R0,R0			found?
	JNE	H094			yes: # in R0
	MOV	R2,R5			no: save # of sectors
	BL	@ADDSEC			update FDR
	JMP	H096			return with memory full
*					
H094	MOV	R1,R1			
	JEQ	H097			empty cluster
	INC	R1			one more sector in cluster
	C	R0,R1			same as the one found in bitmap?
	JEQ	H098			yes: just increase cluster size
	BLWP	@>005A(R9)		no: retrieve R1 (sector #)
	DATA	>4001			
	BLWP	@>005A(R9)		save R0 + R2
	DATA	>A000			
	BL	@UPDCLI			update current cluster info
	BLWP	@>005A(R9)		retrieve R0 + R2
	DATA	>A001			
	AI	R8,3			ptr to next cluster info
	MOV	R8,R1			
	S	@>0056(R9),R1		current FDR size
	CI	R1,>0100		room enough?
	JNE	H099			yes
	BL	@CALSUB			no: call subroutine
	DATA	FFSBM			free sector in bitmap
H096	B	@ERROR6			return with memory full
*					
H099	MOV	R0,R1			new sector #
	BLWP	@>005A(R9)		save R1
	DATA	>4000			
H098	JMP	H100			make a new cluster
*					
H097	BLWP	@>005A(R9)		retrieve R1
	DATA	>4001			
	BLWP	@>005A(R9)		save R0
	DATA	>8000			
	SETO	R2			empty file: start from offset 0
H100	MOV	R0,R1			sector #
	INC	R2			increment cluster size
	C	R2,R4			enough?
	JNE	H095			no: get one more sector
	MOV	R4,R5			
	BL	@ADDSEC			add sector to FDR
	JMP	H101			done
*				
H092	BL	@CALSUB			call subroutine
	DATA	FSCTOF			find a sector from offset in file
	A	R1,R4			last sector in cluster
H101	B	@RTURN1			return to caller
*					
ADDSEC	MOV	R11,R10			add sector to FDR
	MOV	R1,R4			
	BLWP	@>005A(R9)		retrieve R1
	DATA	>4001			
	MOV	R1,R1			sector #
	JEQ	H102			none: return
	BL	@UPDCLI			write info for R1 cluster
	MOV	@>0056(R9),R2		pointer to FDR
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0042			address in R2
	MOVB	@-1026(R15),R1		first char of filename
	ORI	R1,>8000		flag
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0043			address in R2
	MOVB	R1,@-2(R15)			
	AI	R2,14			ptr to # of sectors
	INC	R5			new # of sectors
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0043			address in R2
	MOVB	R5,@-2(R15)		update # of sectors
	SWPB	R5			
	MOVB	R5,@-2(R15)			
H102	B	*R10			
*					
FSCTOF	MOV	@>0056(R9),R8		find sector from offset in file
	AI	R8,28			cluster list
	MOV	R3,R4			desired sector offset is in R3
H105	BL	@DECDCI			decode info: sector in R1, offset in R2
	C	R2,R3			reached yet?
	JLT	H103			no
	JMP	H104			yes: return
H103	AI	R8,3			point to next cluster info
	MOV	R3,R4			
	S	R2,R4			
	DEC	R4			size of the desired cluster (if it's the next)
	JMP	H105			keep trying
H104	B	@RTURN1			return to caller
*
*---------------------------------
* Opcode 7: Delete
* ----------------
* PAB 0: >07
*     1:            <--- error code
*   2-3:
*     4:
*     5:
*   6-7:
*     8:
*---------------------------------					
*
DELETE	BL	@CALSUB			delete file
	DATA	FFFDRV			find file FDR in VDP buffers
	MOV	R4,R4			found?
	JEQ	H106			yes
	BL	@CALSUB			no: call subroutine
	DATA	FFDRDK			find FDR on disk
	MOV	R4,R4			found?
	JEQ	H107			yes
	B	@RTURN1			no: return to caller
*					
H106	INC	R1			FDR found, point to it
	MOV	R1,@>0056(R9)		save it for other routines
	BL	@CALSUB			call subroutine
	DATA	RDSEC1			read sector 1
	BL	@FDR2B1			read 2 bytes from VDP at >8356+offset
	DATA	-4			i.e. get sector # of FRD in R0
	MOV	R0,R3			save it for later
	MOV	R5,R8			ptr to top of sector 1
H108	BL	@VDPR2B			read 2 bytes from VDP at R8 into R0
	INCT	R8			next FDR ptr in sector 1
	C	R0,R3			is this the one we want?
	JNE	H108			not yet
	DECT	R8			yes: point back to it
*
H107	BL	@NTPDT			APEDSK99: update DOAD FAT time/date
*
	BLWP	@>005A(R9)		save R8
	DATA	>0080			
	BL	@CALSUB			call subroutine
	DATA	FFSVIB			free file sectors in VIB bitmap
	BLWP	@>005A(R9)		retrieve R8
	DATA	>0081			
	BL	@RMFPTR			remove FDR ptr from sector 1
	CLR	R2			code for write
	BL	@CALSUB			call subroutine
	DATA	WRSEC1			write sector 1
	BL	@FDR2B1			get 2 bytes from VDP at >8356+offset in R0
	DATA	-4			i.e. sector # of FDR
	BL	@CALSUB			call subroutine
	DATA	FFSBM			free sector in R0 in VIB bitmap
	B	@CLRFBT			clear 1rst byte of filename in VDP
*
* Sector 1 contains an alphabetically sorted list of FDR pointers
* Each pointer is 2 bytes long and contains the sector # of this FDR
* The list must end with a >0000 mark. Thus there can be 127 files at most
*
RMFPTR	MOV	@>0056(R9),R5		remove FDR ptr from sector 1
	AI	R5,256			
	MOV	R5,R3			pointer to data buffer
	AI	R3,256			point to next ctrl block
	MOV	R8,R2			shift up FDR list, erasing FDR pointed by R8
	INCT	R2			point to next FDR ptr in sector 1
H109	BLWP	@>005A(R9)		set VDP to read
	DATA	>0042			address in R2
	MOVB	@-1026(R15),R0		get 1 byte
	INC	R2			inc source ptr
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0103			address in R8
	MOVB	R0,@-2(R15)		copy 1 byte
	INC	R8			inc dest pointer
	C	R2,R3			done?
	JNE	H109			not yet
	B	*R11			
*					
INSFDR	MOV	R11,R10			insert a FDR in sector 1
	MOV	R8,R1			
	BL	@FDR2B1			get 2 bytes from VDP at >8356+offset
	DATA	508			i.e. last FDR slot in sector 1 (list ends with 0)
	MOV	R0,R0			
	JEQ	H110			
	B	@ERROR6			memory full error
H110	DEC	R8			previous byte
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0102			address in R8
	MOVB	@-1026(R15),R0		get 1 byte
	INCT	R8			
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0103			address in R8
	MOVB	R0,@-2(R15)		copy byte two bytes further down
	DECT	R8			
	C	R8,R1			done ?
	JNE	H110			not yet
	B	*R10			
*				
CMPFN	MOV	@>0058(R9),R2		compare filenames
	AI	R2,256			
H111	BLWP	@>005A(R9)		set VDP to read
	DATA	>0022			address in R1 (ptr to filename)
	MOVB	@-1026(R15),R0		get 1 char
	ANDI	R0,>7FFF		clear flag (on drive #)
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0042			address in R2 (filename compare buffer)
	MOVB	@-1026(R15),R3		get 1 char
	CB	R0,R3			compare chars
	JNE	H112			mismatch
	INC	R1			match: increment pointers
	INC	R2			
	DEC	R4			
	JNE	H111			next char
H112	B	*R11			if complete match: ret with EQ set
*					
PABR2B	MOV	@>0054(R9),R8		get two bytes from PAB
	JMP	FDR2B2			
*					
FDR2B1	MOV	@>0056(R9),R8		get two bytes from FDR
FDR2B2	A	*R11+,R8		offset in data word
*					
VDPR2B	BLWP	@>005A(R9)		get two byte from VDP at R8
	DATA	>0102			set VDP to read at R8
	MOVB	@-1026(R15),R0		get two bytes of data
	SWPB	R0			
	MOVB	@-1026(R15),R0			
	SRC	R0,8			why not swpb ?
	B	*R11			
*			
FDSKDR	MOV	@>0058(R9),R1		find disk from name (ptr in R3)
	AI	R1,256			
	BL	@CPCKFN			copy filename from VDP at R3 to compare buffer
	BLWP	@>005A(R9)		save R2 + R3
	DATA	>3000			
	MOV	R0,R0			last char copied
	JLT	H113			flagged
	JMP	H114			
H113	MOV	R0,R6			
	ANDI	R6,>0300			
	JEQ	ERROR7			return with file error
	JMP	H115			return to caller
H114	CLR	R6			don't read any drive
	BL	@CALSUB			call subroutine
	DATA	RWVIB			save current VIB
H116	AI	R6,>0100		next drive
	SETO	R7			error flags
	SETO	R2			code for read
	CLR	R4			sector 0
	BL	@CALSUB			call subroutine
	DATA	RWSECA			read sector 0
	MOV	R7,R7			ok?
	JNE	H118			no: try next drive
	LI	R4,10			yes: diskname size
	MOV	@>0058(R9),R1		VIB ptr
	BLWP	@>005A(R9)		save R1-R3
	DATA	>7000			
	BL	@CMPFN			compare names (ptr in R1 + compare buffer)
	BLWP	@>005A(R9)			
	DATA	>7001			retrieve R1-R3
	MOV	R4,R4			name matched?
	JNE	H118			no: try next drive
	MOV	R6,R0			drive #
	ORI	R0,>8000		add update flag
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0063			address in R3
	MOVB	R0,@-2(R15)		copy drive+flag before diskname in source
	DEC	R5			before sector 0 copy
	BLWP	@>005A(R9)		set VDP to write
	DATA	>00A3			address in R5
	MOVB	R6,@-2(R15)		copy drive # before VIB
	JMP	H115			done
*				
H118	CI	R6,>0300		did we do all drives?
	JNE	H116			no: try next on
	JMP	ERROR7			return with file error
*					
H115	BLWP	@>005A(R9)		retrieve R2 + R3
	DATA	>3001			
	B	@RTURN1			return to caller
*				
CPCKFN	DEC	R2			
	JH	H119			
ERROR7	BL	@RETERR			return with error
	DATA	>E000			file error
*					
H119	LI	R0,>2000		copy (+check) filename in VDP from R3 to R1 (space)
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0023			address in R1
	LI	R8,10			10 chars per filename
H120	MOVB	R0,@-2(R15)		fill filename with spaces
	DEC	R8			
	JNE	H120			
	LI	R8,11			11 chars countring drive #
H122	INC	R3			increment source ptr
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0062			address in R3
	MOVB	@-1026(R15),R0		get a char
	JEQ	ERROR7			>00: return with file error
	JLT	H121			flag bit set
	CI	R0,>2E00			
	JEQ	H121			'.'
	DEC	R8			
	JEQ	ERROR7			name to long: return with file error
	CI	R0,>2000			
	JEQ	ERROR7			name can't contain spaces: file error again
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0023			address in R1
	MOVB	R0,@-2(R15)		copy 1 char
	INC	R1			increment destination pointer
	DEC	R2			more?
	JNE	H122			yes
H121	CI	R8,>000B		name can't be 0 chars long
	JEQ	ERROR7			else return with file error
	B	*R11			
*					
K014	DATA	>AA00			
*				
ERROR5	MOV	R11,R0			update data, then error
	MOV	@>0056(R9),R3		
	DEC	R3			see what >8356 is pointing at
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0062			address in R3
	MOVB	@-1026(R15),R2		get 1 byte
	CB	R2,@K014		is it >AA (disk buffer area mark)
	JEQ	H123			yes: announce error (code in data word)
	BLWP	@>005A(R9)		no: >8356 points to a FDR. Save R0
	DATA	>8000			
	BL	@CALSUB			call subroutine
	DATA	UPDFDR			update FRD and data buffer if needed
	BLWP	@>005A(R9)		retrieve R0
	DATA	>8001			
H123	MOV	R0,R11			
*				
RETERR	MOV	@>0054(R9),R1		annouce error
	JEQ	H124			no PAB
	INC	R1			for DSRs: ptr to status byte
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0022			address in R2
	MOVB	@-1026(R15),R2		get file status byte
	SOC	*R11+,R2		add error code
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0023			address in R2
	MOVB	R2,@-2(R15)		write back status byte
	JMP	H125			
H124	MOV	*R11+,@>0050(R9)	for subs: error code in >8350
H125	MOV	@>0058(R9),R8		get stack ptr
	AI	R8,-12			point back to initial caller
	MOV	R8,@>0066(R9)		update pointer
	B	@RTURN1			return to caller
*				
RWVIB	BLWP	@>005A(R9)		read VIB (drive # in R6)
	DATA	>3000			save R2 + R3
	MOV	@>0058(R9),R5		pointer to VIB in ctrl block
	DEC	R5			ptr to drive #
	BLWP	@>005A(R9)		set VDP for read
	DATA	>00A2			address in R5
	MOVB	@-1026(R15),R2		get drive #
	MOV	R2,R3			
	CLR	R4			sector 0 for VIB
	ANDI	R2,>0300		clear flag (>80 = update data)
	CB	R2,R6			wanted drive?
	JEQ	H126			yes: return
	MOV	R3,R3			no: shall we update VIB?
	JLT	H127			yes
	JMP	H128			no
H127	BLWP	@>005A(R9)		set VDP to write
	DATA	>00A3			address in R5
	MOVB	R4,@-2(R15)		clr drive #
	INC	R5			point back to VIB buffer
	BL	@CALSUB			call subroutine
	DATA	RWSECB			write sector 0 to old drive (in R2)
	DEC	R5			point to drive #
H128	SETO	R2			flag for read
	MOVB	R6,R2			APEDSK99: error in original disassembly (was R5)
	JEQ	H129			none
	INC	R5			point at VIB buffer
	BL	@CALSUB			call subroutine
	DATA	RWSECA			read sector (in R4) to buffer (in R5)
	DEC	R5			point at drive #
H129	BLWP	@>005A(R9)		set VDP to write
	DATA	>00A3			address in R5
	MOVB	R6,@-2(R15)		write drive # in control block, before FDR
H126	INC	R5			point back to FDR
	BLWP	@>005A(R9)			
	DATA	>3001			retrieve R2 + R3 from stack
	B	@RTURN1			branch to address on stack
*				
RDSEC1	SETO	R2			read sector 1
WRSEC1	LI	R4,1
	LI	R5,>0100		into data buffer area of current ctrl block
	JMP	RDFDR1			
*				
WRFDR	BL	@FDR2B1			read FDR
	DATA	-4			get sector # of FDR from control block
*				
RDFDR2	MOV	R0,R4			sector read/write
	CLR	R5
RDFDR1	A	@>0056(R9),R5		point to FDR or data buffer
RWSEC	CLR	R7			
RWSECA	MOVB	R6,R2			add drive # for r/w flag
RWSECB	BLWP	@>005A(R9)		save R0-R8
	DATA	>FF80			
	MOV	R4,@>004A(R9)		sector #
	MOV	R2,@>004C(R9)		drive | r/w flag
	MOV	R5,@>004E(R9)		buffer ptr
	BL	@CALSUB			call subroutine
	DATA	SECRW1			sector read/write
	BLWP	@>005A(R9)		retrieve R0-R8
	DATA	>FF81			
	MOVB	@>0050(R9),R7		get error code | flags
	SWPB	R7			
	JEQ	H130			
	MOV	R7,R7			
	JGT	H131			
	JMP	H132			
H131	ANDI	R7,>00FF			
	CI	R7,>0034			
	JNE	H133			
	BL	@ERROR5			
	DATA	>2000			write protected
H133	BL	@ERROR5			
	DATA	>C000			device error
H132	MOVB	@>004D(R9),@>004D(R9)	read or write?
	JEQ	H131			write
H130	ANDI	R7,>00FF			
	B	@RTURN1			return to caller
*				
FFFDRV	MOV	@>0058(R9),R1		save filename in compare buffer and find its FDR
	AI	R1,256			
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0023			address in R1: filename compare buffer
	MOVB	R6,@-2(R15)		write drive #
	INC	R1			
	BL	@CPCKFN			copy (+ check) filename from R3 to R1
	MOV	R2,R2			all chars copied (or was there a . or a >00
	JEQ	FFDRVB			
H136	B	@ERROR7			return with file error
*					
FFDRVB	MOV	@>0056(R9),R1		find filename in buffered FDRs
	AI	R1,3			
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0022			address in R1
	MOVB	@-1026(R15),R2		get # of files
	SRL	R2,8			make it a word
	MOV	R2,R3			save it
	AI	R1,6			ptr to drive #
H134	LI	R4,11			compare 11 bytes (drive + filename)
	BLWP	@>005A(R9)		save R1-R3
	DATA	>7000			
	BL	@CMPFN			compare with name in compare buffer
	BLWP	@>005A(R9)		retrieve R1-R3
	DATA	>7001			
	MOV	R4,R4			fully compared?
	JEQ	H135			yes: done
	AI	R1,518			move to next FDR in VDP mem
	DEC	R2			
	JNE	H134			next file
H135	B	@RTURN1			return to caller (R4=0 if successfull)
*				
FNDFDR	BL	@CALSUB			
	DATA	FFFDRV			save name in comp buffer, find FDR in VDP buffers
*					
FFDROD	MOV	R4,R4			find FDR on disk (from filename)
	JEQ	H136			file error
FFDRDK	MOV	@>0056(R9),R5		ptr to top of disk buffer in VDP mem
	AI	R5,10			ptr to drive # in first file control block
H138	BLWP	@>005A(R9)		set VDP to read
	DATA	>00A2			address in R5
	MOVB	@-1026(R15),R2		get drive #
	JEQ	H137			free control block found
	AI	R5,518			ptr to file control block
	DEC	R3			
	JNE	H138			more files ?
ERROR6	BL	@ERROR5			no:
	DATA	>8000			memory full
*				
H137	MOV	R5,@>0056(R9)		save ptr to free ctrl block (drive #)
	BL	@CALSUB			call subroutine
	DATA	RDSEC1			read sector 1
FFDRFN	MOV	@>0056(R9),R8		entry point if sector 1 already read
	AI	R8,382			point to middle of sector 1
	LI	R2,64			distance: start with 1/4 sector
H139	SETO	R4			
	BL	@VDPR2B			read 2 bytes in R0 from VDP address in R8
	MOV	R0,R0			
	JEQ	H140			no file here: move up
	BLWP	@>005A(R9)		save R2
	DATA	>2000			
	SETO	R2			code for read
	BL	@CALSUB			call subroutine
	DATA	RDFDR2			read FDR, sector # in R0
	MOV	R5,R1			RDFDR2 sets R5 as FDR ptr
	AI	R5,-4			point to sector # of FDR in ctrl block
	BLWP	@>005A(R9)		set VDP to write
	DATA	>00A3			address in R5
	MOVB	R4,@-2(R15)		RDFDR2 puts sector # in R4
	SWPB	R4			copy it to ctrl block
	MOVB	R4,@-2(R15)			
	MOV	R1,R5			FDR ptr
	DEC	R1			now point to drive #
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0023			address in R1
	MOVB	R6,@-2(R15)		save drive #
	LI	R4,11			size to compare (drive # + filename)
	BL	@CMPFN			compare filenames
	BLWP	@>005A(R9)		retrieve R2
	DATA	>2001			
	JEQ	H141			compared ok: return
	BLWP	@>005A(R9)		set VDP to write
	DATA	>00A3			address in R5
	MOVB	R4,@-2(R15)		remaining chars to compare
	C	R0,R3			what kind of mismatch occured?
	JH	H140			too far down the alphabet
	A	R2,R8			too far up: move half-way down
	MOV	R2,R2			
	JNE	H142			then divide distance by 2
	INCT	R8			already checked: reset EQ
H141	B	@RTURN1			return (from stack)
*				
H140	S	R2,R8			move half-way up
	MOV	R2,R2			
	JEQ	H141			can't: already checked
H142	SRL	R2,2			divide distance by 2
	A	R2,R2			but keep it even
	JMP	H139			
*
* The cluster info list is located in the FDR, bytes >1C to >FF
* A cluster info consists in 3 bytes, i.e 6 nibbles
* 3 nibbles specify the beginning sector for that cluster, and
* 3 nibbles specify the total file offset in sectors, including this cluster.
* The nibbles are arranged as EG SB OF, to be combined as BEG OFS
*
DECDCI	MOV	R11,R10			decode cluster info
	BL	@VDPR2B			read 2 bytes VDP at R8 in R0
	SWPB	R0			
	MOVB	@-1026(R15),R2		get third byte from cluster list
	MOV	R0,R1			
	ANDI	R1,>0FFF		start sector in R1
	SZC	R1,R0			remove it from R0
	SRL	R2,8			
	SOC	R0,R2			combine offset nibbles
	SRC	R2,12			offset in R2
	B	*R10			
*				
UPDCLI	SRC	R2,4			write info for 1 cluster
	MOV	R2,R0			
	ANDI	R0,>F000		sector in R1, offset in R2
	SOC	R0,R1			copy nibble 3 of offset before nibble 1 of sector
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0103			address in R8
	SWPB	R1			write cluster info
	MOVB	R1,@-2(R15)		as 3 bytes
	SWPB	R1			
	MOVB	R1,@-2(R15)			
	SWPB	R2			
	MOVB	R2,@-2(R15)			
	B	*R11			
*
* The sector bitmap is located in the VIB (i.e. sector 0) at bytes >38 to >FF
* In each byte a bit defines a sector, from right to left: "0"=free, "1"=used					
*
FFSBMP	BLWP	@>005A(R9)		find a free sector in bitmap
	DATA	>7800			
	BL	@CALSUB			call subroutine
	DATA	RWVIB			load VIB for drive in R6
	MOV	R1,R1			first sector specified in R1 ?
	JNE	H143			yes
	LI	R1,33			no: start with sector 34
H143	INC	R1			
	MOV	R1,R0			
	SRL	R1,3			div by 8 since 8 sect/byte in bitmap
	LI	R2,>00FF			
	ANDI	R0,>0007		bit number in bitmap byte
	JEQ	H144			
	SLA	R2,0			get that bit
H144	MOV	R1,R3			byte #
	A	R5,R3			add VIB ptr
	AI	R3,56			ptr to sector in bitmap
	CI	R1,>00C8		end of VIB?
	JLT	H145			no
	CLR	R1			yes: top of bitmap
H145	A	R5,R1			
	AI	R1,56			make another bitmap ptr
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0022			address in R1
H146	SETO	R0			
	MOVB	@-1026(R15),R0		get bitmap byte
	MOV	R0,R4			save it
	SOC	R2,R0			mask previous sectors
	CLR	R2			
	INC	R0			get 1 more sector
	JNE	H147			ok
	INC	R1			byte full: try next
	MOV	R1,R0			
	AI	R0,-256			won't change if byte # became >100
	C	R0,R5			still in VIB?
	JNE	H148			yes
	AI	R1,-200			no: to top of bitmap
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0022			address in R1
H148	C	R1,R3			are we back to where we started?
	JNE	H146			no: seach that byte for a free sector
	MOV	R4,R0			get original byte
	INC	R0			try sectors just before ours (no mask this time)
	JEQ	H149			full: return with EQ
H147	DEC	R0			restore original byte
	MOV	R0,R2			
	CLR	R0			bit counter
	SWPB	R2			
H150	INC	R0			increment bit count
	SRC	R2,1			find first 0 bit from the right
	JOC	H150			not yet
	LI	R2,>0080			
	SLA	R2,0			make a mask for that bit
	DEC	R0			bit # (0-7)
	SOC	R2,R4			mark sector as used in bitmap byte
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0023			address in R1
	MOVB	R4,@-2(R15)		update bitmap
	AI	R1,-56			
	S	R5,R1			byte # in bitmap
	SLA	R1,3			times 8 (8 sect per byte)
	SOC	R0,R1			add bit #: = sector #
	MOV	R1,R0			save it
*				
H151	DEC	R5			point to drive #
	BLWP	@>005A(R9)		set VDP to read
	DATA	>00A2			address in R5
	MOVB	@-1026(R15),R1		get drive #
	ORI	R1,>8000		add flag: update VIB
	BLWP	@>005A(R9)		set VDP to write
	DATA	>00A3			address in R5
	MOVB	R1,@-2(R15)		write back flagged drive #
	INC	R5			point to VIB (& return with NEQ)
H149	BLWP	@>005A(R9)		retrieve R1-R4
	DATA	>7801			
	B	@RTURN1			return to caller
*				
FFSBM	MOV	R0,R1			free sector(s) in bitmap
	LI	R2,1			1 sector only
FRSCB1	BLWP	@>005A(R9)		entry point if more than 1 sector
	DATA	>7800			save R1-R4
	BL	@CALSUB			call subroutine
	DATA	RWVIB			load VIB for drive in R6
	MOV	R1,R0			sector #
	ANDI	R0,>0007		bit in bitmap byte (8 per byte)
	SRL	R1,3			byte in bitmap
	A	R5,R1			add VIB buffer
	AI	R1,56			add bitmap offset in VIB
	MOV	R0,R3			
	NEG	R0			
	AI	R0,8			change 0-7 into 8-1
	LI	R4,>00FF		mask to erase
	C	R2,R0			how many to erase?
	JLT	H152			less than in that byte
	JMP	H153			
*				
H152	LI	R0,8			free sectors in first byte
	S	R2,R0			
	SRC	R4,0			adjust mask
	MOV	R3,R0			original bit # of starting sector
	JEQ	H154			
	SLA	R4,0			don't erase before starting sector
H154	JMP	H155			
*				
H155	SWPB	R4			
	JMP	H158			goto erase last byte
*					
H153	SRC	R4,0			adjust mask
H156	S	R0,R2			that many will be freed
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0022			address in R1
	MOVB	@-1026(R15),R0		get bitmap byte
	SZC	R4,R0			mark sectors as free
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0023			address in R1
	MOVB	R0,@-2(R15)		write it back
	LI	R4,>FF00		clear full byte
	INC	R1			next byte
	LI	R0,8			i.e. 8 sectors
	C	R2,R0			how many more sectors?
	JLT	H157			less than 8
	JMP	H156			8 or more: next byte
*					
H157	MOV	R2,R0			remaining sectors
	LI	R4,>00FF			
	SLA	R4,0			coin mask
H158	BLWP	@>005A(R9)		set VDP to read
	DATA	>0022			address in R1
	MOVB	@-1026(R15),R0		get bitmap byte
	SZC	R4,R0			mark sectors as free
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0023			address in R1
	MOVB	R0,@-2(R15)		write it back
	JMP	H151			done: flag drive # and return
*
*===================================
* DSR entry points
*===================================					
*
EDSR01	MOV	R11,R7			DSK
	BL	@PRPFDO			--- prepare file operations
	BL	@CALSUB			call subroutine
	DATA	FDSKDR			find disk in drive (name ptr in R3)
	JMP	H159			
*					
EDSR02	LI	R6,>0100		DSK1
	JMP	H160			----
*					
EDSR03	LI	R6,>0200		DSK2
	JMP	H160			----
*					
EDSR04	LI	R6,>0300		DSK3
*					
H160	MOV	R11,R7			save return address
	BL	@PRPFDO			prepare file operations
H159	MOV	@>0054(R9),R0		PAB ptr
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0002			address in R0
	MOVB	@-1026(R15),R1		get opcode
	SRL	R1,8			
	CI	R1,>0009		check range
	JH	ERROR8			illegal opcode
	CI	R2,>0001		filename lenght (including . )
	JNE	H161			no filename: dir
	AI	R1,10			only allow open, close and read
	CI	R1,>000C			
	JH	ERROR8			others are illegal
H161	A	R1,R1			make it a word ptr
	MOV	@OPCVEC(R1),R1		get vector
	B	*R1			branch to it
*					
OPCVEC	DATA	OPEN			open
	DATA	CLOSE			close
	DATA	READ			read
	DATA	WRITE			write
	DATA	RWIND1			rewind
	DATA	LOAD			load
	DATA	SAVE			save
	DATA	DELETE			delete
	DATA	RETERR			scratch record: return with bad attribute error
	DATA	STATUS			status
*					
	DATA	OPNDIR			open directory
	DATA	CLSDIR			close directory
	DATA	RDDIR			read directory
*					
ERROR8	BL	@ERROR5			return with error
	DATA	>6000			illegal opcode
*
*---------------------------------
* Opcode 0: Open
* --------------
* PAB 0: >00
*     1: file type  <--- error code
*   2-3:
*     4: record length
*     5:
*   6-7: # of records (if output)
*     8:
*---------------------------------					
*
OPEN	CLR	R0			
	MOVB	@-1026(R15),R0		get file attributes
	BLWP	@>005A(R9)			
	DATA	>8000			save R0
	ANDI	R0,>1600		keep fix/var and access mode
	CI	R0,>0600			
	JNE	H162			
ERROR9	BL	@ERROR5			dis/fix, open as append: return with error
	DATA	>4000			bad attribute
*					
H162	JLE	H163			
	MOV	R0,R1			var
	BL	@PABR2B			get 2 bytes from PAB into R0
	DATA	4			rec len and char count
	CI	R0,>FF00		is rec len 255?
	JHE	ERROR9			yes: bad attribute
	MOV	R1,R0			retrieve attributes
	ANDI	R0,>0600		keep only access mode
*					
H163	CI	R0,>0200		is it output?
	JNE	H164			no
	BL	@CALSUB			call subroutine
	DATA	CRFIL1			create file
H165	BL	@PRFDRS			coin status byte in FDR style
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0083			address in R4: status byte in FDR buffer
	MOVB	R2,@-2(R15)		write file status in FDR
	MOV	@>0054(R9),R3		PAB ptr
	AI	R3,4			ptr to rec len
	CLR	R5			
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0062			address in R3
	MOVB	@-1026(R15),R5		get record length
	JNE	H166			
	LI	R5,>5000		>00: default it 80
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0063			address in R3
	MOVB	R5,@-2(R15)		write default rec len
H166	AI	R4,5			point to rec len byte in FDR
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0083			address in R4
	MOVB	R5,@-2(R15)		write rec len in FDR buffer
	LI	R1,256			256 bytes/sector
	MOV	R2,R2			var or dis?
	JLT	H167			var
	JMP	H168			dis
H167	A	R1,R5			var: rec len +1
	DEC	R1			254 bytes only (needs size byte)
H168	SWPB	R5			make it a word
	CLR	R0			
	DIV	R5,R0			how many times in 254/255 bytes?
	AI	R4,-4			point to # of rec/sect in FDR
	MOV	R0,R1			save result for later
	SWPB	R0			
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0083			address in R4
	MOVB	R0,@-2(R15)		write # of rec/sect in FDR
	MOV	@>0056(R9),R8		point to filename in FDR
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0102			address in R8
	MOVB	@-1026(R15),R0		get first char
	ORI	R0,>8000		flag it: update FDR before leaving
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0103			address in R8
	MOVB	R0,@-2(R15)		write it back
	BLWP	@>005A(R9)			
	DATA	>8001			retrieve R0 (access mode)
	BL	@PABR2B			get 2 bytes from PAB into R0
	DATA	6			required size in records
	MOV	R0,R4			
	JEQ	H169			no size specified
	JLT	ERROR9			return with bad attribute error
	A	R1,R4			round up to record size
	DEC	R4			
	CLR	R3			
	DIV	R1,R3			how many sectors will this be?
	DEC	R3			offset start from 0
	BL	@CALSUB			call subroutine
	DATA	APSCTS			add sectors to FDR to match offset in R3
H169	B	@RWIND2			initialise file control block and return to caller
*					
H164	BLWP	@>005A(R9)		not output
	DATA	>8000			save R0
	BL	@CALSUB			call subroutine
	DATA	FNDFDR			find FDR on disk
	BLWP	@>005A(R9)			
	DATA	>8001			retrieve R0 (access mode)
	MOV	R4,R4			found FDR?
	JEQ	H170			yes
	CI	R0,>0400		no: is file open as input?
	JEQ	H171			yes: must exist
	BL	@CALSUB			no: call subroutine
	DATA	CRFIL3			create file
	JMP	H165			
*					
H171	B	@ERROR9			return with bad attribute error
*					
H170	MOV	R0,R7			save access mode
	BL	@PRFDRS			prepare status byte for FDR
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0082			address in R4 (status byte in FDR)
	MOVB	@-1026(R15),R0		get current file status
	MOV	R0,R3			save it
	ANDI	R3,>0800		is file write protected?
	JEQ	H172			no
	CI	R7,>0400		yes: is it open as input?
	JEQ	H172			no
	BL	@ERROR5			yes: return with error
	DATA	>2000			write protected
*					
H172	ANDI	R0,>8300		keep only file type bits (V/F, D/I, Prg/Data)
	XOR	R2,R0			compare with new (coined by PRFDRS)
	JNE	H171			different: bad attribute
	MOV	@>0054(R9),R3		PAB ptr
	AI	R3,4			ptr to rec len in PAB
	AI	R4,5			ptr to rec len in FDR
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0082			address in R4
	MOVB	@-1026(R15),R0		get rec len from FDR
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0062			address in R3
	MOVB	@-1026(R15),R2		get rec len from PAB
	JEQ	H173			0 = keep current one
	CB	R0,R2			are they identical?
	JNE	H171			no: bad attribute
H173	BLWP	@>005A(R9)		set VDP to write
	DATA	>0063			address in R3
	MOVB	R0,@-2(R15)		update rec len in PAB (in case it was 0)
	BLWP	@>005A(R9)		retrieve R0 (open mode)
	DATA	>8001			
	ANDI	R0,>0600		keep only access mode
	CLR	R2			
	SETO	R3			
	CI	R0,>0600		is it append
	JNE	H174			no
	MOV	@>0056(R9),R4		yes: get FDR ptr
	MOV	R4,R7			save it
	AI	R4,14			ptr to # of sectors
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0082			address in R4
	MOVB	@-1026(R15),R3		get # of sectors in file
	SWPB	R3			
	MOVB	@-1026(R15),R3			
	SWPB	R3			
	MOVB	@-1026(R15),R2		get eof offset
	DEC	R3			offset starts from 0
	JLT	H174			file is empty (0 sectors)
	BLWP	@>005A(R9)			
	DATA	>3000			save R2 + R3
	AI	R7,256			ptr to data buffer area for this file
	BL	@CALSUB			call subroutine
	DATA	RDOFSC			read a sector, from offset in R3
	BLWP	@>005A(R9)			
	DATA	>3001			retrieve R2 + R3
H174	BL	@UPDFCB			update current record offset in file ctrl block
	B	@RTURN1			return to caller
*					
PRFDRS	BLWP	@>005A(R9)		prepare file status byte for FDR
	DATA	>8001			access mode in R0
	BLWP	@>005A(R9)			
	DATA	>8000			save it back
	LI	R2,2			int in FDR status byte
	MOV	@>0056(R9),R4		FDR pointer
	SLA	R0,4			fix or var?
	JNC	H175			fix
	LI	R2,>0082		int var in FDR
	MOV	R0,R0			dis or int?
H175	JLT	H176			int
	DECT	R2			dis: remove the int from FDR status
H176	AI	R4,12			point at file status byte in FDR
	SWPB	R2			
	B	*R11			
*					
UPDFCB	MOV	@>0056(R9),R4		update sect + rec offsets in file control block
	AI	R4,-6			
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0083			address in R4
	MOVB	R3,@-2(R15)		write current sect offset
	SWPB	R3			
	MOVB	R3,@-2(R15)			
	AI	R4,4			point to logical rec offset (for var files)
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0083			address in R4
	MOVB	R2,@-2(R15)		write record offset
	B	*R11			
*
*----------------------------------
* Opcode 1: Close
* --------------
* PAB 0: >01
*     1:           <--- error code
*   2-3:
*     4:
*     5:
*   6-7:
*     8:
*----------------------------------					
*
CLOSE	BL	@CALSUB			call subroutine
	DATA	FFDRVP			find file FDR
	B	@UPDFDR			update FDR + data area, get VIB, return to caller
*
*----------------------------------
* Opcode 2: Read
* --------------
* PAB 0: >02
*     1: file type <--- error code
*   2-3: data buffer address in VDP mem
*     4:
*     5: bytes read
*   6-7: record #
*     8:
*
* Logical records organisation whithin sectors
*
* Fixed records (e.g. rec length = 6)
* 11 11 11 11 11 11 22 22 22 22 22 22 33 33 33 33 33 33 xx xx xx
* Where 11=data for record 1, 22=record 2, 33=record 3, xx=junk bytes
*
* Variable records:
* sz 11 11 11 11 11 11 11 sz 22 22 22 22 22 sz 33 33 FF xx xx xx
* Where sz=record size, 11,22,33=record data, FF=end-of-sector mark, xx=junk
*----------------------------------					
*
READ	BL	@CALSUB			call subroutine
	DATA	FFDRVP			find FDR in VDP buffers, get status from PAB
	ANDI	R0,>0200		what type of access?
	JEQ	H177			update or input: ok
H179	B	@ERROR8			append or output: error illegal opcode
H177	BL	@RFDRST			get status byte in R0, from FDR
	JLT	H178			var
	BL	@RRNPAB			fix: get rec # compare to # of recs/file
	JL	H180			ok: in file
H181	BL	@ERROR5			update data and return with error
	DATA	>A000			eof reached
H180	BL	@CALSUB			call subroutine
	DATA	RRFDR			load record from disk into FDR data buffer area
	JMP	H182			
*					
H178	BL	@CALSUB			var: call subroutine
	DATA	RRSEC			load proper sector, point to rec in it
	JMP	H181			skipped if ok: return with eof reached
*					
	INC	R2			next byte in data buffer
	A	R4,R0			add rec size to offset
	INC	R0			room for end-of-sector mark
	MOV	@>0056(R9),R5		FDR ptr
	DECT	R5			point to var record offset in sector
	SWPB	R0			
	BLWP	@>005A(R9)		set VDP to write
	DATA	>00A3			address in R5
	MOVB	R0,@-2(R15)		update var record offset in sector
	MOV	R4,R0			save # of bytes to be read
H182	MOV	@>0054(R9),R4		PAB ptr
	AI	R4,5			point to char count
	SWPB	R0			
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0083			address in R4
	MOVB	R0,@-2(R15)		write # of char to be read
	SWPB	R0			make it a word
*					
WFDRPB	MOV	R0,R0			check it
	JEQ	H183			none: return
H184	BLWP	@>005A(R9)		set VDP to read
	DATA	>0042			address in R2
	MOVB	@-1026(R15),R3		read 1 byte from FDR data buffer area
	INC	R2			increment source ptr
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0023			address in R1
	MOVB	R3,@-2(R15)		write the byte in PAB data buffer
	INC	R1			increment destination ptr
	DEC	R0			more to read?
	JNE	H184			yes
H183	B	@RTURN1			return to caller
*					
RRSEC	BL	@RCOFCB			load sector, point to record in it
	MOV	R3,R3			sector offset
	JLT	H185			-1: top of file
	JMP	H186			in file
H185	MOV	R3,R0			
	INC	R0			next sector
	C	R0,R2			compare to # of sect/file
	JEQ	H183			end-of-file reached: return to caller (JMP to err)
	BL	@CALSUB			call subroutine
	DATA	UPDBF			update data buffer, if needed
	MOV	R0,R3			desired offset
	CLR	R5			
	BL	@UCOFCB			update sect + rec offsets in control block
	AI	R7,256			point to data buffer area (R7 set by UCOFCB)
	BL	@CALSUB			call subroutine
	DATA	RDOFSC			read a sector, from offset in file (in R3)
	CLR	R0			
	JMP	H187			
*					
H186	MOV	R0,R0			in file: test var rec offset (from RCOFCB)
	JNE	H187			inside sector
	C	R0,R2			at beg of sector
	JEQ	H183			file is empty: return
H187	MOV	R0,R2			FDR data buffer will be added to R2 by AFDRPT
	BL	@CALSUB			call subroutine
	DATA	AFDRPT			R2=byte in FDR data buf, R1=top of PAB data buf
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0042			address in R2
	MOVB	@-1026(R15),R4		get first byte (rec length)
	SRL	R4,8			make it a word
	MOV	R0,R0			var rec offset
	JEQ	H188			
	CI	R4,>00FF		is it >FF (end of sector mark) ?
	JNE	H188			no
	BL	@RCOFCB			yes: get sect + rec offsets from control block
	JMP	H185			try again with next sector
*					
H188	BLWP	@>005A(R9)			
	DATA	>0011			retrieve return address from stack in R11
	INCT	R11			skip the JMP to eof reached error
	B	*R11			
*
*------------------------------------
* Opcode 3: Write
* --------------
* PAB 0: >03
*     1: file type <--- error code
*   2-3: data buffer address in VDP mem
*     4:
*     5: bytes to write
*   6-7: record #
*     8:
*------------------------------------					
*
WRITE	BL	@CALSUB			call subroutine
	DATA	FFDRVP			find FDR in VDP buffers
	ANDI	R0,>0600		keep only access mode
	CI	R0,>0400		is it input
	JEQ	H179			yes: return with error illegal opcode
	BL	@RFDRST			get file status byte from FDR
	JLT	H189			var			
	BL	@RRNPAB			fix: get rec # from PAB, sect # in R0
	JL	H190			less that total rec/file
	BLWP	@>005A(R9)		past eof: expand file
	DATA	>D800			save R0, R1, R3, R4
	MOV	R0,R3			desired sector offset
	BL	@CALSUB			call subroutine
	DATA	APSCTS			append enough sectors to reach offset in R3
	BLWP	@>005A(R9)			
	DATA	>D801			restore R0, R1, R3, R4
	BL	@URFFDR			update # of rec/file in FDR
*					
H190	BL	@CALSUB			in file: call subroutine
	DATA	RRFDR			fetch rec from disk into FDR data buffer area
	JMP	H191			set update data flag, write data, return
*					
H189	BL	@RCOFCB			var: R2=sect/file R3=sect offset R0=rec offset
	MOV	R3,R3			sector offset in file
	JLT	H192			-1: top of file
	JMP	H193			in file
H192	BLWP	@>005A(R9)		next sector loop
	DATA	>3000			save R2 + R3
	BL	@CALSUB			call subroutine
	DATA	UPDBF			update data buffer if needed
	BLWP	@>005A(R9)			
	DATA	>3001			retrieve R2 + R3
	INC	R3			next sector
	CLR	R0			init char offset in sector
*					
H193	C	R3,R2			did we reach last sector?
	JNE	H194			no
	BLWP	@>005A(R9)		yes: expand file
	DATA	>9000			save R0 + R4
	BL	@CALSUB			call subroutine
	DATA	APSCTS			get last sector then append sectors to reach R3
	BLWP	@>005A(R9)			
	DATA	>9001			retrieve R0 + R4
*					
H194	MOV	@>0054(R9),R5		PAB ptr
	AI	R5,5			point to char count
	BLWP	@>005A(R9)		set VDP to read
	DATA	>00A2			address in R5
	MOVB	@-1026(R15),R4		get # of chars to write
	SRL	R4,8			make it a word
	MOV	R4,R5			
	A	R0,R5			add current char offset in sector
	INC	R5			make room for size byte
	CI	R5,>00FF		past end of sector?
	JH	H192			yes: not enough room, try next sector
	SETO	R2			ok: rec will fit in sector
	MOV	@>0056(R9),R1		FDR ptr
	A	R5,R1			past-last-byte offset
	AI	R1,256			ptr to data buffer area
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0023			address in R1
	MOVB	R2,@-2(R15)		write end-of-sect mark to FDR data buffer area
	BLWP	@>005A(R9)			
	DATA	>8000			save R0 (current byte offset in sector)
	MOV	R3,R0			
	BL	@UCOFCB			update sect + rec offsets in control block
	AI	R1,18			point to eof offset in FDR (R1 modified by UCOFCB)
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0023			address in R1
	MOVB	R5,@-2(R15)		update eof offset in last sector, in FDR
	BL	@URFFDR			update # of rec/file in FDR
	BLWP	@>005A(R9)			
	DATA	>2001			retrieve old R0 in R2 (current byte offset)
	MOV	R4,R0			record size
	BL	@CALSUB			call subroutine
	DATA	AFDRPT			get FDR data buffer in R2, PAB data buffer in R1
	SWPB	R4			
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0043			address in R2
	MOVB	R4,@-2(R15)		write size byte to FDR data buffer
	INC	R2			increment dest pointer
*					
H191	MOV	R2,R3			invert source and dest
	MOV	R1,R2			so we can use the same read-write loop
	MOV	R3,R1			than the read opcode
	MOV	@>0056(R9),R4		FDR ptr
	DEC	R4			pointer to drive # for that file
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0082			address in R4
	MOVB	@-1026(R15),R5		get drive #
	ORI	R5,>8000		add update data area flag
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0083			address in R4
	MOVB	R5,@-2(R15)		write back flagged byte
	B	@WFDRPB			to read-write loop
*					
FFDRVP	BL	@CALSUB			find FDR in VDP buffer
	DATA	FFFDRV			find file FDR
	MOV	R4,R4			found?
	JEQ	AFPGPF			yes
	BL	@ERROR5			no: return with error
	DATA	>E000			file error
AFPGPF	INC	R1			point to filename in FDR
	MOV	R1,@>0056(R9)		new FDR ptr
	MOV	@>0054(R9),R4		get PAB ptr
	INC	R4			point to status byte
	CLR	R0			
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0082			address in R4
	MOVB	@-1026(R15),R0		get file status
	B	@RTURN1			return to caller
*					
RFDRST	MOV	@>0056(R9),R4		get status byte from FDR
	AI	R4,12			point to status byte
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0082			address in R4
	MOVB	@-1026(R15),R0		read status byte
	B	*R11			
*					
RRNPAB	MOVB	@-1026(R15),R5		get record # from PAB, check if valid
	SRL	R5,8			
	JNE	H195			get # of rec/sector from FDR
	LI	R5,256			0: default to 256
H195	MOV	@>0054(R9),R3		PAB ptr
	AI	R3,6			point to rec #
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0062			address in R3
	MOVB	@-1026(R15),R1		get record # from PAB
	SWPB	R1			
	MOVB	@-1026(R15),R1			
	SWPB	R1			
	MOV	R1,R0			save it
	JLT	H196			too big
	JMP	H197			ok
H196	BL	@ERROR5			update data then return with error
	DATA	>8000			memory full
H197	INC	R0			next record
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0063			address in R3
	MOVB	R0,@-2(R15)		write back # of future record
	SWPB	R0			
	MOVB	R0,@-2(R15)			
	CLR	R0			
	MOV	R1,R3			save # of desired rec
	DIV	R5,R0			divide by # of rec/sector = sect # in R0
RNFISE	MOV	@>0056(R9),R2		FDR ptr
	AI	R2,18			point to total # of rec (# of sectors for var)
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0042			address in R2
	MOVB	@-1026(R15),R2		get total # of recs/file (sect/file for var)
	SWPB	R2			
	MOVB	@-1026(R15),R2		remember: bytes are swapped
	C	R3,R2			compare with desired record (ignored by var)
	B	*R11			
*					
RRFDR	BLWP	@>005A(R9)		fetch record into FDR data buffer area
	DATA	>4000			save R1
	AI	R4,-18			ptr to top of control block
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0082			address in R4
	MOVB	@-1026(R15),R5		get current sector offset in file
	SWPB	R5			
	MOVB	@-1026(R15),R5			
	SRC	R5,8			
	JLT	H198			-1: top of file
	C	R5,R0			compare with desired offset (from RRNPAB)
	JEQ	H199			same
	BL	@CALSUB			call subroutine
	DATA	UPDBF			update data buffer if needed
H198	MOV	R0,R3			desired sector offset in file
	BL	@UCOFCB			update sect + rec offsets in control block
	AI	R7,256			point to data buffer area (R7 set by UCOFCB)
	BL	@CALSUB			call subroutine
	DATA	RDOFSC			read a sector from offset in file (in R3)
H199	BLWP	@>005A(R9)			
	DATA	>4001			retrieve R1
	MOV	@>0056(R9),R3		FDR ptr
	AI	R3,17			point to record length
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0062			address in R3
	MOVB	@-1026(R15),R0		get rec length in bytes
	SRL	R0,8			make it a word
	MPY	R0,R1			calc file offset in bytes
AFDRPT	A	@>0056(R9),R2		add FDR ptr
	AI	R2,256			point inside data buffer area
	MOV	@>0054(R9),R3		PAB ptr
	INCT	R3			point to data buffer address
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0062			address in R3
	MOVB	@-1026(R15),R1		get PAB data buffer address
	SWPB	R1			
	MOVB	@-1026(R15),R1			
	SWPB	R1			
	B	@RTURN1			return
*				
UCOFCB	MOV	@>0056(R9),R7		update sect + rec offsets in control block
	MOV	R7,R1			FDR ptr
	AI	R1,-6			top of file control block
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0023			address in R1
	MOVB	R0,@-2(R15)		current sector offset in file
	SWPB	R0			
	MOVB	R0,@-2(R15)			
	AI	R1,4			point to var rec offset in sector
	SWPB	R5			
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0023			address in R1
	MOVB	R5,@-2(R15)		first free byte in current sector
	B	*R11			
*					
URFFDR	MOV	@>0056(R9),R2		update # of rec/file in FDR
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0042			address in R2 (FDR ptr)
	MOVB	@-1026(R15),R10		get first char of filename
	ORI	R10,>8000		set was modified flag
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0043			address in R2
	MOVB	R10,@-2(R15)		write flagged char back
	AI	R2,18			point to # of recs/file in FDR
	INC	R3			one more
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0043			address in R2
	SWPB	R3			update # of recs/file
	MOVB	R3,@-2(R15)			
	SWPB	R3			
	MOVB	R3,@-2(R15)			
	B	*R11			
*					
RCOFCB	MOV	@>0056(R9),R8		get rec offset, compare sect with total
	MOV	R8,R4			FDR ptr
	AI	R4,256			point to data buffer area
	DECT	R8			point to var record offset
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0102			address in R8
	MOVB	@-1026(R15),R2		get var rec offset in current sector
	SRL	R2,8			make it a word
	MOV	R11,R10			save return point
	BL	@FDR2B2			get 2 bytes from FDR (at R8-4) into R0
	DATA	-4			current sector offset in file
	MOV	R0,R3			save it
	MOV	R10,R11			restore return point
	MOV	R2,R0			var record offset
	B	@RNFISE			get # of sect/file from FDR, return
*
*------------------------------------
* Opcode 4: Rewind
* --------------
* PAB 0: >04
*     1: file type <--- error code
*   2-3:
*     4:
*     5:
*   6-7: record #  <--- >0000 if sequential
*     8:
*------------------------------------					
*
RWIND1	BL	@CALSUB			call subroutine
	DATA	FFDRVP			find FDR in VDP buffers, read status from PAB
	BLWP	@>005A(R9)			
	DATA	>8000			save R0 (status from PAB)
	ANDI	R0,>0600		keep only access mode
	JEQ	H200			update is ok
	CI	R0,>0400		is it input?
	JEQ	H200			yes: ok
	B	@ERROR8			output or append: return with illegal opcode
H200	BL	@CALSUB			call subroutine
	DATA	UPDBF			update data buffer if needed
	BLWP	@>005A(R9)			
	DATA	>8001			retrieve R0 (status from PAB)
	ANDI	R0,>0100		sequential or reloc?
	JNE	H201			reloc: don't do anything, return
*					
RWIND2	CLR	R2			rewind file: record offset = 0
	SETO	R3			current record = -1 (none)
	BL	@UPDFCB			update file control block
	CLR	R0			record 0
	MOV	@>0054(R9),R8		get PAB ptr
	AI	R8,6			point to record #
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0103			address in R8
	MOVB	R0,@-2(R15)		write record #
	NOP				
	MOVB	R0,@-2(R15)			
H201	B	@RTURN1			return to caller
*
*------------------------------------
* Opcode 5: Load
* --------------
* PAB 0: >05
*     1: file type  <--- error code
*   2-3: data buffer address in VDP mem
*     4:
*     5:
*   6-7: maximum # of bytes (size of buffer)
*     8:
*------------------------------------					
*
LOAD	BL	@CALSUB			call subroutine
	DATA	FNDFDR			find FDR on disk
	MOV	R4,R4			found?
	JEQ	H203			yes
H202	BL	@ERROR5			no: return with error
	DATA	>E000			file error
H203	BL	@FDR2B1			get 2 bytes from FDR into R0
	DATA	12			file status byte
	ANDI	R0,>0100		is it program?
	JEQ	H202			no: file error
	INCT	R8			point to # of sect/file in FDR
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0102			address in R8
	MOVB	@-1026(R15),R1		get # of sectors in file
	SWPB	R1			
	MOVB	@-1026(R15),R1			
	SRC	R1,8			
	JEQ	H202			0=empty file: return with file error
	BL	@RBANB			get data buffer address in R7, # of sectors in R2
	INCT	R8			point to eof offset in FDR
	CLR	R4			
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0102			address in R8
	MOVB	@-1026(R15),R4		get # of bytes in last sector
	C	R1,R2			compare # of sect with max in PAB
	JH	H202			file is too big: return with file error
	JNE	H204			file is smaller
	C	R0,R4			same # of sect: check bytes in last sector
	JL	H202			file is too big: file error
H204	CLR	R3			sector offset in file
	SWPB	R4			
H206	DEC	R1			next sector
	JEQ	H205			done
	BLWP	@>005A(R9)			
	DATA	>D900			save R0, R1, R3, R4, R7
	BL	@CALSUB			call subroutine
	DATA	RDOFSC			read a sector from offset in R3
	BLWP	@>005A(R9)		restore R0, R1, R3, R4, R7
	DATA	>D901			
	INC	R3			next sector
	AI	R7,256			256 bytes further in PAB buffer
	JMP	H206			keep going
*					
H205	MOV	R4,R4			
	JNE	H207			
	BL	@CALSUB			call subroutine
	DATA	RDOFSC			read a sector from offset in R3
	JMP	H208			done
*					
H207	MOV	R7,R5			save PAB data buffer ptr
	MOV	@>0056(R9),R7		FDR ptr
	AI	R7,256			point to FDR data area
	BLWP	@>005A(R9)			
	DATA	>0D00			save R4, R5, R7
	BL	@CALSUB			call subroutine
	DATA	RDOFSC			read a sector from offset in R3
	BLWP	@>005A(R9)		restore R4 in R0, R5 in R1, R7 in R2
	DATA	>E001			
	BL	@CALSUB			call subroutine
	DATA	WFDRPB			write bytes from FDR data buffer to PAB data buf
H208	B	@UPDFDR			update FDR, data buffer, VIB and return to caller
*
*------------------------------------
* Opcode 6: Save
* --------------
* PAB 0: >06
*     1: file type  <--- error code
*   2-3: data buffer address in VDP mem
*     4:
*     5:
*   6-7: # of bytes to save
*     8:
*------------------------------------					
*
SAVE	BL	@CALSUB			call subroutine
	DATA	CRFIL1			create file
	BL	@RBANB			get PAB buffer ptr + # of bytes
	CLR	R3			sector offset 0
H209	BLWP	@>005A(R9)			
	DATA	>B100			save R0, R2, R3, R7
	BL	@CALSUB			call subroutine
	DATA	WROFSC			write sector to offset in R3
	BLWP	@>005A(R9)			
	DATA	>B101			retrieve R0, R2, R3, R7
	INC	R3			next sector
	AI	R7,256			256 bytes further in PAB data buffer
	DEC	R2			next sector
	JNE	H209			more to do
*					
	MOV	@>0056(R9),R1		FDR ptr
	AI	R1,12			point to file status byte
	LI	R2,>0100		value for program file
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0023			address in R1
	MOVB	R2,@-2(R15)		write file status byte in FDR
	AI	R1,4			point to eof offset byte in FDR
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0023			address in R1
	MOVB	R0,@-2(R15)		# of bytes in last sector
	B	@UPDFDR			update FDR, data buffer, VIB then return to caller
*					
RBANB	MOV	@>0054(R9),R0		get buffer address + # of bytes
	INCT	R0			data buffer in PAB
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0002			address in R0
	MOVB	@-1026(R15),R7		get data buffer address
	SWPB	R7			
	MOVB	@-1026(R15),R7			
	SWPB	R7			
	AI	R0,4			point to # of bytes to transfer
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0002			address in R0
	MOVB	@-1026(R15),R2		get # of bytes to be transfered
	SRL	R2,8			make it # of sectors (256 bytes each)
	CLR	R0			
	MOVB	@-1026(R15),R0		see if one more is needed
	JEQ	H210			no
	INC	R2			yes: one more sector
H210	B	*R11			
*
*-------------------------------------
* Opcode 9: Status
* --------------
* PAB 0: >09
*     1:
*   2-3:
*     4:
*     5:
*   6-7: record #
*     8:           <--- file status
*
* Status bits, returned in PAB byte 8:
* >80: file not found
* >40: file is protected
* >20:
* >10: internal (else display or program)
* >08: program file
* >04: variable (else fixed or program)
* >02: memory full
* >01: end-of-file reached
*-------------------------------------					
*
STATUS	BL	@CALSUB			call subroutine
	DATA	FFFDRV			save filename in comp buf, then find FDR in VDP
	MOV	R4,R4			found?
	JEQ	H211			yes
*					
	BL	@CALSUB			no: call subroutine
	DATA	FFDRDK			find FDR on disk
	LI	R0,>8000		value for file not found
	MOV	R4,R4			found?
	JNE	H212			no: return with that value
	MOV	@>0056(R9),R1		yes: ptr to FDR
	CLR	R2			
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0023			address in R1
	MOVB	R2,@-2(R15)		invalidate that FDR (file not open)
	JMP	H213			transfer FDR status to PAB status byte
*					
H211	BL	@CALSUB			file is open: call subroutine
	DATA	AFPGPF			adjust FDR ptr, get PAB file type into R4
	BL	@RFDRST			get status byte from FDR
	JLT	H214			var
	JMP	H215			fix
*					
H214	BL	@CALSUB			var: call subroutine
	DATA	RRSEC			load wanted sector, point to wanted rec in buffer
	JMP	H216			out of range
	CLR	R2			ok: clear flag
	JMP	H213			copy status byte from FDR into PAB, return
*					
H215	MOVB	@-1026(R15),R5		fix: get rec/sect byte
	SRL	R5,8			make it a word
	JNE	H217			
	LI	R5,>0100		00 (program files) means 256
H217	BL	@PABR2B			get 2 bytes from PAB into R0
	DATA	6			# of wanted record
	MOV	R0,R3			save it
	JLT	H218			too big: set memory full bit in PAB status byte
	BL	@RNFISE			get # recs/file into R2, comp with R3
	CLR	R2			
	JL	H213			in file: copy file type bits, return
	DIV	R5,R2			how many sectors do we need?
	MOV	R2,R3			save result
*					
H216	BL	@FDR2B1			get 2 bytes from FDR into R0
	DATA	14			# of sectors/file
	INC	R3			plus 1 sector for FDR
	LI	R2,>0100		value for eof reached in PAB status
	S	R0,R3			are there enough sectors in file for these recs?
	JGT	H219			
	JMP	H213			yes: we reached the eof
H219	BL	@CALSUB			call subroutine
	DATA	RWVIB			load VIB (sector 0)
	MOV	R3,R4			number of sectors that will be needed
	MOV	R5,R8			VIB ptr
	AI	R8,10			skip 10 bytes (required by CFSVIB)
	BL	@CFSVIB			count free sectors in bitmap, into R3
	LI	R2,>0100		value for eof reached
	C	R3,R4			are there that many free sectors?
	JHE	H213			yes
H218	LI	R2,>0200		value for memory full
*					
H213	BL	@FDR2B1			get 2 bytes from FDR into R0
	DATA	12			file status byte
	ANDI	R0,>8F00		mask irrelevant bits
	JGT	H220			
	ORI	R0,>0080		var: put var bit in PAB status style
H220	SLA	R0,3			get rid of var bit in FDR style
	SOCB	R2,R0			add eof and mem full bits
*					
H212	MOV	@>0054(R9),R1		PAB ptr
	AI	R1,8			point to bias/status return byte
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0023			address in R1
	MOVB	R0,@-2(R15)		write file status to PAB
	B	@RTURN1			return to caller
*
*---------------------------------
* Disk directory access
* ---------------------
* The directory is accessed by omiting the filename in the DSR name: "DSK1."
* It must be opened for input only, as an Int/Fix 38 file.
* It consists in upto 128 records, the first one contains the disk informations,
* the others the informations for upto 127 files (in alphabetical order).
* Each record consists in an ascii string and three floating point numbers.
*
* Record 0 contains:
* - Diskname (an ascii string of upto 10 chars).
* - The number zero.
* - The number of sectors on disk.
* - The number of free sectors on disk.
*
* Other records contain:
* - Filename (an ascii string of upto 10 chars).
* - Filetype: 1=D/F, 2=D/V, 3=I/F, 4=I/V, 5=Prog, 0=end of directory.
*   If the file is protected, this number is negative (-1=D/F, etc).
* - File size in sectors (including the FDR itself).
* - File record length (0 for programs).
*---------------------------------
 
*---------------------------------
* Open disk directory pseudo-file
*---------------------------------					
*
OPNDIR	MOVB	@-1026(R15),R0		get file type from PAB
	ANDI	R0,>1E00		mask irrelavant bits (rel/seq)
	CI	R0,>0C00		is it int/fix in output mode?
	JEQ	H221			yes
H223	BL	@RETERR			return with error
	DATA	>4000			bad attributes
H221	BL	@PABR2B			get 2 bytes from PAB into R0
	DATA	4			rec length
	SRL	R0,8			make it a word
	JEQ	H222			>00= default: set it to 38
	CI	R0,>0026		is it 38?
	JNE	H223			no: return with bad attributes error
H222	LI	R0,>2600		set rec len to 38
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0103			address in R8 (from PABR2B)
	MOVB	R0,@-2(R15)		write rec len to PAB
*					
	CLR	R7			
	BL	@FNDRV			find matching drive in file control blocks
	DATA	H224			go there if not found
ERRR10	BL	@ERROR5			update data then return with error
	DATA	>E000			file error
H224	MOV	R7,R7			did we find a free slot?
	JNE	H225			yes
	BL	@RETERR			no: return with error
	DATA	>8000			memory full
H225	BLWP	@>005A(R9)		set VDP to write
	DATA	>00E3			address in R7
	MOVB	R3,@-2(R15)		write drive #
	SWPB	R3			
	MOVB	R3,@-2(R15)		and a space as filename (illegal, indicates dir)
	B	@RTURN1			return to caller
*
*---------------------------------
* Close disk directory
*---------------------------------					
CLSDIR	BL	@FNDRV			find matching drive in file control blocks
	DATA	ERRR10			go there if not found: return with file error
	CLR	R0			
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0103			address in R8
	MOVB	R0,@-2(R15)		clear drive #
	B	@RTURN1			return to caller
*
*---------------------------------
* Read a record from disk directory
*---------------------------------					
*
RDDIR	BL	@FNDRV			find matching drive in file control blocks
	DATA	ERRR10			go ther it not found: return with file error
	INC	R8			
	MOV	R8,R5			save ptr to FDR
	BL	@PABR2B			get 2 bytes from PAB into R0
	DATA	6			record #
	MOV	R0,R2			save it
	INC	R2			
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0103			address in R8
	MOVB	R2,@-2(R15)		write record number in FDR
	SWPB	R2			after first char of filename!
	MOVB	R2,@-2(R15)			
	SLA	R0,1			since two byte per file ptr
	MOVB	R0,R0			is rec # greater than 128?
	JEQ	H226			no
	BL	@ERROR5			yes: update data then return with error
	DATA	>A000			past eof
H226	SETO	R2			code for read
	MOV	R0,R4			record #
	JEQ	H227			0=disk parameters
	LI	R4,1			sector #1
	BL	@CALSUB			call subroutine
	DATA	RWSEC			read sector into buffer in R5
	MOV	R5,R8			buffer ptr
	AI	R5,255			point to data buffer area in this ctrl block
	DECT	R0			don't count record 0
	A	R0,R8			point to desired file ptr
	BL	@VDPR2B			get two byte from VDP at R8 into R0
	MOV	R0,R4			sector where that FDR is to be found
	JEQ	H228			no more
	BL	@CALSUB			call subroutine
	DATA	RWSEC			read FDR sector into data buffer area
	BL	@FDR2B1			get 2 bytes from FDR into R0
	DATA	270			# of sect/file
	MOV	R0,R6			save it to output file size
	INC	R6			include the FDR itself
	MOVB	@-1026(R15),R3		ignore eof offset
	LI	R2,>0A00		10 chars per filename
	MOVB	@-1026(R15),R3		get rec length
	SRL	R3,8			make it a word
	DECT	R8			point to status byte in FDR
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0102			address in R8
	MOVB	@-1026(R15),R0		get file status byte
	MOV	R0,R7			
	ANDI	R0,>0800		keep only write protected bit
	SZCB	R0,R7			clear write protected bit (if it was set)
	SRL	R7,8			make it a word
	INC	R7			types are numbered from 1
	CI	R7,>0002		is it a program file?
	JNE	H229			no
	AI	R7,3			yes: make it type 5
H229	CI	R7,>0008		is it var?
	JL	H230			no
	AI	R7,-127			yes: add 1 and clear var bit
H230	SLA	R0,4			write protect bit will be >80
	SOC	R0,R7			add it to file type
	JMP	H231			
*					
H228	CLR	R2			no more files: filename size = 0
	CLR	R6			file size = 0
	CLR	R3			rec length = 0
	CLR	R7			type = 0
H231	JMP	H232			output that
*					
H227	AI	R5,255			disk info: point to data buffer area in ctrl block
	BL	@CALSUB			call subroutine
	DATA	RWSEC			read sector 0
	BL	@FDR2B1			get 2 bytes from FDR into R0
	DATA	266			# of sectors on disk
	MOV	R0,R6			duplicate it
	DECT	R6			minus directory itself (sect 0 + 1)
	BL	@CFSVIB			count free sectors in bitmap, result in R3
	CLR	R7			filetype is not used
	LI	R2,>0A00		diskname is 10 chars
*					
H232	BL	@PABR2B			get 2 bytes from PAB into R0
	DATA	2			APEDSK99: error in source listing (was R2)
	MOV	R0,R8			duplicate it
	INC	R8			skip first byte
	SRL	R2,8			filename length (or diskname)
	JEQ	H233			0: skip filename copying
	CLR	R1			
H234	BLWP	@>005A(R9)		set VDP to read
	DATA	>00A2			address in R5 (FDR ptr)
	MOVB	@-1026(R15),R1		get 1 char from filename in FDR
	CI	R1,>2000		is it a space?
	JEQ	H235			yes: end of name
	BLWP	@>005A(R9)		no: set VDP to write
	DATA	>0103			address in R8 (PAB data buffer ptr)
	MOVB	R1,@-2(R15)		copy char in PAB data buffer
	INC	R5			increment source ptr
	INC	R8			increment destination ptr
	DEC	R2			next char
	JNE	H234			
H235	NEG	R2			number of trailing spaces
	AI	R2,10			number of chars in filename
	SWPB	R2			
H233	BLWP	@>005A(R9)		set VDP to write
	DATA	>0003			address in R0 (beg of PAB data buffer)
	MOVB	R2,@-2(R15)		write string length byte
*					
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0103			address in R8
	MOV	R7,R1			file type + protection
	BL	@INT2FP			make it a float number
	MOV	R6,R1			file size in sectors, including FDR
	BL	@INT2FP			make it a float number
	MOV	R3,R1			record length
	BL	@INT2FP			make it a float number
	MOV	@>0054(R9),R8		get PAB ptr
	AI	R8,5			point to character count
	LI	R0,>2600		always 38 bytes
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0103			address in R8
	MOVB	R0,@-2(R15)		write # of characters in record
	B	@RTURN1			return to caller
*					
CFSVIB	AI	R8,46			count free sectors in VIB bitmap
	LI	R2,200			bitmap size
	CLR	R3			free sectors counter
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0102			address in R8
H236	MOVB	@-1026(R15),R1		get a byte from bitmap
	AI	R1,256			
	SRL	R1,8			
	JEQ	H237			was >FF: no free sectors, next byte
	DEC	R1			was it >00?
	JNE	H238			no: count bits
	AI	R3,8			yes: 8 more free sectors
	JMP	H237			next byte
H238	LI	R0,8			8 bits per byte
H239	SRL	R1,1			test a bit
	JOC	H240			was 1: sector is used
	INC	R3			was 0: one more free sector
H240	DEC	R0			next bit in byte
	JNE	H239			more to come
H237	DEC	R2			next bitmap byte
	JNE	H236			more to come
	B	*R11			
*					
FNDRV	MOV	*R11+,R10		find drive in file control blocks
	MOV	R11,R5			save 2 returns
	MOV	@>0056(R9),R8		top of mem word in VDP buffers header
	AI	R8,3			point to max # of files
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0102			address in R8
	MOVB	@-1026(R15),R2		get # of files
	SRA	R2,8			make it a word
	AI	R8,6			point to drive # in file ctrl block
	LI	R3,>0020		filename begin with space (illegal: flag for dir)
	MOVB	R6,R3			APEDSK99: error in original disassembly (was R5)
H241	BL	@VDPR2B			read 2 bytes from VDP at R8 into R0
	C	R3,R0			match with that control block?
	JEQ	H242			yes
	ANDI	R0,>00FF		keep only first char of filename
	JNE	H243			valid filename: a FDR is loaded here
	MOV	R8,R7			this space is free: save ptr
H243	AI	R8,518			point to next file control block
	DEC	R2			next file
	JNE	H241			more to come
	B	*R10			not found: return to address passed in data word
H242	INC	R8			drive matches: point to FDR
	MOV	R8,@>0056(R9)		save ptr
	B	*R5			return to caller after data word
*
*--------------------------------------
* Floating point format
* ---------------------
* Float numbers are 8 bytes long: EE 12 34 56 78 9A BC
* EE is the exponent in radix 100 (not in radix 10 as usual!). It is biased
* by 64: >40=0, 41=1 (i.e *100), >42=2 (i.e * 10,000) >3F= -1 (i.e /100), etc
*
* 12 ... BC are the mantissa in binary coded decimal: each byte encodes two
* decimal digits from 00 to 99
*
* For negative numbers, the first word is negated
* For zero, the first word is >0000 the others are irrelevant
*
* Examples: 40 08 00 00 00 00 00 00 is 8.0
*           41 02 37 00 00 00 00 00 is 255.0 (>37 hex = 55 decimal)
*           BF F8 00 00 00 00 00 00 is -8.0
*           43 01 02 03 04 05 06 07 is 1020304.050607
*--------------------------------------					
*
INT2FP	LI	R2,>0800		write an integer in floating point format
	MOVB	R2,@-2(R15)		size=8
	MOV	R1,R5			integer is in R1: save it for sign processing
	ANDI	R1,>7FFF		clear sign bit
	CI	R1,100			is it less than 100?
	JL	H244			yes
	CLR	R0			100 or over
	LI	R4,100			
	DIV	R4,R0			divide by 100
	ORI	R0,>4100		add exponent 2 to hundreths
	JMP	H245			
*					
H244	MOV	R1,R0			is it 0?
	JEQ	H246			yes: exponent is 0
	ORI	R0,>4000		no: add exponent 1
H246	CLR	R1			next digits will be 0
*					
H245	MOV	R5,R5			test sign bit
	JLT	H247			negative
	JMP	H248			positive or zero
H247	NEG	R0			negate first word
H248	MOVB	R0,@-2(R15)		write exponent to VDP at preset address
	SWPB	R0			
	MOVB	R0,@-2(R15)		write first first 2 digits (or hundreths)
	SWPB	R1			
	MOVB	R1,@-2(R15)		write last 2 digits (if any)
	LI	R2,5			the remaining bytes are all 0 with integers
H249	MOVB	R2,@-2(R15)		write 0 to VDP
	DEC	R2			next byte
	JNE	H249			more to do
	B	*R11			
*
*---------------------------------------
* Subprogram >10: sector R/W
* --------------
* >834A: (n/a)      <--- sector #
* >834C: drive #
* >834D: R/W code (write if >00)
* >834E: VDP buffer
* >8350: sector #   <--- error code
*---------------------------------------					
*
ESUB01	MOV	R11,R7			
	BL	@PRPFDO			prepare disk operations
	MOV	@>0050(R9),@>004A(R9)	copy sector #
	B	@SECRW1			
*
*---------------------------------------
* Subprogram >11: format disk
* --------------					
*
ESUB02	MOV	R11,R7			
	BL	@PRPFDO			prepare disk operations
	B	@FMTDSK			
*
*---------------------------------------
* Subprogram >12: file (un)protect
* --------------
* >834C: drive #
* >834D: protect code (>00 unprotect)
* >834E: ptr to filename
* >8350: (n/a)      <--- error code
*---------------------------------------				
*
ESUB03	MOV	R11,R7			
	BL	@PRPFDO			prepare disk operations
	MOVB	@>004D(R9),R0		get protection code
	ANDI	R0,>0800		keep the bit that will be needed
	BLWP	@>005A(R9)		save R0 on stack
	DATA	>8000			
	MOV	@>004E(R9),R0		get pointer to filename
	BL	@CALSUB			call subroutine
	DATA	RFDRVB			load FDR in VDP buffer
	BLWP	@>005A(R9)		retrieve old R0, in R2
	DATA	>2001			
	BL	@FDR2B1			read two bytes in R0 from top of FDR + offset
	DATA	12			file status byte
	ANDI	R0,>F700		clear protection flag
	SOCB	R2,R0			set it if needed
	BLWP	@>005A(R9)		set VDP for write
	DATA	>0103			address in R8
	MOVB	R0,@-2(R15)		write back file status to FDR
*					
UWFLVB	MOV	@>0056(R9),R8		FDR address in VDP mem
	BLWP	@>005A(R9)		set VDP for read
	DATA	>0102			address in R8
	MOVB	@-1026(R15),R0		get drive # in ctrl block
	ORI	R0,>8000		flag it
	BLWP	@>005A(R9)		set VDP for write
	DATA	>0103			address in R8
	MOVB	R0,@-2(R15)		write it back
	B	@UPDFDR			update FDR, load VIB
*
*---------------------------------
* Subprogram >13: file rename
* --------------
* >834C: drive #
* >834E: ptr to new name
* >8350: ptr to old name <--- error code
*---------------------------------					
*
ESUB04	MOV	R11,R7			
	BL	@PRPFDO			prepare disk operations
	MOV	@>004E(R9),R0		get ptr to new filename
	BLWP	@>005A(R9)		save R0 on stack
	DATA	>8000			
	MOV	@>0050(R9),R0		get ptr to old filename
	BL	@CALSUB			call subroutine
	DATA	RFDRVB			put FDR in VDP buffer
	BL	@RMFPTR			remove FDR ptr from sector 1
	BL	@FDR2B1			get 2 bytes from FDR
	DATA	12			file status byte
	ANDI	R0,>0800		protected?
	JEQ	H250			no
	BL	@ERROR5			yes: return with error
	DATA	>2000			write protected
H250	BL	@FDR2B1			get 2 bytes from FDR
	DATA	-4			sector # of FDR
	MOV	R0,R1			
	BLWP	@>005A(R9)		retrieve R0 from stack
	DATA	>8001			ptr to new filename
	BLWP	@>005A(R9)		save R1 on stack
	DATA	>4000			sector # of FDR
	BL	@UFNCB			write drive # and filename in compare buffer
	BL	@CALSUB			call subroutine
	DATA	FFDRFN			find FDR from filename
	MOV	R4,R4			found?
	JEQ	H251			yes: return with file error (name already exist)
	BL	@INSFDR			insert a FDR in sector 1
	BLWP	@>005A(R9)		retrieve sect # of FDR in R4
	DATA	>0801			
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0103			address in R8
	MOVB	R4,@-2(R15)		write sector # of FDR
	SWPB	R4			
	MOVB	R4,@-2(R15)			
	SWPB	R4			sector #
	SETO	R2			code for read
	CLR	R5			buffer offset: VDP at >8356
	BL	@CALSUB			call subroutine
	DATA	RDFDR1			read FDR
	MOV	R5,R1			
	MOV	@>0058(R9),R0			
	AI	R0,257			
	DEC	R1			
	BL	@CFNFDR			copy filename in compare buffer to FDR
	CLR	R2			code for write
	BL	@CALSUB			call subroutine
	DATA	RWSEC			write FDR (with new name in it)
	BL	@CALSUB			call subroutine
	DATA	WRSEC1			write sector 1 (with new FDR ptr in it)
	MOV	@>0056(R9),R1		FDR ptr
	BLWP	@>005A(R9)		prepare VDP to write
	DATA	>0023			address in R1
	MOVB	R4,@-2(R15)		clear first char of FDR in buffer
	B	@RTURN1			return to caller
*				
RFDRVB	CLR	R6			put FDR in VDP buffer
	MOVB	@>004C(R9),R6		get drive #
	BL	@UFNCB			update filename compare buffer
	BL	@CALSUB			call subroutine
	DATA	FFDRVB			look if FDR already in VDP buffer
	BL	@CALSUB			call subroutine
	DATA	FFDROD			file FDR on disk
	MOV	R4,R4			found?
	JEQ	H252			yes
H251	BL	@RETERR			no: return with error code in >8350
	DATA	>E000			file error
H252	B	@RTURN1			return to caller
*
*-------------------------------------
* Subprogram >14: file raw read
* --------------
* >834C: drive #                          <--- >00
* >834D: # of sectors (>00=get file info) <--- sectors read
* >834E: ptr to filename
* >8350: file info buffer (>83xx)         <--- error code
*                              |
* >83xx  : VDP buffer       <--'
* >83xx+2: first sector # (total # of sect when get file info)
* >83xx+4: status flag
* >83xx+5: recs/sector
* >83xx+6: eof offset
* >83xx+7: rec size
* >83xx+8: # of recs
*-------------------------------------					
*
ESUB05	MOV	R11,R7			
	BL	@PRPFDO			prepare disk operations
	BL	@RFNPTR			load filename and ptrs
	BL	@FFFDR			find file FDR, load some info
	MOV	R2,R2			# of sectors to read
	JEQ	H253			>00: get file info
	S	R3,R0			sectors in file - first sector to read
	JGT	H254			in file
	CLR	R2			past eof
	JMP	H255			
H254	C	R2,R0			sectors past first one vs sectors to load
	JL	H256			
	MOV	R0,R2			load what's left
H256	BLWP	@>005A(R9)			
	DATA	>2000			save R2
H257	BLWP	@>005A(R9)			
	DATA	>3100			save R2, R3, R7
	BL	@CALSUB			call subroutine
	DATA	RDOFSC			read sector from offset in file
	BLWP	@>005A(R9)			
	DATA	>3101			retrieve R2, R3, R7
	INC	R3			next sector
	AI	R7,256			increment VDP buffer ptr by 256 bytes
	DEC	R2			more to do?
	JNE	H257			yes
H258	BLWP	@>005A(R9)			
	DATA	>2001			retrieve R2 (# of sectors read)
H255	MOV	R2,@>004C(R9)		update # of sectors in parameters
	JMP	H259			
*					
H253	MOV	R0,*R4+			get file info: sectors in file
	DECT	R8			
	INCT	R2			copy 2 bytes (status + recs/sector)
	BL	@VDP2SP			from VDP at R8 to file info structure
	LI	R2,4			copy 4 bytes
	A	R2,R8			
	BL	@VDP2SP			eof offset, rec len, # of recs (or # of sect)
H259	BL	@CALSUB			call subroutine
	DATA	UPDFDR			updata FDR (+ data) if needed, read VIB
	CLR	@>0050(R9)		clear error flag
	B	@RTURN1			return to caller
*
*--------------------------------------
* Subprogram >15: file raw write
* --------------
* >834C: drive #                                  <--- >00
* >834D: # of sectors (>00=create file from info) <--- # of sectors written
* >834E: ptr to filename
* >8350: file info buffer (>83xx)                 <--- error code
*                              |
* >83xx  : VDP buffer       <--'
* >83xx+2: first sector # (total # of sectors when creating file)
* >83xx+4: status flag
* >83xx+5: recs/sector
* >83xx+6: eof offset
* >83xx+7: rec size
* >83xx+8: # of recs
*--------------------------------------					
*
ESUB06	MOV	R11,R7			
	BL	@PRPFDO			prepare disk operations
	BL	@RFNPTR			load drive + filename, + a few info
	JEQ	H260			sectors to write=0: create file
	BL	@FFFDR			find file FDR
	BLWP	@>005A(R9)			
	DATA	>2000			save R2 (# of sectors to write)
H261	BLWP	@>005A(R9)			
	DATA	>3100			save R2, R3, R7
	BL	@CALSUB			call subroutine
	DATA	WROFSC			write sector from offset in file
	BLWP	@>005A(R9)			
	DATA	>3101			retrieve R2, R3, R7
	INC	R3			next sector
	AI	R7,256			increment VDP ptr by 256 bytes
	DEC	R2			more to do?
	JNE	H261			yes
	JMP	H258			update # of sectors written, in param. Then return
*				
H260	BL	@CALSUB			create file
	DATA	FFDRVB			find file FDR in VDP buffers
	BL	@CALSUB			call subroutine
	DATA	FFDROD			find file FDR on disk
	BL	@CALSUB			call subroutine
	DATA	CRFIL2			create file
	BLWP	@>005A(R9)			
	DATA	>0801			retrieve R4 (file info ptr)
	MOV	@>0056(R9),R8		FDR ptr
	INCT	R4			skip 2 bytes
	MOV	*R4+,R3			# of sector to create
	AI	R8,10			skip filename
	BL	@SP2VDP			write 2 bytes in VDP at R8+2
	DATA	2			i.e. status + recs/sector
	BL	@SP2VDP			write 4 bytes in VDP at new R8+4
	DATA	4			i.e. eof offset, rec len, # of recs (or # of
	DEC	R3			offset = # of sectors-1 (starts from 0)
	JLT	H262			create an empty file, FDR only
	BL	@CALSUB			
	DATA	APSCTS			append enough sectors to reach offset
H262	B	@UWFLVB			modify FDR, write it, load VIB, return
*
*---------------------------------------
* Subprogram FILES: number of files
*---------------------------------------					
ESUB08	MOV	R11,R7			
	BL	@PRPFDO			prepare disk operation
	MOV	@>002C(R9),R8		ptr to next basic token
	AI	R8,7			skip FILES
	BL	@VDPR2B			get next two bytes in R0
	CI	R0,>C801		>C8=unquoted string, size=1 char
	JNE	H263			return (with error) if different
	INCT	R8			increment pointer
	BL	@VDPR2B			get next two bytes
	SWPB	R0			
	AI	R0,>49D0		substact >B630: # of files >B6=closed parenthesis
	CI	R0,>0009		only 9 files allowed in Basic !
	JH	H263			return with error if more
	SWPB	R0			
	MOVB	R0,@>004C(R9)		put new # of files in scratch-pad memory
	BL	@CALSUB			call subroutine
	DATA	PESB07			subprogram >16 (private entry point)
	MOVB	@>0050(R9),@>0050(R9)	test result
	JNE	H263			error
	MOV	@>002C(R9),R8		ok: get ptr to Basic token
	AI	R8,12			skip the whole statement
	MOV	R8,@>002C(R9)		update ptr
	SZCB	@>0042(R9),@>0042(R9)	clear current token
H263	B	@RTURN1			return to caller (i.e. Basic)
*
*---------------------------------------
* Subprogram >16: number of files
* --------------
* >834C: # of files
* >8350: (n/a)      <--- error code
*---------------------------------------					
*
ESUB07	MOV	R11,R7			entry point from assembly
	BL	@PRPFDO			prepare disk operations
PESB07	CLR	R0			entry point from call files
	MOVB	@>004C(R9),R0		get # of files
	JEQ	H264			return with error
	MOV	@>0056(R9),R8		ptr to end of buffer word
	AI	R8,3			point to # of files byte
	CLR	R3			
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0102			address in R8
	MOVB	@-1026(R15),R3		get current # of files
	LI	R5,518			size of 1 file control block
	CB	R0,R3			compare required with current
	JEQ	H265			same: return with no error
	JLE	H266			less
	MOV	R0,R6			more files needed
	CI	R0,>1000		maximum is 16
	JH	H264			return with error
	S	R3,R0			how many to add
	SRL	R0,8			make it a word
	MPY	R5,R0			# of bytes to add
	MOV	R1,R4			result in R0:R1
	NEG	R4			
	MOV	@>0070(R9),R2		highest free address in VDP mem
	MOV	R2,R0			
	S	R1,R0			what it would become
	CI	R0,>0800		is there room enough for VDP?
	JLT	H264			no: return with error
	MOV	R0,R1			ok: new base
H267	INC	R2			increment source ptr
	INC	R0			increment destination ptr
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0042			address in R2
	MOVB	@-1026(R15),R3		get a byte
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0003			address in R0
	MOVB	R3,@-2(R15)		copy a byte
	C	R2,R8			did we copy the whole header?
	JNE	H267			not yet
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0003			address in R0
	MOVB	R6,@-2(R15)		new # of files
	CLR	R6			
	S	R0,R2			
H268	MOVB	R6,@-2(R15)		clear byte
	DEC	R2			
	JNE	H268			
	JMP	H269			
*					
H266	BLWP	@>005A(R9)		less files needed
	DATA	>0103			set VDP to write to address in R8
	MOVB	R0,@-2(R15)		new # of files in buffer header
	S	R0,R3			how many to remove
	SRL	R3,8			make it a word
	MPY	R5,R3			# of bytes to remove
	MOV	R4,R1			result in R3:R4
	A	R8,R1			new address for buffer header
	MOV	@>0070(R9),R2		highest free address in VDP mem
H270	BLWP	@>005A(R9)		set VDP to read
	DATA	>0102			address in R8
	MOVB	@-1026(R15),R0		read a byte
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0023			address in R1
	MOVB	R0,@-2(R15)		write byte back
	DEC	R1			decrement destination ptr
	DEC	R8			decrement source ptr
	C	R8,R2			did we copy the whole header?
	JNE	H270			not yet
*					
H269	MOV	R1,@>0070(R9)		new first free address					
H265	CLR	@>0050(R9)		clear error flag
	JMP	H272			
H264	SETO	@>0050(R9)		set error flag
H272	B	@RTURN1			return to caller
*					
UFNCB	CLR	@>0054(R9)		write drive # and filename in compare buffer
	MOV	@>0058(R9),R1		
	AI	R1,256			ptr to filename compare buffer
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0023			address in R1
	MOVB	R6,@-2(R15)		write drive #
CFNFDR	LI	R2,10			filename must be exactly 10 chars
H273	INC	R1			next char in compare buffer
	BLWP	@>005A(R9)		set VDP to read
	DATA	>0002			address in R0
	MOVB	@-1026(R15),R3		get 1 char from filename
	INC	R0			next char in provided filename
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0023			address in R1
	MOVB	R3,@-2(R15)		write 1 char to compare buffer
	DEC	R2			
	JNE	H273			next char
	B	*R11			
*					
RFNPTR	MOV	R11,R10			load compare buffer and ptrs
	CLR	R6			
	MOVB	@>004C(R9),R6		drive #
	MOV	@>004E(R9),R0		ptr to filename
	BL	@UFNCB			write them in compare buffer
	MOVB	@>0050(R9),R4		file info structure ptr
	SRL	R4,8			
	A	R9,R4			make it a PAB address
	MOVB	@>004D(R9),R0		# of sectors (>00=get file info)
	BLWP	@>005A(R9)			
	DATA	>0800			save R4
	SRL	R0,8			
	B	*R10			EQ set for get file info
*					
FFFDR	BLWP	@>005A(R9)		find file FDR
	DATA	>8010			save R0 + R11
	BL	@CALSUB			call subroutine
	DATA	FFDRVB			find file FDR in VDP buffers
	BL	@CALSUB			call subroutine
	DATA	FFDROD			find FDR on disk
	MOV	R4,R4			found ?
	JEQ	H274			yes
	BL	@ERROR5			no: return with error
	DATA	>E000			file error
H274	BL	@FDR2B1			get two bytes from FDR into R0
	DATA	14			# of sectors in file
	BLWP	@>005A(R9)			
	DATA	>2011			retrieve R0 in R2 (# of sect to read), and R11
	BLWP	@>005A(R9)			
	DATA	>0801			retrieve R4 (ptr to file info structure)
	MOV	*R4+,R7			VDP buffer
	MOV	*R4,R3			first sector
	B	*R11			
*					
VDP2SP	BLWP	@>005A(R9)		copy VDP bytes to scratch-pad
	DATA	>0102			read from VDP at R8
H275	MOVB	@-1026(R15),*R4+	read bytes into scratch-pad at R4
	DEC	R2			# of byte in R2
	JNE	H275			next byte
	B	*R11			
*					
SP2VDP	MOV	*R11+,R2		copy scratch-pad bytes to VDP
	A	R2,R8			
	BLWP	@>005A(R9)		set VDP to write
	DATA	>0103			address in R8 + offset in data word
H276	MOVB	*R4+,@-2(R15)		write byte from scratch-pad at R4
	DEC	R2			# of bytes in R2, was in data word
	JNE	H276			next byte
	B	*R11	
*
* APEDSK99 CALL subprograms
*
* parameter is single digit -> 0x00
PDSK	LI	R6,>0100		Protect ACOMND 
	JMP	ACLPRP			generic prep
UDSK	LI	R6,>0200		Unprotect ACOMND 
	JMP	ACLPRP			generic prep
LDSK	LI	R6,>0300		Show Files on DSKx ACOMND 
	JMP	ACLPRP			generic prep
* parameters are single digit + character string -> 1x00; ! >1300 IS RESERVED (BL NTPDT+1) ! 
MDSK	LI	R6,>1000		Change DSK ACOMND
	JMP	ACLPRP			generic prep
NDSK	LI	R6,>1100		create new blank SS/SD DOAD image
	JMP	ACLPRP
* parameter is a charachter string -> 2x00
RDSK	LI	R6,>2000		Remove DOAD from SD card ACOMND 
	JMP	ACLPRP			generic prep
FGET	LI	R6,>2100		get DOAD from FTP server ACOMND
	JMP	ACLPRP			generic prep
FPUT	LI	R6,>2200		save DOAD to FTP server ACOMND 
	JMP	ACLPRP			generic prep
ADSR	LI	R6,>2300		load DSR and reset ACOMND
	JMP	ACLPRP			generic prep
NDIR	LI	R6,>2400		change root folder
	JMP	ACLPRP			generic prep
* no parameters	->3x00
SDSK	LI	R6,>3000		Show DSKx mapping ACOMND
	JMP	ACLPRP			generic prep
SDIR	LI	R6,>3100		Show SD dir ACOMND
	JMP	ACLPRP			generic prep
AHLP	LI	R6,>3200		display APEDSK99 CALL()'s help screen
	JMP	ACLPRP			generic prep
ALOW	LI	R6,>3300		load proper lowercase character set
	JMP	ACLPRP			generic prep
ARST	LI	R6,>3400		reset APEDSK99 ACOMND
	JMP	ACLPRP			generic prep
TIME	LI	R6,>3500		show NTP time and date
*
* Generic prep and return to TI BASIC for APEDSK99 CALL's
*
ACLPRP	MOV	R11,R7			save return-to-TI BASIC address
	BL	@PRPFDO			prepare TI Controller DSR operations
*
	MOV	@>002C(R9),R8		ptr to next basic token
	AI	R8,4			skip length byte and 3 chars of CALL name
	BL	@VDPR2B			get CALL last char and "(" or "0" in R0
	SLA	R0,8			only interested in LSB
	JEQ	NOPARM			0 = no parameters? SDSK / SDIR / AHLP / ALOW / ARST / TIME (and special guest LDSK)
*
	AI	R8,2			adjust token pointer
	BL	@VDPR2B			get next two bytes in R0
	CI	R0,>C801		>C8=unquoted string, size=1 char?
	JEQ	USTRNG			yes: PDSK / UDSK / LDSK / MDSK / NDSK
*
	CI	R0,>C701		>C7=quoted string, minimum 1 character?
	JHE	QSTRNG			yes: RDSK / FGET / FPUT / ADSR / NDIR
*
ACLERR	B	@RTURN1			expect the unexpected				
*
* SDSK / SDIR / AHLP / ALOW / ARST / TIME (and special guest LDSK)
*
NOPARM	CI	R6,>0300		LDSK without parameters is handy (re-use last used DSK#)
	JEQ	NOPRM2
	CI	R6,>3000		catch other CALL's without parameters -> error
	JL	ACLERR
*
NOPRM2	MOVB	@LSTDRV,@CALLBF		get last drive accessed for LDSK without parameters
	MOVB	R6,@ACOMND		execute LDSK / ALOW / ARST / TIME
	CI	R6,>3300		ALOW / ARST / TIME ?	
	JL	LDSK2			no; SDSK / SDIR / AHLP use LDSK display routine
*
QNOPRM	LI	R8,9			current CALL length
	CI	R6,>3300		ALOW?
	JEQ	ALOW2			yes; get some real characters
	CI	R6,>0300		LDSK()?
	JNE	H9901			nope; exit with CALL lenght 9 for SDSK / SDIR / AHLP
	AI	R8,3			yep;  exit with CALL length 12 for LDSK
*
H9901	B	@ACLBAS	
*
ALOW2	CB	@INT2FP+2,@CALLST
	JEQ	H9901			>08; no char definition file found
*
	MOV	@PATTBL,R2		get start of <SPACE> pattern table entry (default >0400 for TI BASIC)
	BL	@VDPWRI			set VPD address
*			
H9902	BL	@DISSTS			use existing display routine to write 4 definitions at a time
	CB	@K004,@CALLST		check Arduino ALOW return code
	JEQ	H9901			we're done
	MOV	R2,@RDINT		generates interrupt for next lot
	JMP	H9902			again
*
* PDSK / UDSK / LDSK / MDSK / NDSK
*
USTRNG	CI	R6,>2000		only PDSK / UDSK / LDSK / MDSK / NDSK?
	JHE	ACLERR			no -> sneaky other commands don't belong here
	INCT	R8			increment pointer
	BL	@VDPR2B			get next two bytes		
*
	SWPB	R0
	AI	R0,>49D0		add 2's complement of >B630: MSB = >B3 / "," or >B6 / ")", LSB= # of files 
	JGT	H9903			>B6
	AI	R0,768			>B3, adjust R0 to positive range
*
H9903	JEQ	ACLERR			DSK0 not valid, * INCORRECT COMMAND
	CI	R0,3			only 3 DSK's allowed
	JH	ACLERR			DSK4+, * INCORRECT COMMAND
*
	SWPB 	R0
	MOVB	R0,@CALLBF		save DSKx
	MOVB	R0,@LSTDRV		remember last drive accessed for LDSK without parameter
*
	CI	R6,>1000		MDSK or NDSK?
	JHE	MNDSK2			yep
*
	MOVB	R6,@ACOMND		send PDSK / UDSK / LDSK command to Arduino

	CI 	R6,>0300		LDSK?
	JEQ	LDSK2			yep
*
PUDSK2	LI	R8,12			CALL length
	JMP	ACLBAS			return to BASIC		
*			
LDSK2	CB	@K002,@CALLST
	JEQ	QNOPRM			LDSK: >00; no DOAD mapped
*
NXTSCR	CLR	R2			clear screen; position 0
	BL	@VDPWRI
*
	LI	R0,>8000		space + TI BASIC bias
	BL	@VDPRPW
	DATA	704			704 positions to clear
*
	LI	R2,32			start 2nd screen line; 1st is lost due to BASIC scroll
H9904	BL	@VDPWRI			
*	
	CB	@K004,@CALLST		check Arduino LDSK / SDSK / SDIR / AHLP return code
	JEQ	QNOPRM			"More" (>F0); blank DSK or done last file / help txt
*
	BL	@DISSTS			LDSK / SDSK / SDIR / AHLP output to screen
*
	AI	R2,32			next screen position
	CI	R2,640			end of display area?
	JEQ	NXTPRP			yes; show "more" symbol
*
	INC	@RDINT			generates interrupt for next file / help txt
	JMP	H9904	
*	
NXTPRP	LI	R2,702
	BL	@VDPWRI
	LI	R5,>9E00		show ">", more file / help txt to display
	MOVB	R5,@-2(R15)
*
	BL	@CHKKEY
*
	INC	@RDINT			generates interrupt for next file / help txt
	JMP	NXTSCR
*
* MDSK / NDSK / RDSK / FGET / FPUT / ADSR / NDIR
*
MNDSK2	INCT	R8			increment pointer
	BL	@VDPR2B			get next two digits
*
QSTRNG	CI	R6,>1000		further check on RDSK / FGET / FPUT / ADSR
	JL	ACLERR			no -> sneaky PDSK / UDSK don't belong here	
	AI	R0,>3900		add 2's complement of >C700 =  only keep # of characters
	JEQ	H9906			0 characters / empty string -> * INCORRECT COMMAND
	CI	R0,8			max 8 characters?
	JH	H9906			no -> * INCORRECT COMMAND
*
	MOV	R0,R4			save # of characters
	LI	R5,CALLBF+2		pointer to DOAD / DSR name	
	INCT	R8			increment pointer
	MOV	R8,R2			for VDPRD, address must be in R2
	BL	@VDPRD			set VDP READ address
H9905	MOVB	@-1026(R15),*R5+	get character and save in CALL buffer
	DEC	R0			one less to go
	JNE	H9905	
	MOVB	@K002,*R5		mark end of string with >00 (Arduino check for < 8 characters)
*
	MOVB	@-1026(R15),R0		get next token
	CI      R0,>B600                is it a ")" ?
	JEQ	H9907
H9906	B	@ACLERR	                * INCORRECT COMMAND
*
H9907	LI	R8,13			prep RDSK / FGET / FPUT / ADSR CALL length ( CALL_XXXX("") )
	A	R4,R8			add # of characters in string
	
	CI	R6,>1100		MDSK or NDSK?
	JH	H9908			no; jump and execute RDSK / FGET / FPUT / ADSR
	INCT	R8			adjust MDSK and NDSK CALL length
*
H9908	MOVB	R6,@ACOMND		command to Arduino
*
ACLBAS	CB	@CALLST,@K004		"More" or "AllGood" received from Arduino?	
	JHE	H9909			yep
*	
	LI	R5,GPLINT		no; GPL routine
	BL	@GPLXML			
	DATA	SCROLL			scroll screen
	LI	R2,736			screen starting position for (error) message
	BL	@VDPWRI			set VDP address
	BL	@DISSTS			show (error) message
	LI	R5,GPLINT		GPL routine
	BL	@GPLXML	
	DATA	SCROLL			scroll screen
*
	CB	@CALLST,@K007		error?
	JH	H9909			no; be silent	
*
	LI	R5,GPLINT		yes: let's make some noise
	BL	@GPLXML
	DATA	HONK			GPL routine"bad tone"
	JMP	H9910
*
H9909	CI	R6,>3500		TIME() ?
	JNE	H9910			no, end the party
	JMP  	TIME2			yes; see if we can assign date/time to NTP$ 
*
H9910	CLR	@>0050(R9)		clear error flag		
	A	R8, @>002C(R9)		add call length to token pointer		
	SZCB	@>0042(R9),@>0042(R9)	clear current token
	B	@RTURN1			return to caller (i.e. TI-BASIC)
*	
* Display data, status messages and errors
*
DISSTS	LI	R5,CALLBF		start of file name buffer
	LI	R6,32			32 bytes / 1 screen row of data to display
H9911	MOVB	*R5+,@-2(R15)		store character in VDP screen memory
	DEC	R6
	JNE	H9911
	B	*R11
*
* Quick key test to display next screen after ">"
* Keyboard column 0 (= space enter <nc> fctn shift ctrl <nc>)
* Code copy from Thierry's TI's Tech Pages site
*
CHKKEY	MOV	R12,R4 			save R12
	CLR  	R1                  	test column 0
     	LI   	R12,>0024           	address for column selection
H9912  	LDCR 	R1,3               	select column
	TB	-14			test R12 address >0008
	JNE	H9913			<SPACE>
	TB	-13			test R12 address >000A
	JEQ	H9912			no key; test again
*
	MOVB	@K004,@CALLST		signal ENTER to SDIR() command
	LI	R11,QNOPRM		leave without clearing screen
*
H9913	MOV	R4,R12 			restore R12
	SLA	R4,2			debounce delay
H9914	DEC	R4			key debounce
	JNE	H9914			debounce some more
*
	B    	*R11               	we got one; return for next screen
*
* prep for calling XML >16 and update BASIC variable NTP$		
*
VARINF	TEXT	'NTP$'
TIME2	LI	R4,VARINF		variable name for XML >16 in FAC
	MOV	R9,R5			get scratchpad start address
H9915	MOVB	*R4+,@>004A(R5)		variable name in FAC
	INC	R5
	CI	R4,VARINF+4		done all chars?
	JNE	H9915			
*
	LI	R5,>0400		variable length for XML >16 in @>8359
	MOVB	R5,@>0059(R9)		
	CLR 	@>0089(R9)	
*
	LI	R5,XML16		ROM routine: find NTP$ in VDP symbol table (returns to GPL interpreter)
	BL	@GPLXML
	DATA	XMLRTN			GPL "RTN", escaping GPL interpreter
*
	CB	@VARINF,@>004A(R9)	found NTP$ in VDP symbol table?
	JEQ	H9917			no symbol table pointer; back to BASIC
*
	BL	@XML14			ROM routine: get NTP$ VDP address and string length (returns through RT)
	STWP	R9			restore scratchpad pointer
	AI	R9,-224
*	
	MOV	@>0050(R9),R5		get string length
	CI	R5,16			16 chars?
	JNE	H9917			no NTP$ assignment for you
*
	MOV	@>834E,R2		yes
	BL	@VDPWRI			set VDP write address
	LI	R5,CALLBF		CALL TIME data still in buffer
H9916	MOVB	*R5+,R2			read character
	AI	R2,>A000		remove TI BASIC bias
	MOVB	R2,@-2(R15)		save to NTP$ value space
	CI	R5,CALLBF+16		done all 16 chars?
	JNE	H9916			no; one more
*
H9917	B	@H9910			yes; back to BASIC
*
* execute GROM or XML routine (SCROLL, "bad sound" / HONK and XML >16)
* DSR and GPL interpreter use same workspace (>83E0) so we need to save a few things
*
SAVGRA	BSS	2			save current GROM address so we can return to BASIC
SAVR11	BSS	2			GPL interpreter uses R11
*
GPLXML	MOVB	@>9802,@SAVGRA		save current GROM address
	NOP
	MOVB	@>9802,@SAVGRA+1
	DEC	@SAVGRA			GRMWA returns address + 1; decrease for correct address
*
	MOVB	*R11+,@>9C02		set GPL routine address
	NOP
	MOVB	*R11+,@>9C02
	MOV	R11,@SAVR11		save final DSR return address
*
	LI	R11,GXRTN		DSR return address after GPL routine
	MOV	R11,@RTN5C		@>4028 is where XML >5C returns to
*
	INCT	@>8373			increase stack pointer
	SWPB	R9			
	MOVB	@>8373,R9
	SWPB	R9			complete stack pointer in R9
	LI	R11,XML5C		GROM pointer to >0F5C (= XML >5C)
	MOV 	R11,*R9			save GROM pointer on stack
*
	B	*R5			execute GROM/ROM routine, return through GPL interpreter
*
GXRTN	MOVB	@SAVGRA,@>9C02		and ... we're back; restore saved GROM address
	NOP
	MOVB	@SAVGRA+1,@>9C02
*
	STWP	R9			restore scratchpad pointer
	AI	R9,-224
*
	MOV	@SAVR11,R11		restore R11
	B	*R11			return to instruction after BL @GPLEXEC DATA statement
* 		
* update FAT time/date for current DOAD after DSR Write / Format / Save
*
NTPDT	MOVB	@NTPFAT+1,@ACOMND	"DSK NTP date/time update" command to Arduino		
	B	*R11			return to Format / Close
*
*----------------------------------------------------------------------------------
* >5F22 - >5FB3: 145 free bytes remaining
* >5FC2 - >5FD3 is DSK1-3 parameters storage
* >5FD4 is the CALL() status byte
* >5FD6 - >5FE7 is buffer storage for APEDSK99 CALL's
* >5FE8	is the Arduino Command Register (TI BASIC CALL support)
* Word >5FEA maps to the read counter (R6, to generate interrupts when reading data) 
* Bytes >5FEE maps to the CRU emulation write register
* Bytes >5FF0 to >5FFE map to the FDC emulation registers
*-----------------------------------------------------------------------------------					
*
	END
