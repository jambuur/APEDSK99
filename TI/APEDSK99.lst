Asm994a TMS99000 Assembler - v3.010

                * Asm994a Generated Register Equates
                *
      0000 0000 R0      EQU     0 
      0000 0001 R1      EQU     1 
      0000 0002 R2      EQU     2 
      0000 0003 R3      EQU     3 
      0000 0004 R4      EQU     4 
      0000 0005 R5      EQU     5 
      0000 0006 R6      EQU     6 
      0000 0007 R7      EQU     7 
      0000 0008 R8      EQU     8 
      0000 0009 R9      EQU     9 
      0000 000A R10     EQU     10
      0000 000B R11     EQU     11
      0000 000C R12     EQU     12
      0000 000D R13     EQU     13
      0000 000E R14     EQU     14
      0000 000F R15     EQU     15
                *
   1            *===============================================================================================================
   2            * TI DISK CONTROLLER ROM   >4000-5FFF
   3            * 
   4            * initial commented disassembly by Thierry Nouspikel
   5            * (see http://www.unige.ch/medecine/nouspikel/ti99/titechpages.htm)
   6            *
   7            * and
   8            * 
   9            * Monty Schmidt's book: TI Technical Drive
  10            *
  11            * adapted for APEDSK99 by Jochen Buur
  12            * github.com/jambuur/APEDSK99
  13            *
  14            * v12r: support for Double Density / 80 tracks (max 1440 AU's)
  15            *================================================================================================================
  16  0000 5FB4 DSKPRM  EQU     >5FB4                   per DSKx: Mbyte #sectors, Lbyte #sectors, #sectors/track, #tracks, #sides
  17  0000 5FC6 CALLST  EQU     >5FC6                   CALL() execution status: finished, still active, error
  18  0000 5FC7 LSTDRV  EQU     >5FC7                   remember last drive accessed for LDSK without argument
  19  0000 5FC8 CALLBF  EQU     >5FC8                   2-way buffer for TI BASIC CALL's (1 screen line, 32 characters)
  20  0000 5FE8 ACOMND  EQU     >5FE8                   APEDSK99-specific Command register
  21  0000 5FE9 ASUBCM  EQU     >5FE9                   APEDSK99-specific SubCommand register
  22  0000 5FEA RDINT   EQU     >5FEA                   issue read interrupt
  23  0000 5FEE CRUWRI  EQU     >5FEE                   emulated 8 CRU output bits
  24  0000 5FF0 RSTAT   EQU     >5FF0                   read FD1771 Status register
  25  0000 5FF6 RDATA   EQU     >5FF6                   read FD1771 Data register
  26  0000 5FF8 WCOMND  EQU     >5FF8                   write FD1771 Command register
  27  0000 5FFC WSECTR  EQU     >5FFC                   write FD1771 Sector register
  28  0000 5FFE WDATA   EQU     >5FFE                   write FD1771 Data register
  29            *
  30  0000 164E XML14   EQU     >164E                   ROM address for XML >14
  31  0000 15D6 XML16   EQU     >15D6                   ROM address for XML >16
  32            *
  33  0000 4409 XMLBC   EQU     >4409                   GROM address for XML >BC 
  34  0000 A018 RTNBC   EQU     >A018                   return address for XML >BC in high memory expansion
  35            *
  36  0000 006A GPLINT  EQU     >006A                   jump to GROM interpreter for SCROLL / HONK
  37  0000 2244 XMLRTN  EQU     >2244                   jump to GROM interpreter for RTN (after executing XML >14 / >16 routine)
  38  0000 56CD SCROLL  EQU     >56CD                   GROM address for scroll routine
  39  0000 0036 HONK    EQU     >0036                   GROM address for bad sound / HONK routine
  40            *
  41                    AORG    >4000                   DSR memory block
  42            *
  43  4000 AA           BYTE    >AA                     standard header mark
  44  4001 02           BYTE    >02                     version 2
  45  4002 0000         DATA    >0000                   no programs
  46  4004 40FC         DATA    PWRUP                   power-up chain ptr
  47  4006 0000         DATA    >0000                   programs chain ptr (none)
  48  4008 4102         DATA    DSR01                   DSR chain ptr
  49  400A 4010         DATA    SUB01                   subprograms chain ptr
  50  400C 0000         DATA    >0000                   ISR chain ptr (none)
  51  400E 0000         DATA    >0000                   
  52            *
  53  4010 4016 SUB01   DATA    SUB02                   link to next subprogram
  54  4012 5820         DATA    ESUB01                  address of that one
  55  4014 0110         DATA    >0110                   subprogram name: >10 (sector R/W)
  56  4016 401C SUB02   DATA    SUB03                   
  57  4018 5830         DATA    ESUB02                  
  58  401A 0111         DATA    >0111                   subprogram >11 (format disk)
  59  401C 4022 SUB03   DATA    SUB04                   
  60  401E 583A         DATA    ESUB03                  
  61  4020 0112         DATA    >0112                   subprogram >12 (file un/protect)
  62  4022 4028 SUB04   DATA    SUB05                   
  63  4024 5894         DATA    ESUB04                  
  64  4026 0113 NTPFAT  DATA    >0113                   subprogram >13 (file rename); doubles as FAT update flag
  65            *
  66  4028 402E SUB05   DATA    SUB06                   
  67  402A 5960         DATA    ESUB05                  
  68  402C 0114         DATA    >0114                   subprogram >14 (file direct input)              
  69  402E 4034 SUB06   DATA    SUB07                   
  70  4030 59D0         DATA    ESUB06                  
  71  4032 0115         DATA    >0115                   subprogram >15 (file direct output)
  72  4034 403A SUB07   DATA    SUB08                   
  73  4036 5A96         DATA    ESUB07                  
  74  4038 0116         DATA    >0116                   subprogram >16 (number of files)
  75  403A 4052 SUB08   DATA    SUB09                   
  76  403C 5A42         DATA    ESUB08                  
  77  403E 05           BYTE    >05                     
  78  403F 4649         TEXT    'FILES'                 same as >16, called from Basic
  78  4041 4C45  
  78  4043 53    
  79            *
  80  4044 0400 PATTBL  DATA    >0400                   TI BASIC VDP RAM address for Pattern Table
  81  4046 7631 AVERSN  TEXT    'v12r'                  APEDSK99 version string (ARST)
  81  4048 3272  
  82            *
  83  404A 0000 XBASRT  DATA    >0000                   CALL LINK return address (Extended Basic)
  84  404C 5D3A XBJUMP  DATA    XBUSTR                  EXBAS PDSK / UDSK/ LDSK entry point
  85  404E 5DEE         DATA    A9909                   EXBAS MDSK / NDSK / RDSK / FGET / FPUT / ADSR / CDIR entry point
  86  4050 5CC2         DATA    NOPRM2                  EXBAS SMAP / LDIR / AHLP / ACHR / ARST / TIME / ACFG entry point
  87            *
  88  4052 405C SUB09   DATA    SUB10
  89  4054 5C14         DATA    PDSK
  90  4056 04           BYTE    >04
  91  4057 5044         TEXT    'PDSK'                  Protect DSKx (apply adhesive tab)
  91  4059 534B  
  92  405B 0000         EVEN
  93  405C 4066 SUB10   DATA    SUB11                   
  94  405E 5C1A         DATA    UDSK
  95  4060 04           BYTE    >04
  96  4061 5544         TEXT    'UDSK'                  Un-protect DSKx (remove adhesive tab)
  96  4063 534B  
  97  4065 0000         EVEN
  98  4066 4070 SUB11   DATA    SUB12
  99  4068 5C20         DATA    LDSK
 100  406A 04           BYTE    >04
 101  406B 4C44         TEXT    'LDSK'                  List files on DSKx
 101  406D 534B  
 102  406F 0000         EVEN
 103  4070 407A SUB12   DATA    SUB13
 104  4072 5C26         DATA    MDSK
 105  4074 04           BYTE    >04
 106  4075 4D44         TEXT    'MDSK'                  Map DOAD to DSKx
 106  4077 534B  
 107  4079 0000         EVEN
 108  407A 4084 SUB13   DATA    SUB14
 109  407C 5C2C         DATA    NDSK
 110  407E 04           BYTE    >04
 111  407F 4E44         TEXT    'NDSK'                  reName mapped DSKx
 111  4081 534B  
 112  4083 0000         EVEN
 113  4084 408E SUB14   DATA    SUB15
 114  4086 5C32         DATA    RDSK
 115  4088 04           BYTE    >04
 116  4089 5244         TEXT    'RDSK'                  Remove DOAD from SD card
 116  408B 534B  
 117  408D 0000         EVEN
 118  408E 4098 SUB15   DATA    SUB16
 119  4090 5C38         DATA    FGET
 120  4092 04           BYTE    >04
 121  4093 4647         TEXT    'FGET'                  Load DOAD from FTP server
 121  4095 4554  
 122  4097 0000         EVEN
 123  4098 40A2 SUB16   DATA    SUB17
 124  409A 5C3E         DATA    FPUT
 125  409C 04           BYTE    >04
 126  409D 4650         TEXT    'FPUT'                  Save DOAD to FTP server
 126  409F 5554  
 127  40A1 0000         EVEN
 128  40A2 40AC SUB17   DATA    SUB18
 129  40A4 5C44         DATA    ADSR
 130  40A6 04           BYTE    >04
 131  40A7 4144         TEXT    'ADSR'                  APEDSK99 DSR load / initialise / set default
 131  40A9 5352  
 132  40AB 0000         EVEN
 133  40AC 40B6 SUB18   DATA    SUB19
 134  40AE 5C4A         DATA    CDIR
 135  40B0 04           BYTE    >04
 136  40B1 4344         TEXT    'CDIR'                  Change working /Folder
 136  40B3 4952  
 137  40B5 0000         EVEN
 138  40B6 40C0 SUB19   DATA    SUB20
 139  40B8 5C50         DATA    SMAP
 140  40BA 04           BYTE    >04
 141  40BB 534D         TEXT    'SMAP'                  Show DOAD mappings for DSK[1-3] + available working /Folders
 141  40BD 4150  
 142  40BF 0000         EVEN
 143  40C0 40CA SUB20   DATA    SUB21
 144  40C2 5C56         DATA    LDIR
 145  40C4 04           BYTE    >04
 146  40C5 4C44         TEXT    'LDIR'                  List DOAD files on SD card
 146  40C7 4952  
 147  40C9 0000         EVEN
 148  40CA 40D4 SUB21   DATA    SUB22
 149  40CC 5C5C         DATA    AHLP
 150  40CE 04           BYTE    >04
 151  40CF 4148         TEXT    'AHLP'                  APEDSK99 CALL help screen
 151  40D1 4C50  
 152  40D3 0000         EVEN
 153  40D4 40DE SUB22   DATA    SUB23
 154  40D6 5C62         DATA    ACHR
 155  40D8 04           BYTE    >04
 156  40D9 4143         TEXT    'ACHR'                  Load real lower case characters
 156  40DB 4852  
 157  40DD 0000         EVEN
 158  40DE 40E8 SUB23   DATA    SUB24
 159  40E0 5C68         DATA    ARST
 160  40E2 04           BYTE    >04
 161  40E3 4152         TEXT    'ARST'                  APEDSK99 Reset
 161  40E5 5354  
 162  40E7 0000         EVEN
 163  40E8 40F2 SUB24   DATA    SUB25
 164  40EA 5C6E         DATA    TIME
 165  40EC 04           BYTE    >04
 166  40ED 5449         TEXT    'TIME'                  NTP date/time display / assign to NTP$
 166  40EF 4D45  
 167  40F1 0000         EVEN
 168  40F2 0000 SUB25   DATA    >0000                   APEDSK99 configuration (IP address etc)
 169  40F4 5C74         DATA    ACFG
 170  40F6 04           BYTE    >04
 171  40F7 4143         TEXT    'ACFG'
 171  40F9 4647  
 172  40FB 0000         EVEN
 173            *
 174  40FC 0000 PWRUP   DATA    >0000                   power-up chain (no more)
 175  40FE 4128         DATA    EPWRUP                  address of power-up routine
 176  4100 0000         DATA    >0000                   no name
 177            *                                       
 178  4102 410A DSR01   DATA    DSR02                   DSR chain
 179  4104 4D36         DATA    EDSR01                  address of DSR
 180  4106 03           BYTE    >03                     name size
 181  4107 4453         TEXT    'DSK'                   DSR name
 181  4109 4B    
 182  410A 4114 DSR02   DATA    DSR03                   
 183  410C 4D44         DATA    EDSR02                  
 184  410E 04           BYTE    >04                     
 185  410F 4453         TEXT    'DSK1'                  
 185  4111 4B31  
 186  4113 0000         EVEN                            
 187  4114 411E DSR03   DATA    DSR04                   
 188  4116 4D4A         DATA    EDSR03                  
 189  4118 04           BYTE    >04                     
 190  4119 4453         TEXT    'DSK2'                  
 190  411B 4B32  
 191  411D 0000         EVEN                            
 192  411E 0000 DSR04   DATA    >0000                   no more
 193  4120 4D50         DATA    EDSR04                  
 194  4122 04           BYTE    >04                     
 195  4123 4453         TEXT    'DSK3'                  
 195  4125 4B33  
 196  4127 0000         EVEN            
 197            *
 198            *=====================================
 199            * Power-up routine
 200            *=====================================                                          
 201            *
 202  4128 028C EPWRUP  CI      R12,>1000               Dhr. F.G. Kaal check: are we powering up 1st CRU (>1000) peripheral?
 202  412A 1000  
 203  412C 1633         JNE     NOCRU                   nope; return
 204            *
 205  412E C1CB         MOV     R11,R7                  yes; save return address
 206  4130 02A9         STWP    R9                      get workspace (should be >83E0)
 207  4132 0229         AI      R9,-224                 point to top of scratch-pad mem (>8300)
 207  4134 FF20  
 208  4136 C0A9         MOV     @>0070(R9),R2           highest free address in vdp mem (>8370)
 208  4138 0070  
 209  413A C002         MOV     R2,R0                   save it
 210  413C 0222         AI      R2,-2088                we'll need >828 bytes
 210  413E F7D8  
 211  4140 CA42         MOV     R2,@>0070(R9)           update address
 211  4142 0070  
 212  4144 0582         INC     R2
 213  4146 06A0         BL      @VDPWRI                 set VDP address
 213  4148 4320  
 214  414A 0201         LI      R1,2088                 
 214  414C 0828  
 215  414E 04EF H001    CLR     @-2(R15)                clear these >828 bytes
 215  4150 FFFE  
 216  4152 0601         DEC     R1                      
 217  4154 16FC         JNE     H001                    
 218  4156 06A0         BL      @VDPWRI                 set VDP address (same)
 218  4158 4320  
 219  415A 0203         LI      R3,>AA03                        
 219  415C AA03  
 220  415E DBC3         MOVB    R3,@-2(R15)             write buffer ID mark
 220  4160 FFFE  
 221  4162 1000         NOP                             
 222  4164 DBC0         MOVB    R0,@-2(R15)             write old highest free address
 222  4166 FFFE  
 223  4168 06C0         SWPB    R0
 224  416A DBC0         MOVB    R0,@-2(R15)
 224  416C FFFE  
 225  416E 1000         NOP                             
 226  4170 DBCC         MOVB    R12,@-2(R15)            write CRU address (>1000 for APEDSK99)
 226  4172 FFFE  
 227  4174 06C3         SWPB    R3                      
 228  4176 DBC3         MOVB    R3,@-2(R15)             write number of files (3)
 228  4178 FFFE  
 229  417A 06A0         BL      @PRPRTN                 preparation routine
 229  417C 4410  
 230  417E 06A0         BL      @CALSUB                 call subroutine
 230  4180 4342  
 231  4182 42B0         DATA    RSTDRV                  reset all drives
 232  4184 04E9         CLR     @>0054(R9)              name length = 0 for power-up
 232  4186 0054  
 233  4188 0429         BLWP    @>005A(R9)              retrieve R7 (saved by PRPRTN)
 233  418A 005A  
 234  418C 0011         DATA    >0011                   put it into R11
 235  418E CA60         MOV     @K001,@>006C(R9)        ???
 235  4190 4196  
 235  4192 006C  
 236  4194 045B NOCRU   B       *R11                    return
 237            *                               
 238  4196 0404 K001    DATA    >0404                   
 239            *
 240            *---------------------------------------
 241            * Sector read/write
 242            *---------------------------------------                                        
 243            *
 244  4198 DA60 SECRW1  MOVB    @K002,@>0050(R9)        APEDSK99: no error
 244  419A 433C  
 244  419C 0050  
 245  419E 06A0         BL      @SELDRV                 select drive
 245  41A0 4282  
 246            *
 247  41A2 C069         MOV     @>004A(R9),R1           sector #
 247  41A4 004A  
 248  41A6 0281         CI      R1,>05A0                APEDSK99: max 1440 (DS/DD/40T or DS/SD/80T)?
 248  41A8 05A0  
 249  41AA 1A03         JL      H002                    APEDSK99: yes; sector# within range
 250  41AC 06A0         BL      @ERROR1                 APEDSK99: no -> "device error"
 250  41AE 42DE  
 251  41B0 0600         DATA    >0600   
 252            
 253  41B2 C801 H002    MOV     R1,@WSECTR              APEDSK99: sector# to FD1771 write sector register (16bits)
 253  41B4 5FFC  
 254            *
 255  41B6 C0A9         MOV     @>004E(R9),R2           data buffer address
 255  41B8 004E  
 256  41BA D029         MOVB    @>004D(R9),R0           read or write ?
 256  41BC 004D  
 257  41BE 1312         JEQ     H005                    write
 258  41C0 06A0         BL      @VDPWRI                 read FD = write to VDP buffer
 258  41C2 4320  
 259  41C4 0206         LI      R6,256                  
 259  41C6 0100  
 260  41C8 C806         MOV     R6,@RDINT               APEDSK99: interrupt Arduino for read operation 
 260  41CA 5FEA  
 261  41CC 06A0         BL      @SNDCMD                 send command
 261  41CE 42F4  
 262  41D0 8800         DATA    >8800                   APEDSK99: read sector
 263            *
 264  41D2 D020 H003    MOVB    @RDATA,R0               get 1 byte from FDC
 264  41D4 5FF6  
 265  41D6 DBC0         MOVB    R0,@-2(R15)             save it to VDP
 265  41D8 FFFE  
 266  41DA 0620         DEC     @RDINT                  APEDSK99: interrupt Arduino for read operation
 266  41DC 5FEA  
 267  41DE 16F9         JNE     H003                    next byte
 268            *
 269  41E0 0460 H004    B       @RTURN1                 return
 269  41E2 4360  
 270            
 271            *       
 272  41E4 06A0 H005    BL      @VDPRD                  write to FD = read from VDP buffer
 272  41E6 432A  
 273  41E8 0206         LI      R6,256                  256 bytes to write
 273  41EA 0100  
 274            *
 275            * APEDSK99: the first byte to be written needs to be in the data register before the write command is given
 276            *
 277  41EC D02F         MOVB    @-1026(R15),R0          APEDSK99: get a byte from data buffer
 277  41EE FBFE  
 278  41F0 D800         MOVB    R0,@WDATA               APEDSK99: write first byte to data register
 278  41F2 5FFE  
 279  41F4 06A0         BL      @SNDCMD                 send command
 279  41F6 42F4  
 280  41F8 A800         DATA    >A800                   APEDSK99: write sector
 281            *
 282  41FA D02F H006    MOVB    @-1026(R15),R0          get a byte from data buffer
 282  41FC FBFE  
 283  41FE D800         MOVB    R0,@WDATA               pass it to data register
 283  4200 5FFE  
 284  4202 0606         DEC     R6                      
 285  4204 16FA         JNE     H006                    next byte
 286            *
 287  4206 06A0         BL      @WTCPT1                 APEDSK99: check for Write Protect
 287  4208 4274  
 288  420A 0A20         SLA     R0,2                    APEDSK99: WP bit in Carry
 289  420C 1801         JOC     ERROR3                  write protect: error 34
 290  420E 10E8         JMP     H004                    APEDSK99: no need to verify             
 291            *                                       
 292  4210 06A0 ERROR3  BL      @ERROR1                 error 34 (Write Protect)
 292  4212 42DE  
 293  4214 3400         DATA    >3400                   
 294            *
 295            *--------------------------------------------------------------------
 296            * Format disk - APEDSK99: we don't do any physical formatting anymore
 297            *--------------------------------------------------------------------
 298            *
 299  4216 04E9 FMTDSK  CLR     @>004A(R9)              called by subprogram >11
 299  4218 004A  
 300            *                                       
 301  421A 5A60         SZCB    @K004,@>004C(R9)        clear DSR version flags
 301  421C 433E  
 301  421E 004C  
 302            *
 303  4220 06A0         BL      @SELDRV                 select drive
 303  4222 4282  
 304            *
 305  4224 D029         MOVB    @>004D(R9),R0           APEDSK99: get # of tracks
 305  4226 004D  
 306  4228 9829         CB      @>0051(R9),@K005        APEDSK99: double sided?
 306  422A 0051  
 306  422C 433F  
 307  422E 1601         JNE     H007                    APEDSK99: single-side
 308            *
 309  4230 0A10         SLA     R0,1                    times two (since 2 sides)
 310            *
 311  4232 0980 H007    SRL     R0,8                    APEDSK99: make it a byte
 312  4234 0206         LI      R6,9                    APEDSK99: start with single density
 312  4236 0009  
 313  4238 9829         CB      @>0050(R9),@K005        APEDSK99: double density required?
 313  423A 0050  
 313  423C 433F  
 314  423E 1601         JNE     H008                    APEDSK99: no, leave R6 alone
 315  4240 0A16         SLA     R6,1                    APEDSK99: yes, R6*2
 316            *               
 317  4242 3806 H008    MPY     R6,R0                   APEDSK99: #sectors/track * #tracks
 318  4244 0281         CI      R1,>05A0                APEDSK99: >1440 sectors?
 318  4246 05A0  
 319  4248 1203         JLE     H009                    APEDSK99: nope; continue
 320  424A 06A0         BL      @ERROR1                 APEDSK99: yes; "device error"
 320  424C 42DE  
 321  424E 0600         DATA    >0600   
 322            *
 323  4250 CA41 H009    MOV     R1,@>004A(R9)           pass total # of sectors per disk
 323  4252 004A  
 324  4254 06C6         SWPB    R6
 325  4256 DA46         MOVB    R6,@>004D(R9)           APEDSK99: pass # of sectors per track
 325  4258 004D  
 326  425A DA60         MOVB    @K002,@>0050(R9)        no error
 326  425C 433C  
 326  425E 0050  
 327            *
 328  4260 06A0         BL      @NTPDT                  APEDSK99: update DOAD FAT time/date
 328  4262 5F5E  
 329            *
 330  4264 0460         B       @RTURN1                 return
 330  4266 4360  
 331            *                                       
 332                                                    
 333  4268 C1BB VDPRPW  MOV     *R11+,R6                VDP repeated write
 334  426A DBC0 H010    MOVB    R0,@-2(R15)
 334  426C FFFE  
 335  426E 0606         DEC     R6                      byte in R0
 336  4270 16FC         JNE     H010                    number of repeats in data word
 337  4272 045B         B       *R11                    
 338            *
 339  4274 D020 WTCPT1  MOVB    @RSTAT,R0               get status. APEDSK99: Not Ready >80 / Write Protect >40
 339  4276 5FF0  
 340  4278 1101         JLT     ERROR4                  drive not ready. APEDSK99: Not Ready set when DOAD file is unavailable
 341  427A 045B         B       *R11                    
 342            *
 343  427C 06A0 ERROR4  BL      @ERROR1                 exit with error code 6, reseting all drives
 343  427E 42DE  
 344  4280 0600         DATA    >0600                   
 345            *                                       
 346  4282 C1CB SELDRV  MOV     R11,R7                  select a drive
 347  4284 C0A9         MOV     @>0058(R9),R2
 347  4286 0058  
 348  4288 0222         AI      R2,-10                  point to drive info
 348  428A FFF6  
 349  428C 04C0         CLR     R0                      
 350  428E D029         MOVB    @>004C(R9),R0           get drive #
 350  4290 004C  
 351  4292 130B         JEQ     H011                    can't be >00: error #7
 352  4294 0280         CI      R0,>0300                        
 352  4296 0300  
 353  4298 1B08         JH      H011                    drive number can't be higher than 3: error #7
 354  429A 06A0         BL      @VDPWRI                 set VDP to write, address in R2
 354  429C 4320  
 355  429E DBC0         MOVB    R0,@-2(R15)             modify last drive accessed              
 355  42A0 FFFE  
 356            *
 357  42A2 0A10         SLA     R0,1                    APEDSK99: bit 0 is side select, 1-3 is drive #
 358  42A4 D800         MOVB    R0,@CRUWRI              APEDSK99: select drive
 358  42A6 5FEE  
 359  42A8 0457         B       *R7                     
 360            *                                       
 361  42AA 06A0 H011    BL      @ERROR1                 exit with error #7
 361  42AC 42DE  
 362  42AE 0700         DATA    >0700                   
 363            *                                       
 364  42B0 5820 RSTDRV  SZCB    @DSDRVS,@CRUWRI         APEDSK99: reset all drives including side
 364  42B2 4340  
 364  42B4 5FEE  
 365  42B6 D820         MOVB    @K013,@WCOMND           send Force Interrupt with no interrupt flag set
 365  42B8 42EE  
 365  42BA 5FF8  
 366  42BC C0A9         MOV     @>0058(R9),R2           ptr to VIB buffer
 366  42BE 0058  
 367  42C0 0222         AI      R2,-10                  now points to drive info buffer
 367  42C2 FFF6  
 368  42C4 06A0         BL      @VDPWRI                 set VDP to write to address in R2
 368  42C6 4320  
 369  42C8 0200         LI      R0,4                    
 369  42CA 0004  
 370  42CC DBC0 H012    MOVB    R0,@-2(R15)             write four >00 (i.e. clear drive info)
 370  42CE FFFE  
 371  42D0 0600         DEC     R0                      
 372  42D2 16FC         JNE     H012                    
 373  42D4 DA60         MOVB    @K002,@>0050(R9)        no error
 373  42D6 433C  
 373  42D8 0050  
 374  42DA 0460         B       @RTURN1                 get return address from stack
 374  42DC 4360  
 375            *                                       
 376  42DE C01B ERROR1  MOV     *R11,R0                 exit with error
 377  42E0 DA40         MOVB    R0,@>0050(R9)           place err code in >8350
 377  42E2 0050  
 378  42E4 0280         CI      R0,>0600                check if device error
 378  42E6 0600  
 379  42E8 1603         JNE     H013                    no: exit
 380  42EA 06A0         BL      @SNDCMD                 yes: reset drives
 380  42EC 42F4  
 381            *
 382  42EE 0000 K013    DATA    >0000                   APEDSK99: send Restore command
 383            *
 384  42F0 0460 H013    B       @RTURN1                 return to caller (address from stack)
 384  42F2 4360  
 385            *                               
 386  42F4 C03B SNDCMD  MOV     *R11+,R0                send command to FDC from data word
 387  42F6 D800         MOVB    R0,@WCOMND              send command
 387  42F8 5FF8  
 388  42FA 045B         B       *R11                    
 389            *                                       
 390  42FC 04C0 LASTRK  CLR     R0                      get last track # for this drive
 391  42FE D029         MOVB    @>004C(R9),R0           get drive #
 391  4300 004C  
 392  4302 130B         JEQ     H014                    can't be 0
 393  4304 06C0         SWPB    R0                      
 394  4306 0280         CI      R0,3                    
 394  4308 0003  
 395  430A 1B07         JH      H014                    can't be higher than 3
 396  430C C0A9         MOV     @>0058(R9),R2                   
 396  430E 0058  
 397  4310 0222         AI      R2,-10                  point to last drive accessed
 397  4312 FFF6  
 398  4314 A080         A       R0,R2                   point to last track for this drive
 399  4316 0460         B       @VDPRD                  prepare VDP to read from address in R2
 399  4318 432A  
 400            *                                       
 401  431A 06A0 H014    BL      @ERROR1                 exit with error code 7
 401  431C 42DE  
 402  431E 0700         DATA    >0700                   
 403            *                                       
 404  4320 0262 VDPWRI  ORI     R2,>4000                set VDP address to write
 404  4322 4000  
 405  4324 0242         ANDI    R2,>7FFF                not to a register
 405  4326 7FFF  
 406  4328 1002         JMP     H015                    
 407  432A 0242 VDPRD   ANDI    R2,>3FFF                set VDP address to read
 407  432C 3FFF  
 408  432E 06C2 H015    SWPB    R2                      
 409  4330 D7C2         MOVB    R2,*R15                 write address
 410  4332 06C2         SWPB    R2                      
 411  4334 D7C2         MOVB    R2,*R15                 
 412  4336 0242         ANDI    R2,>3FFF                        
 412  4338 3FFF  
 413  433A 045B         B       *R11                    
 414            *                                       
 415  433C 00   K002    BYTE    >00                     
 416  433D 09   K007    BYTE    >09                                             
 417  433E F0   K004    BYTE    >F0                     
 418  433F 02   K005    BYTE    2
 419  4340 0F   DSDRVS  BYTE    >0F                     APEDSK99: deselect all drives + side (reset CRUWRI bits 7,6,5 and 4)                    
 420            *
 421  4341 0000         EVEN
 422            *                               
 423  4342 0669 CALSUB  DECT    @>0066(R9)              call subroutine, return address in stack
 423  4344 0066  
 424  4346 C2A9         MOV     @>0066(R9),R10
 424  4348 0066  
 425  434A 0429         BLWP    @>005A(R9)              set VDP to write to address in R10
 425  434C 005A  
 426  434E 0143         DATA    >0143                   
 427  4350 C2BB         MOV     *R11+,R10               get next data word
 428  4352 06CB         SWPB    R11                     write return address to VDP
 429  4354 DBCB         MOVB    R11,@-2(R15)                    
 429  4356 FFFE  
 430  4358 06CB         SWPB    R11                     
 431  435A DBCB         MOVB    R11,@-2(R15)                    
 431  435C FFFE  
 432  435E 045A         B       *R10                    branch to address in data word
 433            *                               
 434  4360 C2E9 RTURN1  MOV     @>0066(R9),R11          get return address from VDP stack
 434  4362 0066  
 435  4364 0429         BLWP    @>005A(R9)              
 435  4366 005A  
 436  4368 0162         DATA    >0162                   set VDP to read from address in R11
 437  436A D2EF         MOVB    @-1026(R15),R11                 
 437  436C FBFE  
 438  436E 06CB         SWPB    R11                     
 439  4370 D2EF         MOVB    @-1026(R15),R11                 
 439  4372 FBFE  
 440  4374 05E9         INCT    @>0066(R9)                      
 440  4376 0066  
 441  4378 045B         B       *R11                    
 442            *
 443            *---------------------------------------
 444            * Custom routines, dealing with VDP memory
 445            * Format is >pppr where r is routine number (0-3)
 446            * and ppp contains parameters
 447            * The workspace it >8300. Called by BLWP @>005A(9).
 448            *---------------------------------------                                        
 449            *
 450  437A C28D ECUSTM  MOV     R13,R10                 save wregs ptr
 451  437C C23E         MOV     *R14+,R8                get next data word
 452  437E C248         MOV     R8,R9                   save it
 453  4380 0949         SRL     R9,4                    keep parameter
 454  4382 0248         ANDI    R8,3                    four possible operations
 454  4384 0003  
 455  4386 A208         A       R8,R8                   make it a word ptr
 456  4388 C2ED         MOV     @>001E(R13),R11         get old R15, i.e. VDP port (>8C02)
 456  438A 001E  
 457  438C C228         MOV     @VECRTN(R8),R8          get vector for operation
 457  438E 4392  
 458  4390 0458         B       *R8                     branch to it
 459            *                                       
 460  4392 439A VECRTN  DATA    SVRVDP                  save registers to VDP stack
 461  4394 43C6         DATA    RVRVDP                  retrieve registers
 462  4396 43FC         DATA    SVDPRD                  set VDP address to read
 463  4398 43F2         DATA    SVDPWR                  set VDP address to write
 464            *                                       
 465  439A 022A SVRVDP  AI      R10,22                  0: save registers in VDP mem
 465  439C 0016  
 466  439E 0919 H016    SRL     R9,1                    start with R12
 467  43A0 1710         JNC     H017                    bits in >ppp tell which register to save (R0-R11)
 468  43A2 064C         DECT    R12                     previous address in VDP stack (grows down)
 469  43A4 C21A         MOV     *R10,R8                 get register contents
 470  43A6 06CC         SWPB    R12                     set VDP address to write
 471  43A8 D6CC         MOVB    R12,*R11                R12 is >8366: VDP stack ptr
 472  43AA 06CC         SWPB    R12                     
 473  43AC 026C         ORI     R12,>4000                       
 473  43AE 4000  
 474  43B0 D6CC         MOVB    R12,*R11                        
 475  43B2 06C8         SWPB    R8                      save register to VDP mem
 476  43B4 DAC8         MOVB    R8,@-2(R11)                     
 476  43B6 FFFE  
 477  43B8 06C8         SWPB    R8                      
 478  43BA DAC8         MOVB    R8,@-2(R11)                     
 478  43BC FFFE  
 479  43BE C249         MOV     R9,R9                   more to come?
 480  43C0 1317         JEQ     H020                    no:return
 481  43C2 064A H017    DECT    R10                     point to previous register
 482  43C4 10EC         JMP     H016                    
 483            *                               
 484  43C6 0A49 RVRVDP  SLA     R9,4                    1: retrieve registers from VDP mem
 485  43C8 0A19 H018    SLA     R9,1                    each bit tells whether to load
 486  43CA 1710         JNC     H019                    don't retrieve that one
 487  43CC 06CC         SWPB    R12                     set VDP address to read
 488  43CE D6CC         MOVB    R12,*R11                R12 is >8366: VDP stack ptr
 489  43D0 06CC         SWPB    R12                     
 490  43D2 024C         ANDI    R12,>3FFF                       
 490  43D4 3FFF  
 491  43D6 D6CC         MOVB    R12,*R11                        
 492  43D8 1000         NOP                             
 493  43DA D22B         MOVB    @-1026(R11),R8          get a 2-byte value from VDP
 493  43DC FBFE  
 494  43DE 06C8         SWPB    R8                      
 495  43E0 D22B         MOVB    @-1026(R11),R8                  
 495  43E2 FBFE  
 496  43E4 C688         MOV     R8,*R10                 save it to register
 497  43E6 05CC         INCT    R12                     increment ptr (stack grows downwards)
 498  43E8 C249         MOV     R9,R9                   more to come?
 499  43EA 1302         JEQ     H020                    no: return
 500  43EC 05CA H019    INCT    R10                     next register
 501  43EE 10EC         JMP     H018                    
 502  43F0 0380 H020    RTWP                            
 503            *                                       
 504  43F2 A24D SVDPWR  A       R13,R9                  2: set VDP for a write
 505  43F4 C219         MOV     *R9,R8                  
 506  43F6 0268         ORI     R8,>4000                get address from reg in >..p2 (*2)
 506  43F8 4000  
 507  43FA 1004         JMP     H021                    
 508            *                                       
 509  43FC A24D SVDPRD  A       R13,R9                  3: set VDP for a read
 510  43FE C219         MOV     *R9,R8
 511  4400 0248         ANDI    R8,>3FFF                get register from reg in >..p3 (*2)
 511  4402 3FFF  
 512  4404 06C8 H021    SWPB    R8                      set VDP address
 513  4406 D6C8         MOVB    R8,*R11                 
 514  4408 06C8         SWPB    R8                      
 515  440A D6C8         MOVB    R8,*R11                 
 516  440C 0380         RTWP                            
 517            *
 518            *---------------------------------------
 519            * Preparation subroutine
 520            * Sets up the 4 custom subroutines
 521            * Gets a few pointers to VDP buffers
 522            *  >8358: copy of VIB  >8366: VDP stack ptr (grows down from drive info)
 523            *  >8354: PAB          >8356: ptr to end-of-buffer
 524            *---------------------------------------                                        
 525            *
 526  440E 05C7 PRPFDO  INCT    R7                      stop scanning upon return
 527  4410 C28B PRPRTN  MOV     R11,R10                 save return address
 528  4412 02A9         STWP    R9                      get workspace (should be >83E0)
 529  4414 0229         AI      R9,-224                 top of scratch/pad mem (>8300)
 529  4416 FF20  
 530  4418 0200         LI      R0,ECUSTM               entry to 4 custom routines
 530  441A 437A  
 531  441C CA40         MOV     R0,@>005C(R9)           put it in >835C
 531  441E 005C  
 532  4420 C009         MOV     R9,R0                   
 533  4422 0220         AI      R0,>004E                workspace for these four (>834E)
 533  4424 004E  
 534  4426 CA40         MOV     R0,@>005A(R9)           put it in >835A
 534  4428 005A  
 535            *                                       
 536  442A C229         MOV     @>0070(R9),R8           highest free address in VDP mem
 536  442C 0070  
 537  442E 05C8         INCT    R8                      point to end-of-buffer word
 538  4430 06A0         BL      @VDPR2B                 read 2 bytes from VDP address R8, into R0
 538  4432 4860  
 539  4434 C088         MOV     R8,R2                   save current R8
 540  4436 C200         MOV     R0,R8                   get end-of-buffer word
 541  4438 0228         AI      R8,-266                 yes: point to volume information block
 541  443A FEF6  
 542  443C CA48         MOV     R8,@>0058(R9)           save it in >8358
 542  443E 0058  
 543  4440 0228         AI      R8,-10                  point to disk drive info (drive #, last tracks)
 543  4442 FFF6  
 544  4444 CA48         MOV     R8,@>0066(R9)           save in >8366: VDP stack ptr (DECT before writing)
 544  4446 0066  
 545  4448 0429         BLWP    @>005A(R9)              save R7 (return address)
 545  444A 005A  
 546  444C 0100         DATA    >0100                   
 547  444E C1E9         MOV     @>0056(R9),R7           ptr to PAB: end of DSR name
 547  4450 0056  
 548  4452 C0C7         MOV     R7,R3                   save it
 549  4454 61E9         S       @>0054(R9),R7           start of DSR name
 549  4456 0054  
 550  4458 CA42         MOV     R2,@>0056(R9)           >8356: ptr to end-of-buffer word in VDP mem
 550  445A 0056  
 551  445C 0607         DEC     R7                      point to name length byte
 552  445E 04C2         CLR     R2                      
 553  4460 0429         BLWP    @>005A(R9)              set VDP to read from address in R2
 553  4462 005A  
 554  4464 00E2         DATA    >00E2                   
 555  4466 D0AF         MOVB    @-1026(R15),R2          get name length byte
 555  4468 FBFE  
 556  446A 06C2         SWPB    R2                      make it a word
 557  446C 60A9         S       @>0054(R9),R2           minus DSR name size: lenght of .parameters
 557  446E 0054  
 558  4470 0227         AI      R7,-9                   point to top of PAB
 558  4472 FFF7  
 559  4474 CA47         MOV     R7,@>0054(R9)           save it in >8354
 559  4476 0054  
 560  4478 045A         B       *R10                    
 561            *                               
 562  447A 06A0 CRFIL1  BL      @CALSUB                 create file
 562  447C 4342  
 563  447E 4AEC         DATA    FNDFDR                  find a FDR in disk
 564  4480 C104 CRFIL2  MOV     R4,R4                   found?
 565  4482 1604         JNE     CRFIL3                  no
 566  4484 06A0         BL      @CALSUB                 yes: delete old file
 566  4486 4342  
 567  4488 45C4         DATA    FFSVIB                  free file sector in VIB bitmap
 568  448A 1045         JMP     H024                    clear its FDR
 569            *                               
 570  448C 06A0 CRFIL3  BL      @INSFDR                 new file: insert a FDR in sector 1
 570  448E 47F4  
 571  4490 0701         SETO    R1                      
 572  4492 06A0         BL      @CALSUB                 call subroutine
 572  4494 4342  
 573  4496 4BE0         DATA    FFSBMP                  find a free sector in VIB bitmap
 574  4498 C000         MOV     R0,R0                   found?
 575  449A 1603         JNE     H022                    yes: # in R0
 576  449C 06A0         BL      @ERROR5                 no: update data, then return with error
 576  449E 495C  
 577  44A0 8000         DATA    >8000                   memory full (APEDSK99: doubles as subcommand flag)
 578            *                               
 579  44A2 0429 H022    BLWP    @>005A(R9)              set VDP to write
 579  44A4 005A  
 580  44A6 0103         DATA    >0103                   address in R8
 581  44A8 DBC0         MOVB    R0,@-2(R15)             write sector # for FDR in sector 1
 581  44AA FFFE  
 582  44AC 06C0         SWPB    R0                      
 583  44AE DBC0         MOVB    R0,@-2(R15)                     
 583  44B0 FFFE  
 584  44B2 06C0         SWPB    R0                      
 585  44B4 C069         MOV     @>0056(R9),R1           ptr to FDR in VDP buffers
 585  44B6 0056  
 586  44B8 0221         AI      R1,-4                   ptr to sector # for FDR
 586  44BA FFFC  
 587  44BC 0429         BLWP    @>005A(R9)              set VDP to write
 587  44BE 005A  
 588  44C0 0023         DATA    >0023                   address in R1
 589  44C2 DBC0         MOVB    R0,@-2(R15)             write sector # for FDR in VDP buffer
 589  44C4 FFFE  
 590  44C6 06C0         SWPB    R0                      
 591  44C8 DBC0         MOVB    R0,@-2(R15)                     
 591  44CA FFFE  
 592  44CC 0221         AI      R1,3                    ptr to drive #
 592  44CE 0003  
 593  44D0 0429         BLWP    @>005A(R9)              set VDP to write
 593  44D2 005A  
 594  44D4 0023         DATA    >0023                   address in R1
 595  44D6 DBC6         MOVB    R6,@-2(R15)             write drive # before FDR in VDP buffer
 595  44D8 FFFE  
 596  44DA 04C2         CLR     R2                      code for write
 597  44DC 0581         INC     R1                      
 598  44DE 06A0         BL      @CALSUB                 call subroutine
 598  44E0 4342  
 599  44E2 4A20         DATA    WRSEC1                  write sector 1
 600  44E4 C169         MOV     @>0058(R9),R5           ptr to VIB in VDP buffers
 600  44E6 0058  
 601  44E8 04C4         CLR     R4                      sector 0
 602  44EA 06A0         BL      @CALSUB                 call subroutine
 602  44EC 4342  
 603  44EE 4A38         DATA    RWSEC                   write VIB to sector 0
 604  44F0 C0C5         MOV     R5,R3                   copy filename from compare buffer to FDR
 605  44F2 0223         AI      R3,257                  ptr to file compare buffer
 605  44F4 0101  
 606  44F6 0202         LI      R2,10                   10 chars per filename
 606  44F8 000A  
 607  44FA 0429 H023    BLWP    @>005A(R9)              set VDP to read
 607  44FC 005A  
 608  44FE 0062         DATA    >0062                   address in R3
 609  4500 D02F         MOVB    @-1026(R15),R0          get 1 char
 609  4502 FBFE  
 610  4504 0583         INC     R3                      increment source ptr
 611  4506 0429         BLWP    @>005A(R9)              set VDP to write
 611  4508 005A  
 612  450A 0023         DATA    >0023                   address in R1
 613  450C DBC0         MOVB    R0,@-2(R15)             copy 1 char
 613  450E FFFE  
 614  4510 0581         INC     R1                      increment destination ptr
 615  4512 0602         DEC     R2                      # of chars in R2
 616  4514 16F2         JNE     H023                    next
 617            *
 618  4516 06A0 H024    BL      @NTPDT                  APEDSK99: update DOAD FAT time/date
 618  4518 5F5E  
 619            *
 620  451A C069         MOV     @>0056(R9),R1           FDR ptr
 620  451C 0056  
 621  451E 0221         AI      R1,10                   skip filename
 621  4520 000A  
 622  4522 0202         LI      R2,246                  remaining bytes in FDR
 622  4524 00F6  
 623  4526 0429         BLWP    @>005A(R9)              set VDP to write
 623  4528 005A  
 624  452A 0023         DATA    >0023                   address in R1
 625  452C DBC2 H025    MOVB    R2,@-2(R15)             write >00
 625  452E FFFE  
 626  4530 0602         DEC     R2                      clear remainder of new FDR
 627  4532 16FC         JNE     H025                    next byte
 628  4534 1010         JMP     H028                    write FDR to disk return to caller
 629            *                                       
 630  4536 C169 H026    MOV     @>0056(R9),R5           check if FDR must be updated
 630  4538 0056  
 631  453A 0429         BLWP    @>005A(R9)              set VDP to read
 631  453C 005A  
 632  453E 00A2         DATA    >00A2                   address in R5
 633  4540 D12F         MOVB    @-1026(R15),R4          get filename in file ctrl block
 633  4542 FBFE  
 634  4544 1101         JLT     H027                    flag: FDR was modified, update it
 635  4546 100A         JMP     H029                    
 636  4548 0244 H027    ANDI    R4,>7F00                clear flag bit
 636  454A 7F00  
 637  454C 0429         BLWP    @>005A(R9)              st VDP to write
 637  454E 005A  
 638  4550 00A3         DATA    >00A3                   address in R5
 639  4552 DBC4         MOVB    R4,@-2(R15)             write back filename without flag bit
 639  4554 FFFE  
 640  4556 04C2 H028    CLR     R2                      code for write
 641  4558 0460         B       @WRFDR                  write FDR to disk
 641  455A 4A2A  
 642  455C 0460 H029    B       @RTURN1                 return to caller
 642  455E 4360  
 643            *                               
 644  4560 06A0 UPDFDR  BL      @CALSUB                 update FDR + data
 644  4562 4342  
 645  4564 4580         DATA    UPDBF                   update data buffer if necessary
 646  4566 06A0         BL      @CALSUB                 call subroutine
 646  4568 4342  
 647  456A 4536         DATA    H026                    update FDR if necessary
 648  456C C169 CLRFBT  MOV     @>0056(R9),R5                   
 648  456E 0056  
 649  4570 04C6         CLR     R6                      
 650  4572 0429         BLWP    @>005A(R9)              set VDP to write
 650  4574 005A  
 651  4576 00A3         DATA    >00A3                   address in R5
 652  4578 DBC6         MOVB    R6,@-2(R15)             clr first byte of filename in FDR
 652  457A FFFE  
 653  457C 0460         B       @RWVIB                  
 653  457E 49BC  
 654            *                                       
 655  4580 C129 UPDBF   MOV     @>0056(R9),R4           check if data buffer must be updated
 655  4582 0056  
 656  4584 0604         DEC     R4                      
 657  4586 0429         BLWP    @>005A(R9)              set VDP to read
 657  4588 005A  
 658  458A 0082         DATA    >0082                   address in R4
 659  458C D06F         MOVB    @-1026(R15),R1          get drive #
 659  458E FBFE  
 660  4590 1101         JLT     H030                    flag: must be updated
 661  4592 1016         JMP     H031                    no need to update: return
 662  4594 0241 H030    ANDI    R1,>7F00                erase flag
 662  4596 7F00  
 663  4598 0429         BLWP    @>005A(R9)              set VDP to write
 663  459A 005A  
 664  459C 0083         DATA    >0083                   address in R4
 665  459E DBC1         MOVB    R1,@-2(R15)             write back drive # without flag
 665  45A0 FFFE  
 666  45A2 0224         AI      R4,-5                   point to current logical record offset
 666  45A4 FFFB  
 667  45A6 0429         BLWP    @>005A(R9)              set VDP to read
 667  45A8 005A  
 668  45AA 0082         DATA    >0082                   address in R4
 669  45AC D0EF         MOVB    @-1026(R15),R3          get current logical record offset
 669  45AE FBFE  
 670  45B0 06C3         SWPB    R3                      
 671  45B2 D0EF         MOVB    @-1026(R15),R3                  
 671  45B4 FBFE  
 672  45B6 06C3         SWPB    R3                      
 673  45B8 C1C4         MOV     R4,R7                   
 674  45BA 0227         AI      R7,262                  point to data buffer area
 674  45BC 0106  
 675  45BE 103A         JMP     WROFSC                  
 676  45C0 0460 H031    B       @RTURN1                 return to caller
 676  45C2 4360  
 677            *                               
 678  45C4 C0A9 FFSVIB  MOV     @>0056(R9),R2           free file sectors in VIB bitmap
 678  45C6 0056  
 679  45C8 0222         AI      R2,12                   
 679  45CA 000C  
 680  45CC 0429         BLWP    @>005A(R9)              set VDP to read
 680  45CE 005A  
 681  45D0 0042         DATA    >0042                   address in R2
 682  45D2 D02F         MOVB    @-1026(R15),R0          get file status byte from FDR
 682  45D4 FBFE  
 683  45D6 0240         ANDI    R0,>0800                write protected?
 683  45D8 0800  
 684  45DA 1303         JEQ     H032                    no
 685  45DC 06A0         BL      @ERROR5                 update data if needed, the return with error
 685  45DE 495C  
 686  45E0 2000         DATA    >2000                   write protected
 687            *                                       
 688  45E2 C229 H032    MOV     @>0056(R9),R8           get ptr to FDR
 688  45E4 0056  
 689  45E6 0228         AI      R8,28                   point to clusters list
 689  45E8 001C  
 690  45EA 0704         SETO    R4                      previous offset
 691  45EC 06A0 H033    BL      @DECDCI                 decode cluster info: sector in R1, offset in R2
 691  45EE 4BA0  
 692  45F0 0228         AI      R8,3                    next cluster ptr
 692  45F2 0003  
 693  45F4 C041         MOV     R1,R1                   
 694  45F6 130C         JEQ     H034                    sector 0 = no more clusters
 695  45F8 C002         MOV     R2,R0                   total offset
 696  45FA 6084         S       R4,R2                   minus previous cluster offset = cluster size
 697  45FC C100         MOV     R0,R4                   new previous cluster offset
 698  45FE 06A0         BL      @CALSUB                 call subroutine
 698  4600 4342  
 699  4602 4CAC         DATA    FRSCB1                  free sectors in bitmap (from R1, # in R2)
 700  4604 C048         MOV     R8,R1                   
 701  4606 6069         S       @>0056(R9),R1                   
 701  4608 0056  
 702  460A 0281         CI      R1,>0100                end of FDR reached?
 702  460C 0100  
 703  460E 16EE         JNE     H033                    not yet
 704  4610 0460 H034    B       @RTURN1                 return to caller
 704  4612 4360  
 705            *                                       
 706  4614 06A0 RDOFSC  BL      @FDR2B1                 read a sector from offset in file
 706  4616 485A  
 707  4618 000E         DATA    14                      get # of sectors
 708  461A 80C0         C       R0,R3                   is desired sector in file?
 709  461C 1B03         JH      H035                    yes
 710  461E 06A0         BL      @ERROR5                 no: update data, then return with error
 710  4620 495C  
 711  4622 A000         DATA    >A000                   past end-of-file
 712  4624 06A0 H035    BL      @CALSUB                 call subroutine
 712  4626 4342  
 713  4628 4734         DATA    FSCTOF                  find sector from cluster list
 714  462A A101         A       R1,R4                   put sector in R4
 715  462C 0702         SETO    R2                      code for read
 716  462E C147 H036    MOV     R7,R5                   buffer ptr
 717  4630 0460         B       @RWSEC                  read/write sector
 717  4632 4A38  
 718            *                                       
 719  4634 0429 WROFSC  BLWP    @>005A(R9)              write sector to offset in file offset in R3
 719  4636 005A  
 720  4638 8100         DATA    >8100                   save R0 and R7
 721  463A 06A0         BL      @CALSUB                 call subroutine
 721  463C 4342  
 722  463E 464A         DATA    APSCTS                  append enough sectors to reach that offset
 723  4640 0429         BLWP    @>005A(R9)              retrieve R0 and R7
 723  4642 005A  
 724  4644 8101         DATA    >8101                   
 725  4646 04C2         CLR     R2                      code for write
 726  4648 10F2         JMP     H036                    write sector
 727            *                               
 728  464A 06A0 APSCTS  BL      @FDR2B1                 append sector(s) to a file to get offset in R3
 728  464C 485A  
 729  464E 000E         DATA    14                      get # of sect from FDR
 730            *                                       
 731  4650 80C0         C       R0,R3                   is desired sector in file?
 732  4652 1B47         JH      H045                    yes: find it and return
 733  4654 C000         MOV     R0,R0                   
 734  4656 1301         JEQ     H037                    empty file
 735  4658 0600         DEC     R0                      last sector #
 736  465A C143 H037    MOV     R3,R5                   save desired sector offset
 737  465C C0C0         MOV     R0,R3                   last sector in file
 738  465E 06A0         BL      @CALSUB                 call subroutine
 738  4660 4342  
 739  4662 4734         DATA    FSCTOF                  find sector # from offset in file
 740  4664 0429         BLWP    @>005A(R9)              save R1 (sector #)
 740  4666 005A  
 741  4668 4000         DATA    >4000                   
 742  466A A044         A       R4,R1                   # of last sector in cluster
 743  466C C105         MOV     R5,R4                   offset of desired sector
 744  466E 06A0 H038    BL      @CALSUB                 call subroutine
 744  4670 4342  
 745  4672 4BE0         DATA    FFSBMP                  find free sector in bitmap, starting from R1
 746  4674 C000         MOV     R0,R0                   found?
 747  4676 1604         JNE     H039                    yes: # in R0
 748  4678 C142         MOV     R2,R5                   no: save # of sectors
 749  467A 06A0         BL      @ADDSEC                 update FDR
 749  467C 46EE  
 750  467E 101B         JMP     H040                    return with memory full
 751            *                                       
 752  4680 C041 H039    MOV     R1,R1                   
 753  4682 1320         JEQ     H043                    empty cluster
 754  4684 0581         INC     R1                      one more sector in cluster
 755  4686 8040         C       R0,R1                   same as the one found in bitmap?
 756  4688 131C         JEQ     H042                    yes: just increase cluster size
 757  468A 0429         BLWP    @>005A(R9)              no: retrieve R1 (sector #)
 757  468C 005A  
 758  468E 4001         DATA    >4001                   
 759  4690 0429         BLWP    @>005A(R9)              save R0 + R2
 759  4692 005A  
 760  4694 A000         DATA    >A000                   
 761  4696 06A0         BL      @UPDCLI                 update current cluster info
 761  4698 4BBC  
 762  469A 0429         BLWP    @>005A(R9)              retrieve R0 + R2
 762  469C 005A  
 763  469E A001         DATA    >A001                   
 764  46A0 0228         AI      R8,3                    ptr to next cluster info
 764  46A2 0003  
 765  46A4 C048         MOV     R8,R1                   
 766  46A6 6069         S       @>0056(R9),R1           current FDR size
 766  46A8 0056  
 767  46AA 0281         CI      R1,>0100                room enough?
 767  46AC 0100  
 768  46AE 1605         JNE     H041                    yes
 769  46B0 06A0         BL      @CALSUB                 no: call subroutine
 769  46B2 4342  
 770  46B4 4CA6         DATA    FFSBM                   free sector in bitmap
 771  46B6 0460 H040    B       @ERROR6                 return with memory full
 771  46B8 4B12  
 772            *                                       
 773  46BA C040 H041    MOV     R0,R1                   new sector #
 774  46BC 0429         BLWP    @>005A(R9)              save R1
 774  46BE 005A  
 775  46C0 4000         DATA    >4000                   
 776  46C2 1007 H042    JMP     H044                    make a new cluster
 777            *                                       
 778  46C4 0429 H043    BLWP    @>005A(R9)              retrieve R1
 778  46C6 005A  
 779  46C8 4001         DATA    >4001                   
 780  46CA 0429         BLWP    @>005A(R9)              save R0
 780  46CC 005A  
 781  46CE 8000         DATA    >8000                   
 782  46D0 0702         SETO    R2                      empty file: start from offset 0
 783  46D2 C040 H044    MOV     R0,R1                   sector #
 784  46D4 0582         INC     R2                      increment cluster size
 785  46D6 8102         C       R2,R4                   enough?
 786  46D8 16CA         JNE     H038                    no: get one more sector
 787  46DA C144         MOV     R4,R5                   
 788  46DC 06A0         BL      @ADDSEC                 add sector to FDR
 788  46DE 46EE  
 789  46E0 1004         JMP     H046                    done
 790            *                               
 791  46E2 06A0 H045    BL      @CALSUB                 call subroutine
 791  46E4 4342  
 792  46E6 4734         DATA    FSCTOF                  find a sector from offset in file
 793  46E8 A101         A       R1,R4                   last sector in cluster
 794  46EA 0460 H046    B       @RTURN1                 return to caller
 794  46EC 4360  
 795            *                                       
 796  46EE C28B ADDSEC  MOV     R11,R10                 add sector to FDR
 797  46F0 C101         MOV     R1,R4                   
 798  46F2 0429         BLWP    @>005A(R9)              retrieve R1
 798  46F4 005A  
 799  46F6 4001         DATA    >4001                   
 800  46F8 C041         MOV     R1,R1                   sector #
 801  46FA 131B         JEQ     H047                    none: return
 802  46FC 06A0         BL      @UPDCLI                 write info for R1 cluster
 802  46FE 4BBC  
 803  4700 C0A9         MOV     @>0056(R9),R2           pointer to FDR
 803  4702 0056  
 804  4704 0429         BLWP    @>005A(R9)              set VDP to read
 804  4706 005A  
 805  4708 0042         DATA    >0042                   address in R2
 806  470A D06F         MOVB    @-1026(R15),R1          first char of filename
 806  470C FBFE  
 807  470E 0261         ORI     R1,>8000                flag
 807  4710 8000  
 808  4712 0429         BLWP    @>005A(R9)              set VDP to write
 808  4714 005A  
 809  4716 0043         DATA    >0043                   address in R2
 810  4718 DBC1         MOVB    R1,@-2(R15)                     
 810  471A FFFE  
 811  471C 0222         AI      R2,14                   ptr to # of sectors
 811  471E 000E  
 812  4720 0585         INC     R5                      new # of sectors
 813  4722 0429         BLWP    @>005A(R9)              set VDP to write
 813  4724 005A  
 814  4726 0043         DATA    >0043                   address in R2
 815  4728 DBC5         MOVB    R5,@-2(R15)             update # of sectors
 815  472A FFFE  
 816  472C 06C5         SWPB    R5                      
 817  472E DBC5         MOVB    R5,@-2(R15)                     
 817  4730 FFFE  
 818  4732 045A H047    B       *R10                    
 819            *                                       
 820  4734 C229 FSCTOF  MOV     @>0056(R9),R8           find sector from offset in file
 820  4736 0056  
 821  4738 0228         AI      R8,28                   cluster list
 821  473A 001C  
 822  473C C103         MOV     R3,R4                   desired sector offset is in R3
 823  473E 06A0 H048    BL      @DECDCI                 decode info: sector in R1, offset in R2
 823  4740 4BA0  
 824  4742 80C2         C       R2,R3                   reached yet?
 825  4744 1101         JLT     H049                    no
 826  4746 1006         JMP     H050                    yes: return
 827  4748 0228 H049    AI      R8,3                    point to next cluster info
 827  474A 0003  
 828  474C C103         MOV     R3,R4                   
 829  474E 6102         S       R2,R4                   
 830  4750 0604         DEC     R4                      size of the desired cluster (if it's the next)
 831  4752 10F5         JMP     H048                    keep trying
 832  4754 0460 H050    B       @RTURN1                 return to caller
 832  4756 4360  
 833            *
 834            *---------------------------------
 835            * Opcode 7: Delete
 836            * ----------------
 837            * PAB 0: >07
 838            *     1:            <--- error code
 839            *   2-3:
 840            *     4:
 841            *     5:
 842            *   6-7:
 843            *     8:
 844            *---------------------------------                                      
 845            *
 846  4758 06A0 DELETE  BL      @CALSUB                 delete file
 846  475A 4342  
 847  475C 4A8E         DATA    FFFDRV                  find file FDR in VDP buffers
 848  475E C104         MOV     R4,R4                   found?
 849  4760 1307         JEQ     H051                    yes
 850  4762 06A0         BL      @CALSUB                 no: call subroutine
 850  4764 4342  
 851  4766 4AF6         DATA    FFDRDK                  find FDR on disk
 852  4768 C104         MOV     R4,R4                   found?
 853  476A 1313         JEQ     H053                    yes
 854  476C 0460         B       @RTURN1                 no: return to caller
 854  476E 4360  
 855            *                                       
 856  4770 0581 H051    INC     R1                      FDR found, point to it
 857  4772 CA41         MOV     R1,@>0056(R9)           save it for other routines
 857  4774 0056  
 858  4776 06A0         BL      @CALSUB                 call subroutine
 858  4778 4342  
 859  477A 4A1E         DATA    RDSEC1                  read sector 1
 860  477C 06A0         BL      @FDR2B1                 read 2 bytes from VDP at >8356+offset
 860  477E 485A  
 861  4780 FFFC         DATA    -4                      i.e. get sector # of FRD in R0
 862  4782 C0C0         MOV     R0,R3                   save it for later
 863  4784 C205         MOV     R5,R8                   ptr to top of sector 1
 864  4786 06A0 H052    BL      @VDPR2B                 read 2 bytes from VDP at R8 into R0
 864  4788 4860  
 865  478A 05C8         INCT    R8                      next FDR ptr in sector 1
 866  478C 80C0         C       R0,R3                   is this the one we want?
 867  478E 16FB         JNE     H052                    not yet
 868  4790 0648         DECT    R8                      yes: point back to it
 869            *
 870  4792 06A0 H053    BL      @NTPDT                  APEDSK99: update DOAD FAT time/date
 870  4794 5F5E  
 871            *
 872  4796 0429         BLWP    @>005A(R9)              save R8
 872  4798 005A  
 873  479A 0080         DATA    >0080                   
 874  479C 06A0         BL      @CALSUB                 call subroutine
 874  479E 4342  
 875  47A0 45C4         DATA    FFSVIB                  free file sectors in VIB bitmap
 876  47A2 0429         BLWP    @>005A(R9)              retrieve R8
 876  47A4 005A  
 877  47A6 0081         DATA    >0081                   
 878  47A8 06A0         BL      @RMFPTR                 remove FDR ptr from sector 1
 878  47AA 47C4  
 879  47AC 04C2         CLR     R2                      code for write
 880  47AE 06A0         BL      @CALSUB                 call subroutine
 880  47B0 4342  
 881  47B2 4A20         DATA    WRSEC1                  write sector 1
 882  47B4 06A0         BL      @FDR2B1                 get 2 bytes from VDP at >8356+offset in R0
 882  47B6 485A  
 883  47B8 FFFC         DATA    -4                      i.e. sector # of FDR
 884  47BA 06A0         BL      @CALSUB                 call subroutine
 884  47BC 4342  
 885  47BE 4CA6         DATA    FFSBM                   free sector in R0 in VIB bitmap
 886  47C0 0460         B       @CLRFBT                 clear 1rst byte of filename in VDP
 886  47C2 456C  
 887            *
 888            * Sector 1 contains an alphabetically sorted list of FDR pointers
 889            * Each pointer is 2 bytes long and contains the sector # of this FDR
 890            * The list must end with a >0000 mark. Thus there can be 127 files at most
 891            *
 892  47C4 C169 RMFPTR  MOV     @>0056(R9),R5           remove FDR ptr from sector 1
 892  47C6 0056  
 893  47C8 0225         AI      R5,256                  
 893  47CA 0100  
 894  47CC C0C5         MOV     R5,R3                   pointer to data buffer
 895  47CE 0223         AI      R3,256                  point to next ctrl block
 895  47D0 0100  
 896  47D2 C088         MOV     R8,R2                   shift up FDR list, erasing FDR pointed by R8
 897  47D4 05C2         INCT    R2                      point to next FDR ptr in sector 1
 898  47D6 0429 H054    BLWP    @>005A(R9)              set VDP to read
 898  47D8 005A  
 899  47DA 0042         DATA    >0042                   address in R2
 900  47DC D02F         MOVB    @-1026(R15),R0          get 1 byte
 900  47DE FBFE  
 901  47E0 0582         INC     R2                      inc source ptr
 902  47E2 0429         BLWP    @>005A(R9)              set VDP to write
 902  47E4 005A  
 903  47E6 0103         DATA    >0103                   address in R8
 904  47E8 DBC0         MOVB    R0,@-2(R15)             copy 1 byte
 904  47EA FFFE  
 905  47EC 0588         INC     R8                      inc dest pointer
 906  47EE 80C2         C       R2,R3                   done?
 907  47F0 16F2         JNE     H054                    not yet
 908  47F2 045B         B       *R11                    
 909            *                                       
 910  47F4 C28B INSFDR  MOV     R11,R10                 insert a FDR in sector 1
 911  47F6 C048         MOV     R8,R1                   
 912  47F8 06A0         BL      @FDR2B1                 get 2 bytes from VDP at >8356+offset
 912  47FA 485A  
 913  47FC 01FC         DATA    508                     i.e. last FDR slot in sector 1 (list ends with 0)
 914  47FE C000         MOV     R0,R0                   
 915  4800 1302         JEQ     H055                    
 916  4802 0460         B       @ERROR6                 memory full error
 916  4804 4B12  
 917  4806 0608 H055    DEC     R8                      previous byte
 918  4808 0429         BLWP    @>005A(R9)              set VDP to read
 918  480A 005A  
 919  480C 0102         DATA    >0102                   address in R8
 920  480E D02F         MOVB    @-1026(R15),R0          get 1 byte
 920  4810 FBFE  
 921  4812 05C8         INCT    R8                      
 922  4814 0429         BLWP    @>005A(R9)              set VDP to write
 922  4816 005A  
 923  4818 0103         DATA    >0103                   address in R8
 924  481A DBC0         MOVB    R0,@-2(R15)             copy byte two bytes further down
 924  481C FFFE  
 925  481E 0648         DECT    R8                      
 926  4820 8048         C       R8,R1                   done ?
 927  4822 16F1         JNE     H055                    not yet
 928  4824 045A         B       *R10                    
 929            *                               
 930  4826 C0A9 CMPFN   MOV     @>0058(R9),R2           compare filenames
 930  4828 0058  
 931  482A 0222         AI      R2,256                  
 931  482C 0100  
 932  482E 0429 H056    BLWP    @>005A(R9)              set VDP to read
 932  4830 005A  
 933  4832 0022         DATA    >0022                   address in R1 (ptr to filename)
 934  4834 D02F         MOVB    @-1026(R15),R0          get 1 char
 934  4836 FBFE  
 935  4838 0240         ANDI    R0,>7FFF                clear flag (on drive #)
 935  483A 7FFF  
 936  483C 0429         BLWP    @>005A(R9)              set VDP to read
 936  483E 005A  
 937  4840 0042         DATA    >0042                   address in R2 (filename compare buffer)
 938  4842 D0EF         MOVB    @-1026(R15),R3          get 1 char
 938  4844 FBFE  
 939  4846 90C0         CB      R0,R3                   compare chars
 940  4848 1604         JNE     H057                    mismatch
 941  484A 0581         INC     R1                      match: increment pointers
 942  484C 0582         INC     R2                      
 943  484E 0604         DEC     R4                      
 944  4850 16EE         JNE     H056                    next char
 945  4852 045B H057    B       *R11                    if complete match: ret with EQ set
 946            *                                       
 947  4854 C229 PABR2B  MOV     @>0054(R9),R8           get two bytes from PAB
 947  4856 0054  
 948  4858 1002         JMP     FDR2B2                  
 949            *                                       
 950  485A C229 FDR2B1  MOV     @>0056(R9),R8           get two bytes from FDR
 950  485C 0056  
 951  485E A23B FDR2B2  A       *R11+,R8                offset in data word
 952            *                                       
 953  4860 0429 VDPR2B  BLWP    @>005A(R9)              get two byte from VDP at R8
 953  4862 005A  
 954  4864 0102         DATA    >0102                   set VDP to read at R8
 955  4866 D02F         MOVB    @-1026(R15),R0          get two bytes of data
 955  4868 FBFE  
 956  486A 06C0         SWPB    R0                      
 957  486C D02F         MOVB    @-1026(R15),R0                  
 957  486E FBFE  
 958  4870 0B80         SRC     R0,8                    why not swpb ?
 959  4872 045B         B       *R11                    
 960            *                       
 961  4874 C069 FDSKDR  MOV     @>0058(R9),R1           find disk from name (ptr in R3)
 961  4876 0058  
 962  4878 0221         AI      R1,256                  
 962  487A 0100  
 963  487C 06A0         BL      @CPCKFN                 copy filename from VDP at R3 to compare buffer
 963  487E 48FE  
 964  4880 0429         BLWP    @>005A(R9)              save R2 + R3
 964  4882 005A  
 965  4884 3000         DATA    >3000                   
 966  4886 C000         MOV     R0,R0                   last char copied
 967  4888 1101         JLT     H058                    flagged
 968  488A 1005         JMP     H059                    
 969  488C C180 H058    MOV     R0,R6                   
 970  488E 0246         ANDI    R6,>0300                        
 970  4890 0300  
 971  4892 1337         JEQ     ERROR7                  return with file error
 972  4894 102F         JMP     H062                    return to caller
 973  4896 04C6 H059    CLR     R6                      don't read any drive
 974  4898 06A0         BL      @CALSUB                 call subroutine
 974  489A 4342  
 975  489C 49BC         DATA    RWVIB                   save current VIB
 976  489E 0226 H060    AI      R6,>0100                next drive
 976  48A0 0100  
 977  48A2 0707         SETO    R7                      error flags
 978  48A4 0702         SETO    R2                      code for read
 979  48A6 04C4         CLR     R4                      sector 0
 980  48A8 06A0         BL      @CALSUB                 call subroutine
 980  48AA 4342  
 981  48AC 4A3A         DATA    RWSECA                  read sector 0
 982  48AE C1C7         MOV     R7,R7                   ok?
 983  48B0 161D         JNE     H061                    no: try next drive
 984  48B2 0204         LI      R4,10                   yes: diskname size
 984  48B4 000A  
 985  48B6 C069         MOV     @>0058(R9),R1           VIB ptr
 985  48B8 0058  
 986  48BA 0429         BLWP    @>005A(R9)              save R1-R3
 986  48BC 005A  
 987  48BE 7000         DATA    >7000                   
 988  48C0 06A0         BL      @CMPFN                  compare names (ptr in R1 + compare buffer)
 988  48C2 4826  
 989  48C4 0429         BLWP    @>005A(R9)                      
 989  48C6 005A  
 990  48C8 7001         DATA    >7001                   retrieve R1-R3
 991  48CA C104         MOV     R4,R4                   name matched?
 992  48CC 160F         JNE     H061                    no: try next drive
 993  48CE C006         MOV     R6,R0                   drive #
 994  48D0 0260         ORI     R0,>8000                add update flag
 994  48D2 8000  
 995  48D4 0429         BLWP    @>005A(R9)              set VDP to write
 995  48D6 005A  
 996  48D8 0063         DATA    >0063                   address in R3
 997  48DA DBC0         MOVB    R0,@-2(R15)             copy drive+flag before diskname in source
 997  48DC FFFE  
 998  48DE 0605         DEC     R5                      before sector 0 copy
 999  48E0 0429         BLWP    @>005A(R9)              set VDP to write
 999  48E2 005A  
1000  48E4 00A3         DATA    >00A3                   address in R5
1001  48E6 DBC6         MOVB    R6,@-2(R15)             copy drive # before VIB
1001  48E8 FFFE  
1002  48EA 1004         JMP     H062                    done
1003            *                               
1004  48EC 0286 H061    CI      R6,>0300                did we do all drives?
1004  48EE 0300  
1005  48F0 16D6         JNE     H060                    no: try next on
1006  48F2 1007         JMP     ERROR7                  return with file error
1007            *                                       
1008  48F4 0429 H062    BLWP    @>005A(R9)              retrieve R2 + R3
1008  48F6 005A  
1009  48F8 3001         DATA    >3001                   
1010  48FA 0460         B       @RTURN1                 return to caller
1010  48FC 4360  
1011            *                               
1012  48FE 0602 CPCKFN  DEC     R2                      
1013  4900 1B03         JH      H063                    
1014  4902 06A0 ERROR7  BL      @RETERR                 return with error
1014  4904 4988  
1015  4906 E000         DATA    >E000                   file error
1016            *                                       
1017  4908 0200 H063    LI      R0,>2000                copy (+check) filename in VDP from R3 to R1 (space)
1017  490A 2000  
1018  490C 0429         BLWP    @>005A(R9)              set VDP to write
1018  490E 005A  
1019  4910 0023         DATA    >0023                   address in R1
1020  4912 0208         LI      R8,10                   10 chars per filename
1020  4914 000A  
1021  4916 DBC0 H064    MOVB    R0,@-2(R15)             fill filename with spaces
1021  4918 FFFE  
1022  491A 0608         DEC     R8                      
1023  491C 16FC         JNE     H064                    
1024  491E 0208         LI      R8,11                   11 chars countring drive #
1024  4920 000B  
1025  4922 0583 H065    INC     R3                      increment source ptr
1026  4924 0429         BLWP    @>005A(R9)              set VDP to read
1026  4926 005A  
1027  4928 0062         DATA    >0062                   address in R3
1028  492A D02F         MOVB    @-1026(R15),R0          get a char
1028  492C FBFE  
1029  492E 13E9         JEQ     ERROR7                  >00: return with file error
1030  4930 1110         JLT     H066                    flag bit set
1031  4932 0280         CI      R0,>2E00                        
1031  4934 2E00  
1032  4936 130D         JEQ     H066                    '.'
1033  4938 0608         DEC     R8                      
1034  493A 13E3         JEQ     ERROR7                  name to long: return with file error
1035  493C 0280         CI      R0,>2000                        
1035  493E 2000  
1036  4940 13E0         JEQ     ERROR7                  name can't contain spaces: file error again
1037  4942 0429         BLWP    @>005A(R9)              set VDP to write
1037  4944 005A  
1038  4946 0023         DATA    >0023                   address in R1
1039  4948 DBC0         MOVB    R0,@-2(R15)             copy 1 char
1039  494A FFFE  
1040  494C 0581         INC     R1                      increment destination pointer
1041  494E 0602         DEC     R2                      more?
1042  4950 16E8         JNE     H065                    yes
1043  4952 0288 H066    CI      R8,>000B                name can't be 0 chars long
1043  4954 000B  
1044  4956 13D5         JEQ     ERROR7                  else return with file error
1045  4958 045B         B       *R11                    
1046            *                                       
1047  495A AA00 K014    DATA    >AA00                   
1048            *                               
1049  495C C00B ERROR5  MOV     R11,R0                  update data, then error
1050  495E C0E9         MOV     @>0056(R9),R3           
1050  4960 0056  
1051  4962 0603         DEC     R3                      see what >8356 is pointing at
1052  4964 0429         BLWP    @>005A(R9)              set VDP to read
1052  4966 005A  
1053  4968 0062         DATA    >0062                   address in R3
1054  496A D0AF         MOVB    @-1026(R15),R2          get 1 byte
1054  496C FBFE  
1055  496E 9802         CB      R2,@K014                is it >AA (disk buffer area mark)
1055  4970 495A  
1056  4972 1309         JEQ     H067                    yes: announce error (code in data word)
1057  4974 0429         BLWP    @>005A(R9)              no: >8356 points to a FDR. Save R0
1057  4976 005A  
1058  4978 8000         DATA    >8000                   
1059  497A 06A0         BL      @CALSUB                 call subroutine
1059  497C 4342  
1060  497E 4560         DATA    UPDFDR                  update FRD and data buffer if needed
1061  4980 0429         BLWP    @>005A(R9)              retrieve R0
1061  4982 005A  
1062  4984 8001         DATA    >8001                   
1063  4986 C2C0 H067    MOV     R0,R11                  
1064            *                               
1065  4988 C069 RETERR  MOV     @>0054(R9),R1           annouce error
1065  498A 0054  
1066  498C 130D         JEQ     H068                    no PAB
1067  498E 0581         INC     R1                      for DSRs: ptr to status byte
1068  4990 0429         BLWP    @>005A(R9)              set VDP to read
1068  4992 005A  
1069  4994 0022         DATA    >0022                   address in R2
1070  4996 D0AF         MOVB    @-1026(R15),R2          get file status byte
1070  4998 FBFE  
1071  499A E0BB         SOC     *R11+,R2                add error code
1072  499C 0429         BLWP    @>005A(R9)              set VDP to write
1072  499E 005A  
1073  49A0 0023         DATA    >0023                   address in R2
1074  49A2 DBC2         MOVB    R2,@-2(R15)             write back status byte
1074  49A4 FFFE  
1075  49A6 1002         JMP     H069                    
1076  49A8 CA7B H068    MOV     *R11+,@>0050(R9)        for subs: error code in >8350
1076  49AA 0050  
1077  49AC C229 H069    MOV     @>0058(R9),R8           get stack ptr
1077  49AE 0058  
1078  49B0 0228         AI      R8,-12                  point back to initial caller
1078  49B2 FFF4  
1079  49B4 CA48         MOV     R8,@>0066(R9)           update pointer
1079  49B6 0066  
1080  49B8 0460         B       @RTURN1                 return to caller
1080  49BA 4360  
1081            *                               
1082  49BC 0429 RWVIB   BLWP    @>005A(R9)              read VIB (drive # in R6)
1082  49BE 005A  
1083  49C0 3000         DATA    >3000                   save R2 + R3
1084  49C2 C169         MOV     @>0058(R9),R5           pointer to VIB in ctrl block
1084  49C4 0058  
1085  49C6 0605         DEC     R5                      ptr to drive #
1086  49C8 0429         BLWP    @>005A(R9)              set VDP for read
1086  49CA 005A  
1087  49CC 00A2         DATA    >00A2                   address in R5
1088  49CE D0AF         MOVB    @-1026(R15),R2          get drive #
1088  49D0 FBFE  
1089  49D2 C0C2         MOV     R2,R3                   
1090  49D4 04C4         CLR     R4                      sector 0 for VIB
1091  49D6 0242         ANDI    R2,>0300                clear flag (>80 = update data)
1091  49D8 0300  
1092  49DA 9182         CB      R2,R6                   wanted drive?
1093  49DC 131A         JEQ     H073                    yes: return
1094  49DE C0C3         MOV     R3,R3                   no: shall we update VIB?
1095  49E0 1101         JLT     H070                    yes
1096  49E2 100A         JMP     H071                    no
1097  49E4 0429 H070    BLWP    @>005A(R9)              set VDP to write
1097  49E6 005A  
1098  49E8 00A3         DATA    >00A3                   address in R5
1099  49EA DBC4         MOVB    R4,@-2(R15)             clr drive #
1099  49EC FFFE  
1100  49EE 0585         INC     R5                      point back to VIB buffer
1101  49F0 06A0         BL      @CALSUB                 call subroutine
1101  49F2 4342  
1102  49F4 4A3C         DATA    RWSECB                  write sector 0 to old drive (in R2)
1103  49F6 0605         DEC     R5                      point to drive #
1104  49F8 0702 H071    SETO    R2                      flag for read
1105  49FA D086         MOVB    R6,R2                   APEDSK99: error in original disassembly (was R5)
1106  49FC 1305         JEQ     H072                    none
1107  49FE 0585         INC     R5                      point at VIB buffer
1108  4A00 06A0         BL      @CALSUB                 call subroutine
1108  4A02 4342  
1109  4A04 4A3A         DATA    RWSECA                  read sector (in R4) to buffer (in R5)
1110  4A06 0605         DEC     R5                      point at drive #
1111  4A08 0429 H072    BLWP    @>005A(R9)              set VDP to write
1111  4A0A 005A  
1112  4A0C 00A3         DATA    >00A3                   address in R5
1113  4A0E DBC6         MOVB    R6,@-2(R15)             write drive # in control block, before FDR
1113  4A10 FFFE  
1114  4A12 0585 H073    INC     R5                      point back to FDR
1115  4A14 0429         BLWP    @>005A(R9)                      
1115  4A16 005A  
1116  4A18 3001         DATA    >3001                   retrieve R2 + R3 from stack
1117  4A1A 0460         B       @RTURN1                 branch to address on stack
1117  4A1C 4360  
1118            *                               
1119  4A1E 0702 RDSEC1  SETO    R2                      read sector 1
1120  4A20 0204 WRSEC1  LI      R4,1
1120  4A22 0001  
1121  4A24 0205         LI      R5,>0100                into data buffer area of current ctrl block
1121  4A26 0100  
1122  4A28 1005         JMP     RDFDR1                  
1123            *                               
1124  4A2A 06A0 WRFDR   BL      @FDR2B1                 read FDR
1124  4A2C 485A  
1125  4A2E FFFC         DATA    -4                      get sector # of FDR from control block
1126            *                               
1127  4A30 C100 RDFDR2  MOV     R0,R4                   sector read/write
1128  4A32 04C5         CLR     R5
1129  4A34 A169 RDFDR1  A       @>0056(R9),R5           point to FDR or data buffer
1129  4A36 0056  
1130  4A38 04C7 RWSEC   CLR     R7                      
1131  4A3A D086 RWSECA  MOVB    R6,R2                   add drive # for r/w flag
1132  4A3C 0429 RWSECB  BLWP    @>005A(R9)              save R0-R8
1132  4A3E 005A  
1133  4A40 FF80         DATA    >FF80                   
1134  4A42 CA44         MOV     R4,@>004A(R9)           sector #
1134  4A44 004A  
1135  4A46 CA42         MOV     R2,@>004C(R9)           drive | r/w flag
1135  4A48 004C  
1136  4A4A CA45         MOV     R5,@>004E(R9)           buffer ptr
1136  4A4C 004E  
1137  4A4E 06A0         BL      @CALSUB                 call subroutine
1137  4A50 4342  
1138  4A52 4198         DATA    SECRW1                  sector read/write
1139  4A54 0429         BLWP    @>005A(R9)              retrieve R0-R8
1139  4A56 005A  
1140  4A58 FF81         DATA    >FF81                   
1141  4A5A D1E9         MOVB    @>0050(R9),R7           get error code | flags
1141  4A5C 0050  
1142  4A5E 06C7         SWPB    R7                      
1143  4A60 1312         JEQ     H077                    
1144  4A62 C1C7         MOV     R7,R7                   
1145  4A64 1501         JGT     H074                    
1146  4A66 100B         JMP     H076                    
1147  4A68 0247 H074    ANDI    R7,>00FF                        
1147  4A6A 00FF  
1148  4A6C 0287         CI      R7,>0034                        
1148  4A6E 0034  
1149  4A70 1603         JNE     H075                    
1150  4A72 06A0         BL      @ERROR5                 
1150  4A74 495C  
1151  4A76 2000         DATA    >2000                   write protected
1152  4A78 06A0 H075    BL      @ERROR5                 
1152  4A7A 495C  
1153  4A7C C000         DATA    >C000                   device error
1154  4A7E DA69 H076    MOVB    @>004D(R9),@>004D(R9)   read or write?
1154  4A80 004D  
1154  4A82 004D  
1155  4A84 13F1         JEQ     H074                    write
1156  4A86 0247 H077    ANDI    R7,>00FF                        
1156  4A88 00FF  
1157  4A8A 0460         B       @RTURN1                 return to caller
1157  4A8C 4360  
1158            *                               
1159  4A8E C069 FFFDRV  MOV     @>0058(R9),R1           save filename in compare buffer and find its FDR
1159  4A90 0058  
1160  4A92 0221         AI      R1,256                  
1160  4A94 0100  
1161  4A96 0429         BLWP    @>005A(R9)              set VDP to write
1161  4A98 005A  
1162  4A9A 0023         DATA    >0023                   address in R1: filename compare buffer
1163  4A9C DBC6         MOVB    R6,@-2(R15)             write drive #
1163  4A9E FFFE  
1164  4AA0 0581         INC     R1                      
1165  4AA2 06A0         BL      @CPCKFN                 copy (+ check) filename from R3 to R1
1165  4AA4 48FE  
1166  4AA6 C082         MOV     R2,R2                   all chars copied (or was there a . or a >00
1167  4AA8 1302         JEQ     FFDRVB                  
1168  4AAA 0460 H078    B       @ERROR7                 return with file error
1168  4AAC 4902  
1169            *                                       
1170  4AAE C069 FFDRVB  MOV     @>0056(R9),R1           find filename in buffered FDRs
1170  4AB0 0056  
1171  4AB2 0221         AI      R1,3                    
1171  4AB4 0003  
1172  4AB6 0429         BLWP    @>005A(R9)              set VDP to read
1172  4AB8 005A  
1173  4ABA 0022         DATA    >0022                   address in R1
1174  4ABC D0AF         MOVB    @-1026(R15),R2          get # of files
1174  4ABE FBFE  
1175  4AC0 0982         SRL     R2,8                    make it a word
1176  4AC2 C0C2         MOV     R2,R3                   save it
1177  4AC4 0221         AI      R1,6                    ptr to drive #
1177  4AC6 0006  
1178  4AC8 0204 H079    LI      R4,11                   compare 11 bytes (drive + filename)
1178  4ACA 000B  
1179  4ACC 0429         BLWP    @>005A(R9)              save R1-R3
1179  4ACE 005A  
1180  4AD0 7000         DATA    >7000                   
1181  4AD2 06A0         BL      @CMPFN                  compare with name in compare buffer
1181  4AD4 4826  
1182  4AD6 0429         BLWP    @>005A(R9)              retrieve R1-R3
1182  4AD8 005A  
1183  4ADA 7001         DATA    >7001                   
1184  4ADC C104         MOV     R4,R4                   fully compared?
1185  4ADE 1304         JEQ     H080                    yes: done
1186  4AE0 0221         AI      R1,518                  move to next FDR in VDP mem
1186  4AE2 0206  
1187  4AE4 0602         DEC     R2                      
1188  4AE6 16F0         JNE     H079                    next file
1189  4AE8 0460 H080    B       @RTURN1                 return to caller (R4=0 if successfull)
1189  4AEA 4360  
1190            *                               
1191  4AEC 06A0 FNDFDR  BL      @CALSUB                 
1191  4AEE 4342  
1192  4AF0 4A8E         DATA    FFFDRV                  save name in comp buffer, find FDR in VDP buffers
1193            *                                       
1194  4AF2 C104 FFDROD  MOV     R4,R4                   find FDR on disk (from filename)
1195  4AF4 13DA         JEQ     H078                    file error
1196  4AF6 C169 FFDRDK  MOV     @>0056(R9),R5           ptr to top of disk buffer in VDP mem
1196  4AF8 0056  
1197  4AFA 0225         AI      R5,10                   ptr to drive # in first file control block
1197  4AFC 000A  
1198  4AFE 0429 H081    BLWP    @>005A(R9)              set VDP to read
1198  4B00 005A  
1199  4B02 00A2         DATA    >00A2                   address in R5
1200  4B04 D0AF         MOVB    @-1026(R15),R2          get drive #
1200  4B06 FBFE  
1201  4B08 1307         JEQ     H082                    free control block found
1202  4B0A 0225         AI      R5,518                  ptr to file control block
1202  4B0C 0206  
1203  4B0E 0603         DEC     R3                      
1204  4B10 16F6         JNE     H081                    more files ?
1205  4B12 06A0 ERROR6  BL      @ERROR5                 no:
1205  4B14 495C  
1206  4B16 8000         DATA    >8000                   memory full
1207            *                               
1208  4B18 CA45 H082    MOV     R5,@>0056(R9)           save ptr to free ctrl block (drive #)
1208  4B1A 0056  
1209  4B1C 06A0         BL      @CALSUB                 call subroutine
1209  4B1E 4342  
1210  4B20 4A1E         DATA    RDSEC1                  read sector 1
1211  4B22 C229 FFDRFN  MOV     @>0056(R9),R8           entry point if sector 1 already read
1211  4B24 0056  
1212  4B26 0228         AI      R8,382                  point to middle of sector 1
1212  4B28 017E  
1213  4B2A 0202         LI      R2,64                   distance: start with 1/4 sector
1213  4B2C 0040  
1214  4B2E 0704 H083    SETO    R4                      
1215  4B30 06A0         BL      @VDPR2B                 read 2 bytes in R0 from VDP address in R8
1215  4B32 4860  
1216  4B34 C000         MOV     R0,R0                   
1217  4B36 132E         JEQ     H085                    no file here: move up
1218  4B38 0429         BLWP    @>005A(R9)              save R2
1218  4B3A 005A  
1219  4B3C 2000         DATA    >2000                   
1220  4B3E 0702         SETO    R2                      code for read
1221  4B40 06A0         BL      @CALSUB                 call subroutine
1221  4B42 4342  
1222  4B44 4A30         DATA    RDFDR2                  read FDR, sector # in R0
1223  4B46 C045         MOV     R5,R1                   RDFDR2 sets R5 as FDR ptr
1224  4B48 0225         AI      R5,-4                   point to sector # of FDR in ctrl block
1224  4B4A FFFC  
1225  4B4C 0429         BLWP    @>005A(R9)              set VDP to write
1225  4B4E 005A  
1226  4B50 00A3         DATA    >00A3                   address in R5
1227  4B52 DBC4         MOVB    R4,@-2(R15)             RDFDR2 puts sector # in R4
1227  4B54 FFFE  
1228  4B56 06C4         SWPB    R4                      copy it to ctrl block
1229  4B58 DBC4         MOVB    R4,@-2(R15)                     
1229  4B5A FFFE  
1230  4B5C C141         MOV     R1,R5                   FDR ptr
1231  4B5E 0601         DEC     R1                      now point to drive #
1232  4B60 0429         BLWP    @>005A(R9)              set VDP to write
1232  4B62 005A  
1233  4B64 0023         DATA    >0023                   address in R1
1234  4B66 DBC6         MOVB    R6,@-2(R15)             save drive #
1234  4B68 FFFE  
1235  4B6A 0204         LI      R4,11                   size to compare (drive # + filename)
1235  4B6C 000B  
1236  4B6E 06A0         BL      @CMPFN                  compare filenames
1236  4B70 4826  
1237  4B72 0429         BLWP    @>005A(R9)              retrieve R2
1237  4B74 005A  
1238  4B76 2001         DATA    >2001                   
1239  4B78 130B         JEQ     H084                    compared ok: return
1240  4B7A 0429         BLWP    @>005A(R9)              set VDP to write
1240  4B7C 005A  
1241  4B7E 00A3         DATA    >00A3                   address in R5
1242  4B80 DBC4         MOVB    R4,@-2(R15)             remaining chars to compare
1242  4B82 FFFE  
1243  4B84 80C0         C       R0,R3                   what kind of mismatch occured?
1244  4B86 1B06         JH      H085                    too far down the alphabet
1245  4B88 A202         A       R2,R8                   too far up: move half-way down
1246  4B8A C082         MOV     R2,R2                   
1247  4B8C 1606         JNE     H086                    then divide distance by 2
1248  4B8E 05C8         INCT    R8                      already checked: reset EQ
1249  4B90 0460 H084    B       @RTURN1                 return (from stack)
1249  4B92 4360  
1250            *                               
1251  4B94 6202 H085    S       R2,R8                   move half-way up
1252  4B96 C082         MOV     R2,R2                   
1253  4B98 13FB         JEQ     H084                    can't: already checked
1254  4B9A 0922 H086    SRL     R2,2                    divide distance by 2
1255  4B9C A082         A       R2,R2                   but keep it even
1256  4B9E 10C7         JMP     H083                    
1257            *
1258            * The cluster info list is located in the FDR, bytes >1C to >FF
1259            * A cluster info consists in 3 bytes, i.e 6 nibbles
1260            * 3 nibbles specify the beginning sector for that cluster, and
1261            * 3 nibbles specify the total file offset in sectors, including this cluster.
1262            * The nibbles are arranged as EG SB OF, to be combined as BEG OFS
1263            *
1264  4BA0 C28B DECDCI  MOV     R11,R10                 decode cluster info
1265  4BA2 06A0         BL      @VDPR2B                 read 2 bytes VDP at R8 in R0
1265  4BA4 4860  
1266  4BA6 06C0         SWPB    R0                      
1267  4BA8 D0AF         MOVB    @-1026(R15),R2          get third byte from cluster list
1267  4BAA FBFE  
1268  4BAC C040         MOV     R0,R1                   
1269  4BAE 0241         ANDI    R1,>0FFF                start sector in R1
1269  4BB0 0FFF  
1270  4BB2 4001         SZC     R1,R0                   remove it from R0
1271  4BB4 0982         SRL     R2,8                    
1272  4BB6 E080         SOC     R0,R2                   combine offset nibbles
1273  4BB8 0BC2         SRC     R2,12                   offset in R2
1274  4BBA 045A         B       *R10                    
1275            *                               
1276  4BBC 0B42 UPDCLI  SRC     R2,4                    write info for 1 cluster
1277  4BBE C002         MOV     R2,R0                   
1278  4BC0 0240         ANDI    R0,>F000                sector in R1, offset in R2
1278  4BC2 F000  
1279  4BC4 E040         SOC     R0,R1                   copy nibble 3 of offset before nibble 1 of sector
1280  4BC6 0429         BLWP    @>005A(R9)              set VDP to write
1280  4BC8 005A  
1281  4BCA 0103         DATA    >0103                   address in R8
1282  4BCC 06C1         SWPB    R1                      write cluster info
1283  4BCE DBC1         MOVB    R1,@-2(R15)             as 3 bytes
1283  4BD0 FFFE  
1284  4BD2 06C1         SWPB    R1                      
1285  4BD4 DBC1         MOVB    R1,@-2(R15)                     
1285  4BD6 FFFE  
1286  4BD8 06C2         SWPB    R2                      
1287  4BDA DBC2         MOVB    R2,@-2(R15)                     
1287  4BDC FFFE  
1288  4BDE 045B         B       *R11                    
1289            *
1290            * The sector bitmap is located in the VIB (i.e. sector 0) at bytes >38 to >FF
1291            * In each byte a bit defines a sector, from right to left: "0"=free, "1"=used                                   
1292            *
1293  4BE0 0429 FFSBMP  BLWP    @>005A(R9)              find a free sector in bitmap
1293  4BE2 005A  
1294  4BE4 7800         DATA    >7800                   
1295  4BE6 06A0         BL      @CALSUB                 call subroutine
1295  4BE8 4342  
1296  4BEA 49BC         DATA    RWVIB                   load VIB for drive in R6
1297  4BEC C041         MOV     R1,R1                   first sector specified in R1 ?
1298  4BEE 1602         JNE     H087                    yes
1299  4BF0 0201         LI      R1,33                   no: start with sector 34
1299  4BF2 0021  
1300  4BF4 0581 H087    INC     R1                      
1301  4BF6 C001         MOV     R1,R0                   
1302  4BF8 0931         SRL     R1,3                    div by 8 since 8 sect/byte in bitmap
1303  4BFA 0202         LI      R2,>00FF                        
1303  4BFC 00FF  
1304  4BFE 0240         ANDI    R0,>0007                bit number in bitmap byte
1304  4C00 0007  
1305  4C02 1301         JEQ     H088                    
1306  4C04 0A02         SLA     R2,0                    get that bit
1307  4C06 C0C1 H088    MOV     R1,R3                   byte #
1308  4C08 A0C5         A       R5,R3                   add VIB ptr
1309  4C0A 0223         AI      R3,56                   ptr to sector in bitmap
1309  4C0C 0038  
1310  4C0E 0281         CI      R1,>00C8                end of VIB?
1310  4C10 00C8  
1311  4C12 1101         JLT     H089                    no
1312  4C14 04C1         CLR     R1                      yes: top of bitmap
1313  4C16 A045 H089    A       R5,R1                   
1314  4C18 0221         AI      R1,56                   make another bitmap ptr
1314  4C1A 0038  
1315  4C1C 0429         BLWP    @>005A(R9)              set VDP to read
1315  4C1E 005A  
1316  4C20 0022         DATA    >0022                   address in R1
1317  4C22 0700 H090    SETO    R0                      
1318  4C24 D02F         MOVB    @-1026(R15),R0          get bitmap byte
1318  4C26 FBFE  
1319  4C28 C100         MOV     R0,R4                   save it
1320  4C2A E002         SOC     R2,R0                   mask previous sectors
1321  4C2C 04C2         CLR     R2                      
1322  4C2E 0580         INC     R0                      get 1 more sector
1323  4C30 1610         JNE     H092                    ok
1324  4C32 0581         INC     R1                      byte full: try next
1325  4C34 C001         MOV     R1,R0                   
1326  4C36 0220         AI      R0,-256                 won't change if byte # became >100
1326  4C38 FF00  
1327  4C3A 8140         C       R0,R5                   still in VIB?
1328  4C3C 1605         JNE     H091                    yes
1329  4C3E 0221         AI      R1,-200                 no: to top of bitmap
1329  4C40 FF38  
1330  4C42 0429         BLWP    @>005A(R9)              set VDP to read
1330  4C44 005A  
1331  4C46 0022         DATA    >0022                   address in R1
1332  4C48 80C1 H091    C       R1,R3                   are we back to where we started?
1333  4C4A 16EB         JNE     H090                    no: seach that byte for a free sector
1334  4C4C C004         MOV     R4,R0                   get original byte
1335  4C4E 0580         INC     R0                      try sectors just before ours (no mask this time)
1336  4C50 1325         JEQ     H095                    full: return with EQ
1337  4C52 0600 H092    DEC     R0                      restore original byte
1338  4C54 C080         MOV     R0,R2                   
1339  4C56 04C0         CLR     R0                      bit counter
1340  4C58 06C2         SWPB    R2                      
1341  4C5A 0580 H093    INC     R0                      increment bit count
1342  4C5C 0B12         SRC     R2,1                    find first 0 bit from the right
1343  4C5E 18FD         JOC     H093                    not yet
1344  4C60 0202         LI      R2,>0080                        
1344  4C62 0080  
1345  4C64 0A02         SLA     R2,0                    make a mask for that bit
1346  4C66 0600         DEC     R0                      bit # (0-7)
1347  4C68 E102         SOC     R2,R4                   mark sector as used in bitmap byte
1348  4C6A 0429         BLWP    @>005A(R9)              set VDP to write
1348  4C6C 005A  
1349  4C6E 0023         DATA    >0023                   address in R1
1350  4C70 DBC4         MOVB    R4,@-2(R15)             update bitmap
1350  4C72 FFFE  
1351  4C74 0221         AI      R1,-56                  
1351  4C76 FFC8  
1352  4C78 6045         S       R5,R1                   byte # in bitmap
1353  4C7A 0A31         SLA     R1,3                    times 8 (8 sect per byte)
1354  4C7C E040         SOC     R0,R1                   add bit #: = sector #
1355  4C7E C001         MOV     R1,R0                   save it
1356            *                               
1357  4C80 0605 H094    DEC     R5                      point to drive #
1358  4C82 0429         BLWP    @>005A(R9)              set VDP to read
1358  4C84 005A  
1359  4C86 00A2         DATA    >00A2                   address in R5
1360  4C88 D06F         MOVB    @-1026(R15),R1          get drive #
1360  4C8A FBFE  
1361  4C8C 0261         ORI     R1,>8000                add flag: update VIB
1361  4C8E 8000  
1362  4C90 0429         BLWP    @>005A(R9)              set VDP to write
1362  4C92 005A  
1363  4C94 00A3         DATA    >00A3                   address in R5
1364  4C96 DBC1         MOVB    R1,@-2(R15)             write back flagged drive #
1364  4C98 FFFE  
1365  4C9A 0585         INC     R5                      point to VIB (& return with NEQ)
1366  4C9C 0429 H095    BLWP    @>005A(R9)              retrieve R1-R4
1366  4C9E 005A  
1367  4CA0 7801         DATA    >7801                   
1368  4CA2 0460         B       @RTURN1                 return to caller
1368  4CA4 4360  
1369            *                               
1370  4CA6 C040 FFSBM   MOV     R0,R1                   free sector(s) in bitmap
1371  4CA8 0202         LI      R2,1                    1 sector only
1371  4CAA 0001  
1372  4CAC 0429 FRSCB1  BLWP    @>005A(R9)              entry point if more than 1 sector
1372  4CAE 005A  
1373  4CB0 7800         DATA    >7800                   save R1-R4
1374  4CB2 06A0         BL      @CALSUB                 call subroutine
1374  4CB4 4342  
1375  4CB6 49BC         DATA    RWVIB                   load VIB for drive in R6
1376  4CB8 C001         MOV     R1,R0                   sector #
1377  4CBA 0240         ANDI    R0,>0007                bit in bitmap byte (8 per byte)
1377  4CBC 0007  
1378  4CBE 0931         SRL     R1,3                    byte in bitmap
1379  4CC0 A045         A       R5,R1                   add VIB buffer
1380  4CC2 0221         AI      R1,56                   add bitmap offset in VIB
1380  4CC4 0038  
1381  4CC6 C0C0         MOV     R0,R3                   
1382  4CC8 0500         NEG     R0                      
1383  4CCA 0220         AI      R0,8                    change 0-7 into 8-1
1383  4CCC 0008  
1384  4CCE 0204         LI      R4,>00FF                mask to erase
1384  4CD0 00FF  
1385  4CD2 8002         C       R2,R0                   how many to erase?
1386  4CD4 1101         JLT     H096                    less than in that byte
1387  4CD6 100A         JMP     H099                    
1388            *                               
1389  4CD8 0200 H096    LI      R0,8                    free sectors in first byte
1389  4CDA 0008  
1390  4CDC 6002         S       R2,R0                   
1391  4CDE 0B04         SRC     R4,0                    adjust mask
1392  4CE0 C003         MOV     R3,R0                   original bit # of starting sector
1393  4CE2 1301         JEQ     H097                    
1394  4CE4 0A04         SLA     R4,0                    don't erase before starting sector
1395  4CE6 1000 H097    JMP     H098                    
1396            *                               
1397  4CE8 06C4 H098    SWPB    R4                      
1398  4CEA 1019         JMP     H102                    goto erase last byte
1399            *                                       
1400  4CEC 0B04 H099    SRC     R4,0                    adjust mask
1401  4CEE 6080 H100    S       R0,R2                   that many will be freed
1402  4CF0 0429         BLWP    @>005A(R9)              set VDP to read
1402  4CF2 005A  
1403  4CF4 0022         DATA    >0022                   address in R1
1404  4CF6 D02F         MOVB    @-1026(R15),R0          get bitmap byte
1404  4CF8 FBFE  
1405  4CFA 4004         SZC     R4,R0                   mark sectors as free
1406  4CFC 0429         BLWP    @>005A(R9)              set VDP to write
1406  4CFE 005A  
1407  4D00 0023         DATA    >0023                   address in R1
1408  4D02 DBC0         MOVB    R0,@-2(R15)             write it back
1408  4D04 FFFE  
1409  4D06 0204         LI      R4,>FF00                clear full byte
1409  4D08 FF00  
1410  4D0A 0581         INC     R1                      next byte
1411  4D0C 0200         LI      R0,8                    i.e. 8 sectors
1411  4D0E 0008  
1412  4D10 8002         C       R2,R0                   how many more sectors?
1413  4D12 1101         JLT     H101                    less than 8
1414  4D14 10EC         JMP     H100                    8 or more: next byte
1415            *                                       
1416  4D16 C002 H101    MOV     R2,R0                   remaining sectors
1417  4D18 0204         LI      R4,>00FF                        
1417  4D1A 00FF  
1418  4D1C 0A04         SLA     R4,0                    coin mask
1419  4D1E 0429 H102    BLWP    @>005A(R9)              set VDP to read
1419  4D20 005A  
1420  4D22 0022         DATA    >0022                   address in R1
1421  4D24 D02F         MOVB    @-1026(R15),R0          get bitmap byte
1421  4D26 FBFE  
1422  4D28 4004         SZC     R4,R0                   mark sectors as free
1423  4D2A 0429         BLWP    @>005A(R9)              set VDP to write
1423  4D2C 005A  
1424  4D2E 0023         DATA    >0023                   address in R1
1425  4D30 DBC0         MOVB    R0,@-2(R15)             write it back
1425  4D32 FFFE  
1426  4D34 10A5         JMP     H094                    done: flag drive # and return
1427            *
1428            *===================================
1429            * DSR entry points
1430            *===================================                                    
1431            *
1432  4D36 C1CB EDSR01  MOV     R11,R7                  DSK
1433  4D38 06A0         BL      @PRPFDO                 --- prepare file operations
1433  4D3A 440E  
1434  4D3C 06A0         BL      @CALSUB                 call subroutine
1434  4D3E 4342  
1435  4D40 4874         DATA    FDSKDR                  find disk in drive (name ptr in R3)
1436  4D42 100B         JMP     H104                    
1437            *                                       
1438  4D44 0206 EDSR02  LI      R6,>0100                DSK1
1438  4D46 0100  
1439  4D48 1005         JMP     H103                    ----
1440            *                                       
1441  4D4A 0206 EDSR03  LI      R6,>0200                DSK2
1441  4D4C 0200  
1442  4D4E 1002         JMP     H103                    ----
1443            *                                       
1444  4D50 0206 EDSR04  LI      R6,>0300                DSK3
1444  4D52 0300  
1445            *                                       
1446  4D54 C1CB H103    MOV     R11,R7                  save return address
1447  4D56 06A0         BL      @PRPFDO                 prepare file operations
1447  4D58 440E  
1448  4D5A C029 H104    MOV     @>0054(R9),R0           PAB ptr
1448  4D5C 0054  
1449  4D5E 0429         BLWP    @>005A(R9)              set VDP to read
1449  4D60 005A  
1450  4D62 0002         DATA    >0002                   address in R0
1451  4D64 D06F         MOVB    @-1026(R15),R1          get opcode
1451  4D66 FBFE  
1452  4D68 0981         SRL     R1,8                    
1453  4D6A 0281         CI      R1,>0009                check range
1453  4D6C 0009  
1454  4D6E 1B19         JH      ERROR8                  illegal opcode
1455  4D70 0282         CI      R2,>0001                filename lenght (including . )
1455  4D72 0001  
1456  4D74 1605         JNE     H105                    no filename: dir
1457  4D76 0221         AI      R1,10                   only allow open, close and read
1457  4D78 000A  
1458  4D7A 0281         CI      R1,>000C                        
1458  4D7C 000C  
1459  4D7E 1B11         JH      ERROR8                  others are illegal
1460  4D80 A041 H105    A       R1,R1                   make it a word ptr
1461  4D82 C061         MOV     @OPCVEC(R1),R1          get vector
1461  4D84 4D88  
1462  4D86 0451         B       *R1                     branch to it
1463            *                                       
1464  4D88 4DA8 OPCVEC  DATA    OPEN                    open
1465  4D8A 4FBA         DATA    CLOSE                   close
1466  4D8C 4FC4         DATA    READ                    read
1467  4D8E 50AE         DATA    WRITE                   write
1468  4D90 5362         DATA    RWIND1                  rewind
1469  4D92 53B6         DATA    LOAD                    load
1470  4D94 5458         DATA    SAVE                    save
1471  4D96 4758         DATA    DELETE                  delete
1472  4D98 4988         DATA    RETERR                  scratch record: return with bad attribute error
1473  4D9A 54DC         DATA    STATUS                  status
1474            *                                       
1475  4D9C 559C         DATA    OPNDIR                  open directory
1476  4D9E 55FA         DATA    CLSDIR                  close directory
1477  4DA0 5610         DATA    RDDIR                   read directory
1478            *                                       
1479  4DA2 06A0 ERROR8  BL      @ERROR5                 return with error
1479  4DA4 495C  
1480  4DA6 6000         DATA    >6000                   illegal opcode
1481            *
1482            *---------------------------------
1483            * Opcode 0: Open
1484            * --------------
1485            * PAB 0: >00
1486            *     1: file type  <--- error code
1487            *   2-3:
1488            *     4: record length
1489            *     5:
1490            *   6-7: # of records (if output)
1491            *     8:
1492            *---------------------------------                                      
1493            *
1494  4DA8 04C0 OPEN    CLR     R0                      
1495  4DAA D02F         MOVB    @-1026(R15),R0          get file attributes
1495  4DAC FBFE  
1496  4DAE 0429         BLWP    @>005A(R9)                      
1496  4DB0 005A  
1497  4DB2 8000         DATA    >8000                   save R0
1498  4DB4 0240         ANDI    R0,>1600                keep fix/var and access mode
1498  4DB6 1600  
1499  4DB8 0280         CI      R0,>0600                        
1499  4DBA 0600  
1500  4DBC 1603         JNE     H106                    
1501  4DBE 06A0 ERROR9  BL      @ERROR5                 dis/fix, open as append: return with error
1501  4DC0 495C  
1502  4DC2 4000         DATA    >4000                   bad attribute
1503            *                                       
1504  4DC4 120A H106    JLE     H107                    
1505  4DC6 C040         MOV     R0,R1                   var
1506  4DC8 06A0         BL      @PABR2B                 get 2 bytes from PAB into R0
1506  4DCA 4854  
1507  4DCC 0004         DATA    4                       rec len and char count
1508  4DCE 0280         CI      R0,>FF00                is rec len 255?
1508  4DD0 FF00  
1509  4DD2 14F5         JHE     ERROR9                  yes: bad attribute
1510  4DD4 C001         MOV     R1,R0                   retrieve attributes
1511  4DD6 0240         ANDI    R0,>0600                keep only access mode
1511  4DD8 0600  
1512            *                                       
1513  4DDA 0280 H107    CI      R0,>0200                is it output?
1513  4DDC 0200  
1514  4DDE 1657         JNE     H113                    no
1515  4DE0 06A0         BL      @CALSUB                 call subroutine
1515  4DE2 4342  
1516  4DE4 447A         DATA    CRFIL1                  create file
1517  4DE6 06A0 H108    BL      @PRFDRS                 coin status byte in FDR style
1517  4DE8 4F68  
1518  4DEA 0429         BLWP    @>005A(R9)              set VDP to write
1518  4DEC 005A  
1519  4DEE 0083         DATA    >0083                   address in R4: status byte in FDR buffer
1520  4DF0 DBC2         MOVB    R2,@-2(R15)             write file status in FDR
1520  4DF2 FFFE  
1521  4DF4 C0E9         MOV     @>0054(R9),R3           PAB ptr
1521  4DF6 0054  
1522  4DF8 0223         AI      R3,4                    ptr to rec len
1522  4DFA 0004  
1523  4DFC 04C5         CLR     R5                      
1524  4DFE 0429         BLWP    @>005A(R9)              set VDP to read
1524  4E00 005A  
1525  4E02 0062         DATA    >0062                   address in R3
1526  4E04 D16F         MOVB    @-1026(R15),R5          get record length
1526  4E06 FBFE  
1527  4E08 1607         JNE     H109                    
1528  4E0A 0205         LI      R5,>5000                >00: default it 80
1528  4E0C 5000  
1529  4E0E 0429         BLWP    @>005A(R9)              set VDP to write
1529  4E10 005A  
1530  4E12 0063         DATA    >0063                   address in R3
1531  4E14 DBC5         MOVB    R5,@-2(R15)             write default rec len
1531  4E16 FFFE  
1532  4E18 0224 H109    AI      R4,5                    point to rec len byte in FDR
1532  4E1A 0005  
1533  4E1C 0429         BLWP    @>005A(R9)              set VDP to write
1533  4E1E 005A  
1534  4E20 0083         DATA    >0083                   address in R4
1535  4E22 DBC5         MOVB    R5,@-2(R15)             write rec len in FDR buffer
1535  4E24 FFFE  
1536  4E26 0201         LI      R1,256                  256 bytes/sector
1536  4E28 0100  
1537  4E2A C082         MOV     R2,R2                   var or dis?
1538  4E2C 1101         JLT     H110                    var
1539  4E2E 1002         JMP     H111                    dis
1540  4E30 A141 H110    A       R1,R5                   var: rec len +1
1541  4E32 0601         DEC     R1                      254 bytes only (needs size byte)
1542  4E34 06C5 H111    SWPB    R5                      make it a word
1543  4E36 04C0         CLR     R0                      
1544  4E38 3C05         DIV     R5,R0                   how many times in 254/255 bytes?
1545  4E3A 0224         AI      R4,-4                   point to # of rec/sect in FDR
1545  4E3C FFFC  
1546  4E3E C040         MOV     R0,R1                   save result for later
1547  4E40 06C0         SWPB    R0                      
1548  4E42 0429         BLWP    @>005A(R9)              set VDP to write
1548  4E44 005A  
1549  4E46 0083         DATA    >0083                   address in R4
1550  4E48 DBC0         MOVB    R0,@-2(R15)             write # of rec/sect in FDR
1550  4E4A FFFE  
1551  4E4C C229         MOV     @>0056(R9),R8           point to filename in FDR
1551  4E4E 0056  
1552  4E50 0429         BLWP    @>005A(R9)              set VDP to read
1552  4E52 005A  
1553  4E54 0102         DATA    >0102                   address in R8
1554  4E56 D02F         MOVB    @-1026(R15),R0          get first char
1554  4E58 FBFE  
1555  4E5A 0260         ORI     R0,>8000                flag it: update FDR before leaving
1555  4E5C 8000  
1556  4E5E 0429         BLWP    @>005A(R9)              set VDP to write
1556  4E60 005A  
1557  4E62 0103         DATA    >0103                   address in R8
1558  4E64 DBC0         MOVB    R0,@-2(R15)             write it back
1558  4E66 FFFE  
1559  4E68 0429         BLWP    @>005A(R9)                      
1559  4E6A 005A  
1560  4E6C 8001         DATA    >8001                   retrieve R0 (access mode)
1561  4E6E 06A0         BL      @PABR2B                 get 2 bytes from PAB into R0
1561  4E70 4854  
1562  4E72 0006         DATA    6                       required size in records
1563  4E74 C100         MOV     R0,R4                   
1564  4E76 1309         JEQ     H112                    no size specified
1565  4E78 11A2         JLT     ERROR9                  return with bad attribute error
1566  4E7A A101         A       R1,R4                   round up to record size
1567  4E7C 0604         DEC     R4                      
1568  4E7E 04C3         CLR     R3                      
1569  4E80 3CC1         DIV     R1,R3                   how many sectors will this be?
1570  4E82 0603         DEC     R3                      offset start from 0
1571  4E84 06A0         BL      @CALSUB                 call subroutine
1571  4E86 4342  
1572  4E88 464A         DATA    APSCTS                  add sectors to FDR to match offset in R3
1573  4E8A 0460 H112    B       @RWIND2                 initialise file control block and return to caller
1573  4E8C 5390  
1574            *                                       
1575  4E8E 0429 H113    BLWP    @>005A(R9)              not output
1575  4E90 005A  
1576  4E92 8000         DATA    >8000                   save R0
1577  4E94 06A0         BL      @CALSUB                 call subroutine
1577  4E96 4342  
1578  4E98 4AEC         DATA    FNDFDR                  find FDR on disk
1579  4E9A 0429         BLWP    @>005A(R9)                      
1579  4E9C 005A  
1580  4E9E 8001         DATA    >8001                   retrieve R0 (access mode)
1581  4EA0 C104         MOV     R4,R4                   found FDR?
1582  4EA2 1309         JEQ     H115                    yes
1583  4EA4 0280         CI      R0,>0400                no: is file open as input?
1583  4EA6 0400  
1584  4EA8 1304         JEQ     H114                    yes: must exist
1585  4EAA 06A0         BL      @CALSUB                 no: call subroutine
1585  4EAC 4342  
1586  4EAE 448C         DATA    CRFIL3                  create file
1587  4EB0 109A         JMP     H108                    
1588            *                                       
1589  4EB2 0460 H114    B       @ERROR9                 return with bad attribute error
1589  4EB4 4DBE  
1590            *                                       
1591  4EB6 C1C0 H115    MOV     R0,R7                   save access mode
1592  4EB8 06A0         BL      @PRFDRS                 prepare status byte for FDR
1592  4EBA 4F68  
1593  4EBC 0429         BLWP    @>005A(R9)              set VDP to read
1593  4EBE 005A  
1594  4EC0 0082         DATA    >0082                   address in R4 (status byte in FDR)
1595  4EC2 D02F         MOVB    @-1026(R15),R0          get current file status
1595  4EC4 FBFE  
1596  4EC6 C0C0         MOV     R0,R3                   save it
1597  4EC8 0243         ANDI    R3,>0800                is file write protected?
1597  4ECA 0800  
1598  4ECC 1306         JEQ     H116                    no
1599  4ECE 0287         CI      R7,>0400                yes: is it open as input?
1599  4ED0 0400  
1600  4ED2 1303         JEQ     H116                    no
1601  4ED4 06A0         BL      @ERROR5                 yes: return with error
1601  4ED6 495C  
1602  4ED8 2000         DATA    >2000                   write protected
1603            *                                       
1604  4EDA 0240 H116    ANDI    R0,>8300                keep only file type bits (V/F, D/I, Prg/Data)
1604  4EDC 8300  
1605  4EDE 2802         XOR     R2,R0                   compare with new (coined by PRFDRS)
1606  4EE0 16E8         JNE     H114                    different: bad attribute
1607  4EE2 C0E9         MOV     @>0054(R9),R3           PAB ptr
1607  4EE4 0054  
1608  4EE6 0223         AI      R3,4                    ptr to rec len in PAB
1608  4EE8 0004  
1609  4EEA 0224         AI      R4,5                    ptr to rec len in FDR
1609  4EEC 0005  
1610  4EEE 0429         BLWP    @>005A(R9)              set VDP to read
1610  4EF0 005A  
1611  4EF2 0082         DATA    >0082                   address in R4
1612  4EF4 D02F         MOVB    @-1026(R15),R0          get rec len from FDR
1612  4EF6 FBFE  
1613  4EF8 0429         BLWP    @>005A(R9)              set VDP to read
1613  4EFA 005A  
1614  4EFC 0062         DATA    >0062                   address in R3
1615  4EFE D0AF         MOVB    @-1026(R15),R2          get rec len from PAB
1615  4F00 FBFE  
1616  4F02 1302         JEQ     H117                    0 = keep current one
1617  4F04 9080         CB      R0,R2                   are they identical?
1618  4F06 16D5         JNE     H114                    no: bad attribute
1619  4F08 0429 H117    BLWP    @>005A(R9)              set VDP to write
1619  4F0A 005A  
1620  4F0C 0063         DATA    >0063                   address in R3
1621  4F0E DBC0         MOVB    R0,@-2(R15)             update rec len in PAB (in case it was 0)
1621  4F10 FFFE  
1622  4F12 0429         BLWP    @>005A(R9)              retrieve R0 (open mode)
1622  4F14 005A  
1623  4F16 8001         DATA    >8001                   
1624  4F18 0240         ANDI    R0,>0600                keep only access mode
1624  4F1A 0600  
1625  4F1C 04C2         CLR     R2                      
1626  4F1E 0703         SETO    R3                      
1627  4F20 0280         CI      R0,>0600                is it append
1627  4F22 0600  
1628  4F24 161D         JNE     H118                    no
1629  4F26 C129         MOV     @>0056(R9),R4           yes: get FDR ptr
1629  4F28 0056  
1630  4F2A C1C4         MOV     R4,R7                   save it
1631  4F2C 0224         AI      R4,14                   ptr to # of sectors
1631  4F2E 000E  
1632  4F30 0429         BLWP    @>005A(R9)              set VDP to read
1632  4F32 005A  
1633  4F34 0082         DATA    >0082                   address in R4
1634  4F36 D0EF         MOVB    @-1026(R15),R3          get # of sectors in file
1634  4F38 FBFE  
1635  4F3A 06C3         SWPB    R3                      
1636  4F3C D0EF         MOVB    @-1026(R15),R3                  
1636  4F3E FBFE  
1637  4F40 06C3         SWPB    R3                      
1638  4F42 D0AF         MOVB    @-1026(R15),R2          get eof offset
1638  4F44 FBFE  
1639  4F46 0603         DEC     R3                      offset starts from 0
1640  4F48 110B         JLT     H118                    file is empty (0 sectors)
1641  4F4A 0429         BLWP    @>005A(R9)                      
1641  4F4C 005A  
1642  4F4E 3000         DATA    >3000                   save R2 + R3
1643  4F50 0227         AI      R7,256                  ptr to data buffer area for this file
1643  4F52 0100  
1644  4F54 06A0         BL      @CALSUB                 call subroutine
1644  4F56 4342  
1645  4F58 4614         DATA    RDOFSC                  read a sector, from offset in R3
1646  4F5A 0429         BLWP    @>005A(R9)                      
1646  4F5C 005A  
1647  4F5E 3001         DATA    >3001                   retrieve R2 + R3
1648  4F60 06A0 H118    BL      @UPDFCB                 update current record offset in file ctrl block
1648  4F62 4F92  
1649  4F64 0460         B       @RTURN1                 return to caller
1649  4F66 4360  
1650            *                                       
1651  4F68 0429 PRFDRS  BLWP    @>005A(R9)              prepare file status byte for FDR
1651  4F6A 005A  
1652  4F6C 8001         DATA    >8001                   access mode in R0
1653  4F6E 0429         BLWP    @>005A(R9)                      
1653  4F70 005A  
1654  4F72 8000         DATA    >8000                   save it back
1655  4F74 0202         LI      R2,2                    int in FDR status byte
1655  4F76 0002  
1656  4F78 C129         MOV     @>0056(R9),R4           FDR pointer
1656  4F7A 0056  
1657  4F7C 0A40         SLA     R0,4                    fix or var?
1658  4F7E 1703         JNC     H119                    fix
1659  4F80 0202         LI      R2,>0082                int var in FDR
1659  4F82 0082  
1660  4F84 C000         MOV     R0,R0                   dis or int?
1661  4F86 1101 H119    JLT     H120                    int
1662  4F88 0642         DECT    R2                      dis: remove the int from FDR status
1663  4F8A 0224 H120    AI      R4,12                   point at file status byte in FDR
1663  4F8C 000C  
1664  4F8E 06C2         SWPB    R2                      
1665  4F90 045B         B       *R11                    
1666            *                                       
1667  4F92 C129 UPDFCB  MOV     @>0056(R9),R4           update sect + rec offsets in file control block
1667  4F94 0056  
1668  4F96 0224         AI      R4,-6                   
1668  4F98 FFFA  
1669  4F9A 0429         BLWP    @>005A(R9)              set VDP to write
1669  4F9C 005A  
1670  4F9E 0083         DATA    >0083                   address in R4
1671  4FA0 DBC3         MOVB    R3,@-2(R15)             write current sect offset
1671  4FA2 FFFE  
1672  4FA4 06C3         SWPB    R3                      
1673  4FA6 DBC3         MOVB    R3,@-2(R15)                     
1673  4FA8 FFFE  
1674  4FAA 0224         AI      R4,4                    point to logical rec offset (for var files)
1674  4FAC 0004  
1675  4FAE 0429         BLWP    @>005A(R9)              set VDP to write
1675  4FB0 005A  
1676  4FB2 0083         DATA    >0083                   address in R4
1677  4FB4 DBC2         MOVB    R2,@-2(R15)             write record offset
1677  4FB6 FFFE  
1678  4FB8 045B         B       *R11                    
1679            *
1680            *----------------------------------
1681            * Opcode 1: Close
1682            * --------------
1683            * PAB 0: >01
1684            *     1:           <--- error code
1685            *   2-3:
1686            *     4:
1687            *     5:
1688            *   6-7:
1689            *     8:
1690            *----------------------------------                                     
1691            *
1692  4FBA 06A0 CLOSE   BL      @CALSUB                 call subroutine
1692  4FBC 4342  
1693  4FBE 51B8         DATA    FFDRVP                  find file FDR
1694  4FC0 0460         B       @UPDFDR                 update FDR + data area, get VIB, return to caller
1694  4FC2 4560  
1695            *
1696            *----------------------------------
1697            * Opcode 2: Read
1698            * --------------
1699            * PAB 0: >02
1700            *     1: file type <--- error code
1701            *   2-3: data buffer address in VDP mem
1702            *     4:
1703            *     5: bytes read
1704            *   6-7: record #
1705            *     8:
1706            *
1707            * Logical records organisation whithin sectors
1708            *
1709            * Fixed records (e.g. rec length = 6)
1710            * 11 11 11 11 11 11 22 22 22 22 22 22 33 33 33 33 33 33 xx xx xx
1711            * Where 11=data for record 1, 22=record 2, 33=record 3, xx=junk bytes
1712            *
1713            * Variable records:
1714            * sz 11 11 11 11 11 11 11 sz 22 22 22 22 22 sz 33 33 FF xx xx xx
1715            * Where sz=record size, 11,22,33=record data, FF=end-of-sector mark, xx=junk
1716            *----------------------------------                                     
1717            *
1718  4FC4 06A0 READ    BL      @CALSUB                 call subroutine
1718  4FC6 4342  
1719  4FC8 51B8         DATA    FFDRVP                  find FDR in VDP buffers, get status from PAB
1720  4FCA 0240         ANDI    R0,>0200                what type of access?
1720  4FCC 0200  
1721  4FCE 1302         JEQ     H122                    update or input: ok
1722  4FD0 0460 H121    B       @ERROR8                 append or output: error illegal opcode
1722  4FD2 4DA2  
1723  4FD4 06A0 H122    BL      @RFDRST                 get status byte in R0, from FDR
1723  4FD6 51E4  
1724  4FD8 110A         JLT     H125                    var
1725  4FDA 06A0         BL      @RRNPAB                 fix: get rec # compare to # of recs/file
1725  4FDC 51F8  
1726  4FDE 1A03         JL      H124                    ok: in file
1727  4FE0 06A0 H123    BL      @ERROR5                 update data and return with error
1727  4FE2 495C  
1728  4FE4 A000         DATA    >A000                   eof reached
1729  4FE6 06A0 H124    BL      @CALSUB                 call subroutine
1729  4FE8 4342  
1730  4FEA 525E         DATA    RRFDR                   load record from disk into FDR data buffer area
1731  4FEC 1011         JMP     H126                    
1732            *                                       
1733  4FEE 06A0 H125    BL      @CALSUB                 var: call subroutine
1733  4FF0 4342  
1734  4FF2 504A         DATA    RRSEC                   load proper sector, point to rec in it
1735  4FF4 10F5         JMP     H123                    skipped if ok: return with eof reached
1736            *                                       
1737  4FF6 0582         INC     R2                      next byte in data buffer
1738  4FF8 A004         A       R4,R0                   add rec size to offset
1739  4FFA 0580         INC     R0                      room for end-of-sector mark
1740  4FFC C169         MOV     @>0056(R9),R5           FDR ptr
1740  4FFE 0056  
1741  5000 0645         DECT    R5                      point to var record offset in sector
1742  5002 06C0         SWPB    R0                      
1743  5004 0429         BLWP    @>005A(R9)              set VDP to write
1743  5006 005A  
1744  5008 00A3         DATA    >00A3                   address in R5
1745  500A DBC0         MOVB    R0,@-2(R15)             update var record offset in sector
1745  500C FFFE  
1746  500E C004         MOV     R4,R0                   save # of bytes to be read
1747  5010 C129 H126    MOV     @>0054(R9),R4           PAB ptr
1747  5012 0054  
1748  5014 0224         AI      R4,5                    point to char count
1748  5016 0005  
1749  5018 06C0         SWPB    R0                      
1750  501A 0429         BLWP    @>005A(R9)              set VDP to write
1750  501C 005A  
1751  501E 0083         DATA    >0083                   address in R4
1752  5020 DBC0         MOVB    R0,@-2(R15)             write # of char to be read
1752  5022 FFFE  
1753  5024 06C0         SWPB    R0                      make it a word
1754            *                                       
1755  5026 C000 WFDRPB  MOV     R0,R0                   check it
1756  5028 130E         JEQ     H128                    none: return
1757  502A 0429 H127    BLWP    @>005A(R9)              set VDP to read
1757  502C 005A  
1758  502E 0042         DATA    >0042                   address in R2
1759  5030 D0EF         MOVB    @-1026(R15),R3          read 1 byte from FDR data buffer area
1759  5032 FBFE  
1760  5034 0582         INC     R2                      increment source ptr
1761  5036 0429         BLWP    @>005A(R9)              set VDP to write
1761  5038 005A  
1762  503A 0023         DATA    >0023                   address in R1
1763  503C DBC3         MOVB    R3,@-2(R15)             write the byte in PAB data buffer
1763  503E FFFE  
1764  5040 0581         INC     R1                      increment destination ptr
1765  5042 0600         DEC     R0                      more to read?
1766  5044 16F2         JNE     H127                    yes
1767  5046 0460 H128    B       @RTURN1                 return to caller
1767  5048 4360  
1768            *                                       
1769  504A 06A0 RRSEC   BL      @RCOFCB                 load sector, point to record in it
1769  504C 5338  
1770  504E C0C3         MOV     R3,R3                   sector offset
1771  5050 1101         JLT     H129                    -1: top of file
1772  5052 1012         JMP     H130                    in file
1773  5054 C003 H129    MOV     R3,R0                   
1774  5056 0580         INC     R0                      next sector
1775  5058 8080         C       R0,R2                   compare to # of sect/file
1776  505A 13F5         JEQ     H128                    end-of-file reached: return to caller (JMP to err)
1777  505C 06A0         BL      @CALSUB                 call subroutine
1777  505E 4342  
1778  5060 4580         DATA    UPDBF                   update data buffer, if needed
1779  5062 C0C0         MOV     R0,R3                   desired offset
1780  5064 04C5         CLR     R5                      
1781  5066 06A0         BL      @UCOFCB                 update sect + rec offsets in control block
1781  5068 52D6  
1782  506A 0227         AI      R7,256                  point to data buffer area (R7 set by UCOFCB)
1782  506C 0100  
1783  506E 06A0         BL      @CALSUB                 call subroutine
1783  5070 4342  
1784  5072 4614         DATA    RDOFSC                  read a sector, from offset in file (in R3)
1785  5074 04C0         CLR     R0                      
1786  5076 1004         JMP     H131                    
1787            *                                       
1788  5078 C000 H130    MOV     R0,R0                   in file: test var rec offset (from RCOFCB)
1789  507A 1602         JNE     H131                    inside sector
1790  507C 8080         C       R0,R2                   at beg of sector
1791  507E 13E3         JEQ     H128                    file is empty: return
1792  5080 C080 H131    MOV     R0,R2                   FDR data buffer will be added to R2 by AFDRPT
1793  5082 06A0         BL      @CALSUB                 call subroutine
1793  5084 4342  
1794  5086 52B2         DATA    AFDRPT                  R2=byte in FDR data buf, R1=top of PAB data buf
1795  5088 0429         BLWP    @>005A(R9)              set VDP to read
1795  508A 005A  
1796  508C 0042         DATA    >0042                   address in R2
1797  508E D12F         MOVB    @-1026(R15),R4          get first byte (rec length)
1797  5090 FBFE  
1798  5092 0984         SRL     R4,8                    make it a word
1799  5094 C000         MOV     R0,R0                   var rec offset
1800  5096 1306         JEQ     H132                    
1801  5098 0284         CI      R4,>00FF                is it >FF (end of sector mark) ?
1801  509A 00FF  
1802  509C 1603         JNE     H132                    no
1803  509E 06A0         BL      @RCOFCB                 yes: get sect + rec offsets from control block
1803  50A0 5338  
1804  50A2 10D8         JMP     H129                    try again with next sector
1805            *                                       
1806  50A4 0429 H132    BLWP    @>005A(R9)                      
1806  50A6 005A  
1807  50A8 0011         DATA    >0011                   retrieve return address from stack in R11
1808  50AA 05CB         INCT    R11                     skip the JMP to eof reached error
1809  50AC 045B         B       *R11                    
1810            *
1811            *------------------------------------
1812            * Opcode 3: Write
1813            * --------------
1814            * PAB 0: >03
1815            *     1: file type <--- error code
1816            *   2-3: data buffer address in VDP mem
1817            *     4:
1818            *     5: bytes to write
1819            *   6-7: record #
1820            *     8:
1821            *------------------------------------                                   
1822            *
1823  50AE 06A0 WRITE   BL      @CALSUB                 call subroutine
1823  50B0 4342  
1824  50B2 51B8         DATA    FFDRVP                  find FDR in VDP buffers
1825  50B4 0240         ANDI    R0,>0600                keep only access mode
1825  50B6 0600  
1826  50B8 0280         CI      R0,>0400                is it input
1826  50BA 0400  
1827  50BC 1389         JEQ     H121                    yes: return with error illegal opcode
1828  50BE 06A0         BL      @RFDRST                 get file status byte from FDR
1828  50C0 51E4  
1829  50C2 1113         JLT     H134                    var                     
1830  50C4 06A0         BL      @RRNPAB                 fix: get rec # from PAB, sect # in R0
1830  50C6 51F8  
1831  50C8 1A0C         JL      H133                    less that total rec/file
1832  50CA 0429         BLWP    @>005A(R9)              past eof: expand file
1832  50CC 005A  
1833  50CE D800         DATA    >D800                   save R0, R1, R3, R4
1834  50D0 C0C0         MOV     R0,R3                   desired sector offset
1835  50D2 06A0         BL      @CALSUB                 call subroutine
1835  50D4 4342  
1836  50D6 464A         DATA    APSCTS                  append enough sectors to reach offset in R3
1837  50D8 0429         BLWP    @>005A(R9)                      
1837  50DA 005A  
1838  50DC D801         DATA    >D801                   restore R0, R1, R3, R4
1839  50DE 06A0         BL      @URFFDR                 update # of rec/file in FDR
1839  50E0 5302  
1840            *                                       
1841  50E2 06A0 H133    BL      @CALSUB                 in file: call subroutine
1841  50E4 4342  
1842  50E6 525E         DATA    RRFDR                   fetch rec from disk into FDR data buffer area
1843  50E8 1053         JMP     H138                    set update data flag, write data, return
1844            *                                       
1845  50EA 06A0 H134    BL      @RCOFCB                 var: R2=sect/file R3=sect offset R0=rec offset
1845  50EC 5338  
1846  50EE C0C3         MOV     R3,R3                   sector offset in file
1847  50F0 1101         JLT     H135                    -1: top of file
1848  50F2 100B         JMP     H136                    in file
1849  50F4 0429 H135    BLWP    @>005A(R9)              next sector loop
1849  50F6 005A  
1850  50F8 3000         DATA    >3000                   save R2 + R3
1851  50FA 06A0         BL      @CALSUB                 call subroutine
1851  50FC 4342  
1852  50FE 4580         DATA    UPDBF                   update data buffer if needed
1853  5100 0429         BLWP    @>005A(R9)                      
1853  5102 005A  
1854  5104 3001         DATA    >3001                   retrieve R2 + R3
1855  5106 0583         INC     R3                      next sector
1856  5108 04C0         CLR     R0                      init char offset in sector
1857            *                                       
1858  510A 8083 H136    C       R3,R2                   did we reach last sector?
1859  510C 1609         JNE     H137                    no
1860  510E 0429         BLWP    @>005A(R9)              yes: expand file
1860  5110 005A  
1861  5112 9000         DATA    >9000                   save R0 + R4
1862  5114 06A0         BL      @CALSUB                 call subroutine
1862  5116 4342  
1863  5118 464A         DATA    APSCTS                  get last sector then append sectors to reach R3
1864  511A 0429         BLWP    @>005A(R9)                      
1864  511C 005A  
1865  511E 9001         DATA    >9001                   retrieve R0 + R4
1866            *                                       
1867  5120 C169 H137    MOV     @>0054(R9),R5           PAB ptr
1867  5122 0054  
1868  5124 0225         AI      R5,5                    point to char count
1868  5126 0005  
1869  5128 0429         BLWP    @>005A(R9)              set VDP to read
1869  512A 005A  
1870  512C 00A2         DATA    >00A2                   address in R5
1871  512E D12F         MOVB    @-1026(R15),R4          get # of chars to write
1871  5130 FBFE  
1872  5132 0984         SRL     R4,8                    make it a word
1873  5134 C144         MOV     R4,R5                   
1874  5136 A140         A       R0,R5                   add current char offset in sector
1875  5138 0585         INC     R5                      make room for size byte
1876  513A 0285         CI      R5,>00FF                past end of sector?
1876  513C 00FF  
1877  513E 1BDA         JH      H135                    yes: not enough room, try next sector
1878  5140 0702         SETO    R2                      ok: rec will fit in sector
1879  5142 C069         MOV     @>0056(R9),R1           FDR ptr
1879  5144 0056  
1880  5146 A045         A       R5,R1                   past-last-byte offset
1881  5148 0221         AI      R1,256                  ptr to data buffer area
1881  514A 0100  
1882  514C 0429         BLWP    @>005A(R9)              set VDP to write
1882  514E 005A  
1883  5150 0023         DATA    >0023                   address in R1
1884  5152 DBC2         MOVB    R2,@-2(R15)             write end-of-sect mark to FDR data buffer area
1884  5154 FFFE  
1885  5156 0429         BLWP    @>005A(R9)                      
1885  5158 005A  
1886  515A 8000         DATA    >8000                   save R0 (current byte offset in sector)
1887  515C C003         MOV     R3,R0                   
1888  515E 06A0         BL      @UCOFCB                 update sect + rec offsets in control block
1888  5160 52D6  
1889  5162 0221         AI      R1,18                   point to eof offset in FDR (R1 modified by UCOFCB)
1889  5164 0012  
1890  5166 0429         BLWP    @>005A(R9)              set VDP to write
1890  5168 005A  
1891  516A 0023         DATA    >0023                   address in R1
1892  516C DBC5         MOVB    R5,@-2(R15)             update eof offset in last sector, in FDR
1892  516E FFFE  
1893  5170 06A0         BL      @URFFDR                 update # of rec/file in FDR
1893  5172 5302  
1894  5174 0429         BLWP    @>005A(R9)                      
1894  5176 005A  
1895  5178 2001         DATA    >2001                   retrieve old R0 in R2 (current byte offset)
1896  517A C004         MOV     R4,R0                   record size
1897  517C 06A0         BL      @CALSUB                 call subroutine
1897  517E 4342  
1898  5180 52B2         DATA    AFDRPT                  get FDR data buffer in R2, PAB data buffer in R1
1899  5182 06C4         SWPB    R4                      
1900  5184 0429         BLWP    @>005A(R9)              set VDP to write
1900  5186 005A  
1901  5188 0043         DATA    >0043                   address in R2
1902  518A DBC4         MOVB    R4,@-2(R15)             write size byte to FDR data buffer
1902  518C FFFE  
1903  518E 0582         INC     R2                      increment dest pointer
1904            *                                       
1905  5190 C0C2 H138    MOV     R2,R3                   invert source and dest
1906  5192 C081         MOV     R1,R2                   so we can use the same read-write loop
1907  5194 C043         MOV     R3,R1                   than the read opcode
1908  5196 C129         MOV     @>0056(R9),R4           FDR ptr
1908  5198 0056  
1909  519A 0604         DEC     R4                      pointer to drive # for that file
1910  519C 0429         BLWP    @>005A(R9)              set VDP to read
1910  519E 005A  
1911  51A0 0082         DATA    >0082                   address in R4
1912  51A2 D16F         MOVB    @-1026(R15),R5          get drive #
1912  51A4 FBFE  
1913  51A6 0265         ORI     R5,>8000                add update data area flag
1913  51A8 8000  
1914  51AA 0429         BLWP    @>005A(R9)              set VDP to write
1914  51AC 005A  
1915  51AE 0083         DATA    >0083                   address in R4
1916  51B0 DBC5         MOVB    R5,@-2(R15)             write back flagged byte
1916  51B2 FFFE  
1917  51B4 0460         B       @WFDRPB                 to read-write loop
1917  51B6 5026  
1918            *                                       
1919  51B8 06A0 FFDRVP  BL      @CALSUB                 find FDR in VDP buffer
1919  51BA 4342  
1920  51BC 4A8E         DATA    FFFDRV                  find file FDR
1921  51BE C104         MOV     R4,R4                   found?
1922  51C0 1303         JEQ     AFPGPF                  yes
1923  51C2 06A0         BL      @ERROR5                 no: return with error
1923  51C4 495C  
1924  51C6 E000         DATA    >E000                   file error
1925  51C8 0581 AFPGPF  INC     R1                      point to filename in FDR
1926  51CA CA41         MOV     R1,@>0056(R9)           new FDR ptr
1926  51CC 0056  
1927  51CE C129         MOV     @>0054(R9),R4           get PAB ptr
1927  51D0 0054  
1928  51D2 0584         INC     R4                      point to status byte
1929  51D4 04C0         CLR     R0                      
1930  51D6 0429         BLWP    @>005A(R9)              set VDP to read
1930  51D8 005A  
1931  51DA 0082         DATA    >0082                   address in R4
1932  51DC D02F         MOVB    @-1026(R15),R0          get file status
1932  51DE FBFE  
1933  51E0 0460         B       @RTURN1                 return to caller
1933  51E2 4360  
1934            *                                       
1935  51E4 C129 RFDRST  MOV     @>0056(R9),R4           get status byte from FDR
1935  51E6 0056  
1936  51E8 0224         AI      R4,12                   point to status byte
1936  51EA 000C  
1937  51EC 0429         BLWP    @>005A(R9)              set VDP to read
1937  51EE 005A  
1938  51F0 0082         DATA    >0082                   address in R4
1939  51F2 D02F         MOVB    @-1026(R15),R0          read status byte
1939  51F4 FBFE  
1940  51F6 045B         B       *R11                    
1941            *                                       
1942  51F8 D16F RRNPAB  MOVB    @-1026(R15),R5          get record # from PAB, check if valid
1942  51FA FBFE  
1943  51FC 0985         SRL     R5,8                    
1944  51FE 1602         JNE     H139                    get # of rec/sector from FDR
1945  5200 0205         LI      R5,256                  0: default to 256
1945  5202 0100  
1946  5204 C0E9 H139    MOV     @>0054(R9),R3           PAB ptr
1946  5206 0054  
1947  5208 0223         AI      R3,6                    point to rec #
1947  520A 0006  
1948  520C 0429         BLWP    @>005A(R9)              set VDP to read
1948  520E 005A  
1949  5210 0062         DATA    >0062                   address in R3
1950  5212 D06F         MOVB    @-1026(R15),R1          get record # from PAB
1950  5214 FBFE  
1951  5216 06C1         SWPB    R1                      
1952  5218 D06F         MOVB    @-1026(R15),R1                  
1952  521A FBFE  
1953  521C 06C1         SWPB    R1                      
1954  521E C001         MOV     R1,R0                   save it
1955  5220 1101         JLT     H140                    too big
1956  5222 1003         JMP     H141                    ok
1957  5224 06A0 H140    BL      @ERROR5                 update data then return with error
1957  5226 495C  
1958  5228 8000         DATA    >8000                   memory full
1959  522A 0580 H141    INC     R0                      next record
1960  522C 0429         BLWP    @>005A(R9)              set VDP to write
1960  522E 005A  
1961  5230 0063         DATA    >0063                   address in R3
1962  5232 DBC0         MOVB    R0,@-2(R15)             write back # of future record
1962  5234 FFFE  
1963  5236 06C0         SWPB    R0                      
1964  5238 DBC0         MOVB    R0,@-2(R15)                     
1964  523A FFFE  
1965  523C 04C0         CLR     R0                      
1966  523E C0C1         MOV     R1,R3                   save # of desired rec
1967  5240 3C05         DIV     R5,R0                   divide by # of rec/sector = sect # in R0
1968  5242 C0A9 RNFISE  MOV     @>0056(R9),R2           FDR ptr
1968  5244 0056  
1969  5246 0222         AI      R2,18                   point to total # of rec (# of sectors for var)
1969  5248 0012  
1970  524A 0429         BLWP    @>005A(R9)              set VDP to read
1970  524C 005A  
1971  524E 0042         DATA    >0042                   address in R2
1972  5250 D0AF         MOVB    @-1026(R15),R2          get total # of recs/file (sect/file for var)
1972  5252 FBFE  
1973  5254 06C2         SWPB    R2                      
1974  5256 D0AF         MOVB    @-1026(R15),R2          remember: bytes are swapped
1974  5258 FBFE  
1975  525A 8083         C       R3,R2                   compare with desired record (ignored by var)
1976  525C 045B         B       *R11                    
1977            *                                       
1978  525E 0429 RRFDR   BLWP    @>005A(R9)              fetch record into FDR data buffer area
1978  5260 005A  
1979  5262 4000         DATA    >4000                   save R1
1980  5264 0224         AI      R4,-18                  ptr to top of control block
1980  5266 FFEE  
1981  5268 0429         BLWP    @>005A(R9)              set VDP to read
1981  526A 005A  
1982  526C 0082         DATA    >0082                   address in R4
1983  526E D16F         MOVB    @-1026(R15),R5          get current sector offset in file
1983  5270 FBFE  
1984  5272 06C5         SWPB    R5                      
1985  5274 D16F         MOVB    @-1026(R15),R5                  
1985  5276 FBFE  
1986  5278 0B85         SRC     R5,8                    
1987  527A 1105         JLT     H142                    -1: top of file
1988  527C 8005         C       R5,R0                   compare with desired offset (from RRNPAB)
1989  527E 130B         JEQ     H143                    same
1990  5280 06A0         BL      @CALSUB                 call subroutine
1990  5282 4342  
1991  5284 4580         DATA    UPDBF                   update data buffer if needed
1992  5286 C0C0 H142    MOV     R0,R3                   desired sector offset in file
1993  5288 06A0         BL      @UCOFCB                 update sect + rec offsets in control block
1993  528A 52D6  
1994  528C 0227         AI      R7,256                  point to data buffer area (R7 set by UCOFCB)
1994  528E 0100  
1995  5290 06A0         BL      @CALSUB                 call subroutine
1995  5292 4342  
1996  5294 4614         DATA    RDOFSC                  read a sector from offset in file (in R3)
1997  5296 0429 H143    BLWP    @>005A(R9)                      
1997  5298 005A  
1998  529A 4001         DATA    >4001                   retrieve R1
1999  529C C0E9         MOV     @>0056(R9),R3           FDR ptr
1999  529E 0056  
2000  52A0 0223         AI      R3,17                   point to record length
2000  52A2 0011  
2001  52A4 0429         BLWP    @>005A(R9)              set VDP to read
2001  52A6 005A  
2002  52A8 0062         DATA    >0062                   address in R3
2003  52AA D02F         MOVB    @-1026(R15),R0          get rec length in bytes
2003  52AC FBFE  
2004  52AE 0980         SRL     R0,8                    make it a word
2005  52B0 3840         MPY     R0,R1                   calc file offset in bytes
2006  52B2 A0A9 AFDRPT  A       @>0056(R9),R2           add FDR ptr
2006  52B4 0056  
2007  52B6 0222         AI      R2,256                  point inside data buffer area
2007  52B8 0100  
2008  52BA C0E9         MOV     @>0054(R9),R3           PAB ptr
2008  52BC 0054  
2009  52BE 05C3         INCT    R3                      point to data buffer address
2010  52C0 0429         BLWP    @>005A(R9)              set VDP to read
2010  52C2 005A  
2011  52C4 0062         DATA    >0062                   address in R3
2012  52C6 D06F         MOVB    @-1026(R15),R1          get PAB data buffer address
2012  52C8 FBFE  
2013  52CA 06C1         SWPB    R1                      
2014  52CC D06F         MOVB    @-1026(R15),R1                  
2014  52CE FBFE  
2015  52D0 06C1         SWPB    R1                      
2016  52D2 0460         B       @RTURN1                 return
2016  52D4 4360  
2017            *                               
2018  52D6 C1E9 UCOFCB  MOV     @>0056(R9),R7           update sect + rec offsets in control block
2018  52D8 0056  
2019  52DA C047         MOV     R7,R1                   FDR ptr
2020  52DC 0221         AI      R1,-6                   top of file control block
2020  52DE FFFA  
2021  52E0 0429         BLWP    @>005A(R9)              set VDP to write
2021  52E2 005A  
2022  52E4 0023         DATA    >0023                   address in R1
2023  52E6 DBC0         MOVB    R0,@-2(R15)             current sector offset in file
2023  52E8 FFFE  
2024  52EA 06C0         SWPB    R0                      
2025  52EC DBC0         MOVB    R0,@-2(R15)                     
2025  52EE FFFE  
2026  52F0 0221         AI      R1,4                    point to var rec offset in sector
2026  52F2 0004  
2027  52F4 06C5         SWPB    R5                      
2028  52F6 0429         BLWP    @>005A(R9)              set VDP to write
2028  52F8 005A  
2029  52FA 0023         DATA    >0023                   address in R1
2030  52FC DBC5         MOVB    R5,@-2(R15)             first free byte in current sector
2030  52FE FFFE  
2031  5300 045B         B       *R11                    
2032            *                                       
2033  5302 C0A9 URFFDR  MOV     @>0056(R9),R2           update # of rec/file in FDR
2033  5304 0056  
2034  5306 0429         BLWP    @>005A(R9)              set VDP to read
2034  5308 005A  
2035  530A 0042         DATA    >0042                   address in R2 (FDR ptr)
2036  530C D2AF         MOVB    @-1026(R15),R10         get first char of filename
2036  530E FBFE  
2037  5310 026A         ORI     R10,>8000               set was modified flag
2037  5312 8000  
2038  5314 0429         BLWP    @>005A(R9)              set VDP to write
2038  5316 005A  
2039  5318 0043         DATA    >0043                   address in R2
2040  531A DBCA         MOVB    R10,@-2(R15)            write flagged char back
2040  531C FFFE  
2041  531E 0222         AI      R2,18                   point to # of recs/file in FDR
2041  5320 0012  
2042  5322 0583         INC     R3                      one more
2043  5324 0429         BLWP    @>005A(R9)              set VDP to write
2043  5326 005A  
2044  5328 0043         DATA    >0043                   address in R2
2045  532A 06C3         SWPB    R3                      update # of recs/file
2046  532C DBC3         MOVB    R3,@-2(R15)                     
2046  532E FFFE  
2047  5330 06C3         SWPB    R3                      
2048  5332 DBC3         MOVB    R3,@-2(R15)                     
2048  5334 FFFE  
2049  5336 045B         B       *R11                    
2050            *                                       
2051  5338 C229 RCOFCB  MOV     @>0056(R9),R8           get rec offset, compare sect with total
2051  533A 0056  
2052  533C C108         MOV     R8,R4                   FDR ptr
2053  533E 0224         AI      R4,256                  point to data buffer area
2053  5340 0100  
2054  5342 0648         DECT    R8                      point to var record offset
2055  5344 0429         BLWP    @>005A(R9)              set VDP to read
2055  5346 005A  
2056  5348 0102         DATA    >0102                   address in R8
2057  534A D0AF         MOVB    @-1026(R15),R2          get var rec offset in current sector
2057  534C FBFE  
2058  534E 0982         SRL     R2,8                    make it a word
2059  5350 C28B         MOV     R11,R10                 save return point
2060  5352 06A0         BL      @FDR2B2                 get 2 bytes from FDR (at R8-4) into R0
2060  5354 485E  
2061  5356 FFFC         DATA    -4                      current sector offset in file
2062  5358 C0C0         MOV     R0,R3                   save it
2063  535A C2CA         MOV     R10,R11                 restore return point
2064  535C C002         MOV     R2,R0                   var record offset
2065  535E 0460         B       @RNFISE                 get # of sect/file from FDR, return
2065  5360 5242  
2066            *
2067            *------------------------------------
2068            * Opcode 4: Rewind
2069            * --------------
2070            * PAB 0: >04
2071            *     1: file type <--- error code
2072            *   2-3:
2073            *     4:
2074            *     5:
2075            *   6-7: record #  <--- >0000 if sequential
2076            *     8:
2077            *------------------------------------                                   
2078            *
2079  5362 06A0 RWIND1  BL      @CALSUB                 call subroutine
2079  5364 4342  
2080  5366 51B8         DATA    FFDRVP                  find FDR in VDP buffers, read status from PAB
2081  5368 0429         BLWP    @>005A(R9)                      
2081  536A 005A  
2082  536C 8000         DATA    >8000                   save R0 (status from PAB)
2083  536E 0240         ANDI    R0,>0600                keep only access mode
2083  5370 0600  
2084  5372 1305         JEQ     H144                    update is ok
2085  5374 0280         CI      R0,>0400                is it input?
2085  5376 0400  
2086  5378 1302         JEQ     H144                    yes: ok
2087  537A 0460         B       @ERROR8                 output or append: return with illegal opcode
2087  537C 4DA2  
2088  537E 06A0 H144    BL      @CALSUB                 call subroutine
2088  5380 4342  
2089  5382 4580         DATA    UPDBF                   update data buffer if needed
2090  5384 0429         BLWP    @>005A(R9)                      
2090  5386 005A  
2091  5388 8001         DATA    >8001                   retrieve R0 (status from PAB)
2092  538A 0240         ANDI    R0,>0100                sequential or reloc?
2092  538C 0100  
2093  538E 1611         JNE     H145                    reloc: don't do anything, return
2094            *                                       
2095  5390 04C2 RWIND2  CLR     R2                      rewind file: record offset = 0
2096  5392 0703         SETO    R3                      current record = -1 (none)
2097  5394 06A0         BL      @UPDFCB                 update file control block
2097  5396 4F92  
2098  5398 04C0         CLR     R0                      record 0
2099  539A C229         MOV     @>0054(R9),R8           get PAB ptr
2099  539C 0054  
2100  539E 0228         AI      R8,6                    point to record #
2100  53A0 0006  
2101  53A2 0429         BLWP    @>005A(R9)              set VDP to write
2101  53A4 005A  
2102  53A6 0103         DATA    >0103                   address in R8
2103  53A8 DBC0         MOVB    R0,@-2(R15)             write record #
2103  53AA FFFE  
2104  53AC 1000         NOP                             
2105  53AE DBC0         MOVB    R0,@-2(R15)                     
2105  53B0 FFFE  
2106  53B2 0460 H145    B       @RTURN1                 return to caller
2106  53B4 4360  
2107            *
2108            *------------------------------------
2109            * Opcode 5: Load
2110            * --------------
2111            * PAB 0: >05
2112            *     1: file type  <--- error code
2113            *   2-3: data buffer address in VDP mem
2114            *     4:
2115            *     5:
2116            *   6-7: maximum # of bytes (size of buffer)
2117            *     8:
2118            *------------------------------------                                   
2119            *
2120  53B6 06A0 LOAD    BL      @CALSUB                 call subroutine
2120  53B8 4342  
2121  53BA 4AEC         DATA    FNDFDR                  find FDR on disk
2122  53BC C104         MOV     R4,R4                   found?
2123  53BE 1303         JEQ     H147                    yes
2124  53C0 06A0 H146    BL      @ERROR5                 no: return with error
2124  53C2 495C  
2125  53C4 E000         DATA    >E000                   file error
2126  53C6 06A0 H147    BL      @FDR2B1                 get 2 bytes from FDR into R0
2126  53C8 485A  
2127  53CA 000C         DATA    12                      file status byte
2128  53CC 0240         ANDI    R0,>0100                is it program?
2128  53CE 0100  
2129  53D0 13F7         JEQ     H146                    no: file error
2130  53D2 05C8         INCT    R8                      point to # of sect/file in FDR
2131  53D4 0429         BLWP    @>005A(R9)              set VDP to read
2131  53D6 005A  
2132  53D8 0102         DATA    >0102                   address in R8
2133  53DA D06F         MOVB    @-1026(R15),R1          get # of sectors in file
2133  53DC FBFE  
2134  53DE 06C1         SWPB    R1                      
2135  53E0 D06F         MOVB    @-1026(R15),R1                  
2135  53E2 FBFE  
2136  53E4 0B81         SRC     R1,8                    
2137  53E6 13EC         JEQ     H146                    0=empty file: return with file error
2138  53E8 06A0         BL      @RBANB                  get data buffer address in R7, # of sectors in R2
2138  53EA 54A8  
2139  53EC 05C8         INCT    R8                      point to eof offset in FDR
2140  53EE 04C4         CLR     R4                      
2141  53F0 0429         BLWP    @>005A(R9)              set VDP to read
2141  53F2 005A  
2142  53F4 0102         DATA    >0102                   address in R8
2143  53F6 D12F         MOVB    @-1026(R15),R4          get # of bytes in last sector
2143  53F8 FBFE  
2144  53FA 8081         C       R1,R2                   compare # of sect with max in PAB
2145  53FC 1BE1         JH      H146                    file is too big: return with file error
2146  53FE 1602         JNE     H148                    file is smaller
2147  5400 8100         C       R0,R4                   same # of sect: check bytes in last sector
2148  5402 1ADE         JL      H146                    file is too big: file error
2149  5404 04C3 H148    CLR     R3                      sector offset in file
2150  5406 06C4         SWPB    R4                      
2151  5408 0601 H149    DEC     R1                      next sector
2152  540A 130D         JEQ     H150                    done
2153  540C 0429         BLWP    @>005A(R9)                      
2153  540E 005A  
2154  5410 D900         DATA    >D900                   save R0, R1, R3, R4, R7
2155  5412 06A0         BL      @CALSUB                 call subroutine
2155  5414 4342  
2156  5416 4614         DATA    RDOFSC                  read a sector from offset in R3
2157  5418 0429         BLWP    @>005A(R9)              restore R0, R1, R3, R4, R7
2157  541A 005A  
2158  541C D901         DATA    >D901                   
2159  541E 0583         INC     R3                      next sector
2160  5420 0227         AI      R7,256                  256 bytes further in PAB buffer
2160  5422 0100  
2161  5424 10F1         JMP     H149                    keep going
2162            *                                       
2163  5426 C104 H150    MOV     R4,R4                   
2164  5428 1604         JNE     H151                    
2165  542A 06A0         BL      @CALSUB                 call subroutine
2165  542C 4342  
2166  542E 4614         DATA    RDOFSC                  read a sector from offset in R3
2167  5430 1011         JMP     H152                    done
2168            *                                       
2169  5432 C147 H151    MOV     R7,R5                   save PAB data buffer ptr
2170  5434 C1E9         MOV     @>0056(R9),R7           FDR ptr
2170  5436 0056  
2171  5438 0227         AI      R7,256                  point to FDR data area
2171  543A 0100  
2172  543C 0429         BLWP    @>005A(R9)                      
2172  543E 005A  
2173  5440 0D00         DATA    >0D00                   save R4, R5, R7
2174  5442 06A0         BL      @CALSUB                 call subroutine
2174  5444 4342  
2175  5446 4614         DATA    RDOFSC                  read a sector from offset in R3
2176  5448 0429         BLWP    @>005A(R9)              restore R4 in R0, R5 in R1, R7 in R2
2176  544A 005A  
2177  544C E001         DATA    >E001                   
2178  544E 06A0         BL      @CALSUB                 call subroutine
2178  5450 4342  
2179  5452 5026         DATA    WFDRPB                  write bytes from FDR data buffer to PAB data buf
2180  5454 0460 H152    B       @UPDFDR                 update FDR, data buffer, VIB and return to caller
2180  5456 4560  
2181            *
2182            *------------------------------------
2183            * Opcode 6: Save
2184            * --------------
2185            * PAB 0: >06
2186            *     1: file type  <--- error code
2187            *   2-3: data buffer address in VDP mem
2188            *     4:
2189            *     5:
2190            *   6-7: # of bytes to save
2191            *     8:
2192            *------------------------------------                                   
2193            *
2194  5458 06A0 SAVE    BL      @CALSUB                 call subroutine
2194  545A 4342  
2195  545C 447A         DATA    CRFIL1                  create file
2196  545E 06A0         BL      @RBANB                  get PAB buffer ptr + # of bytes
2196  5460 54A8  
2197  5462 04C3         CLR     R3                      sector offset 0
2198  5464 0429 H153    BLWP    @>005A(R9)                      
2198  5466 005A  
2199  5468 B100         DATA    >B100                   save R0, R2, R3, R7
2200  546A 06A0         BL      @CALSUB                 call subroutine
2200  546C 4342  
2201  546E 4634         DATA    WROFSC                  write sector to offset in R3
2202  5470 0429         BLWP    @>005A(R9)                      
2202  5472 005A  
2203  5474 B101         DATA    >B101                   retrieve R0, R2, R3, R7
2204  5476 0583         INC     R3                      next sector
2205  5478 0227         AI      R7,256                  256 bytes further in PAB data buffer
2205  547A 0100  
2206  547C 0602         DEC     R2                      next sector
2207  547E 16F2         JNE     H153                    more to do
2208            *                                       
2209  5480 C069         MOV     @>0056(R9),R1           FDR ptr
2209  5482 0056  
2210  5484 0221         AI      R1,12                   point to file status byte
2210  5486 000C  
2211  5488 0202         LI      R2,>0100                value for program file
2211  548A 0100  
2212  548C 0429         BLWP    @>005A(R9)              set VDP to write
2212  548E 005A  
2213  5490 0023         DATA    >0023                   address in R1
2214  5492 DBC2         MOVB    R2,@-2(R15)             write file status byte in FDR
2214  5494 FFFE  
2215  5496 0221         AI      R1,4                    point to eof offset byte in FDR
2215  5498 0004  
2216  549A 0429         BLWP    @>005A(R9)              set VDP to write
2216  549C 005A  
2217  549E 0023         DATA    >0023                   address in R1
2218  54A0 DBC0         MOVB    R0,@-2(R15)             # of bytes in last sector
2218  54A2 FFFE  
2219  54A4 0460         B       @UPDFDR                 update FDR, data buffer, VIB then return to caller
2219  54A6 4560  
2220            *                                       
2221  54A8 C029 RBANB   MOV     @>0054(R9),R0           get buffer address + # of bytes
2221  54AA 0054  
2222  54AC 05C0         INCT    R0                      data buffer in PAB
2223  54AE 0429         BLWP    @>005A(R9)              set VDP to read
2223  54B0 005A  
2224  54B2 0002         DATA    >0002                   address in R0
2225  54B4 D1EF         MOVB    @-1026(R15),R7          get data buffer address
2225  54B6 FBFE  
2226  54B8 06C7         SWPB    R7                      
2227  54BA D1EF         MOVB    @-1026(R15),R7                  
2227  54BC FBFE  
2228  54BE 06C7         SWPB    R7                      
2229  54C0 0220         AI      R0,4                    point to # of bytes to transfer
2229  54C2 0004  
2230  54C4 0429         BLWP    @>005A(R9)              set VDP to read
2230  54C6 005A  
2231  54C8 0002         DATA    >0002                   address in R0
2232  54CA D0AF         MOVB    @-1026(R15),R2          get # of bytes to be transfered
2232  54CC FBFE  
2233  54CE 0982         SRL     R2,8                    make it # of sectors (256 bytes each)
2234  54D0 04C0         CLR     R0                      
2235  54D2 D02F         MOVB    @-1026(R15),R0          see if one more is needed
2235  54D4 FBFE  
2236  54D6 1301         JEQ     H154                    no
2237  54D8 0582         INC     R2                      yes: one more sector
2238  54DA 045B H154    B       *R11                    
2239            *
2240            *-------------------------------------
2241            * Opcode 9: Status
2242            * --------------
2243            * PAB 0: >09
2244            *     1:
2245            *   2-3:
2246            *     4:
2247            *     5:
2248            *   6-7: record #
2249            *     8:           <--- file status
2250            *
2251            * Status bits, returned in PAB byte 8:
2252            * >80: file not found
2253            * >40: file is protected
2254            * >20:
2255            * >10: internal (else display or program)
2256            * >08: program file
2257            * >04: variable (else fixed or program)
2258            * >02: memory full
2259            * >01: end-of-file reached
2260            *-------------------------------------                                  
2261            *
2262  54DC 06A0 STATUS  BL      @CALSUB                 call subroutine
2262  54DE 4342  
2263  54E0 4A8E         DATA    FFFDRV                  save filename in comp buf, then find FDR in VDP
2264  54E2 C104         MOV     R4,R4                   found?
2265  54E4 1310         JEQ     H155                    yes
2266            *                                       
2267  54E6 06A0         BL      @CALSUB                 no: call subroutine
2267  54E8 4342  
2268  54EA 4AF6         DATA    FFDRDK                  find FDR on disk
2269  54EC 0200         LI      R0,>8000                value for file not found
2269  54EE 8000  
2270  54F0 C104         MOV     R4,R4                   found?
2271  54F2 1649         JNE     H164                    no: return with that value
2272  54F4 C069         MOV     @>0056(R9),R1           yes: ptr to FDR
2272  54F6 0056  
2273  54F8 04C2         CLR     R2                      
2274  54FA 0429         BLWP    @>005A(R9)              set VDP to write
2274  54FC 005A  
2275  54FE 0023         DATA    >0023                   address in R1
2276  5500 DBC2         MOVB    R2,@-2(R15)             invalidate that FDR (file not open)
2276  5502 FFFE  
2277  5504 1036         JMP     H162                    transfer FDR status to PAB status byte
2278            *                                       
2279  5506 06A0 H155    BL      @CALSUB                 file is open: call subroutine
2279  5508 4342  
2280  550A 51C8         DATA    AFPGPF                  adjust FDR ptr, get PAB file type into R4
2281  550C 06A0         BL      @RFDRST                 get status byte from FDR
2281  550E 51E4  
2282  5510 1101         JLT     H156                    var
2283  5512 1006         JMP     H157                    fix
2284            *                                       
2285  5514 06A0 H156    BL      @CALSUB                 var: call subroutine
2285  5516 4342  
2286  5518 504A         DATA    RRSEC                   load wanted sector, point to wanted rec in buffer
2287  551A 1013         JMP     H159                    out of range
2288  551C 04C2         CLR     R2                      ok: clear flag
2289  551E 1029         JMP     H162                    copy status byte from FDR into PAB, return
2290            *                                       
2291  5520 D16F H157    MOVB    @-1026(R15),R5          fix: get rec/sect byte
2291  5522 FBFE  
2292  5524 0985         SRL     R5,8                    make it a word
2293  5526 1602         JNE     H158                    
2294  5528 0205         LI      R5,>0100                00 (program files) means 256
2294  552A 0100  
2295  552C 06A0 H158    BL      @PABR2B                 get 2 bytes from PAB into R0
2295  552E 4854  
2296  5530 0006         DATA    6                       # of wanted record
2297  5532 C0C0         MOV     R0,R3                   save it
2298  5534 111C         JLT     H161                    too big: set memory full bit in PAB status byte
2299  5536 06A0         BL      @RNFISE                 get # recs/file into R2, comp with R3
2299  5538 5242  
2300  553A 04C2         CLR     R2                      
2301  553C 1A1A         JL      H162                    in file: copy file type bits, return
2302  553E 3C85         DIV     R5,R2                   how many sectors do we need?
2303  5540 C0C2         MOV     R2,R3                   save result
2304            *                                       
2305  5542 06A0 H159    BL      @FDR2B1                 get 2 bytes from FDR into R0
2305  5544 485A  
2306  5546 000E         DATA    14                      # of sectors/file
2307  5548 0583         INC     R3                      plus 1 sector for FDR
2308  554A 0202         LI      R2,>0100                value for eof reached in PAB status
2308  554C 0100  
2309  554E 60C0         S       R0,R3                   are there enough sectors in file for these recs?
2310  5550 1501         JGT     H160                    
2311  5552 100F         JMP     H162                    yes: we reached the eof
2312  5554 06A0 H160    BL      @CALSUB                 call subroutine
2312  5556 4342  
2313  5558 49BC         DATA    RWVIB                   load VIB (sector 0)
2314  555A C103         MOV     R3,R4                   number of sectors that will be needed
2315  555C C205         MOV     R5,R8                   VIB ptr
2316  555E 0228         AI      R8,10                   skip 10 bytes (required by CFSVIB)
2316  5560 000A  
2317  5562 06A0         BL      @CFSVIB                 count free sectors in bitmap, into R3
2317  5564 5750  
2318  5566 0202         LI      R2,>0100                value for eof reached
2318  5568 0100  
2319  556A 8103         C       R3,R4                   are there that many free sectors?
2320  556C 1402         JHE     H162                    yes
2321  556E 0202 H161    LI      R2,>0200                value for memory full
2321  5570 0200  
2322            *                                       
2323  5572 06A0 H162    BL      @FDR2B1                 get 2 bytes from FDR into R0
2323  5574 485A  
2324  5576 000C         DATA    12                      file status byte
2325  5578 0240         ANDI    R0,>8F00                mask irrelevant bits
2325  557A 8F00  
2326  557C 1502         JGT     H163                    
2327  557E 0260         ORI     R0,>0080                var: put var bit in PAB status style
2327  5580 0080  
2328  5582 0A30 H163    SLA     R0,3                    get rid of var bit in FDR style
2329  5584 F002         SOCB    R2,R0                   add eof and mem full bits
2330            *                                       
2331  5586 C069 H164    MOV     @>0054(R9),R1           PAB ptr
2331  5588 0054  
2332  558A 0221         AI      R1,8                    point to bias/status return byte
2332  558C 0008  
2333  558E 0429         BLWP    @>005A(R9)              set VDP to write
2333  5590 005A  
2334  5592 0023         DATA    >0023                   address in R1
2335  5594 DBC0         MOVB    R0,@-2(R15)             write file status to PAB
2335  5596 FFFE  
2336  5598 0460         B       @RTURN1                 return to caller
2336  559A 4360  
2337            *
2338            *---------------------------------
2339            * Disk directory access
2340            * ---------------------
2341            * The directory is accessed by omiting the filename in the DSR name: "DSK1."
2342            * It must be opened for input only, as an Int/Fix 38 file.
2343            * It consists in upto 128 records, the first one contains the disk informations,
2344            * the others the informations for upto 127 files (in alphabetical order).
2345            * Each record consists in an ascii string and three floating point numbers.
2346            *
2347            * Record 0 contains:
2348            * - Diskname (an ascii string of upto 10 chars).
2349            * - The number zero.
2350            * - The number of sectors on disk.
2351            * - The number of free sectors on disk.
2352            *
2353            * Other records contain:
2354            * - Filename (an ascii string of upto 10 chars).
2355            * - Filetype: 1=D/F, 2=D/V, 3=I/F, 4=I/V, 5=Prog, 0=end of directory.
2356            *   If the file is protected, this number is negative (-1=D/F, etc).
2357            * - File size in sectors (including the FDR itself).
2358            * - File record length (0 for programs).
2359            *---------------------------------
2360             
2361            *---------------------------------
2362            * Open disk directory pseudo-file
2363            *---------------------------------                                      
2364            *
2365  559C D02F OPNDIR  MOVB    @-1026(R15),R0          get file type from PAB
2365  559E FBFE  
2366  55A0 0240         ANDI    R0,>1E00                mask irrelavant bits (rel/seq)
2366  55A2 1E00  
2367  55A4 0280         CI      R0,>0C00                is it int/fix in output mode?
2367  55A6 0C00  
2368  55A8 1303         JEQ     H166                    yes
2369  55AA 06A0 H165    BL      @RETERR                 return with error
2369  55AC 4988  
2370  55AE 4000         DATA    >4000                   bad attributes
2371  55B0 06A0 H166    BL      @PABR2B                 get 2 bytes from PAB into R0
2371  55B2 4854  
2372  55B4 0004         DATA    4                       rec length
2373  55B6 0980         SRL     R0,8                    make it a word
2374  55B8 1303         JEQ     H167                    >00= default: set it to 38
2375  55BA 0280         CI      R0,>0026                is it 38?
2375  55BC 0026  
2376  55BE 16F5         JNE     H165                    no: return with bad attributes error
2377  55C0 0200 H167    LI      R0,>2600                set rec len to 38
2377  55C2 2600  
2378  55C4 0429         BLWP    @>005A(R9)              set VDP to write
2378  55C6 005A  
2379  55C8 0103         DATA    >0103                   address in R8 (from PABR2B)
2380  55CA DBC0         MOVB    R0,@-2(R15)             write rec len to PAB
2380  55CC FFFE  
2381            *                                       
2382  55CE 04C7         CLR     R7                      
2383  55D0 06A0         BL      @FNDRV                  find matching drive in file control blocks
2383  55D2 578A  
2384  55D4 55DC         DATA    H168                    go there if not found
2385  55D6 06A0 ERRR10  BL      @ERROR5                 update data then return with error
2385  55D8 495C  
2386  55DA E000         DATA    >E000                   file error
2387  55DC C1C7 H168    MOV     R7,R7                   did we find a free slot?
2388  55DE 1603         JNE     H169                    yes
2389  55E0 06A0         BL      @RETERR                 no: return with error
2389  55E2 4988  
2390  55E4 8000         DATA    >8000                   memory full
2391  55E6 0429 H169    BLWP    @>005A(R9)              set VDP to write
2391  55E8 005A  
2392  55EA 00E3         DATA    >00E3                   address in R7
2393  55EC DBC3         MOVB    R3,@-2(R15)             write drive #
2393  55EE FFFE  
2394  55F0 06C3         SWPB    R3                      
2395  55F2 DBC3         MOVB    R3,@-2(R15)             and a space as filename (illegal, indicates dir)
2395  55F4 FFFE  
2396  55F6 0460         B       @RTURN1                 return to caller
2396  55F8 4360  
2397            *
2398            *---------------------------------
2399            * Close disk directory
2400            *---------------------------------                                      
2401  55FA 06A0 CLSDIR  BL      @FNDRV                  find matching drive in file control blocks
2401  55FC 578A  
2402  55FE 55D6         DATA    ERRR10                  go there if not found: return with file error
2403  5600 04C0         CLR     R0                      
2404  5602 0429         BLWP    @>005A(R9)              set VDP to write
2404  5604 005A  
2405  5606 0103         DATA    >0103                   address in R8
2406  5608 DBC0         MOVB    R0,@-2(R15)             clear drive #
2406  560A FFFE  
2407  560C 0460         B       @RTURN1                 return to caller
2407  560E 4360  
2408            *
2409            *---------------------------------
2410            * Read a record from disk directory
2411            *---------------------------------                                      
2412            *
2413  5610 06A0 RDDIR   BL      @FNDRV                  find matching drive in file control blocks
2413  5612 578A  
2414  5614 55D6         DATA    ERRR10                  go ther it not found: return with file error
2415  5616 0588         INC     R8                      
2416  5618 C148         MOV     R8,R5                   save ptr to FDR
2417  561A 06A0         BL      @PABR2B                 get 2 bytes from PAB into R0
2417  561C 4854  
2418  561E 0006         DATA    6                       record #
2419  5620 C080         MOV     R0,R2                   save it
2420  5622 0582         INC     R2                      
2421  5624 0429         BLWP    @>005A(R9)              set VDP to write
2421  5626 005A  
2422  5628 0103         DATA    >0103                   address in R8
2423  562A DBC2         MOVB    R2,@-2(R15)             write record number in FDR
2423  562C FFFE  
2424  562E 06C2         SWPB    R2                      after first char of filename!
2425  5630 DBC2         MOVB    R2,@-2(R15)                     
2425  5632 FFFE  
2426  5634 0A10         SLA     R0,1                    since two byte per file ptr
2427  5636 D000         MOVB    R0,R0                   is rec # greater than 128?
2428  5638 1303         JEQ     H170                    no
2429  563A 06A0         BL      @ERROR5                 yes: update data then return with error
2429  563C 495C  
2430  563E A000         DATA    >A000                   past eof
2431  5640 0702 H170    SETO    R2                      code for read
2432  5642 C100         MOV     R0,R4                   record #
2433  5644 133B         JEQ     H175                    0=disk parameters
2434  5646 0204         LI      R4,1                    sector #1
2434  5648 0001  
2435  564A 06A0         BL      @CALSUB                 call subroutine
2435  564C 4342  
2436  564E 4A38         DATA    RWSEC                   read sector into buffer in R5
2437  5650 C205         MOV     R5,R8                   buffer ptr
2438  5652 0225         AI      R5,255                  point to data buffer area in this ctrl block
2438  5654 00FF  
2439  5656 0640         DECT    R0                      don't count record 0
2440  5658 A200         A       R0,R8                   point to desired file ptr
2441  565A 06A0         BL      @VDPR2B                 get two byte from VDP at R8 into R0
2441  565C 4860  
2442  565E C100         MOV     R0,R4                   sector where that FDR is to be found
2443  5660 1328         JEQ     H173                    no more
2444  5662 06A0         BL      @CALSUB                 call subroutine
2444  5664 4342  
2445  5666 4A38         DATA    RWSEC                   read FDR sector into data buffer area
2446  5668 06A0         BL      @FDR2B1                 get 2 bytes from FDR into R0
2446  566A 485A  
2447  566C 010E         DATA    270                     # of sect/file
2448  566E C180         MOV     R0,R6                   save it to output file size
2449  5670 0586         INC     R6                      include the FDR itself
2450  5672 D0EF         MOVB    @-1026(R15),R3          ignore eof offset
2450  5674 FBFE  
2451  5676 0202         LI      R2,>0A00                10 chars per filename
2451  5678 0A00  
2452  567A D0EF         MOVB    @-1026(R15),R3          get rec length
2452  567C FBFE  
2453  567E 0983         SRL     R3,8                    make it a word
2454  5680 0648         DECT    R8                      point to status byte in FDR
2455  5682 0429         BLWP    @>005A(R9)              set VDP to read
2455  5684 005A  
2456  5686 0102         DATA    >0102                   address in R8
2457  5688 D02F         MOVB    @-1026(R15),R0          get file status byte
2457  568A FBFE  
2458  568C C1C0         MOV     R0,R7                   
2459  568E 0240         ANDI    R0,>0800                keep only write protected bit
2459  5690 0800  
2460  5692 51C0         SZCB    R0,R7                   clear write protected bit (if it was set)
2461  5694 0987         SRL     R7,8                    make it a word
2462  5696 0587         INC     R7                      types are numbered from 1
2463  5698 0287         CI      R7,>0002                is it a program file?
2463  569A 0002  
2464  569C 1602         JNE     H171                    no
2465  569E 0227         AI      R7,3                    yes: make it type 5
2465  56A0 0003  
2466  56A2 0287 H171    CI      R7,>0008                is it var?
2466  56A4 0008  
2467  56A6 1A02         JL      H172                    no
2468  56A8 0227         AI      R7,-127                 yes: add 1 and clear var bit
2468  56AA FF81  
2469  56AC 0A40 H172    SLA     R0,4                    write protect bit will be >80
2470  56AE E1C0         SOC     R0,R7                   add it to file type
2471  56B0 1004         JMP     H174                    
2472            *                                       
2473  56B2 04C2 H173    CLR     R2                      no more files: filename size = 0
2474  56B4 04C6         CLR     R6                      file size = 0
2475  56B6 04C3         CLR     R3                      rec length = 0
2476  56B8 04C7         CLR     R7                      type = 0
2477  56BA 100F H174    JMP     H176                    output that
2478            *                                       
2479  56BC 0225 H175    AI      R5,255                  disk info: point to data buffer area in ctrl block
2479  56BE 00FF  
2480  56C0 06A0         BL      @CALSUB                 call subroutine
2480  56C2 4342  
2481  56C4 4A38         DATA    RWSEC                   read sector 0
2482  56C6 06A0         BL      @FDR2B1                 get 2 bytes from FDR into R0
2482  56C8 485A  
2483  56CA 010A         DATA    266                     # of sectors on disk
2484  56CC C180         MOV     R0,R6                   duplicate it
2485  56CE 0646         DECT    R6                      minus directory itself (sect 0 + 1)
2486  56D0 06A0         BL      @CFSVIB                 count free sectors in bitmap, result in R3
2486  56D2 5750  
2487  56D4 04C7         CLR     R7                      filetype is not used
2488  56D6 0202         LI      R2,>0A00                diskname is 10 chars
2488  56D8 0A00  
2489            *                                       
2490  56DA 06A0 H176    BL      @PABR2B                 get 2 bytes from PAB into R0
2490  56DC 4854  
2491  56DE 0002         DATA    2                       APEDSK99: error in source listing (was R2)
2492  56E0 C200         MOV     R0,R8                   duplicate it
2493  56E2 0588         INC     R8                      skip first byte
2494  56E4 0982         SRL     R2,8                    filename length (or diskname)
2495  56E6 1316         JEQ     H179                    0: skip filename copying
2496  56E8 04C1         CLR     R1                      
2497  56EA 0429 H177    BLWP    @>005A(R9)              set VDP to read
2497  56EC 005A  
2498  56EE 00A2         DATA    >00A2                   address in R5 (FDR ptr)
2499  56F0 D06F         MOVB    @-1026(R15),R1          get 1 char from filename in FDR
2499  56F2 FBFE  
2500  56F4 0281         CI      R1,>2000                is it a space?
2500  56F6 2000  
2501  56F8 1309         JEQ     H178                    yes: end of name
2502  56FA 0429         BLWP    @>005A(R9)              no: set VDP to write
2502  56FC 005A  
2503  56FE 0103         DATA    >0103                   address in R8 (PAB data buffer ptr)
2504  5700 DBC1         MOVB    R1,@-2(R15)             copy char in PAB data buffer
2504  5702 FFFE  
2505  5704 0585         INC     R5                      increment source ptr
2506  5706 0588         INC     R8                      increment destination ptr
2507  5708 0602         DEC     R2                      next char
2508  570A 16EF         JNE     H177                    
2509  570C 0502 H178    NEG     R2                      number of trailing spaces
2510  570E 0222         AI      R2,10                   number of chars in filename
2510  5710 000A  
2511  5712 06C2         SWPB    R2                      
2512  5714 0429 H179    BLWP    @>005A(R9)              set VDP to write
2512  5716 005A  
2513  5718 0003         DATA    >0003                   address in R0 (beg of PAB data buffer)
2514  571A DBC2         MOVB    R2,@-2(R15)             write string length byte
2514  571C FFFE  
2515            *                                       
2516  571E 0429         BLWP    @>005A(R9)              set VDP to write
2516  5720 005A  
2517  5722 0103         DATA    >0103                   address in R8
2518  5724 C047         MOV     R7,R1                   file type + protection
2519  5726 06A0         BL      @INT2FP                 make it a float number
2519  5728 57CE  
2520  572A C046         MOV     R6,R1                   file size in sectors, including FDR
2521  572C 06A0         BL      @INT2FP                 make it a float number
2521  572E 57CE  
2522  5730 C043         MOV     R3,R1                   record length
2523  5732 06A0         BL      @INT2FP                 make it a float number
2523  5734 57CE  
2524  5736 C229         MOV     @>0054(R9),R8           get PAB ptr
2524  5738 0054  
2525  573A 0228         AI      R8,5                    point to character count
2525  573C 0005  
2526  573E 0200         LI      R0,>2600                always 38 bytes
2526  5740 2600  
2527  5742 0429         BLWP    @>005A(R9)              set VDP to write
2527  5744 005A  
2528  5746 0103         DATA    >0103                   address in R8
2529  5748 DBC0         MOVB    R0,@-2(R15)             write # of characters in record
2529  574A FFFE  
2530  574C 0460         B       @RTURN1                 return to caller
2530  574E 4360  
2531            *                                       
2532  5750 0228 CFSVIB  AI      R8,46                   count free sectors in VIB bitmap
2532  5752 002E  
2533  5754 0202         LI      R2,200                  bitmap size
2533  5756 00C8  
2534  5758 04C3         CLR     R3                      free sectors counter
2535  575A 0429         BLWP    @>005A(R9)              set VDP to read
2535  575C 005A  
2536  575E 0102         DATA    >0102                   address in R8
2537  5760 D06F H180    MOVB    @-1026(R15),R1          get a byte from bitmap
2537  5762 FBFE  
2538  5764 0221         AI      R1,256                  
2538  5766 0100  
2539  5768 0981         SRL     R1,8                    
2540  576A 130C         JEQ     H184                    was >FF: no free sectors, next byte
2541  576C 0601         DEC     R1                      was it >00?
2542  576E 1603         JNE     H181                    no: count bits
2543  5770 0223         AI      R3,8                    yes: 8 more free sectors
2543  5772 0008  
2544  5774 1007         JMP     H184                    next byte
2545  5776 0200 H181    LI      R0,8                    8 bits per byte
2545  5778 0008  
2546  577A 0911 H182    SRL     R1,1                    test a bit
2547  577C 1801         JOC     H183                    was 1: sector is used
2548  577E 0583         INC     R3                      was 0: one more free sector
2549  5780 0600 H183    DEC     R0                      next bit in byte
2550  5782 16FB         JNE     H182                    more to come
2551  5784 0602 H184    DEC     R2                      next bitmap byte
2552  5786 16EC         JNE     H180                    more to come
2553  5788 045B         B       *R11                    
2554            *                                       
2555  578A C2BB FNDRV   MOV     *R11+,R10               find drive in file control blocks
2556  578C C14B         MOV     R11,R5                  save 2 returns
2557  578E C229         MOV     @>0056(R9),R8           top of mem word in VDP buffers header
2557  5790 0056  
2558  5792 0228         AI      R8,3                    point to max # of files
2558  5794 0003  
2559  5796 0429         BLWP    @>005A(R9)              set VDP to read
2559  5798 005A  
2560  579A 0102         DATA    >0102                   address in R8
2561  579C D0AF         MOVB    @-1026(R15),R2          get # of files
2561  579E FBFE  
2562  57A0 0882         SRA     R2,8                    make it a word
2563  57A2 0228         AI      R8,6                    point to drive # in file ctrl block
2563  57A4 0006  
2564  57A6 0203         LI      R3,>0020                filename begin with space (illegal: flag for dir)
2564  57A8 0020  
2565  57AA D0C6         MOVB    R6,R3                   APEDSK99: error in original disassembly (was R5)
2566  57AC 06A0 H185    BL      @VDPR2B                 read 2 bytes from VDP at R8 into R0
2566  57AE 4860  
2567  57B0 8003         C       R3,R0                   match with that control block?
2568  57B2 1309         JEQ     H187                    yes
2569  57B4 0240         ANDI    R0,>00FF                keep only first char of filename
2569  57B6 00FF  
2570  57B8 1601         JNE     H186                    valid filename: a FDR is loaded here
2571  57BA C1C8         MOV     R8,R7                   this space is free: save ptr
2572  57BC 0228 H186    AI      R8,518                  point to next file control block
2572  57BE 0206  
2573  57C0 0602         DEC     R2                      next file
2574  57C2 16F4         JNE     H185                    more to come
2575  57C4 045A         B       *R10                    not found: return to address passed in data word
2576  57C6 0588 H187    INC     R8                      drive matches: point to FDR
2577  57C8 CA48         MOV     R8,@>0056(R9)           save ptr
2577  57CA 0056  
2578  57CC 0455         B       *R5                     return to caller after data word
2579            *
2580            *--------------------------------------
2581            * Floating point format
2582            * ---------------------
2583            * Float numbers are 8 bytes long: EE 12 34 56 78 9A BC
2584            * EE is the exponent in radix 100 (not in radix 10 as usual!). It is biased
2585            * by 64: >40=0, 41=1 (i.e *100), >42=2 (i.e * 10,000) >3F= -1 (i.e /100), etc
2586            *
2587            * 12 ... BC are the mantissa in binary coded decimal: each byte encodes two
2588            * decimal digits from 00 to 99
2589            *
2590            * For negative numbers, the first word is negated
2591            * For zero, the first word is >0000 the others are irrelevant
2592            *
2593            * Examples: 40 08 00 00 00 00 00 00 is 8.0
2594            *           41 02 37 00 00 00 00 00 is 255.0 (>37 hex = 55 decimal)
2595            *           BF F8 00 00 00 00 00 00 is -8.0
2596            *           43 01 02 03 04 05 06 07 is 1020304.050607
2597            *--------------------------------------                                 
2598            *
2599  57CE 0202 INT2FP  LI      R2,>0800                write an integer in floating point format
2599  57D0 0800  
2600  57D2 DBC2         MOVB    R2,@-2(R15)             size=8
2600  57D4 FFFE  
2601  57D6 C141         MOV     R1,R5                   integer is in R1: save it for sign processing
2602  57D8 0241         ANDI    R1,>7FFF                clear sign bit
2602  57DA 7FFF  
2603  57DC 0281         CI      R1,100                  is it less than 100?
2603  57DE 0064  
2604  57E0 1A07         JL      H188                    yes
2605  57E2 04C0         CLR     R0                      100 or over
2606  57E4 0204         LI      R4,100                  
2606  57E6 0064  
2607  57E8 3C04         DIV     R4,R0                   divide by 100
2608  57EA 0260         ORI     R0,>4100                add exponent 2 to hundreths
2608  57EC 4100  
2609  57EE 1005         JMP     H190                    
2610            *                                       
2611  57F0 C001 H188    MOV     R1,R0                   is it 0?
2612  57F2 1302         JEQ     H189                    yes: exponent is 0
2613  57F4 0260         ORI     R0,>4000                no: add exponent 1
2613  57F6 4000  
2614  57F8 04C1 H189    CLR     R1                      next digits will be 0
2615            *                                       
2616  57FA C145 H190    MOV     R5,R5                   test sign bit
2617  57FC 1101         JLT     H191                    negative
2618  57FE 1001         JMP     H192                    positive or zero
2619  5800 0500 H191    NEG     R0                      negate first word
2620  5802 DBC0 H192    MOVB    R0,@-2(R15)             write exponent to VDP at preset address
2620  5804 FFFE  
2621  5806 06C0         SWPB    R0                      
2622  5808 DBC0         MOVB    R0,@-2(R15)             write first first 2 digits (or hundreths)
2622  580A FFFE  
2623  580C 06C1         SWPB    R1                      
2624  580E DBC1         MOVB    R1,@-2(R15)             write last 2 digits (if any)
2624  5810 FFFE  
2625  5812 0202         LI      R2,5                    the remaining bytes are all 0 with integers
2625  5814 0005  
2626  5816 DBC2 H193    MOVB    R2,@-2(R15)             write 0 to VDP
2626  5818 FFFE  
2627  581A 0602         DEC     R2                      next byte
2628  581C 16FC         JNE     H193                    more to do
2629  581E 045B         B       *R11                    
2630            *
2631            *---------------------------------------
2632            * Subprogram >10: sector R/W
2633            * --------------
2634            * >834A: (n/a)      <--- sector #
2635            * >834C: drive #
2636            * >834D: R/W code (write if >00)
2637            * >834E: VDP buffer
2638            * >8350: sector #   <--- error code
2639            *---------------------------------------                                        
2640            *
2641  5820 C1CB ESUB01  MOV     R11,R7                  
2642  5822 06A0         BL      @PRPFDO                 prepare disk operations
2642  5824 440E  
2643  5826 CA69         MOV     @>0050(R9),@>004A(R9)   copy sector #
2643  5828 0050  
2643  582A 004A  
2644  582C 0460         B       @SECRW1                 
2644  582E 4198  
2645            *
2646            *---------------------------------------
2647            * Subprogram >11: format disk
2648            * --------------                                        
2649            *
2650  5830 C1CB ESUB02  MOV     R11,R7                  
2651  5832 06A0         BL      @PRPFDO                 prepare disk operations
2651  5834 440E  
2652  5836 0460         B       @FMTDSK                 
2652  5838 4216  
2653            *
2654            *---------------------------------------
2655            * Subprogram >12: file (un)protect
2656            * --------------
2657            * >834C: drive #
2658            * >834D: protect code (>00 unprotect)
2659            * >834E: ptr to filename
2660            * >8350: (n/a)      <--- error code
2661            *---------------------------------------                                
2662            *
2663  583A C1CB ESUB03  MOV     R11,R7                  
2664  583C 06A0         BL      @PRPFDO                 prepare disk operations
2664  583E 440E  
2665  5840 D029         MOVB    @>004D(R9),R0           get protection code
2665  5842 004D  
2666  5844 0240         ANDI    R0,>0800                keep the bit that will be needed
2666  5846 0800  
2667  5848 0429         BLWP    @>005A(R9)              save R0 on stack
2667  584A 005A  
2668  584C 8000         DATA    >8000                   
2669  584E C029         MOV     @>004E(R9),R0           get pointer to filename
2669  5850 004E  
2670  5852 06A0         BL      @CALSUB                 call subroutine
2670  5854 4342  
2671  5856 593C         DATA    RFDRVB                  load FDR in VDP buffer
2672  5858 0429         BLWP    @>005A(R9)              retrieve old R0, in R2
2672  585A 005A  
2673  585C 2001         DATA    >2001                   
2674  585E 06A0         BL      @FDR2B1                 read two bytes in R0 from top of FDR + offset
2674  5860 485A  
2675  5862 000C         DATA    12                      file status byte
2676  5864 0240         ANDI    R0,>F700                clear protection flag
2676  5866 F700  
2677  5868 F002         SOCB    R2,R0                   set it if needed
2678  586A 0429         BLWP    @>005A(R9)              set VDP for write
2678  586C 005A  
2679  586E 0103         DATA    >0103                   address in R8
2680  5870 DBC0         MOVB    R0,@-2(R15)             write back file status to FDR
2680  5872 FFFE  
2681            *                                       
2682  5874 C229 UWFLVB  MOV     @>0056(R9),R8           FDR address in VDP mem
2682  5876 0056  
2683  5878 0429         BLWP    @>005A(R9)              set VDP for read
2683  587A 005A  
2684  587C 0102         DATA    >0102                   address in R8
2685  587E D02F         MOVB    @-1026(R15),R0          get drive # in ctrl block
2685  5880 FBFE  
2686  5882 0260         ORI     R0,>8000                flag it
2686  5884 8000  
2687  5886 0429         BLWP    @>005A(R9)              set VDP for write
2687  5888 005A  
2688  588A 0103         DATA    >0103                   address in R8
2689  588C DBC0         MOVB    R0,@-2(R15)             write it back
2689  588E FFFE  
2690  5890 0460         B       @UPDFDR                 update FDR, load VIB
2690  5892 4560  
2691            *
2692            *---------------------------------
2693            * Subprogram >13: file rename
2694            * --------------
2695            * >834C: drive #
2696            * >834E: ptr to new name
2697            * >8350: ptr to old name <--- error code
2698            *---------------------------------                                      
2699            *
2700  5894 C1CB ESUB04  MOV     R11,R7                  
2701  5896 06A0         BL      @PRPFDO                 prepare disk operations
2701  5898 440E  
2702  589A C029         MOV     @>004E(R9),R0           get ptr to new filename
2702  589C 004E  
2703  589E 0429         BLWP    @>005A(R9)              save R0 on stack
2703  58A0 005A  
2704  58A2 8000         DATA    >8000                   
2705  58A4 C029         MOV     @>0050(R9),R0           get ptr to old filename
2705  58A6 0050  
2706  58A8 06A0         BL      @CALSUB                 call subroutine
2706  58AA 4342  
2707  58AC 593C         DATA    RFDRVB                  put FDR in VDP buffer
2708  58AE 06A0         BL      @RMFPTR                 remove FDR ptr from sector 1
2708  58B0 47C4  
2709  58B2 06A0         BL      @FDR2B1                 get 2 bytes from FDR
2709  58B4 485A  
2710  58B6 000C         DATA    12                      file status byte
2711  58B8 0240         ANDI    R0,>0800                protected?
2711  58BA 0800  
2712  58BC 1303         JEQ     H194                    no
2713  58BE 06A0         BL      @ERROR5                 yes: return with error
2713  58C0 495C  
2714  58C2 2000         DATA    >2000                   write protected
2715  58C4 06A0 H194    BL      @FDR2B1                 get 2 bytes from FDR
2715  58C6 485A  
2716  58C8 FFFC         DATA    -4                      sector # of FDR
2717  58CA C040         MOV     R0,R1                   
2718  58CC 0429         BLWP    @>005A(R9)              retrieve R0 from stack
2718  58CE 005A  
2719  58D0 8001         DATA    >8001                   ptr to new filename
2720  58D2 0429         BLWP    @>005A(R9)              save R1 on stack
2720  58D4 005A  
2721  58D6 4000         DATA    >4000                   sector # of FDR
2722  58D8 06A0         BL      @UFNCB                  write drive # and filename in compare buffer
2722  58DA 5B5E  
2723  58DC 06A0         BL      @CALSUB                 call subroutine
2723  58DE 4342  
2724  58E0 4B22         DATA    FFDRFN                  find FDR from filename
2725  58E2 C104         MOV     R4,R4                   found?
2726  58E4 1338         JEQ     H195                    yes: return with file error (name already exist)
2727  58E6 06A0         BL      @INSFDR                 insert a FDR in sector 1
2727  58E8 47F4  
2728  58EA 0429         BLWP    @>005A(R9)              retrieve sect # of FDR in R4
2728  58EC 005A  
2729  58EE 0801         DATA    >0801                   
2730  58F0 0429         BLWP    @>005A(R9)              set VDP to write
2730  58F2 005A  
2731  58F4 0103         DATA    >0103                   address in R8
2732  58F6 DBC4         MOVB    R4,@-2(R15)             write sector # of FDR
2732  58F8 FFFE  
2733  58FA 06C4         SWPB    R4                      
2734  58FC DBC4         MOVB    R4,@-2(R15)                     
2734  58FE FFFE  
2735  5900 06C4         SWPB    R4                      sector #
2736  5902 0702         SETO    R2                      code for read
2737  5904 04C5         CLR     R5                      buffer offset: VDP at >8356
2738  5906 06A0         BL      @CALSUB                 call subroutine
2738  5908 4342  
2739  590A 4A34         DATA    RDFDR1                  read FDR
2740  590C C045         MOV     R5,R1                   
2741  590E C029         MOV     @>0058(R9),R0                   
2741  5910 0058  
2742  5912 0220         AI      R0,257                  
2742  5914 0101  
2743  5916 0601         DEC     R1                      
2744  5918 06A0         BL      @CFNFDR                 copy filename in compare buffer to FDR
2744  591A 5B74  
2745  591C 04C2         CLR     R2                      code for write
2746  591E 06A0         BL      @CALSUB                 call subroutine
2746  5920 4342  
2747  5922 4A38         DATA    RWSEC                   write FDR (with new name in it)
2748  5924 06A0         BL      @CALSUB                 call subroutine
2748  5926 4342  
2749  5928 4A20         DATA    WRSEC1                  write sector 1 (with new FDR ptr in it)
2750  592A C069         MOV     @>0056(R9),R1           FDR ptr
2750  592C 0056  
2751  592E 0429         BLWP    @>005A(R9)              prepare VDP to write
2751  5930 005A  
2752  5932 0023         DATA    >0023                   address in R1
2753  5934 DBC4         MOVB    R4,@-2(R15)             clear first char of FDR in buffer
2753  5936 FFFE  
2754  5938 0460         B       @RTURN1                 return to caller
2754  593A 4360  
2755            *                               
2756  593C 04C6 RFDRVB  CLR     R6                      put FDR in VDP buffer
2757  593E D1A9         MOVB    @>004C(R9),R6           get drive #
2757  5940 004C  
2758  5942 06A0         BL      @UFNCB                  update filename compare buffer
2758  5944 5B5E  
2759  5946 06A0         BL      @CALSUB                 call subroutine
2759  5948 4342  
2760  594A 4AAE         DATA    FFDRVB                  look if FDR already in VDP buffer
2761  594C 06A0         BL      @CALSUB                 call subroutine
2761  594E 4342  
2762  5950 4AF2         DATA    FFDROD                  file FDR on disk
2763  5952 C104         MOV     R4,R4                   found?
2764  5954 1303         JEQ     H196                    yes
2765  5956 06A0 H195    BL      @RETERR                 no: return with error code in >8350
2765  5958 4988  
2766  595A E000         DATA    >E000                   file error
2767  595C 0460 H196    B       @RTURN1                 return to caller
2767  595E 4360  
2768            *
2769            *-------------------------------------
2770            * Subprogram >14: file raw read
2771            * --------------
2772            * >834C: drive #                          <--- >00
2773            * >834D: # of sectors (>00=get file info) <--- sectors read
2774            * >834E: ptr to filename
2775            * >8350: file info buffer (>83xx)         <--- error code
2776            *                              |
2777            * >83xx  : VDP buffer       <--'
2778            * >83xx+2: first sector # (total # of sect when get file info)
2779            * >83xx+4: status flag
2780            * >83xx+5: recs/sector
2781            * >83xx+6: eof offset
2782            * >83xx+7: rec size
2783            * >83xx+8: # of recs
2784            *-------------------------------------                                  
2785            *
2786  5960 C1CB ESUB05  MOV     R11,R7                  
2787  5962 06A0         BL      @PRPFDO                 prepare disk operations
2787  5964 440E  
2788  5966 06A0         BL      @RFNPTR                 load filename and ptrs
2788  5968 5B96  
2789  596A 06A0         BL      @FFFDR                  find file FDR, load some info
2789  596C 5BBC  
2790  596E C082         MOV     R2,R2                   # of sectors to read
2791  5970 131E         JEQ     H202                    >00: get file info
2792  5972 6003         S       R3,R0                   sectors in file - first sector to read
2793  5974 1502         JGT     H197                    in file
2794  5976 04C2         CLR     R2                      past eof
2795  5978 1017         JMP     H201                    
2796  597A 8002 H197    C       R2,R0                   sectors past first one vs sectors to load
2797  597C 1A01         JL      H198                    
2798  597E C080         MOV     R0,R2                   load what's left
2799  5980 0429 H198    BLWP    @>005A(R9)                      
2799  5982 005A  
2800  5984 2000         DATA    >2000                   save R2
2801  5986 0429 H199    BLWP    @>005A(R9)                      
2801  5988 005A  
2802  598A 3100         DATA    >3100                   save R2, R3, R7
2803  598C 06A0         BL      @CALSUB                 call subroutine
2803  598E 4342  
2804  5990 4614         DATA    RDOFSC                  read sector from offset in file
2805  5992 0429         BLWP    @>005A(R9)                      
2805  5994 005A  
2806  5996 3101         DATA    >3101                   retrieve R2, R3, R7
2807  5998 0583         INC     R3                      next sector
2808  599A 0227         AI      R7,256                  increment VDP buffer ptr by 256 bytes
2808  599C 0100  
2809  599E 0602         DEC     R2                      more to do?
2810  59A0 16F2         JNE     H199                    yes
2811  59A2 0429 H200    BLWP    @>005A(R9)                      
2811  59A4 005A  
2812  59A6 2001         DATA    >2001                   retrieve R2 (# of sectors read)
2813  59A8 CA42 H201    MOV     R2,@>004C(R9)           update # of sectors in parameters
2813  59AA 004C  
2814  59AC 100A         JMP     H203                    
2815            *                                       
2816  59AE CD00 H202    MOV     R0,*R4+                 get file info: sectors in file
2817  59B0 0648         DECT    R8                      
2818  59B2 05C2         INCT    R2                      copy 2 bytes (status + recs/sector)
2819  59B4 06A0         BL      @VDP2SP                 from VDP at R8 to file info structure
2819  59B6 5BF0  
2820  59B8 0202         LI      R2,4                    copy 4 bytes
2820  59BA 0004  
2821  59BC A202         A       R2,R8                   
2822  59BE 06A0         BL      @VDP2SP                 eof offset, rec len, # of recs (or # of sect)
2822  59C0 5BF0  
2823  59C2 06A0 H203    BL      @CALSUB                 call subroutine
2823  59C4 4342  
2824  59C6 4560         DATA    UPDFDR                  updata FDR (+ data) if needed, read VIB
2825  59C8 04E9         CLR     @>0050(R9)              clear error flag
2825  59CA 0050  
2826  59CC 0460         B       @RTURN1                 return to caller
2826  59CE 4360  
2827            *
2828            *--------------------------------------
2829            * Subprogram >15: file raw write
2830            * --------------
2831            * >834C: drive #                                  <--- >00
2832            * >834D: # of sectors (>00=create file from info) <--- # of sectors written
2833            * >834E: ptr to filename
2834            * >8350: file info buffer (>83xx)                 <--- error code
2835            *                              |
2836            * >83xx  : VDP buffer       <--'
2837            * >83xx+2: first sector # (total # of sectors when creating file)
2838            * >83xx+4: status flag
2839            * >83xx+5: recs/sector
2840            * >83xx+6: eof offset
2841            * >83xx+7: rec size
2842            * >83xx+8: # of recs
2843            *--------------------------------------                                 
2844            *
2845  59D0 C1CB ESUB06  MOV     R11,R7                  
2846  59D2 06A0         BL      @PRPFDO                 prepare disk operations
2846  59D4 440E  
2847  59D6 06A0         BL      @RFNPTR                 load drive + filename, + a few info
2847  59D8 5B96  
2848  59DA 1314         JEQ     H205                    sectors to write=0: create file
2849  59DC 06A0         BL      @FFFDR                  find file FDR
2849  59DE 5BBC  
2850  59E0 0429         BLWP    @>005A(R9)                      
2850  59E2 005A  
2851  59E4 2000         DATA    >2000                   save R2 (# of sectors to write)
2852  59E6 0429 H204    BLWP    @>005A(R9)                      
2852  59E8 005A  
2853  59EA 3100         DATA    >3100                   save R2, R3, R7
2854  59EC 06A0         BL      @CALSUB                 call subroutine
2854  59EE 4342  
2855  59F0 4634         DATA    WROFSC                  write sector from offset in file
2856  59F2 0429         BLWP    @>005A(R9)                      
2856  59F4 005A  
2857  59F6 3101         DATA    >3101                   retrieve R2, R3, R7
2858  59F8 0583         INC     R3                      next sector
2859  59FA 0227         AI      R7,256                  increment VDP ptr by 256 bytes
2859  59FC 0100  
2860  59FE 0602         DEC     R2                      more to do?
2861  5A00 16F2         JNE     H204                    yes
2862  5A02 10CF         JMP     H200                    update # of sectors written, in param. Then return
2863            *                               
2864  5A04 06A0 H205    BL      @CALSUB                 create file
2864  5A06 4342  
2865  5A08 4AAE         DATA    FFDRVB                  find file FDR in VDP buffers
2866  5A0A 06A0         BL      @CALSUB                 call subroutine
2866  5A0C 4342  
2867  5A0E 4AF2         DATA    FFDROD                  find file FDR on disk
2868  5A10 06A0         BL      @CALSUB                 call subroutine
2868  5A12 4342  
2869  5A14 4480         DATA    CRFIL2                  create file
2870  5A16 0429         BLWP    @>005A(R9)                      
2870  5A18 005A  
2871  5A1A 0801         DATA    >0801                   retrieve R4 (file info ptr)
2872  5A1C C229         MOV     @>0056(R9),R8           FDR ptr
2872  5A1E 0056  
2873  5A20 05C4         INCT    R4                      skip 2 bytes
2874  5A22 C0F4         MOV     *R4+,R3                 # of sector to create
2875  5A24 0228         AI      R8,10                   skip filename
2875  5A26 000A  
2876  5A28 06A0         BL      @SP2VDP                 write 2 bytes in VDP at R8+2
2876  5A2A 5C00  
2877  5A2C 0002         DATA    2                       i.e. status + recs/sector
2878  5A2E 06A0         BL      @SP2VDP                 write 4 bytes in VDP at new R8+4
2878  5A30 5C00  
2879  5A32 0004         DATA    4                       i.e. eof offset, rec len, # of recs (or # of
2880  5A34 0603         DEC     R3                      offset = # of sectors-1 (starts from 0)
2881  5A36 1103         JLT     H206                    create an empty file, FDR only
2882  5A38 06A0         BL      @CALSUB                 
2882  5A3A 4342  
2883  5A3C 464A         DATA    APSCTS                  append enough sectors to reach offset
2884  5A3E 0460 H206    B       @UWFLVB                 modify FDR, write it, load VIB, return
2884  5A40 5874  
2885            *
2886            *---------------------------------------
2887            * Subprogram FILES: number of files
2888            *---------------------------------------                                        
2889  5A42 C1CB ESUB08  MOV     R11,R7                  
2890  5A44 06A0         BL      @PRPFDO                 prepare disk operation
2890  5A46 440E  
2891  5A48 C229         MOV     @>002C(R9),R8           ptr to next basic token
2891  5A4A 002C  
2892  5A4C 0228         AI      R8,7                    skip FILES
2892  5A4E 0007  
2893  5A50 06A0         BL      @VDPR2B                 get next two bytes in R0
2893  5A52 4860  
2894  5A54 0280         CI      R0,>C801                >C8=unquoted string, size=1 char
2894  5A56 C801  
2895  5A58 161C         JNE     H207                    return (with error) if different
2896  5A5A 05C8         INCT    R8                      increment pointer
2897  5A5C 06A0         BL      @VDPR2B                 get next two bytes
2897  5A5E 4860  
2898  5A60 06C0         SWPB    R0                      
2899  5A62 0220         AI      R0,>49D0                substact >B630: # of files >B6=closed parenthesis
2899  5A64 49D0  
2900  5A66 0280         CI      R0,>0009                only 9 files allowed in Basic !
2900  5A68 0009  
2901  5A6A 1B13         JH      H207                    return with error if more
2902  5A6C 06C0         SWPB    R0                      
2903  5A6E DA40         MOVB    R0,@>004C(R9)           put new # of files in scratch-pad memory
2903  5A70 004C  
2904  5A72 06A0         BL      @CALSUB                 call subroutine
2904  5A74 4342  
2905  5A76 5A9C         DATA    PESB07                  subprogram >16 (private entry point)
2906  5A78 DA69         MOVB    @>0050(R9),@>0050(R9)   test result
2906  5A7A 0050  
2906  5A7C 0050  
2907  5A7E 1609         JNE     H207                    error
2908  5A80 C229         MOV     @>002C(R9),R8           ok: get ptr to Basic token
2908  5A82 002C  
2909  5A84 0228         AI      R8,12                   skip the whole statement
2909  5A86 000C  
2910  5A88 CA48         MOV     R8,@>002C(R9)           update ptr
2910  5A8A 002C  
2911  5A8C 5A69         SZCB    @>0042(R9),@>0042(R9)   clear current token
2911  5A8E 0042  
2911  5A90 0042  
2912  5A92 0460 H207    B       @RTURN1                 return to caller (i.e. Basic)
2912  5A94 4360  
2913            *
2914            *---------------------------------------
2915            * Subprogram >16: number of files
2916            * --------------
2917            * >834C: # of files
2918            * >8350: (n/a)      <--- error code
2919            *---------------------------------------                                        
2920            *
2921  5A96 C1CB ESUB07  MOV     R11,R7                  entry point from assembly
2922  5A98 06A0         BL      @PRPFDO                 prepare disk operations
2922  5A9A 440E  
2923  5A9C 04C0 PESB07  CLR     R0                      entry point from call files
2924  5A9E D029         MOVB    @>004C(R9),R0           get # of files
2924  5AA0 004C  
2925  5AA2 1359         JEQ     H214                    return with error
2926  5AA4 C229         MOV     @>0056(R9),R8           ptr to end of buffer word
2926  5AA6 0056  
2927  5AA8 0228         AI      R8,3                    point to # of files byte
2927  5AAA 0003  
2928  5AAC 04C3         CLR     R3                      
2929  5AAE 0429         BLWP    @>005A(R9)              set VDP to read
2929  5AB0 005A  
2930  5AB2 0102         DATA    >0102                   address in R8
2931  5AB4 D0EF         MOVB    @-1026(R15),R3          get current # of files
2931  5AB6 FBFE  
2932  5AB8 0205         LI      R5,518                  size of 1 file control block
2932  5ABA 0206  
2933  5ABC 90C0         CB      R0,R3                   compare required with current
2934  5ABE 1348         JEQ     H213                    same: return with no error
2935  5AC0 122B         JLE     H210                    less
2936  5AC2 C180         MOV     R0,R6                   more files needed
2937  5AC4 0280         CI      R0,>1000                maximum is 16
2937  5AC6 1000  
2938  5AC8 1B46         JH      H214                    return with error
2939  5ACA 6003         S       R3,R0                   how many to add
2940  5ACC 0980         SRL     R0,8                    make it a word
2941  5ACE 3805         MPY     R5,R0                   # of bytes to add
2942  5AD0 C101         MOV     R1,R4                   result in R0:R1
2943  5AD2 0504         NEG     R4                      
2944  5AD4 C0A9         MOV     @>0070(R9),R2           highest free address in VDP mem
2944  5AD6 0070  
2945  5AD8 C002         MOV     R2,R0                   
2946  5ADA 6001         S       R1,R0                   what it would become
2947  5ADC 0280         CI      R0,>0800                is there room enough for VDP?
2947  5ADE 0800  
2948  5AE0 113A         JLT     H214                    no: return with error
2949  5AE2 C040         MOV     R0,R1                   ok: new base
2950  5AE4 0582 H208    INC     R2                      increment source ptr
2951  5AE6 0580         INC     R0                      increment destination ptr
2952  5AE8 0429         BLWP    @>005A(R9)              set VDP to read
2952  5AEA 005A  
2953  5AEC 0042         DATA    >0042                   address in R2
2954  5AEE D0EF         MOVB    @-1026(R15),R3          get a byte
2954  5AF0 FBFE  
2955  5AF2 0429         BLWP    @>005A(R9)              set VDP to write
2955  5AF4 005A  
2956  5AF6 0003         DATA    >0003                   address in R0
2957  5AF8 DBC3         MOVB    R3,@-2(R15)             copy a byte
2957  5AFA FFFE  
2958  5AFC 8202         C       R2,R8                   did we copy the whole header?
2959  5AFE 16F2         JNE     H208                    not yet
2960  5B00 0429         BLWP    @>005A(R9)              set VDP to write
2960  5B02 005A  
2961  5B04 0003         DATA    >0003                   address in R0
2962  5B06 DBC6         MOVB    R6,@-2(R15)             new # of files
2962  5B08 FFFE  
2963  5B0A 04C6         CLR     R6                      
2964  5B0C 6080         S       R0,R2                   
2965  5B0E DBC6 H209    MOVB    R6,@-2(R15)             clear byte
2965  5B10 FFFE  
2966  5B12 0602         DEC     R2                      
2967  5B14 16FC         JNE     H209                    
2968  5B16 101A         JMP     H212                    
2969            *                                       
2970  5B18 0429 H210    BLWP    @>005A(R9)              less files needed
2970  5B1A 005A  
2971  5B1C 0103         DATA    >0103                   set VDP to write to address in R8
2972  5B1E DBC0         MOVB    R0,@-2(R15)             new # of files in buffer header
2972  5B20 FFFE  
2973  5B22 60C0         S       R0,R3                   how many to remove
2974  5B24 0983         SRL     R3,8                    make it a word
2975  5B26 38C5         MPY     R5,R3                   # of bytes to remove
2976  5B28 C044         MOV     R4,R1                   result in R3:R4
2977  5B2A A048         A       R8,R1                   new address for buffer header
2978  5B2C C0A9         MOV     @>0070(R9),R2           highest free address in VDP mem
2978  5B2E 0070  
2979  5B30 0429 H211    BLWP    @>005A(R9)              set VDP to read
2979  5B32 005A  
2980  5B34 0102         DATA    >0102                   address in R8
2981  5B36 D02F         MOVB    @-1026(R15),R0          read a byte
2981  5B38 FBFE  
2982  5B3A 0429         BLWP    @>005A(R9)              set VDP to write
2982  5B3C 005A  
2983  5B3E 0023         DATA    >0023                   address in R1
2984  5B40 DBC0         MOVB    R0,@-2(R15)             write byte back
2984  5B42 FFFE  
2985  5B44 0601         DEC     R1                      decrement destination ptr
2986  5B46 0608         DEC     R8                      decrement source ptr
2987  5B48 8088         C       R8,R2                   did we copy the whole header?
2988  5B4A 16F2         JNE     H211                    not yet
2989            *                                       
2990  5B4C CA41 H212    MOV     R1,@>0070(R9)           new first free address                                  
2990  5B4E 0070  
2991  5B50 04E9 H213    CLR     @>0050(R9)              clear error flag
2991  5B52 0050  
2992  5B54 1002         JMP     H215                    
2993  5B56 0729 H214    SETO    @>0050(R9)              set error flag
2993  5B58 0050  
2994  5B5A 0460 H215    B       @RTURN1                 return to caller
2994  5B5C 4360  
2995            *                                       
2996  5B5E 04E9 UFNCB   CLR     @>0054(R9)              write drive # and filename in compare buffer
2996  5B60 0054  
2997  5B62 C069         MOV     @>0058(R9),R1           
2997  5B64 0058  
2998  5B66 0221         AI      R1,256                  ptr to filename compare buffer
2998  5B68 0100  
2999  5B6A 0429         BLWP    @>005A(R9)              set VDP to write
2999  5B6C 005A  
3000  5B6E 0023         DATA    >0023                   address in R1
3001  5B70 DBC6         MOVB    R6,@-2(R15)             write drive #
3001  5B72 FFFE  
3002  5B74 0202 CFNFDR  LI      R2,10                   filename must be exactly 10 chars
3002  5B76 000A  
3003  5B78 0581 H216    INC     R1                      next char in compare buffer
3004  5B7A 0429         BLWP    @>005A(R9)              set VDP to read
3004  5B7C 005A  
3005  5B7E 0002         DATA    >0002                   address in R0
3006  5B80 D0EF         MOVB    @-1026(R15),R3          get 1 char from filename
3006  5B82 FBFE  
3007  5B84 0580         INC     R0                      next char in provided filename
3008  5B86 0429         BLWP    @>005A(R9)              set VDP to write
3008  5B88 005A  
3009  5B8A 0023         DATA    >0023                   address in R1
3010  5B8C DBC3         MOVB    R3,@-2(R15)             write 1 char to compare buffer
3010  5B8E FFFE  
3011  5B90 0602         DEC     R2                      
3012  5B92 16F2         JNE     H216                    next char
3013  5B94 045B         B       *R11                    
3014            *                                       
3015  5B96 C28B RFNPTR  MOV     R11,R10                 load compare buffer and ptrs
3016  5B98 04C6         CLR     R6                      
3017  5B9A D1A9         MOVB    @>004C(R9),R6           drive #
3017  5B9C 004C  
3018  5B9E C029         MOV     @>004E(R9),R0           ptr to filename
3018  5BA0 004E  
3019  5BA2 06A0         BL      @UFNCB                  write them in compare buffer
3019  5BA4 5B5E  
3020  5BA6 D129         MOVB    @>0050(R9),R4           file info structure ptr
3020  5BA8 0050  
3021  5BAA 0984         SRL     R4,8                    
3022  5BAC A109         A       R9,R4                   make it a PAB address
3023  5BAE D029         MOVB    @>004D(R9),R0           # of sectors (>00=get file info)
3023  5BB0 004D  
3024  5BB2 0429         BLWP    @>005A(R9)                      
3024  5BB4 005A  
3025  5BB6 0800         DATA    >0800                   save R4
3026  5BB8 0980         SRL     R0,8                    
3027  5BBA 045A         B       *R10                    EQ set for get file info
3028            *                                       
3029  5BBC 0429 FFFDR   BLWP    @>005A(R9)              find file FDR
3029  5BBE 005A  
3030  5BC0 8010         DATA    >8010                   save R0 + R11
3031  5BC2 06A0         BL      @CALSUB                 call subroutine
3031  5BC4 4342  
3032  5BC6 4AAE         DATA    FFDRVB                  find file FDR in VDP buffers
3033  5BC8 06A0         BL      @CALSUB                 call subroutine
3033  5BCA 4342  
3034  5BCC 4AF2         DATA    FFDROD                  find FDR on disk
3035  5BCE C104         MOV     R4,R4                   found ?
3036  5BD0 1303         JEQ     H217                    yes
3037  5BD2 06A0         BL      @ERROR5                 no: return with error
3037  5BD4 495C  
3038  5BD6 E000         DATA    >E000                   file error
3039  5BD8 06A0 H217    BL      @FDR2B1                 get two bytes from FDR into R0
3039  5BDA 485A  
3040  5BDC 000E         DATA    14                      # of sectors in file
3041  5BDE 0429         BLWP    @>005A(R9)                      
3041  5BE0 005A  
3042  5BE2 2011         DATA    >2011                   retrieve R0 in R2 (# of sect to read), and R11
3043  5BE4 0429         BLWP    @>005A(R9)                      
3043  5BE6 005A  
3044  5BE8 0801         DATA    >0801                   retrieve R4 (ptr to file info structure)
3045  5BEA C1F4         MOV     *R4+,R7                 VDP buffer
3046  5BEC C0D4         MOV     *R4,R3                  first sector
3047  5BEE 045B         B       *R11                    
3048            *                                       
3049  5BF0 0429 VDP2SP  BLWP    @>005A(R9)              copy VDP bytes to scratch-pad
3049  5BF2 005A  
3050  5BF4 0102         DATA    >0102                   read from VDP at R8
3051  5BF6 DD2F H218    MOVB    @-1026(R15),*R4+        read bytes into scratch-pad at R4
3051  5BF8 FBFE  
3052  5BFA 0602         DEC     R2                      # of byte in R2
3053  5BFC 16FC         JNE     H218                    next byte
3054  5BFE 045B         B       *R11                    
3055            *                                       
3056  5C00 C0BB SP2VDP  MOV     *R11+,R2                copy scratch-pad bytes to VDP
3057  5C02 A202         A       R2,R8                   
3058  5C04 0429         BLWP    @>005A(R9)              set VDP to write
3058  5C06 005A  
3059  5C08 0103         DATA    >0103                   address in R8 + offset in data word
3060  5C0A DBF4 H219    MOVB    *R4+,@-2(R15)           write byte from scratch-pad at R4
3060  5C0C FFFE  
3061  5C0E 0602         DEC     R2                      # of bytes in R2, was in data word
3062  5C10 16FC         JNE     H219                    next byte
3063  5C12 045B         B       *R11    
3064            *
3065            * APEDSK99 CALL subprograms
3066            *
3067            * parameter is single digit -> 0x00
3068  5C14 0206 PDSK    LI      R6,>0100                Protect ACOMND 
3068  5C16 0100  
3069  5C18 102F         JMP     ACLPRP                  generic prep
3070  5C1A 0206 UDSK    LI      R6,>0200                Unprotect ACOMND 
3070  5C1C 0200  
3071  5C1E 102C         JMP     ACLPRP                  generic prep
3072  5C20 0206 LDSK    LI      R6,>0300                List Files on DSKx ACOMND 
3072  5C22 0300  
3073  5C24 1029         JMP     ACLPRP                  generic prep
3074            * parameters are single digit + character string -> 1x00; ! >1300 IS RESERVED (BL NTPDT+1) ! 
3075  5C26 0206 MDSK    LI      R6,>1000                Change DSK ACOMND
3075  5C28 1000  
3076  5C2A 1026         JMP     ACLPRP                  generic prep
3077  5C2C 0206 NDSK    LI      R6,>1100                create new blank SS/SD DOAD image
3077  5C2E 1100  
3078  5C30 1023         JMP     ACLPRP
3079            * parameter is a charachter string -> 2x00
3080  5C32 0206 RDSK    LI      R6,>2000                Remove DOAD from SD card ACOMND 
3080  5C34 2000  
3081  5C36 1020         JMP     ACLPRP                  generic prep
3082  5C38 0206 FGET    LI      R6,>2100                get DOAD from FTP server ACOMND
3082  5C3A 2100  
3083  5C3C 101D         JMP     ACLPRP                  generic prep
3084  5C3E 0206 FPUT    LI      R6,>2200                save DOAD to FTP server ACOMND 
3084  5C40 2200  
3085  5C42 101A         JMP     ACLPRP                  generic prep
3086  5C44 0206 ADSR    LI      R6,>2300                load DSR and reset ACOMND
3086  5C46 2300  
3087  5C48 1017         JMP     ACLPRP                  generic prep
3088  5C4A 0206 CDIR    LI      R6,>2400                change root folder
3088  5C4C 2400  
3089  5C4E 1014         JMP     ACLPRP                  generic prep
3090            * no parameters ->3x00
3091  5C50 0206 SMAP    LI      R6,>3000                Show DSKx mapping ACOMND
3091  5C52 3000  
3092  5C54 1011         JMP     ACLPRP                  generic prep
3093  5C56 0206 LDIR    LI      R6,>3100                List SD dir ACOMND
3093  5C58 3100  
3094  5C5A 100E         JMP     ACLPRP                  generic prep
3095  5C5C 0206 AHLP    LI      R6,>3200                display APEDSK99 CALL()'s help screen
3095  5C5E 3200  
3096  5C60 100B         JMP     ACLPRP                  generic prep
3097  5C62 0206 ACHR    LI      R6,>3300                load proper lowercase character set
3097  5C64 3300  
3098  5C66 1008         JMP     ACLPRP                  generic prep
3099  5C68 0206 ARST    LI      R6,>3468                APEDSK99 reset ACOMND
3099  5C6A 3468  
3100  5C6C 1005         JMP     ACLPRP                  generic prep
3101  5C6E 0206 TIME    LI      R6,>3500                show NTP time and date
3101  5C70 3500  
3102  5C72 1002         JMP     ACLPRP                  generic prep
3103  5C74 0206 ACFG    LI      R6,>3600                APEDSK99 configuration
3103  5C76 3600  
3104            *
3105            * Generic prep and return to TI BASIC for APEDSK99 CALL's
3106            *
3107  5C78 04E0 ACLPRP  CLR     @XBASRT                 return to TI BASIC, not EXBAS
3107  5C7A 404A  
3108  5C7C 06C6         SWPB    R6                      get optional subcommand in MSB
3109  5C7E D806         MOVB    R6,@ASUBCM              save
3109  5C80 5FE9  
3110  5C82 06C6         SWPB    R6                      back to primary command
3111            *
3112  5C84 C1CB         MOV     R11,R7                  save return-to-TI BASIC address
3113  5C86 06A0         BL      @PRPFDO                 prepare TI Controller DSR operations
3113  5C88 440E  
3114            *
3115  5C8A C229         MOV     @>002C(R9),R8           ptr to next basic token
3115  5C8C 002C  
3116  5C8E 0228         AI      R8,4                    skip length byte and 3 chars of CALL name
3116  5C90 0004  
3117  5C92 06A0         BL      @VDPR2B                 get CALL last char and "(" or "0" in R0
3117  5C94 4860  
3118  5C96 0A80         SLA     R0,8                    only interested in LSB
3119  5C98 130E         JEQ     NOPARM                  0 = no parameters? SMAP / LDIR / AHLP / ACHR / ARST / TIME / ACFG (and special guest LDSK)
3120            *
3121  5C9A 0228         AI      R8,2                    adjust token pointer
3121  5C9C 0002  
3122  5C9E 06A0         BL      @VDPR2B                 get next two bytes in R0
3122  5CA0 4860  
3123  5CA2 0280         CI      R0,>C801                >C8=unquoted string, size=1 char?
3123  5CA4 C801  
3124  5CA6 1331         JEQ     USTRNG                  yes: PDSK / UDSK / LDSK / MDSK / NDSK
3125            *
3126  5CA8 0280         CI      R0,>C701                >C7=quoted string, minimum 1 character?
3126  5CAA C701  
3127  5CAC 1A02         JL      ACLERR
3128  5CAE 0460         B       @QSTRNG                 yes: RDSK / FGET / FPUT / ADSR / CDIR
3128  5CB0 5DA6  
3129            *
3130  5CB2 0460 ACLERR  B       @RTURN1                 expect the unexpected                           
3130  5CB4 4360  
3131            *
3132            * SMAP / LDIR / AHLP / ACHR / ARST / TIME / ACFG (and special guest LDSK)
3133            *
3134  5CB6 0286 NOPARM  CI      R6,>0300                LDSK without parameters is handy (re-use last used DSK#)
3134  5CB8 0300  
3135  5CBA 1303         JEQ     NOPRM2
3136  5CBC 0286         CI      R6,>3000                catch other CALL's without parameters -> error
3136  5CBE 3000  
3137  5CC0 1AF8         JL      ACLERR
3138            *
3139  5CC2 D820 NOPRM2  MOVB    @LSTDRV,@CALLBF         get last drive accessed (LDSK without parameters)
3139  5CC4 5FC7  
3139  5CC6 5FC8  
3140  5CC8 D806         MOVB    R6,@ACOMND              execute LDSK / ACHR / ARST / TIME / ACFG
3140  5CCA 5FE8  
3141  5CCC 0286         CI      R6,>3300                ACHR / ARST / TIME / ACFG?      
3141  5CCE 3300  
3142  5CD0 1A3C         JL      LDSK2                   no; SMAP / LDIR / AHLP use LDSK display routine
3143            *
3144  5CD2 0208 QNOPRM  LI      R8,9                    current CALL length
3144  5CD4 0009  
3145  5CD6 0286         CI      R6,>3300                ACHR?
3145  5CD8 3300  
3146  5CDA 1306         JEQ     ACHR2                   yes; get some real characters
3147  5CDC 0286         CI      R6,>0300                LDSK()?
3147  5CDE 0300  
3148  5CE0 1602         JNE     A9901                   nope; exit with CALL lenght 9 for SMAP / LDIR / AHLP / ARST / TIME / ACFG
3149  5CE2 0228         AI      R8,3                    yep;  exit with CALL length 12 for LDSK
3149  5CE4 0003  
3150            *
3151  5CE6 1030 A9901   JMP     A9904
3152            *
3153  5CE8 9820 ACHR2   CB      @INT2FP+2,@CALLST
3153  5CEA 57D0  
3153  5CEC 5FC6  
3154  5CEE 132C         JEQ     A9904                   >08; no char definition file found
3155            *
3156  5CF0 C0A0         MOV     @PATTBL,R2              get start of <SPACE> pattern table entry (default >0400 for TI BASIC)
3156  5CF2 4044  
3157  5CF4 06A0         BL      @VDPWRI                 set VPD address
3157  5CF6 4320  
3158            *                       
3159  5CF8 06A0 A9902   BL      @DISSTS                 use existing display routine to write 4 definitions at a time
3159  5CFA 5E58  
3160  5CFC 9820         CB      @K004,@CALLST           check Arduino ACHR return code
3160  5CFE 433E  
3160  5D00 5FC6  
3161  5D02 1322         JEQ     A9904                   we're done
3162  5D04 05A0         INC     @RDINT                  generates interrupt for next lot
3162  5D06 5FEA  
3163  5D08 10F7         JMP     A9902                   again
3164            *
3165            * PDSK / UDSK / LDSK / MDSK / NDSK
3166            *
3167  5D0A 0286 USTRNG  CI      R6,>2000                only PDSK / UDSK / LDSK / MDSK / NDSK?
3167  5D0C 2000  
3168  5D0E 14D1         JHE     ACLERR                  no -> sneaky other commands don't belong here
3169  5D10 05C8         INCT    R8                      increment pointer
3170  5D12 06A0         BL      @VDPR2B                 get next two bytes              
3170  5D14 4860  
3171            *
3172  5D16 06C0         SWPB    R0
3173  5D18 0220         AI      R0,>49D0                add 2's complement of >B630: MSB = >B3 / "," or >B6 / ")", LSB= # of files 
3173  5D1A 49D0  
3174  5D1C 1502         JGT     A9903                   >B6
3175  5D1E 0220         AI      R0,768                  >B3, adjust R0 to positive range
3175  5D20 0300  
3176            *
3177  5D22 13C7 A9903   JEQ     ACLERR                  DSK0 not valid, * INCORRECT COMMAND
3178  5D24 0280         CI      R0,3                    only 3 DSK's allowed
3178  5D26 0003  
3179  5D28 1BC4         JH      ACLERR                  DSK4+, * INCORRECT COMMAND
3180            *
3181  5D2A 06C0         SWPB    R0
3182  5D2C D800         MOVB    R0,@CALLBF              save DSKx
3182  5D2E 5FC8  
3183  5D30 D800         MOVB    R0,@LSTDRV              remember last drive accessed for LDSK without parameter
3183  5D32 5FC7  
3184            *
3185  5D34 0286         CI      R6,>1000                MDSK or NDSK?
3185  5D36 1000  
3186  5D38 1433         JHE     MNDSK2                  yep
3187            *
3188  5D3A D806 XBUSTR  MOVB    R6,@ACOMND              send PDSK / UDSK / LDSK command to Arduino
3188  5D3C 5FE8  
3189            
3190  5D3E 0286         CI      R6,>0300                LDSK?
3190  5D40 0300  
3191  5D42 1303         JEQ     LDSK2                   yep
3192            *
3193  5D44 0208 PUDSK2  LI      R8,12                   CALL length
3193  5D46 000C  
3194  5D48 1054 A9904   JMP     ACLBAS                  return to BASIC         
3195            *                       
3196  5D4A 9820 LDSK2   CB      @K002,@CALLST
3196  5D4C 433C  
3196  5D4E 5FC6  
3197  5D50 13C0         JEQ     QNOPRM                  LDSK: >00; no DOAD mapped
3198            *
3199  5D52 04C2 NXTSCR  CLR     R2                      clear screen; position 0
3200  5D54 06A0         BL      @VDPWRI
3200  5D56 4320  
3201            *
3202  5D58 0200         LI      R0,>8000                space + TI BASIC bias
3202  5D5A 8000  
3203  5D5C 06A0         BL      @VDPRPW
3203  5D5E 4268  
3204  5D60 02C0         DATA    704                     704 positions to clear
3205            *
3206  5D62 0202         LI      R2,32                   start 2nd screen line; 1st is lost due to BASIC scroll
3206  5D64 0020  
3207  5D66 06A0 A9905   BL      @VDPWRI                 
3207  5D68 4320  
3208            *       
3209  5D6A 9820         CB      @K004,@CALLST           check Arduino LDSK / SDSK / LDIR / AHLP return code
3209  5D6C 433E  
3209  5D6E 5FC6  
3210  5D70 13B0         JEQ     QNOPRM                  "More" (>F0); blank DSK or done last file / help txt
3211            *
3212  5D72 06A0         BL      @DISSTS                 LDSK / SDSK / LDIR / AHLP output to screen
3212  5D74 5E58  
3213            *
3214  5D76 0222         AI      R2,32                   next screen position
3214  5D78 0020  
3215  5D7A 0282         CI      R2,640                  end of display area?
3215  5D7C 0280  
3216  5D7E 1303         JEQ     NXTPRP                  yes; show "more" symbol
3217            *
3218  5D80 05A0         INC     @RDINT                  generates interrupt for next file / help txt
3218  5D82 5FEA  
3219  5D84 10F0         JMP     A9905   
3220            *       
3221  5D86 0202 NXTPRP  LI      R2,702
3221  5D88 02BE  
3222  5D8A 06A0         BL      @VDPWRI
3222  5D8C 4320  
3223  5D8E 0205         LI      R5,>9E00                show ">", more file / help txt to display
3223  5D90 9E00  
3224  5D92 DBC5         MOVB    R5,@-2(R15)
3224  5D94 FFFE  
3225            *
3226  5D96 06A0         BL      @CHKKEY
3226  5D98 5E6A  
3227            *
3228  5D9A 05A0         INC     @RDINT                  generates interrupt for next file / help txt
3228  5D9C 5FEA  
3229  5D9E 10D9         JMP     NXTSCR
3230            *
3231            * MDSK / NDSK / RDSK / FGET / FPUT / ADSR / CDIR
3232            *
3233  5DA0 05C8 MNDSK2  INCT    R8                      increment pointer
3234  5DA2 06A0         BL      @VDPR2B                 get next two digits
3234  5DA4 4860  
3235            *
3236  5DA6 0286 QSTRNG  CI      R6,>1000                further check on RDSK / FGET / FPUT / ADSR / CDIR
3236  5DA8 1000  
3237  5DAA 1A18         JL      A9907                   no -> sneaky PDSK / UDSK don't belong here      
3238  5DAC 0220         AI      R0,>3900                add 2's complement of >C700 =  only keep # of characters
3238  5DAE 3900  
3239  5DB0 1315         JEQ     A9907                   0 characters / empty string -> * INCORRECT COMMAND
3240  5DB2 0280         CI      R0,8                    max 8 characters?
3240  5DB4 0008  
3241  5DB6 1B12         JH      A9907                   no -> * INCORRECT COMMAND
3242            *
3243  5DB8 C100         MOV     R0,R4                   save #characters
3244  5DBA 0205         LI      R5,CALLBF+2             buffer pointer to DOAD / DSR name       
3244  5DBC 5FCA  
3245  5DBE 05C8         INCT    R8                      increment pointer
3246  5DC0 C088         MOV     R8,R2                   for VDPRD, address must be in R2
3247  5DC2 06A0         BL      @VDPRD                  set VDP READ address
3247  5DC4 432A  
3248  5DC6 DD6F A9906   MOVB    @-1026(R15),*R5+        get character and save in CALL buffer
3248  5DC8 FBFE  
3249  5DCA 0600         DEC     R0                      one less to go
3250  5DCC 16FC         JNE     A9906   
3251  5DCE D560         MOVB    @K002,*R5               mark end of string with >00 (Arduino check for end of string)
3251  5DD0 433C  
3252            *
3253  5DD2 D02F         MOVB    @-1026(R15),R0          get next token
3253  5DD4 FBFE  
3254  5DD6 0280         CI      R0,>B600                is it a ")" ?
3254  5DD8 B600  
3255  5DDA 1302         JEQ     A9908
3256  5DDC 0460 A9907   B       @ACLERR                 * INCORRECT COMMAND
3256  5DDE 5CB2  
3257            *
3258  5DE0 0208 A9908   LI      R8,13                   prep RDSK / FGET / FPUT / ADSR / CDIR CALL length ( CALL_XXXX("") )
3258  5DE2 000D  
3259  5DE4 A204         A       R4,R8                   add # of characters in string
3260                    
3261  5DE6 0286         CI      R6,>1100                MDSK or NDSK?
3261  5DE8 1100  
3262  5DEA 1B01         JH      A9909                   no; jump and execute RDSK / FGET / FPUT / ADSR / CDIR
3263  5DEC 05C8         INCT    R8                      adjust MDSK and NDSK CALL length
3264            *
3265  5DEE D806 A9909   MOVB    R6,@ACOMND              command to Arduino
3265  5DF0 5FE8  
3266            *
3267  5DF2 9820 ACLBAS  CB      @CALLST,@K004           "More" or "AllGood" received from Arduino?      
3267  5DF4 5FC6  
3267  5DF6 433E  
3268  5DF8 1419         JHE     A9910                   yep
3269            *       
3270  5DFA 0205         LI      R5,GPLINT               no; GPL routine
3270  5DFC 006A  
3271  5DFE 06A0         BL      @GPLXML                 
3271  5E00 5EFC  
3272  5E02 56CD         DATA    SCROLL                  scroll screen
3273  5E04 0202         LI      R2,736                  screen starting position for (error) message
3273  5E06 02E0  
3274  5E08 06A0         BL      @VDPWRI                 set VDP address
3274  5E0A 4320  
3275  5E0C 06A0         BL      @DISSTS                 show (error) message
3275  5E0E 5E58  
3276  5E10 0205         LI      R5,GPLINT               GPL routine
3276  5E12 006A  
3277  5E14 06A0         BL      @GPLXML 
3277  5E16 5EFC  
3278  5E18 56CD         DATA    SCROLL                  scroll screen
3279            *
3280  5E1A 9820         CB      @CALLST,@K007           error (status code 0 - 9)?
3280  5E1C 5FC6  
3280  5E1E 433D  
3281  5E20 1405         JHE     A9910                   no, informational; be silent    
3282            *
3283  5E22 0205         LI      R5,GPLINT               yes: let's make some noise
3283  5E24 006A  
3284  5E26 06A0         BL      @GPLXML
3284  5E28 5EFC  
3285  5E2A 0036         DATA    HONK                    GPL routine"bad tone"
3286            *
3287  5E2C 0286 A9910   CI      R6,>3500                TIME() ?
3287  5E2E 3500  
3288  5E30 1331         JEQ     TIME2                   yes; see if we can assign date/time to NTP$
3289            *
3290  5E32 04C6 A9911   CLR     R6
3291  5E34 D1A0         MOVB    @ASUBCM,R6              any subcommand to execute?
3291  5E36 5FE9  
3292  5E38 1302         JEQ     A9912                   no
3293  5E3A D806         MOVB    R6,@ACOMND              yes; execute (currently only ARST)
3293  5E3C 5FE8  
3294            *
3295  5E3E C2E0 A9912   MOV     @XBASRT,R11             APEDSK99: CALL LINK from Extended Basic?
3295  5E40 404A  
3296  5E42 1301         JEQ     A9913                   nope
3297  5E44 045B         B       *R11                    yes; return to ExBas program
3298            *
3299  5E46 04E9 A9913   CLR     @>0050(R9)              clear error flag                
3299  5E48 0050  
3300  5E4A AA48         A       R8, @>002C(R9)          add call length to token pointer                
3300  5E4C 002C  
3301  5E4E 5A69         SZCB    @>0042(R9),@>0042(R9)   clear current token
3301  5E50 0042  
3301  5E52 0042  
3302  5E54 0460         B       @RTURN1                 return to caller (i.e. TI-BASIC)
3302  5E56 4360  
3303            *       
3304            * Display data, status messages and errors
3305            *
3306  5E58 0205 DISSTS  LI      R5,CALLBF               start of file name buffer
3306  5E5A 5FC8  
3307  5E5C 0206         LI      R6,32                   32 bytes / 1 screen row of data to display
3307  5E5E 0020  
3308  5E60 DBF5 A9914   MOVB    *R5+,@-2(R15)           store character in VDP screen memory
3308  5E62 FFFE  
3309  5E64 0606         DEC     R6
3310  5E66 16FC         JNE     A9914
3311  5E68 045B         B       *R11
3312            *
3313            * Quick key test to display next screen after ">"
3314            * Keyboard column 0 (= space enter <nc> fctn shift ctrl <nc>)
3315            * Code copy from Thierry's TI's Tech Pages site
3316            *
3317  5E6A C10C CHKKEY  MOV     R12,R4                  save R12
3318  5E6C 04C1         CLR     R1                      test column 0
3319  5E6E 020C         LI      R12,>0024               address for column selection
3319  5E70 0024  
3320  5E72 30C1 A9915   LDCR    R1,3                    select column
3321  5E74 1FF2         TB      -14                     test R12 address >0008
3322  5E76 1607         JNE     A9916                   <SPACE>
3323  5E78 1FF3         TB      -13                     test R12 address >000A
3324  5E7A 13FB         JEQ     A9915                   no key; test again
3325            *
3326  5E7C D820         MOVB    @K004,@CALLST           signal ENTER to LDIR() command
3326  5E7E 433E  
3326  5E80 5FC6  
3327  5E82 020B         LI      R11,QNOPRM              leave without clearing screen
3327  5E84 5CD2  
3328            *
3329  5E86 C304 A9916   MOV     R4,R12                  restore R12
3330  5E88 0A24         SLA     R4,2                    debounce delay
3331  5E8A 0604 A9917   DEC     R4                      key debounce
3332  5E8C 16FE         JNE     A9917                   debounce some more
3333            *
3334  5E8E 045B         B       *R11                    we got one; return for next screen
3335            *
3336            * prep for calling XML >16 and update BASIC variable NTP$               
3337            *
3338  5E90 4E54 VARINF  TEXT    'NTP$'
3338  5E92 5024  
3339  5E94 0204 TIME2   LI      R4,VARINF               variable name for XML >16 in FAC
3339  5E96 5E90  
3340  5E98 C149         MOV     R9,R5                   get scratchpad start address
3341  5E9A D974 A9918   MOVB    *R4+,@>004A(R5)         variable name in FAC
3341  5E9C 004A  
3342  5E9E 0585         INC     R5
3343  5EA0 0284         CI      R4,VARINF+4             done all chars?
3343  5EA2 5E94  
3344  5EA4 16FA         JNE     A9918                   
3345            *
3346  5EA6 0205         LI      R5,>0400                variable length for XML >16 in @>8359
3346  5EA8 0400  
3347  5EAA DA45         MOVB    R5,@>0059(R9)           
3347  5EAC 0059  
3348  5EAE 04E9         CLR     @>0089(R9)      
3348  5EB0 0089  
3349            *
3350  5EB2 0205         LI      R5,XML16                ROM routine: find NTP$ in VDP symbol table (returns to GPL interpreter)
3350  5EB4 15D6  
3351  5EB6 06A0         BL      @GPLXML
3351  5EB8 5EFC  
3352  5EBA 2244         DATA    XMLRTN                  GPL "RTN", escaping GPL interpreter
3353            *
3354  5EBC 9A60         CB      @VARINF,@>004A(R9)      found NTP$ in VDP symbol table?
3354  5EBE 5E90  
3354  5EC0 004A  
3355  5EC2 1318         JEQ     A9920                   no symbol table pointer; back to BASIC
3356            *
3357  5EC4 06A0         BL      @XML14                  ROM routine: get NTP$ VDP address and string length (returns through RT)
3357  5EC6 164E  
3358  5EC8 02A9         STWP    R9                      restore scratchpad pointer
3359  5ECA 0229         AI      R9,-224
3359  5ECC FF20  
3360            *       
3361  5ECE C169         MOV     @>0050(R9),R5           get string length
3361  5ED0 0050  
3362  5ED2 0285         CI      R5,16                   16 chars?
3362  5ED4 0010  
3363  5ED6 160E         JNE     A9920                   no NTP$ assignment for you
3364            *
3365  5ED8 C0A0         MOV     @>834E,R2               yes
3365  5EDA 834E  
3366  5EDC 06A0         BL      @VDPWRI                 set VDP write address
3366  5EDE 4320  
3367  5EE0 0205         LI      R5,CALLBF               CALL TIME data still in buffer
3367  5EE2 5FC8  
3368  5EE4 D0B5 A9919   MOVB    *R5+,R2                 read character
3369  5EE6 0222         AI      R2,>A000                remove TI BASIC bias
3369  5EE8 A000  
3370  5EEA DBC2         MOVB    R2,@-2(R15)             save to NTP$ value space
3370  5EEC FFFE  
3371  5EEE 0285         CI      R5,CALLBF+16            done all 16 chars?
3371  5EF0 5FD8  
3372  5EF2 16F8         JNE     A9919                   no; one more
3373            *
3374  5EF4 109E A9920   JMP     A9911                   yes; back to BASIC
3375            *
3376            * execute GROM or XML routine (SCROLL, "bad sound" / HONK and XML >16)
3377            * DSR and GPL interpreter use same workspace (>83E0) so we need to save a few things
3378            *
3379  5EF6 0000 SAVGRA  BSS     2                       save current GROM address so we can return to BASIC
3380  5EF8 0000 SAVR11  BSS     2                       GPL interpreter uses R11
3381  5EFA 0000 SAVMEX  BSS     2                       save current >A018 value
3382            *
3383  5EFC D820 GPLXML  MOVB    @>9802,@SAVGRA          save current GROM address
3383  5EFE 9802  
3383  5F00 5EF6  
3384  5F02 1000         NOP
3385  5F04 D820         MOVB    @>9802,@SAVGRA+1
3385  5F06 9802  
3385  5F08 5EF7  
3386  5F0A 0620         DEC     @SAVGRA                 GRMWA returns address + 1; decrease for correct address
3386  5F0C 5EF6  
3387            *
3388  5F0E D83B         MOVB    *R11+,@>9C02            set GPL routine address
3388  5F10 9C02  
3389  5F12 1000         NOP
3390  5F14 D83B         MOVB    *R11+,@>9C02
3390  5F16 9C02  
3391  5F18 C80B         MOV     R11,@SAVR11             save final DSR return address
3391  5F1A 5EF8  
3392            *
3393  5F1C C820         MOV     @RTNBC,@SAVMEX          save >A018
3393  5F1E A018  
3393  5F20 5EFA  
3394  5F22 020B         LI      R11,GXRTN               DSR return address after GPL routine
3394  5F24 5F3E  
3395  5F26 C80B         MOV     R11,@RTNBC              @>A018 is where XML >BC returns to
3395  5F28 A018  
3396            *
3397  5F2A 05E0         INCT    @>8373                  increase stack pointer
3397  5F2C 8373  
3398  5F2E 06C9         SWPB    R9                      
3399  5F30 D260         MOVB    @>8373,R9
3399  5F32 8373  
3400  5F34 06C9         SWPB    R9                      complete stack pointer in R9
3401  5F36 020B         LI      R11,XMLBC               GROM pointer to >0FBC (= XML >BC)
3401  5F38 4409  
3402  5F3A C64B         MOV     R11,*R9                 save GROM pointer on stack
3403            *
3404  5F3C 0455         B       *R5                     execute GROM/ROM routine, return through GPL interpreter
3405            *
3406  5F3E D820 GXRTN   MOVB    @SAVGRA,@>9C02          and ... we're back; restore saved GROM address
3406  5F40 5EF6  
3406  5F42 9C02  
3407  5F44 1000         NOP
3408  5F46 D820         MOVB    @SAVGRA+1,@>9C02
3408  5F48 5EF7  
3408  5F4A 9C02  
3409            *
3410  5F4C C820         MOV     @SAVMEX,@RTNBC          restore original >A018 value
3410  5F4E 5EFA  
3410  5F50 A018  
3411            *
3412  5F52 02A9         STWP    R9                      restore scratchpad pointer
3413  5F54 0229         AI      R9,-224
3413  5F56 FF20  
3414            *
3415  5F58 C2E0         MOV     @SAVR11,R11             restore R11
3415  5F5A 5EF8  
3416  5F5C 045B         B       *R11                    return to instruction after BL @GPLEXEC DATA statement
3417            *               
3418            * update FAT time/date for current DOAD after DSR Write / Format / Save
3419            *
3420  5F5E D820 NTPDT   MOVB    @NTPFAT+1,@ACOMND       "DSK NTP date/time update" command to Arduino           
3420  5F60 4027  
3420  5F62 5FE8  
3421  5F64 045B         B       *R11                    return to Format / Close
3422            *
3423            *----------------------------------------------------------------------------------
3424            * >5F66 - >5FB3: 48 free bytes remaining
3425            * >5FC2 - >5FD3 is DSK1-3 parameters storage
3426            * >5FD4 is the CALL() status byte
3427            * >5FD6 - >5FE7 is buffer storage for APEDSK99 CALL's
3428            * >5FE8 is the Arduino Command Register (TI BASIC CALL support)
3429            * Word >5FEA maps to the read counter (R6, to generate interrupts when reading data) 
3430            * Bytes >5FEE maps to the CRU emulation write register
3431            * Bytes >5FF0 to >5FFE map to the FDC emulation registers
3432            *-----------------------------------------------------------------------------------                                    
3433            *
3434  5F66 0000         END
3434            


 Assembly Complete - Errors: 0,  Warnings: 0


 ------ Symbol Listing ------

 A9901  ABS:5CE6 A9901
 A9902  ABS:5CF8 A9902
 A9903  ABS:5D22 A9903
 A9904  ABS:5D48 A9904
 A9905  ABS:5D66 A9905
 A9906  ABS:5DC6 A9906
 A9907  ABS:5DDC A9907
 A9908  ABS:5DE0 A9908
 A9909  ABS:5DEE A9909
 A9910  ABS:5E2C A9910
 A9911  ABS:5E32 A9911
 A9912  ABS:5E3E A9912
 A9913  ABS:5E46 A9913
 A9914  ABS:5E60 A9914
 A9915  ABS:5E72 A9915
 A9916  ABS:5E86 A9916
 A9917  ABS:5E8A A9917
 A9918  ABS:5E9A A9918
 A9919  ABS:5EE4 A9919
 A9920  ABS:5EF4 A9920
 ACFG   ABS:5C74 ACFG
 ACHR   ABS:5C62 ACHR
 ACHR2  ABS:5CE8 ACHR2
 ACLBAS ABS:5DF2 ACLBAS
 ACLERR ABS:5CB2 ACLERR
 ACLPRP ABS:5C78 ACLPRP
 ACOMND ABS:5FE8 ACOMND
 ADDSEC ABS:46EE ADDSEC
 ADSR   ABS:5C44 ADSR
 AFDRPT ABS:52B2 AFDRPT
 AFPGPF ABS:51C8 AFPGPF
 AHLP   ABS:5C5C AHLP
 APSCTS ABS:464A APSCTS
 ARST   ABS:5C68 ARST
 ASUBCM ABS:5FE9 ASUBCM
 AVERSN ABS:4046 AVERSN
 CALLBF ABS:5FC8 CALLBF
 CALLST ABS:5FC6 CALLST
 CALSUB ABS:4342 CALSUB
 CDIR   ABS:5C4A CDIR
 CFNFDR ABS:5B74 CFNFDR
 CFSVIB ABS:5750 CFSVIB
 CHKKEY ABS:5E6A CHKKEY
 CLOSE  ABS:4FBA CLOSE
 CLRFBT ABS:456C CLRFBT
 CLSDIR ABS:55FA CLSDIR
 CMPFN  ABS:4826 CMPFN
 CPCKFN ABS:48FE CPCKFN
 CRFIL1 ABS:447A CRFIL1
 CRFIL2 ABS:4480 CRFIL2
 CRFIL3 ABS:448C CRFIL3
 CRUWRI ABS:5FEE CRUWRI
 DECDCI ABS:4BA0 DECDCI
 DELETE ABS:4758 DELETE
 DISSTS ABS:5E58 DISSTS
 DSDRVS ABS:4340 DSDRVS
 DSKPRM ABS:5FB4 DSKPRM
 DSR01  ABS:4102 DSR01
 DSR02  ABS:410A DSR02
 DSR03  ABS:4114 DSR03
 DSR04  ABS:411E DSR04
 ECUSTM ABS:437A ECUSTM
 EDSR01 ABS:4D36 EDSR01
 EDSR02 ABS:4D44 EDSR02
 EDSR03 ABS:4D4A EDSR03
 EDSR04 ABS:4D50 EDSR04
 EPWRUP ABS:4128 EPWRUP
 ERROR1 ABS:42DE ERROR1
 ERROR3 ABS:4210 ERROR3
 ERROR4 ABS:427C ERROR4
 ERROR5 ABS:495C ERROR5
 ERROR6 ABS:4B12 ERROR6
 ERROR7 ABS:4902 ERROR7
 ERROR8 ABS:4DA2 ERROR8
 ERROR9 ABS:4DBE ERROR9
 ERRR10 ABS:55D6 ERRR10
 ESUB01 ABS:5820 ESUB01
 ESUB02 ABS:5830 ESUB02
 ESUB03 ABS:583A ESUB03
 ESUB04 ABS:5894 ESUB04
 ESUB05 ABS:5960 ESUB05
 ESUB06 ABS:59D0 ESUB06
 ESUB07 ABS:5A96 ESUB07
 ESUB08 ABS:5A42 ESUB08
 FDR2B1 ABS:485A FDR2B1
 FDR2B2 ABS:485E FDR2B2
 FDSKDR ABS:4874 FDSKDR
 FFDRDK ABS:4AF6 FFDRDK
 FFDRFN ABS:4B22 FFDRFN
 FFDROD ABS:4AF2 FFDROD
 FFDRVB ABS:4AAE FFDRVB
 FFDRVP ABS:51B8 FFDRVP
 FFFDR  ABS:5BBC FFFDR
 FFFDRV ABS:4A8E FFFDRV
 FFSBM  ABS:4CA6 FFSBM
 FFSBMP ABS:4BE0 FFSBMP
 FFSVIB ABS:45C4 FFSVIB
 FGET   ABS:5C38 FGET
 FMTDSK ABS:4216 FMTDSK
 FNDFDR ABS:4AEC FNDFDR
 FNDRV  ABS:578A FNDRV
 FPUT   ABS:5C3E FPUT
 FRSCB1 ABS:4CAC FRSCB1
 FSCTOF ABS:4734 FSCTOF
 GPLINT ABS:006A GPLINT
 GPLXML ABS:5EFC GPLXML
 GXRTN  ABS:5F3E GXRTN
 H001   ABS:414E H001
 H002   ABS:41B2 H002
 H003   ABS:41D2 H003
 H004   ABS:41E0 H004
 H005   ABS:41E4 H005
 H006   ABS:41FA H006
 H007   ABS:4232 H007
 H008   ABS:4242 H008
 H009   ABS:4250 H009
 H010   ABS:426A H010
 H011   ABS:42AA H011
 H012   ABS:42CC H012
 H013   ABS:42F0 H013
 H014   ABS:431A H014
 H015   ABS:432E H015
 H016   ABS:439E H016
 H017   ABS:43C2 H017
 H018   ABS:43C8 H018
 H019   ABS:43EC H019
 H020   ABS:43F0 H020
 H021   ABS:4404 H021
 H022   ABS:44A2 H022
 H023   ABS:44FA H023
 H024   ABS:4516 H024
 H025   ABS:452C H025
 H026   ABS:4536 H026
 H027   ABS:4548 H027
 H028   ABS:4556 H028
 H029   ABS:455C H029
 H030   ABS:4594 H030
 H031   ABS:45C0 H031
 H032   ABS:45E2 H032
 H033   ABS:45EC H033
 H034   ABS:4610 H034
 H035   ABS:4624 H035
 H036   ABS:462E H036
 H037   ABS:465A H037
 H038   ABS:466E H038
 H039   ABS:4680 H039
 H040   ABS:46B6 H040
 H041   ABS:46BA H041
 H042   ABS:46C2 H042
 H043   ABS:46C4 H043
 H044   ABS:46D2 H044
 H045   ABS:46E2 H045
 H046   ABS:46EA H046
 H047   ABS:4732 H047
 H048   ABS:473E H048
 H049   ABS:4748 H049
 H050   ABS:4754 H050
 H051   ABS:4770 H051
 H052   ABS:4786 H052
 H053   ABS:4792 H053
 H054   ABS:47D6 H054
 H055   ABS:4806 H055
 H056   ABS:482E H056
 H057   ABS:4852 H057
 H058   ABS:488C H058
 H059   ABS:4896 H059
 H060   ABS:489E H060
 H061   ABS:48EC H061
 H062   ABS:48F4 H062
 H063   ABS:4908 H063
 H064   ABS:4916 H064
 H065   ABS:4922 H065
 H066   ABS:4952 H066
 H067   ABS:4986 H067
 H068   ABS:49A8 H068
 H069   ABS:49AC H069
 H070   ABS:49E4 H070
 H071   ABS:49F8 H071
 H072   ABS:4A08 H072
 H073   ABS:4A12 H073
 H074   ABS:4A68 H074
 H075   ABS:4A78 H075
 H076   ABS:4A7E H076
 H077   ABS:4A86 H077
 H078   ABS:4AAA H078
 H079   ABS:4AC8 H079
 H080   ABS:4AE8 H080
 H081   ABS:4AFE H081
 H082   ABS:4B18 H082
 H083   ABS:4B2E H083
 H084   ABS:4B90 H084
 H085   ABS:4B94 H085
 H086   ABS:4B9A H086
 H087   ABS:4BF4 H087
 H088   ABS:4C06 H088
 H089   ABS:4C16 H089
 H090   ABS:4C22 H090
 H091   ABS:4C48 H091
 H092   ABS:4C52 H092
 H093   ABS:4C5A H093
 H094   ABS:4C80 H094
 H095   ABS:4C9C H095
 H096   ABS:4CD8 H096
 H097   ABS:4CE6 H097
 H098   ABS:4CE8 H098
 H099   ABS:4CEC H099
 H100   ABS:4CEE H100
 H101   ABS:4D16 H101
 H102   ABS:4D1E H102
 H103   ABS:4D54 H103
 H104   ABS:4D5A H104
 H105   ABS:4D80 H105
 H106   ABS:4DC4 H106
 H107   ABS:4DDA H107
 H108   ABS:4DE6 H108
 H109   ABS:4E18 H109
 H110   ABS:4E30 H110
 H111   ABS:4E34 H111
 H112   ABS:4E8A H112
 H113   ABS:4E8E H113
 H114   ABS:4EB2 H114
 H115   ABS:4EB6 H115
 H116   ABS:4EDA H116
 H117   ABS:4F08 H117
 H118   ABS:4F60 H118
 H119   ABS:4F86 H119
 H120   ABS:4F8A H120
 H121   ABS:4FD0 H121
 H122   ABS:4FD4 H122
 H123   ABS:4FE0 H123
 H124   ABS:4FE6 H124
 H125   ABS:4FEE H125
 H126   ABS:5010 H126
 H127   ABS:502A H127
 H128   ABS:5046 H128
 H129   ABS:5054 H129
 H130   ABS:5078 H130
 H131   ABS:5080 H131
 H132   ABS:50A4 H132
 H133   ABS:50E2 H133
 H134   ABS:50EA H134
 H135   ABS:50F4 H135
 H136   ABS:510A H136
 H137   ABS:5120 H137
 H138   ABS:5190 H138
 H139   ABS:5204 H139
 H140   ABS:5224 H140
 H141   ABS:522A H141
 H142   ABS:5286 H142
 H143   ABS:5296 H143
 H144   ABS:537E H144
 H145   ABS:53B2 H145
 H146   ABS:53C0 H146
 H147   ABS:53C6 H147
 H148   ABS:5404 H148
 H149   ABS:5408 H149
 H150   ABS:5426 H150
 H151   ABS:5432 H151
 H152   ABS:5454 H152
 H153   ABS:5464 H153
 H154   ABS:54DA H154
 H155   ABS:5506 H155
 H156   ABS:5514 H156
 H157   ABS:5520 H157
 H158   ABS:552C H158
 H159   ABS:5542 H159
 H160   ABS:5554 H160
 H161   ABS:556E H161
 H162   ABS:5572 H162
 H163   ABS:5582 H163
 H164   ABS:5586 H164
 H165   ABS:55AA H165
 H166   ABS:55B0 H166
 H167   ABS:55C0 H167
 H168   ABS:55DC H168
 H169   ABS:55E6 H169
 H170   ABS:5640 H170
 H171   ABS:56A2 H171
 H172   ABS:56AC H172
 H173   ABS:56B2 H173
 H174   ABS:56BA H174
 H175   ABS:56BC H175
 H176   ABS:56DA H176
 H177   ABS:56EA H177
 H178   ABS:570C H178
 H179   ABS:5714 H179
 H180   ABS:5760 H180
 H181   ABS:5776 H181
 H182   ABS:577A H182
 H183   ABS:5780 H183
 H184   ABS:5784 H184
 H185   ABS:57AC H185
 H186   ABS:57BC H186
 H187   ABS:57C6 H187
 H188   ABS:57F0 H188
 H189   ABS:57F8 H189
 H190   ABS:57FA H190
 H191   ABS:5800 H191
 H192   ABS:5802 H192
 H193   ABS:5816 H193
 H194   ABS:58C4 H194
 H195   ABS:5956 H195
 H196   ABS:595C H196
 H197   ABS:597A H197
 H198   ABS:5980 H198
 H199   ABS:5986 H199
 H200   ABS:59A2 H200
 H201   ABS:59A8 H201
 H202   ABS:59AE H202
 H203   ABS:59C2 H203
 H204   ABS:59E6 H204
 H205   ABS:5A04 H205
 H206   ABS:5A3E H206
 H207   ABS:5A92 H207
 H208   ABS:5AE4 H208
 H209   ABS:5B0E H209
 H210   ABS:5B18 H210
 H211   ABS:5B30 H211
 H212   ABS:5B4C H212
 H213   ABS:5B50 H213
 H214   ABS:5B56 H214
 H215   ABS:5B5A H215
 H216   ABS:5B78 H216
 H217   ABS:5BD8 H217
 H218   ABS:5BF6 H218
 H219   ABS:5C0A H219
 HONK   ABS:0036 HONK
 INSFDR ABS:47F4 INSFDR
 INT2FP ABS:57CE INT2FP
 K001   ABS:4196 K001
 K002   ABS:433C K002
 K004   ABS:433E K004
 K005   ABS:433F K005
 K007   ABS:433D K007
 K013   ABS:42EE K013
 K014   ABS:495A K014
 LASTRK ABS:42FC LASTRK
 LDIR   ABS:5C56 LDIR
 LDSK   ABS:5C20 LDSK
 LDSK2  ABS:5D4A LDSK2
 LOAD   ABS:53B6 LOAD
 LSTDRV ABS:5FC7 LSTDRV
 MDSK   ABS:5C26 MDSK
 MNDSK2 ABS:5DA0 MNDSK2
 NDSK   ABS:5C2C NDSK
 NOCRU  ABS:4194 NOCRU
 NOPARM ABS:5CB6 NOPARM
 NOPRM2 ABS:5CC2 NOPRM2
 NTPDT  ABS:5F5E NTPDT
 NTPFAT ABS:4026 NTPFAT
 NXTPRP ABS:5D86 NXTPRP
 NXTSCR ABS:5D52 NXTSCR
 OPCVEC ABS:4D88 OPCVEC
 OPEN   ABS:4DA8 OPEN
 OPNDIR ABS:559C OPNDIR
 PABR2B ABS:4854 PABR2B
 PATTBL ABS:4044 PATTBL
 PDSK   ABS:5C14 PDSK
 PESB07 ABS:5A9C PESB07
 PRFDRS ABS:4F68 PRFDRS
 PRPFDO ABS:440E PRPFDO
 PRPRTN ABS:4410 PRPRTN
 PUDSK2 ABS:5D44 PUDSK2
 PWRUP  ABS:40FC PWRUP
 QNOPRM ABS:5CD2 QNOPRM
 QSTRNG ABS:5DA6 QSTRNG
 R0     ABS:0000 R0
 R1     ABS:0001 R1
 R10    ABS:000A R10
 R11    ABS:000B R11
 R12    ABS:000C R12
 R13    ABS:000D R13
 R14    ABS:000E R14
 R15    ABS:000F R15
 R2     ABS:0002 R2
 R3     ABS:0003 R3
 R4     ABS:0004 R4
 R5     ABS:0005 R5
 R6     ABS:0006 R6
 R7     ABS:0007 R7
 R8     ABS:0008 R8
 R9     ABS:0009 R9
 RBANB  ABS:54A8 RBANB
 RCOFCB ABS:5338 RCOFCB
 RDATA  ABS:5FF6 RDATA
 RDDIR  ABS:5610 RDDIR
 RDFDR1 ABS:4A34 RDFDR1
 RDFDR2 ABS:4A30 RDFDR2
 RDINT  ABS:5FEA RDINT
 RDOFSC ABS:4614 RDOFSC
 RDSEC1 ABS:4A1E RDSEC1
 RDSK   ABS:5C32 RDSK
 READ   ABS:4FC4 READ
 RETERR ABS:4988 RETERR
 RFDRST ABS:51E4 RFDRST
 RFDRVB ABS:593C RFDRVB
 RFNPTR ABS:5B96 RFNPTR
 RMFPTR ABS:47C4 RMFPTR
 RNFISE ABS:5242 RNFISE
 RRFDR  ABS:525E RRFDR
 RRNPAB ABS:51F8 RRNPAB
 RRSEC  ABS:504A RRSEC
 RSTAT  ABS:5FF0 RSTAT
 RSTDRV ABS:42B0 RSTDRV
 RTNBC  ABS:A018 RTNBC
 RTURN1 ABS:4360 RTURN1
 RVRVDP ABS:43C6 RVRVDP
 RWIND1 ABS:5362 RWIND1
 RWIND2 ABS:5390 RWIND2
 RWSEC  ABS:4A38 RWSEC
 RWSECA ABS:4A3A RWSECA
 RWSECB ABS:4A3C RWSECB
 RWVIB  ABS:49BC RWVIB
 SAVE   ABS:5458 SAVE
 SAVGRA ABS:5EF6 SAVGRA
 SAVMEX ABS:5EFA SAVMEX
 SAVR11 ABS:5EF8 SAVR11
 SCROLL ABS:56CD SCROLL
 SECRW1 ABS:4198 SECRW1
 SELDRV ABS:4282 SELDRV
 SMAP   ABS:5C50 SMAP
 SNDCMD ABS:42F4 SNDCMD
 SP2VDP ABS:5C00 SP2VDP
 STATUS ABS:54DC STATUS
 SUB01  ABS:4010 SUB01
 SUB02  ABS:4016 SUB02
 SUB03  ABS:401C SUB03
 SUB04  ABS:4022 SUB04
 SUB05  ABS:4028 SUB05
 SUB06  ABS:402E SUB06
 SUB07  ABS:4034 SUB07
 SUB08  ABS:403A SUB08
 SUB09  ABS:4052 SUB09
 SUB10  ABS:405C SUB10
 SUB11  ABS:4066 SUB11
 SUB12  ABS:4070 SUB12
 SUB13  ABS:407A SUB13
 SUB14  ABS:4084 SUB14
 SUB15  ABS:408E SUB15
 SUB16  ABS:4098 SUB16
 SUB17  ABS:40A2 SUB17
 SUB18  ABS:40AC SUB18
 SUB19  ABS:40B6 SUB19
 SUB20  ABS:40C0 SUB20
 SUB21  ABS:40CA SUB21
 SUB22  ABS:40D4 SUB22
 SUB23  ABS:40DE SUB23
 SUB24  ABS:40E8 SUB24
 SUB25  ABS:40F2 SUB25
 SVDPRD ABS:43FC SVDPRD
 SVDPWR ABS:43F2 SVDPWR
 SVRVDP ABS:439A SVRVDP
 TIME   ABS:5C6E TIME
 TIME2  ABS:5E94 TIME2
 UCOFCB ABS:52D6 UCOFCB
 UDSK   ABS:5C1A UDSK
 UFNCB  ABS:5B5E UFNCB
 UPDBF  ABS:4580 UPDBF
 UPDCLI ABS:4BBC UPDCLI
 UPDFCB ABS:4F92 UPDFCB
 UPDFDR ABS:4560 UPDFDR
 URFFDR ABS:5302 URFFDR
 USTRNG ABS:5D0A USTRNG
 UWFLVB ABS:5874 UWFLVB
 VARINF ABS:5E90 VARINF
 VDP2SP ABS:5BF0 VDP2SP
 VDPR2B ABS:4860 VDPR2B
 VDPRD  ABS:432A VDPRD
 VDPRPW ABS:4268 VDPRPW
 VDPWRI ABS:4320 VDPWRI
 VECRTN ABS:4392 VECRTN
 WCOMND ABS:5FF8 WCOMND
 WDATA  ABS:5FFE WDATA
 WFDRPB ABS:5026 WFDRPB
 WRFDR  ABS:4A2A WRFDR
 WRITE  ABS:50AE WRITE
 WROFSC ABS:4634 WROFSC
 WRSEC1 ABS:4A20 WRSEC1
 WSECTR ABS:5FFC WSECTR
 WTCPT1 ABS:4274 WTCPT1
 XBASRT ABS:404A XBASRT
 XBJUMP ABS:404C XBJUMP
 XBUSTR ABS:5D3A XBUSTR
 XML14  ABS:164E XML14
 XML16  ABS:15D6 XML16
 XMLBC  ABS:4409 XMLBC
 XMLRTN ABS:2244 XMLRTN
