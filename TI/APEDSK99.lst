Asm994a TMS99000 Assembler - v3.010

                * Asm994a Generated Register Equates
                *
      0000 0000 R0      EQU     0 
      0000 0001 R1      EQU     1 
      0000 0002 R2      EQU     2 
      0000 0003 R3      EQU     3 
      0000 0004 R4      EQU     4 
      0000 0005 R5      EQU     5 
      0000 0006 R6      EQU     6 
      0000 0007 R7      EQU     7 
      0000 0008 R8      EQU     8 
      0000 0009 R9      EQU     9 
      0000 000A R10     EQU     10
      0000 000B R11     EQU     11
      0000 000C R12     EQU     12
      0000 000D R13     EQU     13
      0000 000E R14     EQU     14
      0000 000F R15     EQU     15
                *
   1            *===============================================================================================================
   2            * TI DISK CONTROLLER ROM   >4000-5FFF
   3            * 
   4            * initial commented disassembly by Thierry Nouspikel
   5            * (see http://www.unige.ch/medecine/nouspikel/ti99/titechpages.htm)
   6            *
   7            * and
   8            * 
   9            * Monty Schmidt's book: TI Technical Drive
  10            *
  11            * adapted for APEDSK99 by Jochen Buur
  12            * github.com/jambuur/APEDSK99
  13            *
  14            * v12r: support for Double Density / 80 tracks (max 1440 AU's)
  15            *================================================================================================================
  16  0000 5FC2 DSKPRM  EQU     >5FC2                   per DSKx: Mbyte #sectors, Lbyte #sectors, #sectors/track, #tracks, #sides
  17  0000 5FD4 CALLST  EQU     >5FD4                   CALL() execution status: finished, still active, error
  18  0000 5FD6 CALLBF  EQU     >5FD6                   2-way buffer for TI BASIC CALL's
  19  0000 5FE8 ACOMND  EQU     >5FE8                   APEDSK99-specific Command register
  20  0000 5FEA RDINT   EQU     >5FEA                   issue read interrupt (R6 counter) 
  21  0000 5FEE CRUWRI  EQU     >5FEE                   emulated 8 CRU output bits
  22  0000 5FF0 RSTAT   EQU     >5FF0                   read FD1771 Status register
  23  0000 5FF6 RDATA   EQU     >5FF6                   read FD1771 Data register
  24  0000 5FF8 WCOMND  EQU     >5FF8                   write FD1771 Command register
  25  0000 5FFC WSECTR  EQU     >5FFC                   write FD1771 Sector register
  26  0000 5FFE WDATA   EQU     >5FFE                   write FD1771 Data register
  27            *
  28  0000 164E XML14   EQU     >164E                   ROM address for XML >14
  29  0000 15D6 XML16   EQU     >15D6                   ROM address for XML >16
  30            *
  31            *!!! CHECK GROM ADDRESS CONTENTS, NEEDS TO BE >0F5C; UNCOMMENT RELEVANT LINE (different GROM 0 versions)
  32            *
  33            *XML5C  EQU     >1039                   GROM address for XML >5C; GROM v2.2 consoles
  34            *XML5C  EQU     >1058                   GROM address for XML >5C; GROM - Heiner Martin version
  35  0000 105C XML5C   EQU     >105C                   GROM address for XML >5C; GROM - different pointers to character blocks
  36            *
  37  0000 006A GPLINT  EQU     >006A                   jump to GROM interpreter for SCROLL / HONK
  38  0000 2244 XMLRTN  EQU     >2244                   jump to GROM interpreter for RTN (after executing XML >14 / >16 routine)
  39  0000 56CD SCROLL  EQU     >56CD                   GROM address for scroll routine
  40            *
  41            *!!! CHECK GROM ADDRESS CONTENTS, NEEDS TO BE >BF58; UNCOMMENT RELEVANT LINE (different GROM 0 versions)
  42            *
  43            *HONK   EQU     >03AF                   GROM address for "bad tone"; GROM v2.2 consoles
  44            *HONK   EQU     >03D3                   GROM address for "bad tone"; GROM - Heiner Martin version
  45  0000 03D6 HONK    EQU     >03D6                   GROM address for "bad tone"; GROM - different pointers to character blocks
  46            *
  47                    AORG    >4000
  48            *
  49  4000 AA           BYTE    >AA                     standard header mark
  50  4001 02           BYTE    >02                     version 2
  51  4002 0000         DATA    >0000                   no programs
  52  4004 40C8         DATA    PWRUP                   power-up chain ptr
  53  4006 0000         DATA    >0000                   programs chain ptr (none)
  54  4008 40CE         DATA    DSR01                   DSR chain ptr
  55  400A 4010         DATA    SUB01                   subprograms chain ptr
  56  400C 0000         DATA    >0000                   ISR chain ptr (none)
  57  400E 0000         DATA    >0000                   
  58            *                                       
  59  4010 4016 SUB01   DATA    SUB02                   link to next subprogram
  60  4012 57EC         DATA    ESUB01                  address of that one
  61  4014 0110         DATA    >0110                   subprogram name: >10 (sector R/W)
  62  4016 401C SUB02   DATA    SUB03                   
  63  4018 57FC         DATA    ESUB02                  
  64  401A 0111         DATA    >0111                   subprogram >11 (format disk)
  65  401C 4022 SUB03   DATA    SUB04                   
  66  401E 5806         DATA    ESUB03                  
  67  4020 0112         DATA    >0112                   subprogram >12 (file un/protect)
  68  4022 402A SUB04   DATA    SUB05                   
  69  4024 5860         DATA    ESUB04                  
  70  4026 0113 NTPFAT  DATA    >0113                   subprogram >13 (file rename); doubles as FAT update flag
  71            *
  72  4028 0000 RTN5C   DATA    >0000                   save GPL return address (needs to be @>4028 for XML >5C!)
  73            *
  74  402A 4030 SUB05   DATA    SUB06                   
  75  402C 592C         DATA    ESUB05                  
  76  402E 0114         DATA    >0114                   subprogram >14 (file direct input)              
  77  4030 4036 SUB06   DATA    SUB07                   
  78  4032 599C         DATA    ESUB06                  
  79  4034 0115         DATA    >0115                   subprogram >15 (file direct output)
  80  4036 403C SUB07   DATA    SUB08                   
  81  4038 5A62         DATA    ESUB07                  
  82  403A 0116         DATA    >0116                   subprogram >16 (number of files)
  83  403C 4046 SUB08   DATA    SUB09                   
  84  403E 5A0E         DATA    ESUB08                  
  85  4040 05           BYTE    >05                     
  86  4041 4649         TEXT    'FILES'                 same as >16, called from Basic
  86  4043 4C45  
  86  4045 53    
  87            *
  88  4046 4050 SUB09   DATA    SUB10
  89  4048 5BE0         DATA    PDSK
  90  404A 04           BYTE    >04
  91  404B 5044         TEXT    'PDSK'                  Protect DSKx (apply adhesive tab)
  91  404D 534B  
  92  404F 0000         EVEN
  93  4050 405A SUB10   DATA    SUB11                   
  94  4052 5BE6         DATA    UDSK
  95  4054 04           BYTE    >04
  96  4055 5544         TEXT    'UDSK'                  Un-protect DSKx (remove adhesive tab)
  96  4057 534B  
  97  4059 0000         EVEN
  98  405A 4064 SUB11   DATA    SUB12
  99  405C 5BEC         DATA    MDSK
 100  405E 04           BYTE    >04
 101  405F 4D44         TEXT    'MDSK'                  Map DOAD to DSKx
 101  4061 534B  
 102  4063 0000         EVEN
 103  4064 406E SUB12   DATA    SUB13
 104  4066 5BF2         DATA    LDSK
 105  4068 04           BYTE    >04
 106  4069 4C44         TEXT    'LDSK'                  List files on DSKx
 106  406B 534B  
 107  406D 0000         EVEN
 108  406E 4078 SUB13   DATA    SUB14
 109  4070 5BF8         DATA    RDSK
 110  4072 04           BYTE    >04
 111  4073 5244         TEXT    'RDSK'                  Remove DOAD from SD card
 111  4075 534B  
 112  4077 0000         EVEN
 113  4078 4082 SUB14   DATA    SUB15
 114  407A 5BFE         DATA    SDSK
 115  407C 04           BYTE    >04
 116  407D 5344         TEXT    'SDSK'                  Show DOAD mapping for DSKx
 116  407F 534B  
 117  4081 0000         EVEN
 118  4082 408C SUB15   DATA    SUB16
 119  4084 5C04         DATA    SDIR
 120  4086 04           BYTE    >04
 121  4087 5344         TEXT    'SDIR'                  List DOAD files on SD card
 121  4089 4952  
 122  408B 0000         EVEN
 123  408C 4096 SUB16   DATA    SUB17
 124  408E 5C0A         DATA    AHLP
 125  4090 04           BYTE    >04
 126  4091 4148         TEXT    'AHLP'                  APEDSK99 CALL help screen
 126  4093 4C50  
 127  4095 0000         EVEN
 128  4096 40A0 SUB17   DATA    SUB18
 129  4098 5C10         DATA    TIME
 130  409A 04           BYTE    >04
 131  409B 5449         TEXT    'TIME'                  NTP date/time display / assign to NTP$
 131  409D 4D45  
 132  409F 0000         EVEN
 133  40A0 40AA SUB18   DATA    SUB19
 134  40A2 5C16         DATA    ARST
 135  40A4 04           BYTE    >04
 136  40A5 4152         TEXT    'ARST'                  APEDSK99 Reset
 136  40A7 5354  
 137  40A9 0000         EVEN
 138  40AA 40B4 SUB19   DATA    SUB20
 139  40AC 5C1C         DATA    FGET
 140  40AE 04           BYTE    >04
 141  40AF 4647         TEXT    'FGET'                  Load DOAD from FTP server
 141  40B1 4554  
 142  40B3 0000         EVEN
 143  40B4 40BE SUB20   DATA    SUB21
 144  40B6 5C22         DATA    FPUT
 145  40B8 04           BYTE    >04
 146  40B9 4650         TEXT    'FPUT'                  Save DOAD to FTP server
 146  40BB 5554  
 147  40BD 0000         EVEN
 148  40BE 0000 SUB21   DATA    >0000
 149  40C0 5C28         DATA    ADSR
 150  40C2 04           BYTE    >04
 151  40C3 4144         TEXT    'ADSR'                  APEDSK99 load DSR
 151  40C5 5352  
 152  40C7 0000         EVEN
 153            *
 154  40C8 0000 PWRUP   DATA    >0000                   power-up chain (no more)
 155  40CA 40F4         DATA    EPWRUP                  address of power-up routine
 156  40CC 0000         DATA    >0000                   no name
 157                                                    
 158  40CE 40D6 DSR01   DATA    DSR02                   DSR chain
 159  40D0 4D02         DATA    EDSR01                  address of DSR
 160  40D2 03           BYTE    >03                     name size
 161  40D3 4453         TEXT    'DSK'                   DSR name
 161  40D5 4B    
 162  40D6 40E0 DSR02   DATA    DSR03                   
 163  40D8 4D10         DATA    EDSR02                  
 164  40DA 04           BYTE    >04                     
 165  40DB 4453         TEXT    'DSK1'                  
 165  40DD 4B31  
 166  40DF 0000         EVEN                            
 167  40E0 40EA DSR03   DATA    DSR04                   
 168  40E2 4D16         DATA    EDSR03                  
 169  40E4 04           BYTE    >04                     
 170  40E5 4453         TEXT    'DSK2'                  
 170  40E7 4B32  
 171  40E9 0000         EVEN                            
 172  40EA 0000 DSR04   DATA    >0000                   no more
 173  40EC 4D1C         DATA    EDSR04                  
 174  40EE 04           BYTE    >04                     
 175  40EF 4453         TEXT    'DSK3'                  
 175  40F1 4B33  
 176  40F3 0000         EVEN            
 177            *
 178            *=====================================
 179            * Power-up routine
 180            *=====================================                                          
 181            *
 182  40F4 028C EPWRUP  CI      R12,>1000               Dhr. F.G. Kaal check: are we powering up 1st CRU (>1000) peripheral?
 182  40F6 1000  
 183  40F8 1633         JNE     NOCRU                   nope; return
 184            *
 185  40FA C1CB         MOV     R11,R7                  yes; save return address
 186  40FC 02A9         STWP    R9                      get workspace (should be >83E0)
 187  40FE 0229         AI      R9,-224                 point to top of scratch-pad mem (>8300)
 187  4100 FF20  
 188  4102 C0A9         MOV     @>0070(R9),R2           highest free address in vdp mem (>8370)
 188  4104 0070  
 189  4106 C002         MOV     R2,R0                   save it
 190  4108 0222         AI      R2,-2088                we'll need >828 bytes
 190  410A F7D8  
 191  410C CA42         MOV     R2,@>0070(R9)           update address
 191  410E 0070  
 192  4110 0582         INC     R2
 193  4112 06A0         BL      @VDPWRI                 set VDP address
 193  4114 42EC  
 194  4116 0201         LI      R1,2088                 
 194  4118 0828  
 195  411A 04EF H001    CLR     @-2(R15)                clear these >828 bytes
 195  411C FFFE  
 196  411E 0601         DEC     R1                      
 197  4120 16FC         JNE     H001                    
 198  4122 06A0         BL      @VDPWRI                 set VDP address (same)
 198  4124 42EC  
 199  4126 0203         LI      R3,>AA03                        
 199  4128 AA03  
 200  412A DBC3         MOVB    R3,@-2(R15)             write buffer ID mark
 200  412C FFFE  
 201  412E 1000         NOP                             
 202  4130 DBC0         MOVB    R0,@-2(R15)             write old highest free address
 202  4132 FFFE  
 203  4134 06C0         SWPB    R0
 204  4136 DBC0         MOVB    R0,@-2(R15)
 204  4138 FFFE  
 205  413A 1000         NOP                             
 206  413C DBCC         MOVB    R12,@-2(R15)            write CRU address (>1000 for APEDSK99)
 206  413E FFFE  
 207  4140 06C3         SWPB    R3                      
 208  4142 DBC3         MOVB    R3,@-2(R15)             write number of files (3)
 208  4144 FFFE  
 209  4146 06A0         BL      @PRPRTN                 preparation routine
 209  4148 43DC  
 210  414A 06A0         BL      @CALSUB                 call subroutine
 210  414C 430E  
 211  414E 427C         DATA    RSTDRV                  reset all drives
 212  4150 04E9         CLR     @>0054(R9)              name length = 0 for power-up
 212  4152 0054  
 213  4154 0429         BLWP    @>005A(R9)              retrieve R7 (saved by PRPRTN)
 213  4156 005A  
 214  4158 0011         DATA    >0011                   put it into R11
 215  415A CA60         MOV     @K001,@>006C(R9)        ???
 215  415C 4162  
 215  415E 006C  
 216  4160 045B NOCRU   B       *R11                    return
 217            *                               
 218  4162 0404 K001    DATA    >0404                   
 219            *
 220            *---------------------------------------
 221            * Sector read/write
 222            *---------------------------------------                                        
 223            *
 224  4164 DA60 SECRW1  MOVB    @K002,@>0050(R9)        APEDSK99: no error
 224  4166 4308  
 224  4168 0050  
 225  416A 06A0         BL      @SELDRV                 select drive
 225  416C 424E  
 226            *
 227  416E C069         MOV     @>004A(R9),R1           sector #
 227  4170 004A  
 228  4172 0281         CI      R1,>05A0                APEDSK99: max 1440 (DS/DD/40T or DS/SD/80T)?
 228  4174 05A0  
 229  4176 1A03         JL      H005                    APEDSK99: yes; sector# within range
 230  4178 06A0         BL      @ERROR1                 APEDSK99: no -> "device error"
 230  417A 42AA  
 231  417C 0600         DATA    >0600   
 232            
 233  417E C801 H005    MOV     R1,@WSECTR              APEDSK99: sector# to FD1771 write sector register (16bits)
 233  4180 5FFC  
 234            *
 235  4182 C0A9 H013    MOV     @>004E(R9),R2           data buffer address
 235  4184 004E  
 236  4186 D029         MOVB    @>004D(R9),R0           read or write ?
 236  4188 004D  
 237  418A 1312         JEQ     H014                    write
 238  418C 06A0         BL      @VDPWRI                 read FD = write to VDP buffer
 238  418E 42EC  
 239  4190 0206 H015    LI      R6,256                  APEDSK99: re-arranged H015 to sync reading sector bytes
 239  4192 0100  
 240  4194 C806         MOV     R6,@RDINT               APEDSK99: interrupt Arduino for read operation 
 240  4196 5FEA  
 241  4198 06A0         BL      @SNDCMD                 send command
 241  419A 42C0  
 242  419C 8800         DATA    >8800                   APEDSK99: read sector
 243            *
 244  419E D020 H016    MOVB    @RDATA,R0               get 1 byte from FDC
 244  41A0 5FF6  
 245  41A2 DBC0         MOVB    R0,@-2(R15)             save it to VDP
 245  41A4 FFFE  
 246  41A6 0620         DEC     @RDINT                  APEDSK99: interrupt Arduino for read operation
 246  41A8 5FEA  
 247  41AA 16F9         JNE     H016                    next byte
 248            *
 249  41AC 0460 H019    B       @RTURN1                 return
 249  41AE 432C  
 250            
 251            *       
 252  41B0 06A0 H014    BL      @VDPRD                  write to FD = read from VDP buffer
 252  41B2 42F6  
 253  41B4 0206         LI      R6,256                  256 bytes to write
 253  41B6 0100  
 254            *
 255            * APEDSK99: the first byte to be written needs to be in the data register before the write command is given
 256            *
 257  41B8 D02F         MOVB    @-1026(R15),R0          APEDSK99: get a byte from data buffer
 257  41BA FBFE  
 258  41BC D800         MOVB    R0,@WDATA               APEDSK99: write first byte to data register
 258  41BE 5FFE  
 259  41C0 06A0         BL      @SNDCMD                 send command
 259  41C2 42C0  
 260  41C4 A800         DATA    >A800                   APEDSK99: write sector
 261            *
 262  41C6 D02F H024    MOVB    @-1026(R15),R0          get a byte from data buffer
 262  41C8 FBFE  
 263  41CA D800         MOVB    R0,@WDATA               pass it to data register
 263  41CC 5FFE  
 264  41CE 0606         DEC     R6                      
 265  41D0 16FA         JNE     H024                    next byte
 266            *
 267  41D2 06A0         BL      @WTCPT1                 APEDSK99: check for Write Protect
 267  41D4 4240  
 268  41D6 0A20         SLA     R0,2                    APEDSK99: WP bit in Carry
 269  41D8 1801         JOC     ERROR3                  write protect: error 34
 270  41DA 10E8         JMP     H019                    APEDSK99: no need to verify             
 271            *                                       
 272  41DC 06A0 ERROR3  BL      @ERROR1                 error 34 (Write Protect)
 272  41DE 42AA  
 273  41E0 3400         DATA    >3400                   
 274            *
 275            *--------------------------------------------------------------------
 276            * Format disk - APEDSK99: we don't do any physical formatting anymore
 277            *--------------------------------------------------------------------
 278            *
 279  41E2 04E9 FMTDSK  CLR     @>004A(R9)              called by subprogram >11
 279  41E4 004A  
 280            *                                       
 281  41E6 5A60 H027    SZCB    @K004,@>004C(R9)        clear DSR version flags
 281  41E8 430A  
 281  41EA 004C  
 282            *
 283  41EC 06A0         BL      @SELDRV                 select drive
 283  41EE 424E  
 284            *
 285  41F0 D029         MOVB    @>004D(R9),R0           APEDSK99: get # of tracks
 285  41F2 004D  
 286  41F4 9829         CB      @>0051(R9),@K005        APEDSK99: double sided?
 286  41F6 0051  
 286  41F8 430B  
 287  41FA 1601         JNE     H036                    APEDSK99: single-side
 288            *
 289  41FC 0A10         SLA     R0,1                    times two (since 2 sides)
 290            *
 291  41FE 0980 H036    SRL     R0,8                    APEDSK99: make it a byte
 292  4200 0206         LI      R6,9                    APEDSK99: start with single density
 292  4202 0009  
 293  4204 9829         CB      @>0050(R9),@K005        APEDSK99: double density required?
 293  4206 0050  
 293  4208 430B  
 294  420A 1601         JNE     H037                    APEDSK99: no, leave R6 alone
 295  420C 0A16         SLA     R6,1                    APEDSK99: yes, R6*2
 296            *               
 297  420E 3806 H037    MPY     R6,R0                   APEDSK99: #sectors/track * #tracks
 298  4210 0281         CI      R1,>05A0                APEDSK99: >1440 sectors?
 298  4212 05A0  
 299  4214 1203         JLE     H038                    APEDSK99: nope; continue
 300  4216 06A0         BL      @ERROR1                 APEDSK99: yes; "device error"
 300  4218 42AA  
 301  421A 0600         DATA    >0600   
 302            *
 303  421C CA41 H038    MOV     R1,@>004A(R9)           pass total # of sectors per disk
 303  421E 004A  
 304  4220 06C6         SWPB    R6
 305  4222 DA46         MOVB    R6,@>004D(R9)           APEDSK99: pass # of sectors per track
 305  4224 004D  
 306  4226 DA60         MOVB    @K002,@>0050(R9)        no error
 306  4228 4308  
 306  422A 0050  
 307            *
 308  422C 06A0         BL      @NTPDT                  APEDSK99: update DOAD FAT time/date
 308  422E 5DD8  
 309            *
 310  4230 0460         B       @RTURN1                 return
 310  4232 432C  
 311            *                                       
 312                                                    
 313  4234 C1BB VDPRPW  MOV     *R11+,R6                VDP repeated write
 314  4236 DBC0 H044    MOVB    R0,@-2(R15)
 314  4238 FFFE  
 315  423A 0606         DEC     R6                      byte in R0
 316  423C 16FC         JNE     H044                    number of repeats in data word
 317  423E 045B         B       *R11                    
 318            *
 319  4240 D020 WTCPT1  MOVB    @RSTAT,R0               get status. APEDSK99: Not Ready >80 / Write Protect >40
 319  4242 5FF0  
 320  4244 1101         JLT     ERROR4                  drive not ready. APEDSK99: Not Ready set when DOAD file is unavailable
 321  4246 045B         B       *R11                    
 322            *
 323  4248 06A0 ERROR4  BL      @ERROR1                 exit with error code 6, reseting all drives
 323  424A 42AA  
 324  424C 0600         DATA    >0600                   
 325            *                                       
 326  424E C1CB SELDRV  MOV     R11,R7                  select a drive
 327  4250 C0A9         MOV     @>0058(R9),R2
 327  4252 0058  
 328  4254 0222         AI      R2,-10                  point to drive info
 328  4256 FFF6  
 329  4258 04C0 H055    CLR     R0                      
 330  425A D029         MOVB    @>004C(R9),R0           get drive #
 330  425C 004C  
 331  425E 130B         JEQ     H056                    can't be >00: error #7
 332  4260 0280         CI      R0,>0300                        
 332  4262 0300  
 333  4264 1B08         JH      H056                    drive number can't be higher than 3: error #7
 334  4266 06A0         BL      @VDPWRI                 set VDP to write, address in R2
 334  4268 42EC  
 335  426A DBC0         MOVB    R0,@-2(R15)             modify last drive accessed              
 335  426C FFFE  
 336            *
 337  426E 0A10 H057    SLA     R0,1                    APEDSK99: bit 0 is side select, 1-3 is drive #
 338  4270 D800         MOVB    R0,@CRUWRI              APEDSK99: select drive
 338  4272 5FEE  
 339  4274 0457 H058    B       *R7                     
 340            *                                       
 341  4276 06A0 H056    BL      @ERROR1                 exit with error #7
 341  4278 42AA  
 342  427A 0700         DATA    >0700                   
 343            *                                       
 344  427C 5820 RSTDRV  SZCB    @DSDRVS,@CRUWRI         APEDSK99: reset all drives including side
 344  427E 430C  
 344  4280 5FEE  
 345  4282 D820         MOVB    @K013,@WCOMND           send Force Interrupt with no interrupt flag set
 345  4284 42BA  
 345  4286 5FF8  
 346  4288 C0A9         MOV     @>0058(R9),R2           ptr to VIB buffer
 346  428A 0058  
 347  428C 0222         AI      R2,-10                  now points to drive info buffer
 347  428E FFF6  
 348  4290 06A0         BL      @VDPWRI                 set VDP to write to address in R2
 348  4292 42EC  
 349  4294 0200         LI      R0,4                    
 349  4296 0004  
 350  4298 DBC0 H061    MOVB    R0,@-2(R15)             write four >00 (i.e. clear drive info)
 350  429A FFFE  
 351  429C 0600         DEC     R0                      
 352  429E 16FC         JNE     H061                    
 353  42A0 DA60         MOVB    @K002,@>0050(R9)        no error
 353  42A2 4308  
 353  42A4 0050  
 354  42A6 0460         B       @RTURN1                 get return address from stack
 354  42A8 432C  
 355            *                                       
 356  42AA C01B ERROR1  MOV     *R11,R0                 exit with error
 357  42AC DA40         MOVB    R0,@>0050(R9)           place err code in >8350
 357  42AE 0050  
 358  42B0 0280         CI      R0,>0600                check if device error
 358  42B2 0600  
 359  42B4 1603         JNE     H064                    no: exit
 360  42B6 06A0         BL      @SNDCMD                 yes: reset drives
 360  42B8 42C0  
 361            *
 362  42BA 0000 K013    DATA    >0000                   APEDSK99: send Restore command
 363            *
 364  42BC 0460 H064    B       @RTURN1                 return to caller (address from stack)
 364  42BE 432C  
 365            *                               
 366  42C0 C03B SNDCMD  MOV     *R11+,R0                send command to FDC from data word
 367  42C2 D800 H066    MOVB    R0,@WCOMND              send command
 367  42C4 5FF8  
 368  42C6 045B         B       *R11                    
 369            *                                       
 370  42C8 04C0 LASTRK  CLR     R0                      get last track # for this drive
 371  42CA D029         MOVB    @>004C(R9),R0           get drive #
 371  42CC 004C  
 372  42CE 130B         JEQ     H068                    can't be 0
 373  42D0 06C0         SWPB    R0                      
 374  42D2 0280         CI      R0,3                    
 374  42D4 0003  
 375  42D6 1B07         JH      H068                    can't be higher than 3
 376  42D8 C0A9         MOV     @>0058(R9),R2                   
 376  42DA 0058  
 377  42DC 0222         AI      R2,-10                  point to last drive accessed
 377  42DE FFF6  
 378  42E0 A080         A       R0,R2                   point to last track for this drive
 379  42E2 0460         B       @VDPRD                  prepare VDP to read from address in R2
 379  42E4 42F6  
 380            *                                       
 381  42E6 06A0 H068    BL      @ERROR1                 exit with error code 7
 381  42E8 42AA  
 382  42EA 0700         DATA    >0700                   
 383            *                                       
 384  42EC 0262 VDPWRI  ORI     R2,>4000                set VDP address to write
 384  42EE 4000  
 385  42F0 0242         ANDI    R2,>7FFF                not to a register
 385  42F2 7FFF  
 386  42F4 1002         JMP     H069                    
 387  42F6 0242 VDPRD   ANDI    R2,>3FFF                set VDP address to read
 387  42F8 3FFF  
 388  42FA 06C2 H069    SWPB    R2                      
 389  42FC D7C2         MOVB    R2,*R15                 write address
 390  42FE 06C2         SWPB    R2                      
 391  4300 D7C2         MOVB    R2,*R15                 
 392  4302 0242         ANDI    R2,>3FFF                        
 392  4304 3FFF  
 393  4306 045B         B       *R11                    
 394            *                                       
 395  4308 00   K002    BYTE    >00                     
 396  4309 09   K007    BYTE    >09                                             
 397  430A F0   K004    BYTE    >F0                     
 398  430B 02   K005    BYTE    2
 399  430C 0F   DSDRVS  BYTE    >0F                     APEDSK99: deselect all drives + side (reset CRUWRI bits 7,6,5 and 4)                    
 400            *
 401  430D 0000         EVEN
 402            *                               
 403  430E 0669 CALSUB  DECT    @>0066(R9)              call subroutine, return address in stack
 403  4310 0066  
 404  4312 C2A9         MOV     @>0066(R9),R10
 404  4314 0066  
 405  4316 0429         BLWP    @>005A(R9)              set VDP to write to address in R10
 405  4318 005A  
 406  431A 0143         DATA    >0143                   
 407  431C C2BB         MOV     *R11+,R10               get next data word
 408  431E 06CB         SWPB    R11                     write return address to VDP
 409  4320 DBCB         MOVB    R11,@-2(R15)                    
 409  4322 FFFE  
 410  4324 06CB         SWPB    R11                     
 411  4326 DBCB         MOVB    R11,@-2(R15)                    
 411  4328 FFFE  
 412  432A 045A         B       *R10                    branch to address in data word
 413            *                               
 414  432C C2E9 RTURN1  MOV     @>0066(R9),R11          get return address from VDP stack
 414  432E 0066  
 415  4330 0429         BLWP    @>005A(R9)              
 415  4332 005A  
 416  4334 0162         DATA    >0162                   set VDP to read from address in R11
 417  4336 D2EF         MOVB    @-1026(R15),R11                 
 417  4338 FBFE  
 418  433A 06CB         SWPB    R11                     
 419  433C D2EF         MOVB    @-1026(R15),R11                 
 419  433E FBFE  
 420  4340 05E9         INCT    @>0066(R9)                      
 420  4342 0066  
 421  4344 045B         B       *R11                    
 422            *
 423            *---------------------------------------
 424            * Custom routines, dealing with VDP memory
 425            * Format is >pppr where r is routine number (0-3)
 426            * and ppp contains parameters
 427            * The workspace it >8300. Called by BLWP @>005A(9).
 428            *---------------------------------------                                        
 429            *
 430  4346 C28D ECUSTM  MOV     R13,R10                 save wregs ptr
 431  4348 C23E         MOV     *R14+,R8                get next data word
 432  434A C248         MOV     R8,R9                   save it
 433  434C 0949         SRL     R9,4                    keep parameter
 434  434E 0248         ANDI    R8,3                    four possible operations
 434  4350 0003  
 435  4352 A208         A       R8,R8                   make it a word ptr
 436  4354 C2ED         MOV     @>001E(R13),R11         get old R15, i.e. VDP port (>8C02)
 436  4356 001E  
 437  4358 C228         MOV     @VECRTN(R8),R8          get vector for operation
 437  435A 435E  
 438  435C 0458         B       *R8                     branch to it
 439            *                                       
 440  435E 4366 VECRTN  DATA    SVRVDP                  save registers to VDP stack
 441  4360 4392         DATA    RVRVDP                  retrieve registers
 442  4362 43C8         DATA    SVDPRD                  set VDP address to read
 443  4364 43BE         DATA    SVDPWR                  set VDP address to write
 444            *                                       
 445  4366 022A SVRVDP  AI      R10,22                  0: save registers in VDP mem
 445  4368 0016  
 446  436A 0919 H072    SRL     R9,1                    start with R12
 447  436C 1710         JNC     H070                    bits in >ppp tell which register to save (R0-R11)
 448  436E 064C         DECT    R12                     previous address in VDP stack (grows down)
 449  4370 C21A         MOV     *R10,R8                 get register contents
 450  4372 06CC         SWPB    R12                     set VDP address to write
 451  4374 D6CC         MOVB    R12,*R11                R12 is >8366: VDP stack ptr
 452  4376 06CC         SWPB    R12                     
 453  4378 026C         ORI     R12,>4000                       
 453  437A 4000  
 454  437C D6CC         MOVB    R12,*R11                        
 455  437E 06C8         SWPB    R8                      save register to VDP mem
 456  4380 DAC8         MOVB    R8,@-2(R11)                     
 456  4382 FFFE  
 457  4384 06C8         SWPB    R8                      
 458  4386 DAC8         MOVB    R8,@-2(R11)                     
 458  4388 FFFE  
 459  438A C249         MOV     R9,R9                   more to come?
 460  438C 1317         JEQ     H071                    no:return
 461  438E 064A H070    DECT    R10                     point to previous register
 462  4390 10EC         JMP     H072                    
 463            *                               
 464  4392 0A49 RVRVDP  SLA     R9,4                    1: retrieve registers from VDP mem
 465  4394 0A19 H074    SLA     R9,1                    each bit tells whether to load
 466  4396 1710         JNC     H073                    don't retrieve that one
 467  4398 06CC         SWPB    R12                     set VDP address to read
 468  439A D6CC         MOVB    R12,*R11                R12 is >8366: VDP stack ptr
 469  439C 06CC         SWPB    R12                     
 470  439E 024C         ANDI    R12,>3FFF                       
 470  43A0 3FFF  
 471  43A2 D6CC         MOVB    R12,*R11                        
 472  43A4 1000         NOP                             
 473  43A6 D22B         MOVB    @-1026(R11),R8          get a 2-byte value from VDP
 473  43A8 FBFE  
 474  43AA 06C8         SWPB    R8                      
 475  43AC D22B         MOVB    @-1026(R11),R8                  
 475  43AE FBFE  
 476  43B0 C688         MOV     R8,*R10                 save it to register
 477  43B2 05CC         INCT    R12                     increment ptr (stack grows downwards)
 478  43B4 C249         MOV     R9,R9                   more to come?
 479  43B6 1302         JEQ     H071                    no: return
 480  43B8 05CA H073    INCT    R10                     next register
 481  43BA 10EC         JMP     H074                    
 482  43BC 0380 H071    RTWP                            
 483            *                                       
 484  43BE A24D SVDPWR  A       R13,R9                  2: set VDP for a write
 485  43C0 C219         MOV     *R9,R8                  
 486  43C2 0268         ORI     R8,>4000                get address from reg in >..p2 (*2)
 486  43C4 4000  
 487  43C6 1004         JMP     H075                    
 488            *                                       
 489  43C8 A24D SVDPRD  A       R13,R9                  3: set VDP for a read
 490  43CA C219         MOV     *R9,R8
 491  43CC 0248         ANDI    R8,>3FFF                get register from reg in >..p3 (*2)
 491  43CE 3FFF  
 492  43D0 06C8 H075    SWPB    R8                      set VDP address
 493  43D2 D6C8         MOVB    R8,*R11                 
 494  43D4 06C8         SWPB    R8                      
 495  43D6 D6C8         MOVB    R8,*R11                 
 496  43D8 0380         RTWP                            
 497            *
 498            *---------------------------------------
 499            * Preparation subroutine
 500            * Sets up the 4 custom subroutines
 501            * Gets a few pointers to VDP buffers
 502            *  >8358: copy of VIB  >8366: VDP stack ptr (grows down from drive info)
 503            *  >8354: PAB          >8356: ptr to end-of-buffer
 504            *---------------------------------------                                        
 505            *
 506  43DA 05C7 PRPFDO  INCT    R7                      stop scanning upon return
 507  43DC C28B PRPRTN  MOV     R11,R10                 save return address
 508  43DE 02A9         STWP    R9                      get workspace (should be >83E0)
 509  43E0 0229         AI      R9,-224                 top of scratch/pad mem (>8300)
 509  43E2 FF20  
 510  43E4 0200         LI      R0,ECUSTM               entry to 4 custom routines
 510  43E6 4346  
 511  43E8 CA40         MOV     R0,@>005C(R9)           put it in >835C
 511  43EA 005C  
 512  43EC C009         MOV     R9,R0                   
 513  43EE 0220         AI      R0,>004E                workspace for these four (>834E)
 513  43F0 004E  
 514  43F2 CA40         MOV     R0,@>005A(R9)           put it in >835A
 514  43F4 005A  
 515            *                                       
 516  43F6 C229         MOV     @>0070(R9),R8           highest free address in VDP mem
 516  43F8 0070  
 517  43FA 05C8 H076    INCT    R8                      point to end-of-buffer word
 518  43FC 06A0         BL      @VDPR2B                 read 2 bytes from VDP address R8, into R0
 518  43FE 482C  
 519  4400 C088         MOV     R8,R2                   save current R8
 520  4402 C200         MOV     R0,R8                   get end-of-buffer word
 521  4404 0228         AI      R8,-266                 yes: point to volume information block
 521  4406 FEF6  
 522  4408 CA48         MOV     R8,@>0058(R9)           save it in >8358
 522  440A 0058  
 523  440C 0228         AI      R8,-10                  point to disk drive info (drive #, last tracks)
 523  440E FFF6  
 524  4410 CA48         MOV     R8,@>0066(R9)           save in >8366: VDP stack ptr (DECT before writing)
 524  4412 0066  
 525  4414 0429         BLWP    @>005A(R9)              save R7 (return address)
 525  4416 005A  
 526  4418 0100         DATA    >0100                   
 527  441A C1E9         MOV     @>0056(R9),R7           ptr to PAB: end of DSR name
 527  441C 0056  
 528  441E C0C7         MOV     R7,R3                   save it
 529  4420 61E9         S       @>0054(R9),R7           start of DSR name
 529  4422 0054  
 530  4424 CA42         MOV     R2,@>0056(R9)           >8356: ptr to end-of-buffer word in VDP mem
 530  4426 0056  
 531  4428 0607         DEC     R7                      point to name length byte
 532  442A 04C2         CLR     R2                      
 533  442C 0429         BLWP    @>005A(R9)              set VDP to read from address in R2
 533  442E 005A  
 534  4430 00E2         DATA    >00E2                   
 535  4432 D0AF         MOVB    @-1026(R15),R2          get name length byte
 535  4434 FBFE  
 536  4436 06C2         SWPB    R2                      make it a word
 537  4438 60A9         S       @>0054(R9),R2           minus DSR name size: lenght of .parameters
 537  443A 0054  
 538  443C 0227         AI      R7,-9                   point to top of PAB
 538  443E FFF7  
 539  4440 CA47         MOV     R7,@>0054(R9)           save it in >8354
 539  4442 0054  
 540  4444 045A         B       *R10                    
 541            *                               
 542  4446 06A0 CRFIL1  BL      @CALSUB                 create file
 542  4448 430E  
 543  444A 4AB8         DATA    FNDFDR                  find a FDR in disk
 544  444C C104 CRFIL2  MOV     R4,R4                   found?
 545  444E 1604         JNE     CRFIL3                  no
 546  4450 06A0         BL      @CALSUB                 yes: delete old file
 546  4452 430E  
 547  4454 4590         DATA    FFSVIB                  free file sector in VIB bitmap
 548  4456 1045         JMP     H077                    clear its FDR
 549            *                               
 550  4458 06A0 CRFIL3  BL      @INSFDR                 new file: insert a FDR in sector 1
 550  445A 47C0  
 551  445C 0701         SETO    R1                      
 552  445E 06A0         BL      @CALSUB                 call subroutine
 552  4460 430E  
 553  4462 4BAC         DATA    FFSBMP                  find a free sector in VIB bitmap
 554  4464 C000         MOV     R0,R0                   found?
 555  4466 1603         JNE     H078                    yes: # in R0
 556  4468 06A0         BL      @ERROR5                 no: update data, then return with error
 556  446A 4928  
 557  446C 8000         DATA    >8000                   memory full
 558            *                               
 559  446E 0429 H078    BLWP    @>005A(R9)              set VDP to write
 559  4470 005A  
 560  4472 0103         DATA    >0103                   address in R8
 561  4474 DBC0         MOVB    R0,@-2(R15)             write sector # for FDR in sector 1
 561  4476 FFFE  
 562  4478 06C0         SWPB    R0                      
 563  447A DBC0         MOVB    R0,@-2(R15)                     
 563  447C FFFE  
 564  447E 06C0         SWPB    R0                      
 565  4480 C069         MOV     @>0056(R9),R1           ptr to FDR in VDP buffers
 565  4482 0056  
 566  4484 0221         AI      R1,-4                   ptr to sector # for FDR
 566  4486 FFFC  
 567  4488 0429         BLWP    @>005A(R9)              set VDP to write
 567  448A 005A  
 568  448C 0023         DATA    >0023                   address in R1
 569  448E DBC0         MOVB    R0,@-2(R15)             write sector # for FDR in VDP buffer
 569  4490 FFFE  
 570  4492 06C0         SWPB    R0                      
 571  4494 DBC0         MOVB    R0,@-2(R15)                     
 571  4496 FFFE  
 572  4498 0221         AI      R1,3                    ptr to drive #
 572  449A 0003  
 573  449C 0429         BLWP    @>005A(R9)              set VDP to write
 573  449E 005A  
 574  44A0 0023         DATA    >0023                   address in R1
 575  44A2 DBC6         MOVB    R6,@-2(R15)             write drive # before FDR in VDP buffer
 575  44A4 FFFE  
 576  44A6 04C2         CLR     R2                      code for write
 577  44A8 0581         INC     R1                      
 578  44AA 06A0         BL      @CALSUB                 call subroutine
 578  44AC 430E  
 579  44AE 49EC         DATA    WRSEC1                  write sector 1
 580  44B0 C169         MOV     @>0058(R9),R5           ptr to VIB in VDP buffers
 580  44B2 0058  
 581  44B4 04C4         CLR     R4                      sector 0
 582  44B6 06A0         BL      @CALSUB                 call subroutine
 582  44B8 430E  
 583  44BA 4A04         DATA    RWSEC                   write VIB to sector 0
 584  44BC C0C5         MOV     R5,R3                   copy filename from compare buffer to FDR
 585  44BE 0223         AI      R3,257                  ptr to file compare buffer
 585  44C0 0101  
 586  44C2 0202         LI      R2,10                   10 chars per filename
 586  44C4 000A  
 587  44C6 0429 H079    BLWP    @>005A(R9)              set VDP to read
 587  44C8 005A  
 588  44CA 0062         DATA    >0062                   address in R3
 589  44CC D02F         MOVB    @-1026(R15),R0          get 1 char
 589  44CE FBFE  
 590  44D0 0583         INC     R3                      increment source ptr
 591  44D2 0429         BLWP    @>005A(R9)              set VDP to write
 591  44D4 005A  
 592  44D6 0023         DATA    >0023                   address in R1
 593  44D8 DBC0         MOVB    R0,@-2(R15)             copy 1 char
 593  44DA FFFE  
 594  44DC 0581         INC     R1                      increment destination ptr
 595  44DE 0602         DEC     R2                      # of chars in R2
 596  44E0 16F2         JNE     H079                    next
 597            *
 598  44E2 06A0 H077    BL      @NTPDT                  APEDSK99: update DOAD FAT time/date
 598  44E4 5DD8  
 599            *
 600  44E6 C069         MOV     @>0056(R9),R1           FDR ptr
 600  44E8 0056  
 601  44EA 0221         AI      R1,10                   skip filename
 601  44EC 000A  
 602  44EE 0202         LI      R2,246                  remaining bytes in FDR
 602  44F0 00F6  
 603  44F2 0429         BLWP    @>005A(R9)              set VDP to write
 603  44F4 005A  
 604  44F6 0023         DATA    >0023                   address in R1
 605  44F8 DBC2 H080    MOVB    R2,@-2(R15)             write >00
 605  44FA FFFE  
 606  44FC 0602         DEC     R2                      clear remainder of new FDR
 607  44FE 16FC         JNE     H080                    next byte
 608  4500 1010         JMP     H081                    write FDR to disk return to caller
 609            *                                       
 610  4502 C169 H082    MOV     @>0056(R9),R5           check if FDR must be updated
 610  4504 0056  
 611  4506 0429         BLWP    @>005A(R9)              set VDP to read
 611  4508 005A  
 612  450A 00A2         DATA    >00A2                   address in R5
 613  450C D12F         MOVB    @-1026(R15),R4          get filename in file ctrl block
 613  450E FBFE  
 614  4510 1101         JLT     H083                    flag: FDR was modified, update it
 615  4512 100A         JMP     H084                    
 616  4514 0244 H083    ANDI    R4,>7F00                clear flag bit
 616  4516 7F00  
 617  4518 0429         BLWP    @>005A(R9)              st VDP to write
 617  451A 005A  
 618  451C 00A3         DATA    >00A3                   address in R5
 619  451E DBC4         MOVB    R4,@-2(R15)             write back filename without flag bit
 619  4520 FFFE  
 620  4522 04C2 H081    CLR     R2                      code for write
 621  4524 0460         B       @WRFDR                  write FDR to disk
 621  4526 49F6  
 622  4528 0460 H084    B       @RTURN1                 return to caller
 622  452A 432C  
 623            *                               
 624  452C 06A0 UPDFDR  BL      @CALSUB                 update FDR + data
 624  452E 430E  
 625  4530 454C         DATA    UPDBF                   update data buffer if necessary
 626  4532 06A0         BL      @CALSUB                 call subroutine
 626  4534 430E  
 627  4536 4502         DATA    H082                    update FDR if necessary
 628  4538 C169 CLRFBT  MOV     @>0056(R9),R5                   
 628  453A 0056  
 629  453C 04C6         CLR     R6                      
 630  453E 0429         BLWP    @>005A(R9)              set VDP to write
 630  4540 005A  
 631  4542 00A3         DATA    >00A3                   address in R5
 632  4544 DBC6         MOVB    R6,@-2(R15)             clr first byte of filename in FDR
 632  4546 FFFE  
 633  4548 0460         B       @RWVIB                  
 633  454A 4988  
 634            *                                       
 635  454C C129 UPDBF   MOV     @>0056(R9),R4           check if data buffer must be updated
 635  454E 0056  
 636  4550 0604         DEC     R4                      
 637  4552 0429         BLWP    @>005A(R9)              set VDP to read
 637  4554 005A  
 638  4556 0082         DATA    >0082                   address in R4
 639  4558 D06F         MOVB    @-1026(R15),R1          get drive #
 639  455A FBFE  
 640  455C 1101         JLT     H085                    flag: must be updated
 641  455E 1016         JMP     H086                    no need to update: return
 642  4560 0241 H085    ANDI    R1,>7F00                erase flag
 642  4562 7F00  
 643  4564 0429         BLWP    @>005A(R9)              set VDP to write
 643  4566 005A  
 644  4568 0083         DATA    >0083                   address in R4
 645  456A DBC1         MOVB    R1,@-2(R15)             write back drive # without flag
 645  456C FFFE  
 646  456E 0224         AI      R4,-5                   point to current logical record offset
 646  4570 FFFB  
 647  4572 0429         BLWP    @>005A(R9)              set VDP to read
 647  4574 005A  
 648  4576 0082         DATA    >0082                   address in R4
 649  4578 D0EF         MOVB    @-1026(R15),R3          get current logical record offset
 649  457A FBFE  
 650  457C 06C3         SWPB    R3                      
 651  457E D0EF         MOVB    @-1026(R15),R3                  
 651  4580 FBFE  
 652  4582 06C3         SWPB    R3                      
 653  4584 C1C4         MOV     R4,R7                   
 654  4586 0227         AI      R7,262                  point to data buffer area
 654  4588 0106  
 655  458A 103A         JMP     WROFSC                  
 656  458C 0460 H086    B       @RTURN1                 return to caller
 656  458E 432C  
 657            *                               
 658  4590 C0A9 FFSVIB  MOV     @>0056(R9),R2           free file sectors in VIB bitmap
 658  4592 0056  
 659  4594 0222         AI      R2,12                   
 659  4596 000C  
 660  4598 0429         BLWP    @>005A(R9)              set VDP to read
 660  459A 005A  
 661  459C 0042         DATA    >0042                   address in R2
 662  459E D02F         MOVB    @-1026(R15),R0          get file status byte from FDR
 662  45A0 FBFE  
 663  45A2 0240         ANDI    R0,>0800                write protected?
 663  45A4 0800  
 664  45A6 1303         JEQ     H087                    no
 665  45A8 06A0         BL      @ERROR5                 update data if needed, the return with error
 665  45AA 4928  
 666  45AC 2000         DATA    >2000                   write protected
 667            *                                       
 668  45AE C229 H087    MOV     @>0056(R9),R8           get ptr to FDR
 668  45B0 0056  
 669  45B2 0228         AI      R8,28                   point to clusters list
 669  45B4 001C  
 670  45B6 0704         SETO    R4                      previous offset
 671  45B8 06A0 H089    BL      @DECDCI                 decode cluster info: sector in R1, offset in R2
 671  45BA 4B6C  
 672  45BC 0228         AI      R8,3                    next cluster ptr
 672  45BE 0003  
 673  45C0 C041         MOV     R1,R1                   
 674  45C2 130C         JEQ     H088                    sector 0 = no more clusters
 675  45C4 C002         MOV     R2,R0                   total offset
 676  45C6 6084         S       R4,R2                   minus previous cluster offset = cluster size
 677  45C8 C100         MOV     R0,R4                   new previous cluster offset
 678  45CA 06A0         BL      @CALSUB                 call subroutine
 678  45CC 430E  
 679  45CE 4C78         DATA    FRSCB1                  free sectors in bitmap (from R1, # in R2)
 680  45D0 C048         MOV     R8,R1                   
 681  45D2 6069         S       @>0056(R9),R1                   
 681  45D4 0056  
 682  45D6 0281         CI      R1,>0100                end of FDR reached?
 682  45D8 0100  
 683  45DA 16EE         JNE     H089                    not yet
 684  45DC 0460 H088    B       @RTURN1                 return to caller
 684  45DE 432C  
 685            *                                       
 686  45E0 06A0 RDOFSC  BL      @FDR2B1                 read a sector from offset in file
 686  45E2 4826  
 687  45E4 000E         DATA    14                      get # of sectors
 688  45E6 80C0         C       R0,R3                   is desired sector in file?
 689  45E8 1B03         JH      H090                    yes
 690  45EA 06A0         BL      @ERROR5                 no: update data, then return with error
 690  45EC 4928  
 691  45EE A000         DATA    >A000                   past end-of-file
 692  45F0 06A0 H090    BL      @CALSUB                 call subroutine
 692  45F2 430E  
 693  45F4 4700         DATA    FSCTOF                  find sector from cluster list
 694  45F6 A101         A       R1,R4                   put sector in R4
 695  45F8 0702         SETO    R2                      code for read
 696  45FA C147 H091    MOV     R7,R5                   buffer ptr
 697  45FC 0460         B       @RWSEC                  read/write sector
 697  45FE 4A04  
 698            *                                       
 699  4600 0429 WROFSC  BLWP    @>005A(R9)              write sector to offset in file offset in R3
 699  4602 005A  
 700  4604 8100         DATA    >8100                   save R0 and R7
 701  4606 06A0         BL      @CALSUB                 call subroutine
 701  4608 430E  
 702  460A 4616         DATA    APSCTS                  append enough sectors to reach that offset
 703  460C 0429         BLWP    @>005A(R9)              retrieve R0 and R7
 703  460E 005A  
 704  4610 8101         DATA    >8101                   
 705  4612 04C2         CLR     R2                      code for write
 706  4614 10F2         JMP     H091                    write sector
 707            *                               
 708  4616 06A0 APSCTS  BL      @FDR2B1                 append sector(s) to a file to get offset in R3
 708  4618 4826  
 709  461A 000E         DATA    14                      get # of sect from FDR
 710            *                                       
 711  461C 80C0         C       R0,R3                   is desired sector in file?
 712  461E 1B47         JH      H092                    yes: find it and return
 713  4620 C000         MOV     R0,R0                   
 714  4622 1301         JEQ     H093                    empty file
 715  4624 0600         DEC     R0                      last sector #
 716  4626 C143 H093    MOV     R3,R5                   save desired sector offset
 717  4628 C0C0         MOV     R0,R3                   last sector in file
 718  462A 06A0         BL      @CALSUB                 call subroutine
 718  462C 430E  
 719  462E 4700         DATA    FSCTOF                  find sector # from offset in file
 720  4630 0429         BLWP    @>005A(R9)              save R1 (sector #)
 720  4632 005A  
 721  4634 4000         DATA    >4000                   
 722  4636 A044         A       R4,R1                   # of last sector in cluster
 723  4638 C105         MOV     R5,R4                   offset of desired sector
 724  463A 06A0 H095    BL      @CALSUB                 call subroutine
 724  463C 430E  
 725  463E 4BAC         DATA    FFSBMP                  find free sector in bitmap, starting from R1
 726  4640 C000         MOV     R0,R0                   found?
 727  4642 1604         JNE     H094                    yes: # in R0
 728  4644 C142         MOV     R2,R5                   no: save # of sectors
 729  4646 06A0         BL      @ADDSEC                 update FDR
 729  4648 46BA  
 730  464A 101B         JMP     H096                    return with memory full
 731            *                                       
 732  464C C041 H094    MOV     R1,R1                   
 733  464E 1320         JEQ     H097                    empty cluster
 734  4650 0581         INC     R1                      one more sector in cluster
 735  4652 8040         C       R0,R1                   same as the one found in bitmap?
 736  4654 131C         JEQ     H098                    yes: just increase cluster size
 737  4656 0429         BLWP    @>005A(R9)              no: retrieve R1 (sector #)
 737  4658 005A  
 738  465A 4001         DATA    >4001                   
 739  465C 0429         BLWP    @>005A(R9)              save R0 + R2
 739  465E 005A  
 740  4660 A000         DATA    >A000                   
 741  4662 06A0         BL      @UPDCLI                 update current cluster info
 741  4664 4B88  
 742  4666 0429         BLWP    @>005A(R9)              retrieve R0 + R2
 742  4668 005A  
 743  466A A001         DATA    >A001                   
 744  466C 0228         AI      R8,3                    ptr to next cluster info
 744  466E 0003  
 745  4670 C048         MOV     R8,R1                   
 746  4672 6069         S       @>0056(R9),R1           current FDR size
 746  4674 0056  
 747  4676 0281         CI      R1,>0100                room enough?
 747  4678 0100  
 748  467A 1605         JNE     H099                    yes
 749  467C 06A0         BL      @CALSUB                 no: call subroutine
 749  467E 430E  
 750  4680 4C72         DATA    FFSBM                   free sector in bitmap
 751  4682 0460 H096    B       @ERROR6                 return with memory full
 751  4684 4ADE  
 752            *                                       
 753  4686 C040 H099    MOV     R0,R1                   new sector #
 754  4688 0429         BLWP    @>005A(R9)              save R1
 754  468A 005A  
 755  468C 4000         DATA    >4000                   
 756  468E 1007 H098    JMP     H100                    make a new cluster
 757            *                                       
 758  4690 0429 H097    BLWP    @>005A(R9)              retrieve R1
 758  4692 005A  
 759  4694 4001         DATA    >4001                   
 760  4696 0429         BLWP    @>005A(R9)              save R0
 760  4698 005A  
 761  469A 8000         DATA    >8000                   
 762  469C 0702         SETO    R2                      empty file: start from offset 0
 763  469E C040 H100    MOV     R0,R1                   sector #
 764  46A0 0582         INC     R2                      increment cluster size
 765  46A2 8102         C       R2,R4                   enough?
 766  46A4 16CA         JNE     H095                    no: get one more sector
 767  46A6 C144         MOV     R4,R5                   
 768  46A8 06A0         BL      @ADDSEC                 add sector to FDR
 768  46AA 46BA  
 769  46AC 1004         JMP     H101                    done
 770            *                               
 771  46AE 06A0 H092    BL      @CALSUB                 call subroutine
 771  46B0 430E  
 772  46B2 4700         DATA    FSCTOF                  find a sector from offset in file
 773  46B4 A101         A       R1,R4                   last sector in cluster
 774  46B6 0460 H101    B       @RTURN1                 return to caller
 774  46B8 432C  
 775            *                                       
 776  46BA C28B ADDSEC  MOV     R11,R10                 add sector to FDR
 777  46BC C101         MOV     R1,R4                   
 778  46BE 0429         BLWP    @>005A(R9)              retrieve R1
 778  46C0 005A  
 779  46C2 4001         DATA    >4001                   
 780  46C4 C041         MOV     R1,R1                   sector #
 781  46C6 131B         JEQ     H102                    none: return
 782  46C8 06A0         BL      @UPDCLI                 write info for R1 cluster
 782  46CA 4B88  
 783  46CC C0A9         MOV     @>0056(R9),R2           pointer to FDR
 783  46CE 0056  
 784  46D0 0429         BLWP    @>005A(R9)              set VDP to read
 784  46D2 005A  
 785  46D4 0042         DATA    >0042                   address in R2
 786  46D6 D06F         MOVB    @-1026(R15),R1          first char of filename
 786  46D8 FBFE  
 787  46DA 0261         ORI     R1,>8000                flag
 787  46DC 8000  
 788  46DE 0429         BLWP    @>005A(R9)              set VDP to write
 788  46E0 005A  
 789  46E2 0043         DATA    >0043                   address in R2
 790  46E4 DBC1         MOVB    R1,@-2(R15)                     
 790  46E6 FFFE  
 791  46E8 0222         AI      R2,14                   ptr to # of sectors
 791  46EA 000E  
 792  46EC 0585         INC     R5                      new # of sectors
 793  46EE 0429         BLWP    @>005A(R9)              set VDP to write
 793  46F0 005A  
 794  46F2 0043         DATA    >0043                   address in R2
 795  46F4 DBC5         MOVB    R5,@-2(R15)             update # of sectors
 795  46F6 FFFE  
 796  46F8 06C5         SWPB    R5                      
 797  46FA DBC5         MOVB    R5,@-2(R15)                     
 797  46FC FFFE  
 798  46FE 045A H102    B       *R10                    
 799            *                                       
 800  4700 C229 FSCTOF  MOV     @>0056(R9),R8           find sector from offset in file
 800  4702 0056  
 801  4704 0228         AI      R8,28                   cluster list
 801  4706 001C  
 802  4708 C103         MOV     R3,R4                   desired sector offset is in R3
 803  470A 06A0 H105    BL      @DECDCI                 decode info: sector in R1, offset in R2
 803  470C 4B6C  
 804  470E 80C2         C       R2,R3                   reached yet?
 805  4710 1101         JLT     H103                    no
 806  4712 1006         JMP     H104                    yes: return
 807  4714 0228 H103    AI      R8,3                    point to next cluster info
 807  4716 0003  
 808  4718 C103         MOV     R3,R4                   
 809  471A 6102         S       R2,R4                   
 810  471C 0604         DEC     R4                      size of the desired cluster (if it's the next)
 811  471E 10F5         JMP     H105                    keep trying
 812  4720 0460 H104    B       @RTURN1                 return to caller
 812  4722 432C  
 813            *
 814            *---------------------------------
 815            * Opcode 7: Delete
 816            * ----------------
 817            * PAB 0: >07
 818            *     1:            <--- error code
 819            *   2-3:
 820            *     4:
 821            *     5:
 822            *   6-7:
 823            *     8:
 824            *---------------------------------                                      
 825            *
 826  4724 06A0 DELETE  BL      @CALSUB                 delete file
 826  4726 430E  
 827  4728 4A5A         DATA    FFFDRV                  find file FDR in VDP buffers
 828  472A C104         MOV     R4,R4                   found?
 829  472C 1307         JEQ     H106                    yes
 830  472E 06A0         BL      @CALSUB                 no: call subroutine
 830  4730 430E  
 831  4732 4AC2         DATA    FFDRDK                  find FDR on disk
 832  4734 C104         MOV     R4,R4                   found?
 833  4736 1313         JEQ     H107                    yes
 834  4738 0460         B       @RTURN1                 no: return to caller
 834  473A 432C  
 835            *                                       
 836  473C 0581 H106    INC     R1                      FDR found, point to it
 837  473E CA41         MOV     R1,@>0056(R9)           save it for other routines
 837  4740 0056  
 838  4742 06A0         BL      @CALSUB                 call subroutine
 838  4744 430E  
 839  4746 49EA         DATA    RDSEC1                  read sector 1
 840  4748 06A0         BL      @FDR2B1                 read 2 bytes from VDP at >8356+offset
 840  474A 4826  
 841  474C FFFC         DATA    -4                      i.e. get sector # of FRD in R0
 842  474E C0C0         MOV     R0,R3                   save it for later
 843  4750 C205         MOV     R5,R8                   ptr to top of sector 1
 844  4752 06A0 H108    BL      @VDPR2B                 read 2 bytes from VDP at R8 into R0
 844  4754 482C  
 845  4756 05C8         INCT    R8                      next FDR ptr in sector 1
 846  4758 80C0         C       R0,R3                   is this the one we want?
 847  475A 16FB         JNE     H108                    not yet
 848  475C 0648         DECT    R8                      yes: point back to it
 849            *
 850  475E 06A0 H107    BL      @NTPDT                  APEDSK99: update DOAD FAT time/date
 850  4760 5DD8  
 851            *
 852  4762 0429         BLWP    @>005A(R9)              save R8
 852  4764 005A  
 853  4766 0080         DATA    >0080                   
 854  4768 06A0         BL      @CALSUB                 call subroutine
 854  476A 430E  
 855  476C 4590         DATA    FFSVIB                  free file sectors in VIB bitmap
 856  476E 0429         BLWP    @>005A(R9)              retrieve R8
 856  4770 005A  
 857  4772 0081         DATA    >0081                   
 858  4774 06A0         BL      @RMFPTR                 remove FDR ptr from sector 1
 858  4776 4790  
 859  4778 04C2         CLR     R2                      code for write
 860  477A 06A0         BL      @CALSUB                 call subroutine
 860  477C 430E  
 861  477E 49EC         DATA    WRSEC1                  write sector 1
 862  4780 06A0         BL      @FDR2B1                 get 2 bytes from VDP at >8356+offset in R0
 862  4782 4826  
 863  4784 FFFC         DATA    -4                      i.e. sector # of FDR
 864  4786 06A0         BL      @CALSUB                 call subroutine
 864  4788 430E  
 865  478A 4C72         DATA    FFSBM                   free sector in R0 in VIB bitmap
 866  478C 0460         B       @CLRFBT                 clear 1rst byte of filename in VDP
 866  478E 4538  
 867            *
 868            * Sector 1 contains an alphabetically sorted list of FDR pointers
 869            * Each pointer is 2 bytes long and contains the sector # of this FDR
 870            * The list must end with a >0000 mark. Thus there can be 127 files at most
 871            *
 872  4790 C169 RMFPTR  MOV     @>0056(R9),R5           remove FDR ptr from sector 1
 872  4792 0056  
 873  4794 0225         AI      R5,256                  
 873  4796 0100  
 874  4798 C0C5         MOV     R5,R3                   pointer to data buffer
 875  479A 0223         AI      R3,256                  point to next ctrl block
 875  479C 0100  
 876  479E C088         MOV     R8,R2                   shift up FDR list, erasing FDR pointed by R8
 877  47A0 05C2         INCT    R2                      point to next FDR ptr in sector 1
 878  47A2 0429 H109    BLWP    @>005A(R9)              set VDP to read
 878  47A4 005A  
 879  47A6 0042         DATA    >0042                   address in R2
 880  47A8 D02F         MOVB    @-1026(R15),R0          get 1 byte
 880  47AA FBFE  
 881  47AC 0582         INC     R2                      inc source ptr
 882  47AE 0429         BLWP    @>005A(R9)              set VDP to write
 882  47B0 005A  
 883  47B2 0103         DATA    >0103                   address in R8
 884  47B4 DBC0         MOVB    R0,@-2(R15)             copy 1 byte
 884  47B6 FFFE  
 885  47B8 0588         INC     R8                      inc dest pointer
 886  47BA 80C2         C       R2,R3                   done?
 887  47BC 16F2         JNE     H109                    not yet
 888  47BE 045B         B       *R11                    
 889            *                                       
 890  47C0 C28B INSFDR  MOV     R11,R10                 insert a FDR in sector 1
 891  47C2 C048         MOV     R8,R1                   
 892  47C4 06A0         BL      @FDR2B1                 get 2 bytes from VDP at >8356+offset
 892  47C6 4826  
 893  47C8 01FC         DATA    508                     i.e. last FDR slot in sector 1 (list ends with 0)
 894  47CA C000         MOV     R0,R0                   
 895  47CC 1302         JEQ     H110                    
 896  47CE 0460         B       @ERROR6                 memory full error
 896  47D0 4ADE  
 897  47D2 0608 H110    DEC     R8                      previous byte
 898  47D4 0429         BLWP    @>005A(R9)              set VDP to read
 898  47D6 005A  
 899  47D8 0102         DATA    >0102                   address in R8
 900  47DA D02F         MOVB    @-1026(R15),R0          get 1 byte
 900  47DC FBFE  
 901  47DE 05C8         INCT    R8                      
 902  47E0 0429         BLWP    @>005A(R9)              set VDP to write
 902  47E2 005A  
 903  47E4 0103         DATA    >0103                   address in R8
 904  47E6 DBC0         MOVB    R0,@-2(R15)             copy byte two bytes further down
 904  47E8 FFFE  
 905  47EA 0648         DECT    R8                      
 906  47EC 8048         C       R8,R1                   done ?
 907  47EE 16F1         JNE     H110                    not yet
 908  47F0 045A         B       *R10                    
 909            *                               
 910  47F2 C0A9 CMPFN   MOV     @>0058(R9),R2           compare filenames
 910  47F4 0058  
 911  47F6 0222         AI      R2,256                  
 911  47F8 0100  
 912  47FA 0429 H111    BLWP    @>005A(R9)              set VDP to read
 912  47FC 005A  
 913  47FE 0022         DATA    >0022                   address in R1 (ptr to filename)
 914  4800 D02F         MOVB    @-1026(R15),R0          get 1 char
 914  4802 FBFE  
 915  4804 0240         ANDI    R0,>7FFF                clear flag (on drive #)
 915  4806 7FFF  
 916  4808 0429         BLWP    @>005A(R9)              set VDP to read
 916  480A 005A  
 917  480C 0042         DATA    >0042                   address in R2 (filename compare buffer)
 918  480E D0EF         MOVB    @-1026(R15),R3          get 1 char
 918  4810 FBFE  
 919  4812 90C0         CB      R0,R3                   compare chars
 920  4814 1604         JNE     H112                    mismatch
 921  4816 0581         INC     R1                      match: increment pointers
 922  4818 0582         INC     R2                      
 923  481A 0604         DEC     R4                      
 924  481C 16EE         JNE     H111                    next char
 925  481E 045B H112    B       *R11                    if complete match: ret with EQ set
 926            *                                       
 927  4820 C229 PABR2B  MOV     @>0054(R9),R8           get two bytes from PAB
 927  4822 0054  
 928  4824 1002         JMP     FDR2B2                  
 929            *                                       
 930  4826 C229 FDR2B1  MOV     @>0056(R9),R8           get two bytes from FDR
 930  4828 0056  
 931  482A A23B FDR2B2  A       *R11+,R8                offset in data word
 932            *                                       
 933  482C 0429 VDPR2B  BLWP    @>005A(R9)              get two byte from VDP at R8
 933  482E 005A  
 934  4830 0102         DATA    >0102                   set VDP to read at R8
 935  4832 D02F         MOVB    @-1026(R15),R0          get two bytes of data
 935  4834 FBFE  
 936  4836 06C0         SWPB    R0                      
 937  4838 D02F         MOVB    @-1026(R15),R0                  
 937  483A FBFE  
 938  483C 0B80         SRC     R0,8                    why not swpb ?
 939  483E 045B         B       *R11                    
 940            *                       
 941  4840 C069 FDSKDR  MOV     @>0058(R9),R1           find disk from name (ptr in R3)
 941  4842 0058  
 942  4844 0221         AI      R1,256                  
 942  4846 0100  
 943  4848 06A0         BL      @CPCKFN                 copy filename from VDP at R3 to compare buffer
 943  484A 48CA  
 944  484C 0429         BLWP    @>005A(R9)              save R2 + R3
 944  484E 005A  
 945  4850 3000         DATA    >3000                   
 946  4852 C000         MOV     R0,R0                   last char copied
 947  4854 1101         JLT     H113                    flagged
 948  4856 1005         JMP     H114                    
 949  4858 C180 H113    MOV     R0,R6                   
 950  485A 0246         ANDI    R6,>0300                        
 950  485C 0300  
 951  485E 1337         JEQ     ERROR7                  return with file error
 952  4860 102F         JMP     H115                    return to caller
 953  4862 04C6 H114    CLR     R6                      don't read any drive
 954  4864 06A0         BL      @CALSUB                 call subroutine
 954  4866 430E  
 955  4868 4988         DATA    RWVIB                   save current VIB
 956  486A 0226 H116    AI      R6,>0100                next drive
 956  486C 0100  
 957  486E 0707         SETO    R7                      error flags
 958  4870 0702         SETO    R2                      code for read
 959  4872 04C4         CLR     R4                      sector 0
 960  4874 06A0         BL      @CALSUB                 call subroutine
 960  4876 430E  
 961  4878 4A06         DATA    RWSECA                  read sector 0
 962  487A C1C7         MOV     R7,R7                   ok?
 963  487C 161D         JNE     H118                    no: try next drive
 964  487E 0204         LI      R4,10                   yes: diskname size
 964  4880 000A  
 965  4882 C069         MOV     @>0058(R9),R1           VIB ptr
 965  4884 0058  
 966  4886 0429         BLWP    @>005A(R9)              save R1-R3
 966  4888 005A  
 967  488A 7000         DATA    >7000                   
 968  488C 06A0         BL      @CMPFN                  compare names (ptr in R1 + compare buffer)
 968  488E 47F2  
 969  4890 0429         BLWP    @>005A(R9)                      
 969  4892 005A  
 970  4894 7001         DATA    >7001                   retrieve R1-R3
 971  4896 C104         MOV     R4,R4                   name matched?
 972  4898 160F         JNE     H118                    no: try next drive
 973  489A C006         MOV     R6,R0                   drive #
 974  489C 0260         ORI     R0,>8000                add update flag
 974  489E 8000  
 975  48A0 0429         BLWP    @>005A(R9)              set VDP to write
 975  48A2 005A  
 976  48A4 0063         DATA    >0063                   address in R3
 977  48A6 DBC0         MOVB    R0,@-2(R15)             copy drive+flag before diskname in source
 977  48A8 FFFE  
 978  48AA 0605         DEC     R5                      before sector 0 copy
 979  48AC 0429         BLWP    @>005A(R9)              set VDP to write
 979  48AE 005A  
 980  48B0 00A3         DATA    >00A3                   address in R5
 981  48B2 DBC6         MOVB    R6,@-2(R15)             copy drive # before VIB
 981  48B4 FFFE  
 982  48B6 1004         JMP     H115                    done
 983            *                               
 984  48B8 0286 H118    CI      R6,>0300                did we do all drives?
 984  48BA 0300  
 985  48BC 16D6         JNE     H116                    no: try next on
 986  48BE 1007         JMP     ERROR7                  return with file error
 987            *                                       
 988  48C0 0429 H115    BLWP    @>005A(R9)              retrieve R2 + R3
 988  48C2 005A  
 989  48C4 3001         DATA    >3001                   
 990  48C6 0460         B       @RTURN1                 return to caller
 990  48C8 432C  
 991            *                               
 992  48CA 0602 CPCKFN  DEC     R2                      
 993  48CC 1B03         JH      H119                    
 994  48CE 06A0 ERROR7  BL      @RETERR                 return with error
 994  48D0 4954  
 995  48D2 E000         DATA    >E000                   file error
 996            *                                       
 997  48D4 0200 H119    LI      R0,>2000                copy (+check) filename in VDP from R3 to R1 (space)
 997  48D6 2000  
 998  48D8 0429         BLWP    @>005A(R9)              set VDP to write
 998  48DA 005A  
 999  48DC 0023         DATA    >0023                   address in R1
1000  48DE 0208         LI      R8,10                   10 chars per filename
1000  48E0 000A  
1001  48E2 DBC0 H120    MOVB    R0,@-2(R15)             fill filename with spaces
1001  48E4 FFFE  
1002  48E6 0608         DEC     R8                      
1003  48E8 16FC         JNE     H120                    
1004  48EA 0208         LI      R8,11                   11 chars countring drive #
1004  48EC 000B  
1005  48EE 0583 H122    INC     R3                      increment source ptr
1006  48F0 0429         BLWP    @>005A(R9)              set VDP to read
1006  48F2 005A  
1007  48F4 0062         DATA    >0062                   address in R3
1008  48F6 D02F         MOVB    @-1026(R15),R0          get a char
1008  48F8 FBFE  
1009  48FA 13E9         JEQ     ERROR7                  >00: return with file error
1010  48FC 1110         JLT     H121                    flag bit set
1011  48FE 0280         CI      R0,>2E00                        
1011  4900 2E00  
1012  4902 130D         JEQ     H121                    '.'
1013  4904 0608         DEC     R8                      
1014  4906 13E3         JEQ     ERROR7                  name to long: return with file error
1015  4908 0280         CI      R0,>2000                        
1015  490A 2000  
1016  490C 13E0         JEQ     ERROR7                  name can't contain spaces: file error again
1017  490E 0429         BLWP    @>005A(R9)              set VDP to write
1017  4910 005A  
1018  4912 0023         DATA    >0023                   address in R1
1019  4914 DBC0         MOVB    R0,@-2(R15)             copy 1 char
1019  4916 FFFE  
1020  4918 0581         INC     R1                      increment destination pointer
1021  491A 0602         DEC     R2                      more?
1022  491C 16E8         JNE     H122                    yes
1023  491E 0288 H121    CI      R8,>000B                name can't be 0 chars long
1023  4920 000B  
1024  4922 13D5         JEQ     ERROR7                  else return with file error
1025  4924 045B         B       *R11                    
1026            *                                       
1027  4926 AA00 K014    DATA    >AA00                   
1028            *                               
1029  4928 C00B ERROR5  MOV     R11,R0                  update data, then error
1030  492A C0E9         MOV     @>0056(R9),R3           
1030  492C 0056  
1031  492E 0603         DEC     R3                      see what >8356 is pointing at
1032  4930 0429         BLWP    @>005A(R9)              set VDP to read
1032  4932 005A  
1033  4934 0062         DATA    >0062                   address in R3
1034  4936 D0AF         MOVB    @-1026(R15),R2          get 1 byte
1034  4938 FBFE  
1035  493A 9802         CB      R2,@K014                is it >AA (disk buffer area mark)
1035  493C 4926  
1036  493E 1309         JEQ     H123                    yes: announce error (code in data word)
1037  4940 0429         BLWP    @>005A(R9)              no: >8356 points to a FDR. Save R0
1037  4942 005A  
1038  4944 8000         DATA    >8000                   
1039  4946 06A0         BL      @CALSUB                 call subroutine
1039  4948 430E  
1040  494A 452C         DATA    UPDFDR                  update FRD and data buffer if needed
1041  494C 0429         BLWP    @>005A(R9)              retrieve R0
1041  494E 005A  
1042  4950 8001         DATA    >8001                   
1043  4952 C2C0 H123    MOV     R0,R11                  
1044            *                               
1045  4954 C069 RETERR  MOV     @>0054(R9),R1           annouce error
1045  4956 0054  
1046  4958 130D         JEQ     H124                    no PAB
1047  495A 0581         INC     R1                      for DSRs: ptr to status byte
1048  495C 0429         BLWP    @>005A(R9)              set VDP to read
1048  495E 005A  
1049  4960 0022         DATA    >0022                   address in R2
1050  4962 D0AF         MOVB    @-1026(R15),R2          get file status byte
1050  4964 FBFE  
1051  4966 E0BB         SOC     *R11+,R2                add error code
1052  4968 0429         BLWP    @>005A(R9)              set VDP to write
1052  496A 005A  
1053  496C 0023         DATA    >0023                   address in R2
1054  496E DBC2         MOVB    R2,@-2(R15)             write back status byte
1054  4970 FFFE  
1055  4972 1002         JMP     H125                    
1056  4974 CA7B H124    MOV     *R11+,@>0050(R9)        for subs: error code in >8350
1056  4976 0050  
1057  4978 C229 H125    MOV     @>0058(R9),R8           get stack ptr
1057  497A 0058  
1058  497C 0228         AI      R8,-12                  point back to initial caller
1058  497E FFF4  
1059  4980 CA48         MOV     R8,@>0066(R9)           update pointer
1059  4982 0066  
1060  4984 0460         B       @RTURN1                 return to caller
1060  4986 432C  
1061            *                               
1062  4988 0429 RWVIB   BLWP    @>005A(R9)              read VIB (drive # in R6)
1062  498A 005A  
1063  498C 3000         DATA    >3000                   save R2 + R3
1064  498E C169         MOV     @>0058(R9),R5           pointer to VIB in ctrl block
1064  4990 0058  
1065  4992 0605         DEC     R5                      ptr to drive #
1066  4994 0429         BLWP    @>005A(R9)              set VDP for read
1066  4996 005A  
1067  4998 00A2         DATA    >00A2                   address in R5
1068  499A D0AF         MOVB    @-1026(R15),R2          get drive #
1068  499C FBFE  
1069  499E C0C2         MOV     R2,R3                   
1070  49A0 04C4         CLR     R4                      sector 0 for VIB
1071  49A2 0242         ANDI    R2,>0300                clear flag (>80 = update data)
1071  49A4 0300  
1072  49A6 9182         CB      R2,R6                   wanted drive?
1073  49A8 131A         JEQ     H126                    yes: return
1074  49AA C0C3         MOV     R3,R3                   no: shall we update VIB?
1075  49AC 1101         JLT     H127                    yes
1076  49AE 100A         JMP     H128                    no
1077  49B0 0429 H127    BLWP    @>005A(R9)              set VDP to write
1077  49B2 005A  
1078  49B4 00A3         DATA    >00A3                   address in R5
1079  49B6 DBC4         MOVB    R4,@-2(R15)             clr drive #
1079  49B8 FFFE  
1080  49BA 0585         INC     R5                      point back to VIB buffer
1081  49BC 06A0         BL      @CALSUB                 call subroutine
1081  49BE 430E  
1082  49C0 4A08         DATA    RWSECB                  write sector 0 to old drive (in R2)
1083  49C2 0605         DEC     R5                      point to drive #
1084  49C4 0702 H128    SETO    R2                      flag for read
1085  49C6 D086         MOVB    R6,R2                   APEDSK99: error in original disassembly (was R5)
1086  49C8 1305         JEQ     H129                    none
1087  49CA 0585         INC     R5                      point at VIB buffer
1088  49CC 06A0         BL      @CALSUB                 call subroutine
1088  49CE 430E  
1089  49D0 4A06         DATA    RWSECA                  read sector (in R4) to buffer (in R5)
1090  49D2 0605         DEC     R5                      point at drive #
1091  49D4 0429 H129    BLWP    @>005A(R9)              set VDP to write
1091  49D6 005A  
1092  49D8 00A3         DATA    >00A3                   address in R5
1093  49DA DBC6         MOVB    R6,@-2(R15)             write drive # in control block, before FDR
1093  49DC FFFE  
1094  49DE 0585 H126    INC     R5                      point back to FDR
1095  49E0 0429         BLWP    @>005A(R9)                      
1095  49E2 005A  
1096  49E4 3001         DATA    >3001                   retrieve R2 + R3 from stack
1097  49E6 0460         B       @RTURN1                 branch to address on stack
1097  49E8 432C  
1098            *                               
1099  49EA 0702 RDSEC1  SETO    R2                      read sector 1
1100  49EC 0204 WRSEC1  LI      R4,1
1100  49EE 0001  
1101  49F0 0205         LI      R5,>0100                into data buffer area of current ctrl block
1101  49F2 0100  
1102  49F4 1005         JMP     RDFDR1                  
1103            *                               
1104  49F6 06A0 WRFDR   BL      @FDR2B1                 read FDR
1104  49F8 4826  
1105  49FA FFFC         DATA    -4                      get sector # of FDR from control block
1106            *                               
1107  49FC C100 RDFDR2  MOV     R0,R4                   sector read/write
1108  49FE 04C5         CLR     R5
1109  4A00 A169 RDFDR1  A       @>0056(R9),R5           point to FDR or data buffer
1109  4A02 0056  
1110  4A04 04C7 RWSEC   CLR     R7                      
1111  4A06 D086 RWSECA  MOVB    R6,R2                   add drive # for r/w flag
1112  4A08 0429 RWSECB  BLWP    @>005A(R9)              save R0-R8
1112  4A0A 005A  
1113  4A0C FF80         DATA    >FF80                   
1114  4A0E CA44         MOV     R4,@>004A(R9)           sector #
1114  4A10 004A  
1115  4A12 CA42         MOV     R2,@>004C(R9)           drive | r/w flag
1115  4A14 004C  
1116  4A16 CA45         MOV     R5,@>004E(R9)           buffer ptr
1116  4A18 004E  
1117  4A1A 06A0         BL      @CALSUB                 call subroutine
1117  4A1C 430E  
1118  4A1E 4164         DATA    SECRW1                  sector read/write
1119  4A20 0429         BLWP    @>005A(R9)              retrieve R0-R8
1119  4A22 005A  
1120  4A24 FF81         DATA    >FF81                   
1121  4A26 D1E9         MOVB    @>0050(R9),R7           get error code | flags
1121  4A28 0050  
1122  4A2A 06C7         SWPB    R7                      
1123  4A2C 1312         JEQ     H130                    
1124  4A2E C1C7         MOV     R7,R7                   
1125  4A30 1501         JGT     H131                    
1126  4A32 100B         JMP     H132                    
1127  4A34 0247 H131    ANDI    R7,>00FF                        
1127  4A36 00FF  
1128  4A38 0287         CI      R7,>0034                        
1128  4A3A 0034  
1129  4A3C 1603         JNE     H133                    
1130  4A3E 06A0         BL      @ERROR5                 
1130  4A40 4928  
1131  4A42 2000         DATA    >2000                   write protected
1132  4A44 06A0 H133    BL      @ERROR5                 
1132  4A46 4928  
1133  4A48 C000         DATA    >C000                   device error
1134  4A4A DA69 H132    MOVB    @>004D(R9),@>004D(R9)   read or write?
1134  4A4C 004D  
1134  4A4E 004D  
1135  4A50 13F1         JEQ     H131                    write
1136  4A52 0247 H130    ANDI    R7,>00FF                        
1136  4A54 00FF  
1137  4A56 0460         B       @RTURN1                 return to caller
1137  4A58 432C  
1138            *                               
1139  4A5A C069 FFFDRV  MOV     @>0058(R9),R1           save filename in compare buffer and find its FDR
1139  4A5C 0058  
1140  4A5E 0221         AI      R1,256                  
1140  4A60 0100  
1141  4A62 0429         BLWP    @>005A(R9)              set VDP to write
1141  4A64 005A  
1142  4A66 0023         DATA    >0023                   address in R1: filename compare buffer
1143  4A68 DBC6         MOVB    R6,@-2(R15)             write drive #
1143  4A6A FFFE  
1144  4A6C 0581         INC     R1                      
1145  4A6E 06A0         BL      @CPCKFN                 copy (+ check) filename from R3 to R1
1145  4A70 48CA  
1146  4A72 C082         MOV     R2,R2                   all chars copied (or was there a . or a >00
1147  4A74 1302         JEQ     FFDRVB                  
1148  4A76 0460 H136    B       @ERROR7                 return with file error
1148  4A78 48CE  
1149            *                                       
1150  4A7A C069 FFDRVB  MOV     @>0056(R9),R1           find filename in buffered FDRs
1150  4A7C 0056  
1151  4A7E 0221         AI      R1,3                    
1151  4A80 0003  
1152  4A82 0429         BLWP    @>005A(R9)              set VDP to read
1152  4A84 005A  
1153  4A86 0022         DATA    >0022                   address in R1
1154  4A88 D0AF         MOVB    @-1026(R15),R2          get # of files
1154  4A8A FBFE  
1155  4A8C 0982         SRL     R2,8                    make it a word
1156  4A8E C0C2         MOV     R2,R3                   save it
1157  4A90 0221         AI      R1,6                    ptr to drive #
1157  4A92 0006  
1158  4A94 0204 H134    LI      R4,11                   compare 11 bytes (drive + filename)
1158  4A96 000B  
1159  4A98 0429         BLWP    @>005A(R9)              save R1-R3
1159  4A9A 005A  
1160  4A9C 7000         DATA    >7000                   
1161  4A9E 06A0         BL      @CMPFN                  compare with name in compare buffer
1161  4AA0 47F2  
1162  4AA2 0429         BLWP    @>005A(R9)              retrieve R1-R3
1162  4AA4 005A  
1163  4AA6 7001         DATA    >7001                   
1164  4AA8 C104         MOV     R4,R4                   fully compared?
1165  4AAA 1304         JEQ     H135                    yes: done
1166  4AAC 0221         AI      R1,518                  move to next FDR in VDP mem
1166  4AAE 0206  
1167  4AB0 0602         DEC     R2                      
1168  4AB2 16F0         JNE     H134                    next file
1169  4AB4 0460 H135    B       @RTURN1                 return to caller (R4=0 if successfull)
1169  4AB6 432C  
1170            *                               
1171  4AB8 06A0 FNDFDR  BL      @CALSUB                 
1171  4ABA 430E  
1172  4ABC 4A5A         DATA    FFFDRV                  save name in comp buffer, find FDR in VDP buffers
1173            *                                       
1174  4ABE C104 FFDROD  MOV     R4,R4                   find FDR on disk (from filename)
1175  4AC0 13DA         JEQ     H136                    file error
1176  4AC2 C169 FFDRDK  MOV     @>0056(R9),R5           ptr to top of disk buffer in VDP mem
1176  4AC4 0056  
1177  4AC6 0225         AI      R5,10                   ptr to drive # in first file control block
1177  4AC8 000A  
1178  4ACA 0429 H138    BLWP    @>005A(R9)              set VDP to read
1178  4ACC 005A  
1179  4ACE 00A2         DATA    >00A2                   address in R5
1180  4AD0 D0AF         MOVB    @-1026(R15),R2          get drive #
1180  4AD2 FBFE  
1181  4AD4 1307         JEQ     H137                    free control block found
1182  4AD6 0225         AI      R5,518                  ptr to file control block
1182  4AD8 0206  
1183  4ADA 0603         DEC     R3                      
1184  4ADC 16F6         JNE     H138                    more files ?
1185  4ADE 06A0 ERROR6  BL      @ERROR5                 no:
1185  4AE0 4928  
1186  4AE2 8000         DATA    >8000                   memory full
1187            *                               
1188  4AE4 CA45 H137    MOV     R5,@>0056(R9)           save ptr to free ctrl block (drive #)
1188  4AE6 0056  
1189  4AE8 06A0         BL      @CALSUB                 call subroutine
1189  4AEA 430E  
1190  4AEC 49EA         DATA    RDSEC1                  read sector 1
1191  4AEE C229 FFDRFN  MOV     @>0056(R9),R8           entry point if sector 1 already read
1191  4AF0 0056  
1192  4AF2 0228         AI      R8,382                  point to middle of sector 1
1192  4AF4 017E  
1193  4AF6 0202         LI      R2,64                   distance: start with 1/4 sector
1193  4AF8 0040  
1194  4AFA 0704 H139    SETO    R4                      
1195  4AFC 06A0         BL      @VDPR2B                 read 2 bytes in R0 from VDP address in R8
1195  4AFE 482C  
1196  4B00 C000         MOV     R0,R0                   
1197  4B02 132E         JEQ     H140                    no file here: move up
1198  4B04 0429         BLWP    @>005A(R9)              save R2
1198  4B06 005A  
1199  4B08 2000         DATA    >2000                   
1200  4B0A 0702         SETO    R2                      code for read
1201  4B0C 06A0         BL      @CALSUB                 call subroutine
1201  4B0E 430E  
1202  4B10 49FC         DATA    RDFDR2                  read FDR, sector # in R0
1203  4B12 C045         MOV     R5,R1                   RDFDR2 sets R5 as FDR ptr
1204  4B14 0225         AI      R5,-4                   point to sector # of FDR in ctrl block
1204  4B16 FFFC  
1205  4B18 0429         BLWP    @>005A(R9)              set VDP to write
1205  4B1A 005A  
1206  4B1C 00A3         DATA    >00A3                   address in R5
1207  4B1E DBC4         MOVB    R4,@-2(R15)             RDFDR2 puts sector # in R4
1207  4B20 FFFE  
1208  4B22 06C4         SWPB    R4                      copy it to ctrl block
1209  4B24 DBC4         MOVB    R4,@-2(R15)                     
1209  4B26 FFFE  
1210  4B28 C141         MOV     R1,R5                   FDR ptr
1211  4B2A 0601         DEC     R1                      now point to drive #
1212  4B2C 0429         BLWP    @>005A(R9)              set VDP to write
1212  4B2E 005A  
1213  4B30 0023         DATA    >0023                   address in R1
1214  4B32 DBC6         MOVB    R6,@-2(R15)             save drive #
1214  4B34 FFFE  
1215  4B36 0204         LI      R4,11                   size to compare (drive # + filename)
1215  4B38 000B  
1216  4B3A 06A0         BL      @CMPFN                  compare filenames
1216  4B3C 47F2  
1217  4B3E 0429         BLWP    @>005A(R9)              retrieve R2
1217  4B40 005A  
1218  4B42 2001         DATA    >2001                   
1219  4B44 130B         JEQ     H141                    compared ok: return
1220  4B46 0429         BLWP    @>005A(R9)              set VDP to write
1220  4B48 005A  
1221  4B4A 00A3         DATA    >00A3                   address in R5
1222  4B4C DBC4         MOVB    R4,@-2(R15)             remaining chars to compare
1222  4B4E FFFE  
1223  4B50 80C0         C       R0,R3                   what kind of mismatch occured?
1224  4B52 1B06         JH      H140                    too far down the alphabet
1225  4B54 A202         A       R2,R8                   too far up: move half-way down
1226  4B56 C082         MOV     R2,R2                   
1227  4B58 1606         JNE     H142                    then divide distance by 2
1228  4B5A 05C8         INCT    R8                      already checked: reset EQ
1229  4B5C 0460 H141    B       @RTURN1                 return (from stack)
1229  4B5E 432C  
1230            *                               
1231  4B60 6202 H140    S       R2,R8                   move half-way up
1232  4B62 C082         MOV     R2,R2                   
1233  4B64 13FB         JEQ     H141                    can't: already checked
1234  4B66 0922 H142    SRL     R2,2                    divide distance by 2
1235  4B68 A082         A       R2,R2                   but keep it even
1236  4B6A 10C7         JMP     H139                    
1237            *
1238            * The cluster info list is located in the FDR, bytes >1C to >FF
1239            * A cluster info consists in 3 bytes, i.e 6 nibbles
1240            * 3 nibbles specify the beginning sector for that cluster, and
1241            * 3 nibbles specify the total file offset in sectors, including this cluster.
1242            * The nibbles are arranged as EG SB OF, to be combined as BEG OFS
1243            *
1244  4B6C C28B DECDCI  MOV     R11,R10                 decode cluster info
1245  4B6E 06A0         BL      @VDPR2B                 read 2 bytes VDP at R8 in R0
1245  4B70 482C  
1246  4B72 06C0         SWPB    R0                      
1247  4B74 D0AF         MOVB    @-1026(R15),R2          get third byte from cluster list
1247  4B76 FBFE  
1248  4B78 C040         MOV     R0,R1                   
1249  4B7A 0241         ANDI    R1,>0FFF                start sector in R1
1249  4B7C 0FFF  
1250  4B7E 4001         SZC     R1,R0                   remove it from R0
1251  4B80 0982         SRL     R2,8                    
1252  4B82 E080         SOC     R0,R2                   combine offset nibbles
1253  4B84 0BC2         SRC     R2,12                   offset in R2
1254  4B86 045A         B       *R10                    
1255            *                               
1256  4B88 0B42 UPDCLI  SRC     R2,4                    write info for 1 cluster
1257  4B8A C002         MOV     R2,R0                   
1258  4B8C 0240         ANDI    R0,>F000                sector in R1, offset in R2
1258  4B8E F000  
1259  4B90 E040         SOC     R0,R1                   copy nibble 3 of offset before nibble 1 of sector
1260  4B92 0429         BLWP    @>005A(R9)              set VDP to write
1260  4B94 005A  
1261  4B96 0103         DATA    >0103                   address in R8
1262  4B98 06C1         SWPB    R1                      write cluster info
1263  4B9A DBC1         MOVB    R1,@-2(R15)             as 3 bytes
1263  4B9C FFFE  
1264  4B9E 06C1         SWPB    R1                      
1265  4BA0 DBC1         MOVB    R1,@-2(R15)                     
1265  4BA2 FFFE  
1266  4BA4 06C2         SWPB    R2                      
1267  4BA6 DBC2         MOVB    R2,@-2(R15)                     
1267  4BA8 FFFE  
1268  4BAA 045B         B       *R11                    
1269            *
1270            * The sector bitmap is located in the VIB (i.e. sector 0) at bytes >38 to >FF
1271            * In each byte a bit defines a sector, from right to left: "0"=free, "1"=used                                   
1272            *
1273  4BAC 0429 FFSBMP  BLWP    @>005A(R9)              find a free sector in bitmap
1273  4BAE 005A  
1274  4BB0 7800         DATA    >7800                   
1275  4BB2 06A0         BL      @CALSUB                 call subroutine
1275  4BB4 430E  
1276  4BB6 4988         DATA    RWVIB                   load VIB for drive in R6
1277  4BB8 C041         MOV     R1,R1                   first sector specified in R1 ?
1278  4BBA 1602         JNE     H143                    yes
1279  4BBC 0201         LI      R1,33                   no: start with sector 34
1279  4BBE 0021  
1280  4BC0 0581 H143    INC     R1                      
1281  4BC2 C001         MOV     R1,R0                   
1282  4BC4 0931         SRL     R1,3                    div by 8 since 8 sect/byte in bitmap
1283  4BC6 0202         LI      R2,>00FF                        
1283  4BC8 00FF  
1284  4BCA 0240         ANDI    R0,>0007                bit number in bitmap byte
1284  4BCC 0007  
1285  4BCE 1301         JEQ     H144                    
1286  4BD0 0A02         SLA     R2,0                    get that bit
1287  4BD2 C0C1 H144    MOV     R1,R3                   byte #
1288  4BD4 A0C5         A       R5,R3                   add VIB ptr
1289  4BD6 0223         AI      R3,56                   ptr to sector in bitmap
1289  4BD8 0038  
1290  4BDA 0281         CI      R1,>00C8                end of VIB?
1290  4BDC 00C8  
1291  4BDE 1101         JLT     H145                    no
1292  4BE0 04C1         CLR     R1                      yes: top of bitmap
1293  4BE2 A045 H145    A       R5,R1                   
1294  4BE4 0221         AI      R1,56                   make another bitmap ptr
1294  4BE6 0038  
1295  4BE8 0429         BLWP    @>005A(R9)              set VDP to read
1295  4BEA 005A  
1296  4BEC 0022         DATA    >0022                   address in R1
1297  4BEE 0700 H146    SETO    R0                      
1298  4BF0 D02F         MOVB    @-1026(R15),R0          get bitmap byte
1298  4BF2 FBFE  
1299  4BF4 C100         MOV     R0,R4                   save it
1300  4BF6 E002         SOC     R2,R0                   mask previous sectors
1301  4BF8 04C2         CLR     R2                      
1302  4BFA 0580         INC     R0                      get 1 more sector
1303  4BFC 1610         JNE     H147                    ok
1304  4BFE 0581         INC     R1                      byte full: try next
1305  4C00 C001         MOV     R1,R0                   
1306  4C02 0220         AI      R0,-256                 won't change if byte # became >100
1306  4C04 FF00  
1307  4C06 8140         C       R0,R5                   still in VIB?
1308  4C08 1605         JNE     H148                    yes
1309  4C0A 0221         AI      R1,-200                 no: to top of bitmap
1309  4C0C FF38  
1310  4C0E 0429         BLWP    @>005A(R9)              set VDP to read
1310  4C10 005A  
1311  4C12 0022         DATA    >0022                   address in R1
1312  4C14 80C1 H148    C       R1,R3                   are we back to where we started?
1313  4C16 16EB         JNE     H146                    no: seach that byte for a free sector
1314  4C18 C004         MOV     R4,R0                   get original byte
1315  4C1A 0580         INC     R0                      try sectors just before ours (no mask this time)
1316  4C1C 1325         JEQ     H149                    full: return with EQ
1317  4C1E 0600 H147    DEC     R0                      restore original byte
1318  4C20 C080         MOV     R0,R2                   
1319  4C22 04C0         CLR     R0                      bit counter
1320  4C24 06C2         SWPB    R2                      
1321  4C26 0580 H150    INC     R0                      increment bit count
1322  4C28 0B12         SRC     R2,1                    find first 0 bit from the right
1323  4C2A 18FD         JOC     H150                    not yet
1324  4C2C 0202         LI      R2,>0080                        
1324  4C2E 0080  
1325  4C30 0A02         SLA     R2,0                    make a mask for that bit
1326  4C32 0600         DEC     R0                      bit # (0-7)
1327  4C34 E102         SOC     R2,R4                   mark sector as used in bitmap byte
1328  4C36 0429         BLWP    @>005A(R9)              set VDP to write
1328  4C38 005A  
1329  4C3A 0023         DATA    >0023                   address in R1
1330  4C3C DBC4         MOVB    R4,@-2(R15)             update bitmap
1330  4C3E FFFE  
1331  4C40 0221         AI      R1,-56                  
1331  4C42 FFC8  
1332  4C44 6045         S       R5,R1                   byte # in bitmap
1333  4C46 0A31         SLA     R1,3                    times 8 (8 sect per byte)
1334  4C48 E040         SOC     R0,R1                   add bit #: = sector #
1335  4C4A C001         MOV     R1,R0                   save it
1336            *                               
1337  4C4C 0605 H151    DEC     R5                      point to drive #
1338  4C4E 0429         BLWP    @>005A(R9)              set VDP to read
1338  4C50 005A  
1339  4C52 00A2         DATA    >00A2                   address in R5
1340  4C54 D06F         MOVB    @-1026(R15),R1          get drive #
1340  4C56 FBFE  
1341  4C58 0261         ORI     R1,>8000                add flag: update VIB
1341  4C5A 8000  
1342  4C5C 0429         BLWP    @>005A(R9)              set VDP to write
1342  4C5E 005A  
1343  4C60 00A3         DATA    >00A3                   address in R5
1344  4C62 DBC1         MOVB    R1,@-2(R15)             write back flagged drive #
1344  4C64 FFFE  
1345  4C66 0585         INC     R5                      point to VIB (& return with NEQ)
1346  4C68 0429 H149    BLWP    @>005A(R9)              retrieve R1-R4
1346  4C6A 005A  
1347  4C6C 7801         DATA    >7801                   
1348  4C6E 0460         B       @RTURN1                 return to caller
1348  4C70 432C  
1349            *                               
1350  4C72 C040 FFSBM   MOV     R0,R1                   free sector(s) in bitmap
1351  4C74 0202         LI      R2,1                    1 sector only
1351  4C76 0001  
1352  4C78 0429 FRSCB1  BLWP    @>005A(R9)              entry point if more than 1 sector
1352  4C7A 005A  
1353  4C7C 7800         DATA    >7800                   save R1-R4
1354  4C7E 06A0         BL      @CALSUB                 call subroutine
1354  4C80 430E  
1355  4C82 4988         DATA    RWVIB                   load VIB for drive in R6
1356  4C84 C001         MOV     R1,R0                   sector #
1357  4C86 0240         ANDI    R0,>0007                bit in bitmap byte (8 per byte)
1357  4C88 0007  
1358  4C8A 0931         SRL     R1,3                    byte in bitmap
1359  4C8C A045         A       R5,R1                   add VIB buffer
1360  4C8E 0221         AI      R1,56                   add bitmap offset in VIB
1360  4C90 0038  
1361  4C92 C0C0         MOV     R0,R3                   
1362  4C94 0500         NEG     R0                      
1363  4C96 0220         AI      R0,8                    change 0-7 into 8-1
1363  4C98 0008  
1364  4C9A 0204         LI      R4,>00FF                mask to erase
1364  4C9C 00FF  
1365  4C9E 8002         C       R2,R0                   how many to erase?
1366  4CA0 1101         JLT     H152                    less than in that byte
1367  4CA2 100A         JMP     H153                    
1368            *                               
1369  4CA4 0200 H152    LI      R0,8                    free sectors in first byte
1369  4CA6 0008  
1370  4CA8 6002         S       R2,R0                   
1371  4CAA 0B04         SRC     R4,0                    adjust mask
1372  4CAC C003         MOV     R3,R0                   original bit # of starting sector
1373  4CAE 1301         JEQ     H154                    
1374  4CB0 0A04         SLA     R4,0                    don't erase before starting sector
1375  4CB2 1000 H154    JMP     H155                    
1376            *                               
1377  4CB4 06C4 H155    SWPB    R4                      
1378  4CB6 1019         JMP     H158                    goto erase last byte
1379            *                                       
1380  4CB8 0B04 H153    SRC     R4,0                    adjust mask
1381  4CBA 6080 H156    S       R0,R2                   that many will be freed
1382  4CBC 0429         BLWP    @>005A(R9)              set VDP to read
1382  4CBE 005A  
1383  4CC0 0022         DATA    >0022                   address in R1
1384  4CC2 D02F         MOVB    @-1026(R15),R0          get bitmap byte
1384  4CC4 FBFE  
1385  4CC6 4004         SZC     R4,R0                   mark sectors as free
1386  4CC8 0429         BLWP    @>005A(R9)              set VDP to write
1386  4CCA 005A  
1387  4CCC 0023         DATA    >0023                   address in R1
1388  4CCE DBC0         MOVB    R0,@-2(R15)             write it back
1388  4CD0 FFFE  
1389  4CD2 0204         LI      R4,>FF00                clear full byte
1389  4CD4 FF00  
1390  4CD6 0581         INC     R1                      next byte
1391  4CD8 0200         LI      R0,8                    i.e. 8 sectors
1391  4CDA 0008  
1392  4CDC 8002         C       R2,R0                   how many more sectors?
1393  4CDE 1101         JLT     H157                    less than 8
1394  4CE0 10EC         JMP     H156                    8 or more: next byte
1395            *                                       
1396  4CE2 C002 H157    MOV     R2,R0                   remaining sectors
1397  4CE4 0204         LI      R4,>00FF                        
1397  4CE6 00FF  
1398  4CE8 0A04         SLA     R4,0                    coin mask
1399  4CEA 0429 H158    BLWP    @>005A(R9)              set VDP to read
1399  4CEC 005A  
1400  4CEE 0022         DATA    >0022                   address in R1
1401  4CF0 D02F         MOVB    @-1026(R15),R0          get bitmap byte
1401  4CF2 FBFE  
1402  4CF4 4004         SZC     R4,R0                   mark sectors as free
1403  4CF6 0429         BLWP    @>005A(R9)              set VDP to write
1403  4CF8 005A  
1404  4CFA 0023         DATA    >0023                   address in R1
1405  4CFC DBC0         MOVB    R0,@-2(R15)             write it back
1405  4CFE FFFE  
1406  4D00 10A5         JMP     H151                    done: flag drive # and return
1407            *
1408            *===================================
1409            * DSR entry points
1410            *===================================                                    
1411            *
1412  4D02 C1CB EDSR01  MOV     R11,R7                  DSK
1413  4D04 06A0         BL      @PRPFDO                 --- prepare file operations
1413  4D06 43DA  
1414  4D08 06A0         BL      @CALSUB                 call subroutine
1414  4D0A 430E  
1415  4D0C 4840         DATA    FDSKDR                  find disk in drive (name ptr in R3)
1416  4D0E 100B         JMP     H159                    
1417            *                                       
1418  4D10 0206 EDSR02  LI      R6,>0100                DSK1
1418  4D12 0100  
1419  4D14 1005         JMP     H160                    ----
1420            *                                       
1421  4D16 0206 EDSR03  LI      R6,>0200                DSK2
1421  4D18 0200  
1422  4D1A 1002         JMP     H160                    ----
1423            *                                       
1424  4D1C 0206 EDSR04  LI      R6,>0300                DSK3
1424  4D1E 0300  
1425            *                                       
1426  4D20 C1CB H160    MOV     R11,R7                  save return address
1427  4D22 06A0         BL      @PRPFDO                 prepare file operations
1427  4D24 43DA  
1428  4D26 C029 H159    MOV     @>0054(R9),R0           PAB ptr
1428  4D28 0054  
1429  4D2A 0429         BLWP    @>005A(R9)              set VDP to read
1429  4D2C 005A  
1430  4D2E 0002         DATA    >0002                   address in R0
1431  4D30 D06F         MOVB    @-1026(R15),R1          get opcode
1431  4D32 FBFE  
1432  4D34 0981         SRL     R1,8                    
1433  4D36 0281         CI      R1,>0009                check range
1433  4D38 0009  
1434  4D3A 1B19         JH      ERROR8                  illegal opcode
1435  4D3C 0282         CI      R2,>0001                filename lenght (including . )
1435  4D3E 0001  
1436  4D40 1605         JNE     H161                    no filename: dir
1437  4D42 0221         AI      R1,10                   only allow open, close and read
1437  4D44 000A  
1438  4D46 0281         CI      R1,>000C                        
1438  4D48 000C  
1439  4D4A 1B11         JH      ERROR8                  others are illegal
1440  4D4C A041 H161    A       R1,R1                   make it a word ptr
1441  4D4E C061         MOV     @OPCVEC(R1),R1          get vector
1441  4D50 4D54  
1442  4D52 0451         B       *R1                     branch to it
1443            *                                       
1444  4D54 4D74 OPCVEC  DATA    OPEN                    open
1445  4D56 4F86         DATA    CLOSE                   close
1446  4D58 4F90         DATA    READ                    read
1447  4D5A 507A         DATA    WRITE                   write
1448  4D5C 532E         DATA    RWIND1                  rewind
1449  4D5E 5382         DATA    LOAD                    load
1450  4D60 5424         DATA    SAVE                    save
1451  4D62 4724         DATA    DELETE                  delete
1452  4D64 4954         DATA    RETERR                  scratch record: return with bad attribute error
1453  4D66 54A8         DATA    STATUS                  status
1454            *                                       
1455  4D68 5568         DATA    OPNDIR                  open directory
1456  4D6A 55C6         DATA    CLSDIR                  close directory
1457  4D6C 55DC         DATA    RDDIR                   read directory
1458            *                                       
1459  4D6E 06A0 ERROR8  BL      @ERROR5                 return with error
1459  4D70 4928  
1460  4D72 6000         DATA    >6000                   illegal opcode
1461            *
1462            *---------------------------------
1463            * Opcode 0: Open
1464            * --------------
1465            * PAB 0: >00
1466            *     1: file type  <--- error code
1467            *   2-3:
1468            *     4: record length
1469            *     5:
1470            *   6-7: # of records (if output)
1471            *     8:
1472            *---------------------------------                                      
1473            *
1474  4D74 04C0 OPEN    CLR     R0                      
1475  4D76 D02F         MOVB    @-1026(R15),R0          get file attributes
1475  4D78 FBFE  
1476  4D7A 0429         BLWP    @>005A(R9)                      
1476  4D7C 005A  
1477  4D7E 8000         DATA    >8000                   save R0
1478  4D80 0240         ANDI    R0,>1600                keep fix/var and access mode
1478  4D82 1600  
1479  4D84 0280         CI      R0,>0600                        
1479  4D86 0600  
1480  4D88 1603         JNE     H162                    
1481  4D8A 06A0 ERROR9  BL      @ERROR5                 dis/fix, open as append: return with error
1481  4D8C 4928  
1482  4D8E 4000         DATA    >4000                   bad attribute
1483            *                                       
1484  4D90 120A H162    JLE     H163                    
1485  4D92 C040         MOV     R0,R1                   var
1486  4D94 06A0         BL      @PABR2B                 get 2 bytes from PAB into R0
1486  4D96 4820  
1487  4D98 0004         DATA    4                       rec len and char count
1488  4D9A 0280         CI      R0,>FF00                is rec len 255?
1488  4D9C FF00  
1489  4D9E 14F5         JHE     ERROR9                  yes: bad attribute
1490  4DA0 C001         MOV     R1,R0                   retrieve attributes
1491  4DA2 0240         ANDI    R0,>0600                keep only access mode
1491  4DA4 0600  
1492            *                                       
1493  4DA6 0280 H163    CI      R0,>0200                is it output?
1493  4DA8 0200  
1494  4DAA 1657         JNE     H164                    no
1495  4DAC 06A0         BL      @CALSUB                 call subroutine
1495  4DAE 430E  
1496  4DB0 4446         DATA    CRFIL1                  create file
1497  4DB2 06A0 H165    BL      @PRFDRS                 coin status byte in FDR style
1497  4DB4 4F34  
1498  4DB6 0429         BLWP    @>005A(R9)              set VDP to write
1498  4DB8 005A  
1499  4DBA 0083         DATA    >0083                   address in R4: status byte in FDR buffer
1500  4DBC DBC2         MOVB    R2,@-2(R15)             write file status in FDR
1500  4DBE FFFE  
1501  4DC0 C0E9         MOV     @>0054(R9),R3           PAB ptr
1501  4DC2 0054  
1502  4DC4 0223         AI      R3,4                    ptr to rec len
1502  4DC6 0004  
1503  4DC8 04C5         CLR     R5                      
1504  4DCA 0429         BLWP    @>005A(R9)              set VDP to read
1504  4DCC 005A  
1505  4DCE 0062         DATA    >0062                   address in R3
1506  4DD0 D16F         MOVB    @-1026(R15),R5          get record length
1506  4DD2 FBFE  
1507  4DD4 1607         JNE     H166                    
1508  4DD6 0205         LI      R5,>5000                >00: default it 80
1508  4DD8 5000  
1509  4DDA 0429         BLWP    @>005A(R9)              set VDP to write
1509  4DDC 005A  
1510  4DDE 0063         DATA    >0063                   address in R3
1511  4DE0 DBC5         MOVB    R5,@-2(R15)             write default rec len
1511  4DE2 FFFE  
1512  4DE4 0224 H166    AI      R4,5                    point to rec len byte in FDR
1512  4DE6 0005  
1513  4DE8 0429         BLWP    @>005A(R9)              set VDP to write
1513  4DEA 005A  
1514  4DEC 0083         DATA    >0083                   address in R4
1515  4DEE DBC5         MOVB    R5,@-2(R15)             write rec len in FDR buffer
1515  4DF0 FFFE  
1516  4DF2 0201         LI      R1,256                  256 bytes/sector
1516  4DF4 0100  
1517  4DF6 C082         MOV     R2,R2                   var or dis?
1518  4DF8 1101         JLT     H167                    var
1519  4DFA 1002         JMP     H168                    dis
1520  4DFC A141 H167    A       R1,R5                   var: rec len +1
1521  4DFE 0601         DEC     R1                      254 bytes only (needs size byte)
1522  4E00 06C5 H168    SWPB    R5                      make it a word
1523  4E02 04C0         CLR     R0                      
1524  4E04 3C05         DIV     R5,R0                   how many times in 254/255 bytes?
1525  4E06 0224         AI      R4,-4                   point to # of rec/sect in FDR
1525  4E08 FFFC  
1526  4E0A C040         MOV     R0,R1                   save result for later
1527  4E0C 06C0         SWPB    R0                      
1528  4E0E 0429         BLWP    @>005A(R9)              set VDP to write
1528  4E10 005A  
1529  4E12 0083         DATA    >0083                   address in R4
1530  4E14 DBC0         MOVB    R0,@-2(R15)             write # of rec/sect in FDR
1530  4E16 FFFE  
1531  4E18 C229         MOV     @>0056(R9),R8           point to filename in FDR
1531  4E1A 0056  
1532  4E1C 0429         BLWP    @>005A(R9)              set VDP to read
1532  4E1E 005A  
1533  4E20 0102         DATA    >0102                   address in R8
1534  4E22 D02F         MOVB    @-1026(R15),R0          get first char
1534  4E24 FBFE  
1535  4E26 0260         ORI     R0,>8000                flag it: update FDR before leaving
1535  4E28 8000  
1536  4E2A 0429         BLWP    @>005A(R9)              set VDP to write
1536  4E2C 005A  
1537  4E2E 0103         DATA    >0103                   address in R8
1538  4E30 DBC0         MOVB    R0,@-2(R15)             write it back
1538  4E32 FFFE  
1539  4E34 0429         BLWP    @>005A(R9)                      
1539  4E36 005A  
1540  4E38 8001         DATA    >8001                   retrieve R0 (access mode)
1541  4E3A 06A0         BL      @PABR2B                 get 2 bytes from PAB into R0
1541  4E3C 4820  
1542  4E3E 0006         DATA    6                       required size in records
1543  4E40 C100         MOV     R0,R4                   
1544  4E42 1309         JEQ     H169                    no size specified
1545  4E44 11A2         JLT     ERROR9                  return with bad attribute error
1546  4E46 A101         A       R1,R4                   round up to record size
1547  4E48 0604         DEC     R4                      
1548  4E4A 04C3         CLR     R3                      
1549  4E4C 3CC1         DIV     R1,R3                   how many sectors will this be?
1550  4E4E 0603         DEC     R3                      offset start from 0
1551  4E50 06A0         BL      @CALSUB                 call subroutine
1551  4E52 430E  
1552  4E54 4616         DATA    APSCTS                  add sectors to FDR to match offset in R3
1553  4E56 0460 H169    B       @RWIND2                 initialise file control block and return to caller
1553  4E58 535C  
1554            *                                       
1555  4E5A 0429 H164    BLWP    @>005A(R9)              not output
1555  4E5C 005A  
1556  4E5E 8000         DATA    >8000                   save R0
1557  4E60 06A0         BL      @CALSUB                 call subroutine
1557  4E62 430E  
1558  4E64 4AB8         DATA    FNDFDR                  find FDR on disk
1559  4E66 0429         BLWP    @>005A(R9)                      
1559  4E68 005A  
1560  4E6A 8001         DATA    >8001                   retrieve R0 (access mode)
1561  4E6C C104         MOV     R4,R4                   found FDR?
1562  4E6E 1309         JEQ     H170                    yes
1563  4E70 0280         CI      R0,>0400                no: is file open as input?
1563  4E72 0400  
1564  4E74 1304         JEQ     H171                    yes: must exist
1565  4E76 06A0         BL      @CALSUB                 no: call subroutine
1565  4E78 430E  
1566  4E7A 4458         DATA    CRFIL3                  create file
1567  4E7C 109A         JMP     H165                    
1568            *                                       
1569  4E7E 0460 H171    B       @ERROR9                 return with bad attribute error
1569  4E80 4D8A  
1570            *                                       
1571  4E82 C1C0 H170    MOV     R0,R7                   save access mode
1572  4E84 06A0         BL      @PRFDRS                 prepare status byte for FDR
1572  4E86 4F34  
1573  4E88 0429         BLWP    @>005A(R9)              set VDP to read
1573  4E8A 005A  
1574  4E8C 0082         DATA    >0082                   address in R4 (status byte in FDR)
1575  4E8E D02F         MOVB    @-1026(R15),R0          get current file status
1575  4E90 FBFE  
1576  4E92 C0C0         MOV     R0,R3                   save it
1577  4E94 0243         ANDI    R3,>0800                is file write protected?
1577  4E96 0800  
1578  4E98 1306         JEQ     H172                    no
1579  4E9A 0287         CI      R7,>0400                yes: is it open as input?
1579  4E9C 0400  
1580  4E9E 1303         JEQ     H172                    no
1581  4EA0 06A0         BL      @ERROR5                 yes: return with error
1581  4EA2 4928  
1582  4EA4 2000         DATA    >2000                   write protected
1583            *                                       
1584  4EA6 0240 H172    ANDI    R0,>8300                keep only file type bits (V/F, D/I, Prg/Data)
1584  4EA8 8300  
1585  4EAA 2802         XOR     R2,R0                   compare with new (coined by PRFDRS)
1586  4EAC 16E8         JNE     H171                    different: bad attribute
1587  4EAE C0E9         MOV     @>0054(R9),R3           PAB ptr
1587  4EB0 0054  
1588  4EB2 0223         AI      R3,4                    ptr to rec len in PAB
1588  4EB4 0004  
1589  4EB6 0224         AI      R4,5                    ptr to rec len in FDR
1589  4EB8 0005  
1590  4EBA 0429         BLWP    @>005A(R9)              set VDP to read
1590  4EBC 005A  
1591  4EBE 0082         DATA    >0082                   address in R4
1592  4EC0 D02F         MOVB    @-1026(R15),R0          get rec len from FDR
1592  4EC2 FBFE  
1593  4EC4 0429         BLWP    @>005A(R9)              set VDP to read
1593  4EC6 005A  
1594  4EC8 0062         DATA    >0062                   address in R3
1595  4ECA D0AF         MOVB    @-1026(R15),R2          get rec len from PAB
1595  4ECC FBFE  
1596  4ECE 1302         JEQ     H173                    0 = keep current one
1597  4ED0 9080         CB      R0,R2                   are they identical?
1598  4ED2 16D5         JNE     H171                    no: bad attribute
1599  4ED4 0429 H173    BLWP    @>005A(R9)              set VDP to write
1599  4ED6 005A  
1600  4ED8 0063         DATA    >0063                   address in R3
1601  4EDA DBC0         MOVB    R0,@-2(R15)             update rec len in PAB (in case it was 0)
1601  4EDC FFFE  
1602  4EDE 0429         BLWP    @>005A(R9)              retrieve R0 (open mode)
1602  4EE0 005A  
1603  4EE2 8001         DATA    >8001                   
1604  4EE4 0240         ANDI    R0,>0600                keep only access mode
1604  4EE6 0600  
1605  4EE8 04C2         CLR     R2                      
1606  4EEA 0703         SETO    R3                      
1607  4EEC 0280         CI      R0,>0600                is it append
1607  4EEE 0600  
1608  4EF0 161D         JNE     H174                    no
1609  4EF2 C129         MOV     @>0056(R9),R4           yes: get FDR ptr
1609  4EF4 0056  
1610  4EF6 C1C4         MOV     R4,R7                   save it
1611  4EF8 0224         AI      R4,14                   ptr to # of sectors
1611  4EFA 000E  
1612  4EFC 0429         BLWP    @>005A(R9)              set VDP to read
1612  4EFE 005A  
1613  4F00 0082         DATA    >0082                   address in R4
1614  4F02 D0EF         MOVB    @-1026(R15),R3          get # of sectors in file
1614  4F04 FBFE  
1615  4F06 06C3         SWPB    R3                      
1616  4F08 D0EF         MOVB    @-1026(R15),R3                  
1616  4F0A FBFE  
1617  4F0C 06C3         SWPB    R3                      
1618  4F0E D0AF         MOVB    @-1026(R15),R2          get eof offset
1618  4F10 FBFE  
1619  4F12 0603         DEC     R3                      offset starts from 0
1620  4F14 110B         JLT     H174                    file is empty (0 sectors)
1621  4F16 0429         BLWP    @>005A(R9)                      
1621  4F18 005A  
1622  4F1A 3000         DATA    >3000                   save R2 + R3
1623  4F1C 0227         AI      R7,256                  ptr to data buffer area for this file
1623  4F1E 0100  
1624  4F20 06A0         BL      @CALSUB                 call subroutine
1624  4F22 430E  
1625  4F24 45E0         DATA    RDOFSC                  read a sector, from offset in R3
1626  4F26 0429         BLWP    @>005A(R9)                      
1626  4F28 005A  
1627  4F2A 3001         DATA    >3001                   retrieve R2 + R3
1628  4F2C 06A0 H174    BL      @UPDFCB                 update current record offset in file ctrl block
1628  4F2E 4F5E  
1629  4F30 0460         B       @RTURN1                 return to caller
1629  4F32 432C  
1630            *                                       
1631  4F34 0429 PRFDRS  BLWP    @>005A(R9)              prepare file status byte for FDR
1631  4F36 005A  
1632  4F38 8001         DATA    >8001                   access mode in R0
1633  4F3A 0429         BLWP    @>005A(R9)                      
1633  4F3C 005A  
1634  4F3E 8000         DATA    >8000                   save it back
1635  4F40 0202         LI      R2,2                    int in FDR status byte
1635  4F42 0002  
1636  4F44 C129         MOV     @>0056(R9),R4           FDR pointer
1636  4F46 0056  
1637  4F48 0A40         SLA     R0,4                    fix or var?
1638  4F4A 1703         JNC     H175                    fix
1639  4F4C 0202         LI      R2,>0082                int var in FDR
1639  4F4E 0082  
1640  4F50 C000         MOV     R0,R0                   dis or int?
1641  4F52 1101 H175    JLT     H176                    int
1642  4F54 0642         DECT    R2                      dis: remove the int from FDR status
1643  4F56 0224 H176    AI      R4,12                   point at file status byte in FDR
1643  4F58 000C  
1644  4F5A 06C2         SWPB    R2                      
1645  4F5C 045B         B       *R11                    
1646            *                                       
1647  4F5E C129 UPDFCB  MOV     @>0056(R9),R4           update sect + rec offsets in file control block
1647  4F60 0056  
1648  4F62 0224         AI      R4,-6                   
1648  4F64 FFFA  
1649  4F66 0429         BLWP    @>005A(R9)              set VDP to write
1649  4F68 005A  
1650  4F6A 0083         DATA    >0083                   address in R4
1651  4F6C DBC3         MOVB    R3,@-2(R15)             write current sect offset
1651  4F6E FFFE  
1652  4F70 06C3         SWPB    R3                      
1653  4F72 DBC3         MOVB    R3,@-2(R15)                     
1653  4F74 FFFE  
1654  4F76 0224         AI      R4,4                    point to logical rec offset (for var files)
1654  4F78 0004  
1655  4F7A 0429         BLWP    @>005A(R9)              set VDP to write
1655  4F7C 005A  
1656  4F7E 0083         DATA    >0083                   address in R4
1657  4F80 DBC2         MOVB    R2,@-2(R15)             write record offset
1657  4F82 FFFE  
1658  4F84 045B         B       *R11                    
1659            *
1660            *----------------------------------
1661            * Opcode 1: Close
1662            * --------------
1663            * PAB 0: >01
1664            *     1:           <--- error code
1665            *   2-3:
1666            *     4:
1667            *     5:
1668            *   6-7:
1669            *     8:
1670            *----------------------------------                                     
1671            *
1672  4F86 06A0 CLOSE   BL      @CALSUB                 call subroutine
1672  4F88 430E  
1673  4F8A 5184         DATA    FFDRVP                  find file FDR
1674  4F8C 0460         B       @UPDFDR                 update FDR + data area, get VIB, return to caller
1674  4F8E 452C  
1675            *
1676            *----------------------------------
1677            * Opcode 2: Read
1678            * --------------
1679            * PAB 0: >02
1680            *     1: file type <--- error code
1681            *   2-3: data buffer address in VDP mem
1682            *     4:
1683            *     5: bytes read
1684            *   6-7: record #
1685            *     8:
1686            *
1687            * Logical records organisation whithin sectors
1688            *
1689            * Fixed records (e.g. rec length = 6)
1690            * 11 11 11 11 11 11 22 22 22 22 22 22 33 33 33 33 33 33 xx xx xx
1691            * Where 11=data for record 1, 22=record 2, 33=record 3, xx=junk bytes
1692            *
1693            * Variable records:
1694            * sz 11 11 11 11 11 11 11 sz 22 22 22 22 22 sz 33 33 FF xx xx xx
1695            * Where sz=record size, 11,22,33=record data, FF=end-of-sector mark, xx=junk
1696            *----------------------------------                                     
1697            *
1698  4F90 06A0 READ    BL      @CALSUB                 call subroutine
1698  4F92 430E  
1699  4F94 5184         DATA    FFDRVP                  find FDR in VDP buffers, get status from PAB
1700  4F96 0240         ANDI    R0,>0200                what type of access?
1700  4F98 0200  
1701  4F9A 1302         JEQ     H177                    update or input: ok
1702  4F9C 0460 H179    B       @ERROR8                 append or output: error illegal opcode
1702  4F9E 4D6E  
1703  4FA0 06A0 H177    BL      @RFDRST                 get status byte in R0, from FDR
1703  4FA2 51B0  
1704  4FA4 110A         JLT     H178                    var
1705  4FA6 06A0         BL      @RRNPAB                 fix: get rec # compare to # of recs/file
1705  4FA8 51C4  
1706  4FAA 1A03         JL      H180                    ok: in file
1707  4FAC 06A0 H181    BL      @ERROR5                 update data and return with error
1707  4FAE 4928  
1708  4FB0 A000         DATA    >A000                   eof reached
1709  4FB2 06A0 H180    BL      @CALSUB                 call subroutine
1709  4FB4 430E  
1710  4FB6 522A         DATA    RRFDR                   load record from disk into FDR data buffer area
1711  4FB8 1011         JMP     H182                    
1712            *                                       
1713  4FBA 06A0 H178    BL      @CALSUB                 var: call subroutine
1713  4FBC 430E  
1714  4FBE 5016         DATA    RRSEC                   load proper sector, point to rec in it
1715  4FC0 10F5         JMP     H181                    skipped if ok: return with eof reached
1716            *                                       
1717  4FC2 0582         INC     R2                      next byte in data buffer
1718  4FC4 A004         A       R4,R0                   add rec size to offset
1719  4FC6 0580         INC     R0                      room for end-of-sector mark
1720  4FC8 C169         MOV     @>0056(R9),R5           FDR ptr
1720  4FCA 0056  
1721  4FCC 0645         DECT    R5                      point to var record offset in sector
1722  4FCE 06C0         SWPB    R0                      
1723  4FD0 0429         BLWP    @>005A(R9)              set VDP to write
1723  4FD2 005A  
1724  4FD4 00A3         DATA    >00A3                   address in R5
1725  4FD6 DBC0         MOVB    R0,@-2(R15)             update var record offset in sector
1725  4FD8 FFFE  
1726  4FDA C004         MOV     R4,R0                   save # of bytes to be read
1727  4FDC C129 H182    MOV     @>0054(R9),R4           PAB ptr
1727  4FDE 0054  
1728  4FE0 0224         AI      R4,5                    point to char count
1728  4FE2 0005  
1729  4FE4 06C0         SWPB    R0                      
1730  4FE6 0429         BLWP    @>005A(R9)              set VDP to write
1730  4FE8 005A  
1731  4FEA 0083         DATA    >0083                   address in R4
1732  4FEC DBC0         MOVB    R0,@-2(R15)             write # of char to be read
1732  4FEE FFFE  
1733  4FF0 06C0         SWPB    R0                      make it a word
1734            *                                       
1735  4FF2 C000 WFDRPB  MOV     R0,R0                   check it
1736  4FF4 130E         JEQ     H183                    none: return
1737  4FF6 0429 H184    BLWP    @>005A(R9)              set VDP to read
1737  4FF8 005A  
1738  4FFA 0042         DATA    >0042                   address in R2
1739  4FFC D0EF         MOVB    @-1026(R15),R3          read 1 byte from FDR data buffer area
1739  4FFE FBFE  
1740  5000 0582         INC     R2                      increment source ptr
1741  5002 0429         BLWP    @>005A(R9)              set VDP to write
1741  5004 005A  
1742  5006 0023         DATA    >0023                   address in R1
1743  5008 DBC3         MOVB    R3,@-2(R15)             write the byte in PAB data buffer
1743  500A FFFE  
1744  500C 0581         INC     R1                      increment destination ptr
1745  500E 0600         DEC     R0                      more to read?
1746  5010 16F2         JNE     H184                    yes
1747  5012 0460 H183    B       @RTURN1                 return to caller
1747  5014 432C  
1748            *                                       
1749  5016 06A0 RRSEC   BL      @RCOFCB                 load sector, point to record in it
1749  5018 5304  
1750  501A C0C3         MOV     R3,R3                   sector offset
1751  501C 1101         JLT     H185                    -1: top of file
1752  501E 1012         JMP     H186                    in file
1753  5020 C003 H185    MOV     R3,R0                   
1754  5022 0580         INC     R0                      next sector
1755  5024 8080         C       R0,R2                   compare to # of sect/file
1756  5026 13F5         JEQ     H183                    end-of-file reached: return to caller (JMP to err)
1757  5028 06A0         BL      @CALSUB                 call subroutine
1757  502A 430E  
1758  502C 454C         DATA    UPDBF                   update data buffer, if needed
1759  502E C0C0         MOV     R0,R3                   desired offset
1760  5030 04C5         CLR     R5                      
1761  5032 06A0         BL      @UCOFCB                 update sect + rec offsets in control block
1761  5034 52A2  
1762  5036 0227         AI      R7,256                  point to data buffer area (R7 set by UCOFCB)
1762  5038 0100  
1763  503A 06A0         BL      @CALSUB                 call subroutine
1763  503C 430E  
1764  503E 45E0         DATA    RDOFSC                  read a sector, from offset in file (in R3)
1765  5040 04C0         CLR     R0                      
1766  5042 1004         JMP     H187                    
1767            *                                       
1768  5044 C000 H186    MOV     R0,R0                   in file: test var rec offset (from RCOFCB)
1769  5046 1602         JNE     H187                    inside sector
1770  5048 8080         C       R0,R2                   at beg of sector
1771  504A 13E3         JEQ     H183                    file is empty: return
1772  504C C080 H187    MOV     R0,R2                   FDR data buffer will be added to R2 by AFDRPT
1773  504E 06A0         BL      @CALSUB                 call subroutine
1773  5050 430E  
1774  5052 527E         DATA    AFDRPT                  R2=byte in FDR data buf, R1=top of PAB data buf
1775  5054 0429         BLWP    @>005A(R9)              set VDP to read
1775  5056 005A  
1776  5058 0042         DATA    >0042                   address in R2
1777  505A D12F         MOVB    @-1026(R15),R4          get first byte (rec length)
1777  505C FBFE  
1778  505E 0984         SRL     R4,8                    make it a word
1779  5060 C000         MOV     R0,R0                   var rec offset
1780  5062 1306         JEQ     H188                    
1781  5064 0284         CI      R4,>00FF                is it >FF (end of sector mark) ?
1781  5066 00FF  
1782  5068 1603         JNE     H188                    no
1783  506A 06A0         BL      @RCOFCB                 yes: get sect + rec offsets from control block
1783  506C 5304  
1784  506E 10D8         JMP     H185                    try again with next sector
1785            *                                       
1786  5070 0429 H188    BLWP    @>005A(R9)                      
1786  5072 005A  
1787  5074 0011         DATA    >0011                   retrieve return address from stack in R11
1788  5076 05CB         INCT    R11                     skip the JMP to eof reached error
1789  5078 045B         B       *R11                    
1790            *
1791            *------------------------------------
1792            * Opcode 3: Write
1793            * --------------
1794            * PAB 0: >03
1795            *     1: file type <--- error code
1796            *   2-3: data buffer address in VDP mem
1797            *     4:
1798            *     5: bytes to write
1799            *   6-7: record #
1800            *     8:
1801            *------------------------------------                                   
1802            *
1803  507A 06A0 WRITE   BL      @CALSUB                 call subroutine
1803  507C 430E  
1804  507E 5184         DATA    FFDRVP                  find FDR in VDP buffers
1805  5080 0240         ANDI    R0,>0600                keep only access mode
1805  5082 0600  
1806  5084 0280         CI      R0,>0400                is it input
1806  5086 0400  
1807  5088 1389         JEQ     H179                    yes: return with error illegal opcode
1808  508A 06A0         BL      @RFDRST                 get file status byte from FDR
1808  508C 51B0  
1809  508E 1113         JLT     H189                    var                     
1810  5090 06A0         BL      @RRNPAB                 fix: get rec # from PAB, sect # in R0
1810  5092 51C4  
1811  5094 1A0C         JL      H190                    less that total rec/file
1812  5096 0429         BLWP    @>005A(R9)              past eof: expand file
1812  5098 005A  
1813  509A D800         DATA    >D800                   save R0, R1, R3, R4
1814  509C C0C0         MOV     R0,R3                   desired sector offset
1815  509E 06A0         BL      @CALSUB                 call subroutine
1815  50A0 430E  
1816  50A2 4616         DATA    APSCTS                  append enough sectors to reach offset in R3
1817  50A4 0429         BLWP    @>005A(R9)                      
1817  50A6 005A  
1818  50A8 D801         DATA    >D801                   restore R0, R1, R3, R4
1819  50AA 06A0         BL      @URFFDR                 update # of rec/file in FDR
1819  50AC 52CE  
1820            *                                       
1821  50AE 06A0 H190    BL      @CALSUB                 in file: call subroutine
1821  50B0 430E  
1822  50B2 522A         DATA    RRFDR                   fetch rec from disk into FDR data buffer area
1823  50B4 1053         JMP     H191                    set update data flag, write data, return
1824            *                                       
1825  50B6 06A0 H189    BL      @RCOFCB                 var: R2=sect/file R3=sect offset R0=rec offset
1825  50B8 5304  
1826  50BA C0C3         MOV     R3,R3                   sector offset in file
1827  50BC 1101         JLT     H192                    -1: top of file
1828  50BE 100B         JMP     H193                    in file
1829  50C0 0429 H192    BLWP    @>005A(R9)              next sector loop
1829  50C2 005A  
1830  50C4 3000         DATA    >3000                   save R2 + R3
1831  50C6 06A0         BL      @CALSUB                 call subroutine
1831  50C8 430E  
1832  50CA 454C         DATA    UPDBF                   update data buffer if needed
1833  50CC 0429         BLWP    @>005A(R9)                      
1833  50CE 005A  
1834  50D0 3001         DATA    >3001                   retrieve R2 + R3
1835  50D2 0583         INC     R3                      next sector
1836  50D4 04C0         CLR     R0                      init char offset in sector
1837            *                                       
1838  50D6 8083 H193    C       R3,R2                   did we reach last sector?
1839  50D8 1609         JNE     H194                    no
1840  50DA 0429         BLWP    @>005A(R9)              yes: expand file
1840  50DC 005A  
1841  50DE 9000         DATA    >9000                   save R0 + R4
1842  50E0 06A0         BL      @CALSUB                 call subroutine
1842  50E2 430E  
1843  50E4 4616         DATA    APSCTS                  get last sector then append sectors to reach R3
1844  50E6 0429         BLWP    @>005A(R9)                      
1844  50E8 005A  
1845  50EA 9001         DATA    >9001                   retrieve R0 + R4
1846            *                                       
1847  50EC C169 H194    MOV     @>0054(R9),R5           PAB ptr
1847  50EE 0054  
1848  50F0 0225         AI      R5,5                    point to char count
1848  50F2 0005  
1849  50F4 0429         BLWP    @>005A(R9)              set VDP to read
1849  50F6 005A  
1850  50F8 00A2         DATA    >00A2                   address in R5
1851  50FA D12F         MOVB    @-1026(R15),R4          get # of chars to write
1851  50FC FBFE  
1852  50FE 0984         SRL     R4,8                    make it a word
1853  5100 C144         MOV     R4,R5                   
1854  5102 A140         A       R0,R5                   add current char offset in sector
1855  5104 0585         INC     R5                      make room for size byte
1856  5106 0285         CI      R5,>00FF                past end of sector?
1856  5108 00FF  
1857  510A 1BDA         JH      H192                    yes: not enough room, try next sector
1858  510C 0702         SETO    R2                      ok: rec will fit in sector
1859  510E C069         MOV     @>0056(R9),R1           FDR ptr
1859  5110 0056  
1860  5112 A045         A       R5,R1                   past-last-byte offset
1861  5114 0221         AI      R1,256                  ptr to data buffer area
1861  5116 0100  
1862  5118 0429         BLWP    @>005A(R9)              set VDP to write
1862  511A 005A  
1863  511C 0023         DATA    >0023                   address in R1
1864  511E DBC2         MOVB    R2,@-2(R15)             write end-of-sect mark to FDR data buffer area
1864  5120 FFFE  
1865  5122 0429         BLWP    @>005A(R9)                      
1865  5124 005A  
1866  5126 8000         DATA    >8000                   save R0 (current byte offset in sector)
1867  5128 C003         MOV     R3,R0                   
1868  512A 06A0         BL      @UCOFCB                 update sect + rec offsets in control block
1868  512C 52A2  
1869  512E 0221         AI      R1,18                   point to eof offset in FDR (R1 modified by UCOFCB)
1869  5130 0012  
1870  5132 0429         BLWP    @>005A(R9)              set VDP to write
1870  5134 005A  
1871  5136 0023         DATA    >0023                   address in R1
1872  5138 DBC5         MOVB    R5,@-2(R15)             update eof offset in last sector, in FDR
1872  513A FFFE  
1873  513C 06A0         BL      @URFFDR                 update # of rec/file in FDR
1873  513E 52CE  
1874  5140 0429         BLWP    @>005A(R9)                      
1874  5142 005A  
1875  5144 2001         DATA    >2001                   retrieve old R0 in R2 (current byte offset)
1876  5146 C004         MOV     R4,R0                   record size
1877  5148 06A0         BL      @CALSUB                 call subroutine
1877  514A 430E  
1878  514C 527E         DATA    AFDRPT                  get FDR data buffer in R2, PAB data buffer in R1
1879  514E 06C4         SWPB    R4                      
1880  5150 0429         BLWP    @>005A(R9)              set VDP to write
1880  5152 005A  
1881  5154 0043         DATA    >0043                   address in R2
1882  5156 DBC4         MOVB    R4,@-2(R15)             write size byte to FDR data buffer
1882  5158 FFFE  
1883  515A 0582         INC     R2                      increment dest pointer
1884            *                                       
1885  515C C0C2 H191    MOV     R2,R3                   invert source and dest
1886  515E C081         MOV     R1,R2                   so we can use the same read-write loop
1887  5160 C043         MOV     R3,R1                   than the read opcode
1888  5162 C129         MOV     @>0056(R9),R4           FDR ptr
1888  5164 0056  
1889  5166 0604         DEC     R4                      pointer to drive # for that file
1890  5168 0429         BLWP    @>005A(R9)              set VDP to read
1890  516A 005A  
1891  516C 0082         DATA    >0082                   address in R4
1892  516E D16F         MOVB    @-1026(R15),R5          get drive #
1892  5170 FBFE  
1893  5172 0265         ORI     R5,>8000                add update data area flag
1893  5174 8000  
1894  5176 0429         BLWP    @>005A(R9)              set VDP to write
1894  5178 005A  
1895  517A 0083         DATA    >0083                   address in R4
1896  517C DBC5         MOVB    R5,@-2(R15)             write back flagged byte
1896  517E FFFE  
1897  5180 0460         B       @WFDRPB                 to read-write loop
1897  5182 4FF2  
1898            *                                       
1899  5184 06A0 FFDRVP  BL      @CALSUB                 find FDR in VDP buffer
1899  5186 430E  
1900  5188 4A5A         DATA    FFFDRV                  find file FDR
1901  518A C104         MOV     R4,R4                   found?
1902  518C 1303         JEQ     AFPGPF                  yes
1903  518E 06A0         BL      @ERROR5                 no: return with error
1903  5190 4928  
1904  5192 E000         DATA    >E000                   file error
1905  5194 0581 AFPGPF  INC     R1                      point to filename in FDR
1906  5196 CA41         MOV     R1,@>0056(R9)           new FDR ptr
1906  5198 0056  
1907  519A C129         MOV     @>0054(R9),R4           get PAB ptr
1907  519C 0054  
1908  519E 0584         INC     R4                      point to status byte
1909  51A0 04C0         CLR     R0                      
1910  51A2 0429         BLWP    @>005A(R9)              set VDP to read
1910  51A4 005A  
1911  51A6 0082         DATA    >0082                   address in R4
1912  51A8 D02F         MOVB    @-1026(R15),R0          get file status
1912  51AA FBFE  
1913  51AC 0460         B       @RTURN1                 return to caller
1913  51AE 432C  
1914            *                                       
1915  51B0 C129 RFDRST  MOV     @>0056(R9),R4           get status byte from FDR
1915  51B2 0056  
1916  51B4 0224         AI      R4,12                   point to status byte
1916  51B6 000C  
1917  51B8 0429         BLWP    @>005A(R9)              set VDP to read
1917  51BA 005A  
1918  51BC 0082         DATA    >0082                   address in R4
1919  51BE D02F         MOVB    @-1026(R15),R0          read status byte
1919  51C0 FBFE  
1920  51C2 045B         B       *R11                    
1921            *                                       
1922  51C4 D16F RRNPAB  MOVB    @-1026(R15),R5          get record # from PAB, check if valid
1922  51C6 FBFE  
1923  51C8 0985         SRL     R5,8                    
1924  51CA 1602         JNE     H195                    get # of rec/sector from FDR
1925  51CC 0205         LI      R5,256                  0: default to 256
1925  51CE 0100  
1926  51D0 C0E9 H195    MOV     @>0054(R9),R3           PAB ptr
1926  51D2 0054  
1927  51D4 0223         AI      R3,6                    point to rec #
1927  51D6 0006  
1928  51D8 0429         BLWP    @>005A(R9)              set VDP to read
1928  51DA 005A  
1929  51DC 0062         DATA    >0062                   address in R3
1930  51DE D06F         MOVB    @-1026(R15),R1          get record # from PAB
1930  51E0 FBFE  
1931  51E2 06C1         SWPB    R1                      
1932  51E4 D06F         MOVB    @-1026(R15),R1                  
1932  51E6 FBFE  
1933  51E8 06C1         SWPB    R1                      
1934  51EA C001         MOV     R1,R0                   save it
1935  51EC 1101         JLT     H196                    too big
1936  51EE 1003         JMP     H197                    ok
1937  51F0 06A0 H196    BL      @ERROR5                 update data then return with error
1937  51F2 4928  
1938  51F4 8000         DATA    >8000                   memory full
1939  51F6 0580 H197    INC     R0                      next record
1940  51F8 0429         BLWP    @>005A(R9)              set VDP to write
1940  51FA 005A  
1941  51FC 0063         DATA    >0063                   address in R3
1942  51FE DBC0         MOVB    R0,@-2(R15)             write back # of future record
1942  5200 FFFE  
1943  5202 06C0         SWPB    R0                      
1944  5204 DBC0         MOVB    R0,@-2(R15)                     
1944  5206 FFFE  
1945  5208 04C0         CLR     R0                      
1946  520A C0C1         MOV     R1,R3                   save # of desired rec
1947  520C 3C05         DIV     R5,R0                   divide by # of rec/sector = sect # in R0
1948  520E C0A9 RNFISE  MOV     @>0056(R9),R2           FDR ptr
1948  5210 0056  
1949  5212 0222         AI      R2,18                   point to total # of rec (# of sectors for var)
1949  5214 0012  
1950  5216 0429         BLWP    @>005A(R9)              set VDP to read
1950  5218 005A  
1951  521A 0042         DATA    >0042                   address in R2
1952  521C D0AF         MOVB    @-1026(R15),R2          get total # of recs/file (sect/file for var)
1952  521E FBFE  
1953  5220 06C2         SWPB    R2                      
1954  5222 D0AF         MOVB    @-1026(R15),R2          remember: bytes are swapped
1954  5224 FBFE  
1955  5226 8083         C       R3,R2                   compare with desired record (ignored by var)
1956  5228 045B         B       *R11                    
1957            *                                       
1958  522A 0429 RRFDR   BLWP    @>005A(R9)              fetch record into FDR data buffer area
1958  522C 005A  
1959  522E 4000         DATA    >4000                   save R1
1960  5230 0224         AI      R4,-18                  ptr to top of control block
1960  5232 FFEE  
1961  5234 0429         BLWP    @>005A(R9)              set VDP to read
1961  5236 005A  
1962  5238 0082         DATA    >0082                   address in R4
1963  523A D16F         MOVB    @-1026(R15),R5          get current sector offset in file
1963  523C FBFE  
1964  523E 06C5         SWPB    R5                      
1965  5240 D16F         MOVB    @-1026(R15),R5                  
1965  5242 FBFE  
1966  5244 0B85         SRC     R5,8                    
1967  5246 1105         JLT     H198                    -1: top of file
1968  5248 8005         C       R5,R0                   compare with desired offset (from RRNPAB)
1969  524A 130B         JEQ     H199                    same
1970  524C 06A0         BL      @CALSUB                 call subroutine
1970  524E 430E  
1971  5250 454C         DATA    UPDBF                   update data buffer if needed
1972  5252 C0C0 H198    MOV     R0,R3                   desired sector offset in file
1973  5254 06A0         BL      @UCOFCB                 update sect + rec offsets in control block
1973  5256 52A2  
1974  5258 0227         AI      R7,256                  point to data buffer area (R7 set by UCOFCB)
1974  525A 0100  
1975  525C 06A0         BL      @CALSUB                 call subroutine
1975  525E 430E  
1976  5260 45E0         DATA    RDOFSC                  read a sector from offset in file (in R3)
1977  5262 0429 H199    BLWP    @>005A(R9)                      
1977  5264 005A  
1978  5266 4001         DATA    >4001                   retrieve R1
1979  5268 C0E9         MOV     @>0056(R9),R3           FDR ptr
1979  526A 0056  
1980  526C 0223         AI      R3,17                   point to record length
1980  526E 0011  
1981  5270 0429         BLWP    @>005A(R9)              set VDP to read
1981  5272 005A  
1982  5274 0062         DATA    >0062                   address in R3
1983  5276 D02F         MOVB    @-1026(R15),R0          get rec length in bytes
1983  5278 FBFE  
1984  527A 0980         SRL     R0,8                    make it a word
1985  527C 3840         MPY     R0,R1                   calc file offset in bytes
1986  527E A0A9 AFDRPT  A       @>0056(R9),R2           add FDR ptr
1986  5280 0056  
1987  5282 0222         AI      R2,256                  point inside data buffer area
1987  5284 0100  
1988  5286 C0E9         MOV     @>0054(R9),R3           PAB ptr
1988  5288 0054  
1989  528A 05C3         INCT    R3                      point to data buffer address
1990  528C 0429         BLWP    @>005A(R9)              set VDP to read
1990  528E 005A  
1991  5290 0062         DATA    >0062                   address in R3
1992  5292 D06F         MOVB    @-1026(R15),R1          get PAB data buffer address
1992  5294 FBFE  
1993  5296 06C1         SWPB    R1                      
1994  5298 D06F         MOVB    @-1026(R15),R1                  
1994  529A FBFE  
1995  529C 06C1         SWPB    R1                      
1996  529E 0460         B       @RTURN1                 return
1996  52A0 432C  
1997            *                               
1998  52A2 C1E9 UCOFCB  MOV     @>0056(R9),R7           update sect + rec offsets in control block
1998  52A4 0056  
1999  52A6 C047         MOV     R7,R1                   FDR ptr
2000  52A8 0221         AI      R1,-6                   top of file control block
2000  52AA FFFA  
2001  52AC 0429         BLWP    @>005A(R9)              set VDP to write
2001  52AE 005A  
2002  52B0 0023         DATA    >0023                   address in R1
2003  52B2 DBC0         MOVB    R0,@-2(R15)             current sector offset in file
2003  52B4 FFFE  
2004  52B6 06C0         SWPB    R0                      
2005  52B8 DBC0         MOVB    R0,@-2(R15)                     
2005  52BA FFFE  
2006  52BC 0221         AI      R1,4                    point to var rec offset in sector
2006  52BE 0004  
2007  52C0 06C5         SWPB    R5                      
2008  52C2 0429         BLWP    @>005A(R9)              set VDP to write
2008  52C4 005A  
2009  52C6 0023         DATA    >0023                   address in R1
2010  52C8 DBC5         MOVB    R5,@-2(R15)             first free byte in current sector
2010  52CA FFFE  
2011  52CC 045B         B       *R11                    
2012            *                                       
2013  52CE C0A9 URFFDR  MOV     @>0056(R9),R2           update # of rec/file in FDR
2013  52D0 0056  
2014  52D2 0429         BLWP    @>005A(R9)              set VDP to read
2014  52D4 005A  
2015  52D6 0042         DATA    >0042                   address in R2 (FDR ptr)
2016  52D8 D2AF         MOVB    @-1026(R15),R10         get first char of filename
2016  52DA FBFE  
2017  52DC 026A         ORI     R10,>8000               set was modified flag
2017  52DE 8000  
2018  52E0 0429         BLWP    @>005A(R9)              set VDP to write
2018  52E2 005A  
2019  52E4 0043         DATA    >0043                   address in R2
2020  52E6 DBCA         MOVB    R10,@-2(R15)            write flagged char back
2020  52E8 FFFE  
2021  52EA 0222         AI      R2,18                   point to # of recs/file in FDR
2021  52EC 0012  
2022  52EE 0583         INC     R3                      one more
2023  52F0 0429         BLWP    @>005A(R9)              set VDP to write
2023  52F2 005A  
2024  52F4 0043         DATA    >0043                   address in R2
2025  52F6 06C3         SWPB    R3                      update # of recs/file
2026  52F8 DBC3         MOVB    R3,@-2(R15)                     
2026  52FA FFFE  
2027  52FC 06C3         SWPB    R3                      
2028  52FE DBC3         MOVB    R3,@-2(R15)                     
2028  5300 FFFE  
2029  5302 045B         B       *R11                    
2030            *                                       
2031  5304 C229 RCOFCB  MOV     @>0056(R9),R8           get rec offset, compare sect with total
2031  5306 0056  
2032  5308 C108         MOV     R8,R4                   FDR ptr
2033  530A 0224         AI      R4,256                  point to data buffer area
2033  530C 0100  
2034  530E 0648         DECT    R8                      point to var record offset
2035  5310 0429         BLWP    @>005A(R9)              set VDP to read
2035  5312 005A  
2036  5314 0102         DATA    >0102                   address in R8
2037  5316 D0AF         MOVB    @-1026(R15),R2          get var rec offset in current sector
2037  5318 FBFE  
2038  531A 0982         SRL     R2,8                    make it a word
2039  531C C28B         MOV     R11,R10                 save return point
2040  531E 06A0         BL      @FDR2B2                 get 2 bytes from FDR (at R8-4) into R0
2040  5320 482A  
2041  5322 FFFC         DATA    -4                      current sector offset in file
2042  5324 C0C0         MOV     R0,R3                   save it
2043  5326 C2CA         MOV     R10,R11                 restore return point
2044  5328 C002         MOV     R2,R0                   var record offset
2045  532A 0460         B       @RNFISE                 get # of sect/file from FDR, return
2045  532C 520E  
2046            *
2047            *------------------------------------
2048            * Opcode 4: Rewind
2049            * --------------
2050            * PAB 0: >04
2051            *     1: file type <--- error code
2052            *   2-3:
2053            *     4:
2054            *     5:
2055            *   6-7: record #  <--- >0000 if sequential
2056            *     8:
2057            *------------------------------------                                   
2058            *
2059  532E 06A0 RWIND1  BL      @CALSUB                 call subroutine
2059  5330 430E  
2060  5332 5184         DATA    FFDRVP                  find FDR in VDP buffers, read status from PAB
2061  5334 0429         BLWP    @>005A(R9)                      
2061  5336 005A  
2062  5338 8000         DATA    >8000                   save R0 (status from PAB)
2063  533A 0240         ANDI    R0,>0600                keep only access mode
2063  533C 0600  
2064  533E 1305         JEQ     H200                    update is ok
2065  5340 0280         CI      R0,>0400                is it input?
2065  5342 0400  
2066  5344 1302         JEQ     H200                    yes: ok
2067  5346 0460         B       @ERROR8                 output or append: return with illegal opcode
2067  5348 4D6E  
2068  534A 06A0 H200    BL      @CALSUB                 call subroutine
2068  534C 430E  
2069  534E 454C         DATA    UPDBF                   update data buffer if needed
2070  5350 0429         BLWP    @>005A(R9)                      
2070  5352 005A  
2071  5354 8001         DATA    >8001                   retrieve R0 (status from PAB)
2072  5356 0240         ANDI    R0,>0100                sequential or reloc?
2072  5358 0100  
2073  535A 1611         JNE     H201                    reloc: don't do anything, return
2074            *                                       
2075  535C 04C2 RWIND2  CLR     R2                      rewind file: record offset = 0
2076  535E 0703         SETO    R3                      current record = -1 (none)
2077  5360 06A0         BL      @UPDFCB                 update file control block
2077  5362 4F5E  
2078  5364 04C0         CLR     R0                      record 0
2079  5366 C229         MOV     @>0054(R9),R8           get PAB ptr
2079  5368 0054  
2080  536A 0228         AI      R8,6                    point to record #
2080  536C 0006  
2081  536E 0429         BLWP    @>005A(R9)              set VDP to write
2081  5370 005A  
2082  5372 0103         DATA    >0103                   address in R8
2083  5374 DBC0         MOVB    R0,@-2(R15)             write record #
2083  5376 FFFE  
2084  5378 1000         NOP                             
2085  537A DBC0         MOVB    R0,@-2(R15)                     
2085  537C FFFE  
2086  537E 0460 H201    B       @RTURN1                 return to caller
2086  5380 432C  
2087            *
2088            *------------------------------------
2089            * Opcode 5: Load
2090            * --------------
2091            * PAB 0: >05
2092            *     1: file type  <--- error code
2093            *   2-3: data buffer address in VDP mem
2094            *     4:
2095            *     5:
2096            *   6-7: maximum # of bytes (size of buffer)
2097            *     8:
2098            *------------------------------------                                   
2099            *
2100  5382 06A0 LOAD    BL      @CALSUB                 call subroutine
2100  5384 430E  
2101  5386 4AB8         DATA    FNDFDR                  find FDR on disk
2102  5388 C104         MOV     R4,R4                   found?
2103  538A 1303         JEQ     H203                    yes
2104  538C 06A0 H202    BL      @ERROR5                 no: return with error
2104  538E 4928  
2105  5390 E000         DATA    >E000                   file error
2106  5392 06A0 H203    BL      @FDR2B1                 get 2 bytes from FDR into R0
2106  5394 4826  
2107  5396 000C         DATA    12                      file status byte
2108  5398 0240         ANDI    R0,>0100                is it program?
2108  539A 0100  
2109  539C 13F7         JEQ     H202                    no: file error
2110  539E 05C8         INCT    R8                      point to # of sect/file in FDR
2111  53A0 0429         BLWP    @>005A(R9)              set VDP to read
2111  53A2 005A  
2112  53A4 0102         DATA    >0102                   address in R8
2113  53A6 D06F         MOVB    @-1026(R15),R1          get # of sectors in file
2113  53A8 FBFE  
2114  53AA 06C1         SWPB    R1                      
2115  53AC D06F         MOVB    @-1026(R15),R1                  
2115  53AE FBFE  
2116  53B0 0B81         SRC     R1,8                    
2117  53B2 13EC         JEQ     H202                    0=empty file: return with file error
2118  53B4 06A0         BL      @RBANB                  get data buffer address in R7, # of sectors in R2
2118  53B6 5474  
2119  53B8 05C8         INCT    R8                      point to eof offset in FDR
2120  53BA 04C4         CLR     R4                      
2121  53BC 0429         BLWP    @>005A(R9)              set VDP to read
2121  53BE 005A  
2122  53C0 0102         DATA    >0102                   address in R8
2123  53C2 D12F         MOVB    @-1026(R15),R4          get # of bytes in last sector
2123  53C4 FBFE  
2124  53C6 8081         C       R1,R2                   compare # of sect with max in PAB
2125  53C8 1BE1         JH      H202                    file is too big: return with file error
2126  53CA 1602         JNE     H204                    file is smaller
2127  53CC 8100         C       R0,R4                   same # of sect: check bytes in last sector
2128  53CE 1ADE         JL      H202                    file is too big: file error
2129  53D0 04C3 H204    CLR     R3                      sector offset in file
2130  53D2 06C4         SWPB    R4                      
2131  53D4 0601 H206    DEC     R1                      next sector
2132  53D6 130D         JEQ     H205                    done
2133  53D8 0429         BLWP    @>005A(R9)                      
2133  53DA 005A  
2134  53DC D900         DATA    >D900                   save R0, R1, R3, R4, R7
2135  53DE 06A0         BL      @CALSUB                 call subroutine
2135  53E0 430E  
2136  53E2 45E0         DATA    RDOFSC                  read a sector from offset in R3
2137  53E4 0429         BLWP    @>005A(R9)              restore R0, R1, R3, R4, R7
2137  53E6 005A  
2138  53E8 D901         DATA    >D901                   
2139  53EA 0583         INC     R3                      next sector
2140  53EC 0227         AI      R7,256                  256 bytes further in PAB buffer
2140  53EE 0100  
2141  53F0 10F1         JMP     H206                    keep going
2142            *                                       
2143  53F2 C104 H205    MOV     R4,R4                   
2144  53F4 1604         JNE     H207                    
2145  53F6 06A0         BL      @CALSUB                 call subroutine
2145  53F8 430E  
2146  53FA 45E0         DATA    RDOFSC                  read a sector from offset in R3
2147  53FC 1011         JMP     H208                    done
2148            *                                       
2149  53FE C147 H207    MOV     R7,R5                   save PAB data buffer ptr
2150  5400 C1E9         MOV     @>0056(R9),R7           FDR ptr
2150  5402 0056  
2151  5404 0227         AI      R7,256                  point to FDR data area
2151  5406 0100  
2152  5408 0429         BLWP    @>005A(R9)                      
2152  540A 005A  
2153  540C 0D00         DATA    >0D00                   save R4, R5, R7
2154  540E 06A0         BL      @CALSUB                 call subroutine
2154  5410 430E  
2155  5412 45E0         DATA    RDOFSC                  read a sector from offset in R3
2156  5414 0429         BLWP    @>005A(R9)              restore R4 in R0, R5 in R1, R7 in R2
2156  5416 005A  
2157  5418 E001         DATA    >E001                   
2158  541A 06A0         BL      @CALSUB                 call subroutine
2158  541C 430E  
2159  541E 4FF2         DATA    WFDRPB                  write bytes from FDR data buffer to PAB data buf
2160  5420 0460 H208    B       @UPDFDR                 update FDR, data buffer, VIB and return to caller
2160  5422 452C  
2161            *
2162            *------------------------------------
2163            * Opcode 6: Save
2164            * --------------
2165            * PAB 0: >06
2166            *     1: file type  <--- error code
2167            *   2-3: data buffer address in VDP mem
2168            *     4:
2169            *     5:
2170            *   6-7: # of bytes to save
2171            *     8:
2172            *------------------------------------                                   
2173            *
2174  5424 06A0 SAVE    BL      @CALSUB                 call subroutine
2174  5426 430E  
2175  5428 4446         DATA    CRFIL1                  create file
2176  542A 06A0         BL      @RBANB                  get PAB buffer ptr + # of bytes
2176  542C 5474  
2177  542E 04C3         CLR     R3                      sector offset 0
2178  5430 0429 H209    BLWP    @>005A(R9)                      
2178  5432 005A  
2179  5434 B100         DATA    >B100                   save R0, R2, R3, R7
2180  5436 06A0         BL      @CALSUB                 call subroutine
2180  5438 430E  
2181  543A 4600         DATA    WROFSC                  write sector to offset in R3
2182  543C 0429         BLWP    @>005A(R9)                      
2182  543E 005A  
2183  5440 B101         DATA    >B101                   retrieve R0, R2, R3, R7
2184  5442 0583         INC     R3                      next sector
2185  5444 0227         AI      R7,256                  256 bytes further in PAB data buffer
2185  5446 0100  
2186  5448 0602         DEC     R2                      next sector
2187  544A 16F2         JNE     H209                    more to do
2188            *                                       
2189  544C C069         MOV     @>0056(R9),R1           FDR ptr
2189  544E 0056  
2190  5450 0221         AI      R1,12                   point to file status byte
2190  5452 000C  
2191  5454 0202         LI      R2,>0100                value for program file
2191  5456 0100  
2192  5458 0429         BLWP    @>005A(R9)              set VDP to write
2192  545A 005A  
2193  545C 0023         DATA    >0023                   address in R1
2194  545E DBC2         MOVB    R2,@-2(R15)             write file status byte in FDR
2194  5460 FFFE  
2195  5462 0221         AI      R1,4                    point to eof offset byte in FDR
2195  5464 0004  
2196  5466 0429         BLWP    @>005A(R9)              set VDP to write
2196  5468 005A  
2197  546A 0023         DATA    >0023                   address in R1
2198  546C DBC0         MOVB    R0,@-2(R15)             # of bytes in last sector
2198  546E FFFE  
2199  5470 0460         B       @UPDFDR                 update FDR, data buffer, VIB then return to caller
2199  5472 452C  
2200            *                                       
2201  5474 C029 RBANB   MOV     @>0054(R9),R0           get buffer address + # of bytes
2201  5476 0054  
2202  5478 05C0         INCT    R0                      data buffer in PAB
2203  547A 0429         BLWP    @>005A(R9)              set VDP to read
2203  547C 005A  
2204  547E 0002         DATA    >0002                   address in R0
2205  5480 D1EF         MOVB    @-1026(R15),R7          get data buffer address
2205  5482 FBFE  
2206  5484 06C7         SWPB    R7                      
2207  5486 D1EF         MOVB    @-1026(R15),R7                  
2207  5488 FBFE  
2208  548A 06C7         SWPB    R7                      
2209  548C 0220         AI      R0,4                    point to # of bytes to transfer
2209  548E 0004  
2210  5490 0429         BLWP    @>005A(R9)              set VDP to read
2210  5492 005A  
2211  5494 0002         DATA    >0002                   address in R0
2212  5496 D0AF         MOVB    @-1026(R15),R2          get # of bytes to be transfered
2212  5498 FBFE  
2213  549A 0982         SRL     R2,8                    make it # of sectors (256 bytes each)
2214  549C 04C0         CLR     R0                      
2215  549E D02F         MOVB    @-1026(R15),R0          see if one more is needed
2215  54A0 FBFE  
2216  54A2 1301         JEQ     H210                    no
2217  54A4 0582         INC     R2                      yes: one more sector
2218  54A6 045B H210    B       *R11                    
2219            *
2220            *-------------------------------------
2221            * Opcode 9: Status
2222            * --------------
2223            * PAB 0: >09
2224            *     1:
2225            *   2-3:
2226            *     4:
2227            *     5:
2228            *   6-7: record #
2229            *     8:           <--- file status
2230            *
2231            * Status bits, returned in PAB byte 8:
2232            * >80: file not found
2233            * >40: file is protected
2234            * >20:
2235            * >10: internal (else display or program)
2236            * >08: program file
2237            * >04: variable (else fixed or program)
2238            * >02: memory full
2239            * >01: end-of-file reached
2240            *-------------------------------------                                  
2241            *
2242  54A8 06A0 STATUS  BL      @CALSUB                 call subroutine
2242  54AA 430E  
2243  54AC 4A5A         DATA    FFFDRV                  save filename in comp buf, then find FDR in VDP
2244  54AE C104         MOV     R4,R4                   found?
2245  54B0 1310         JEQ     H211                    yes
2246            *                                       
2247  54B2 06A0         BL      @CALSUB                 no: call subroutine
2247  54B4 430E  
2248  54B6 4AC2         DATA    FFDRDK                  find FDR on disk
2249  54B8 0200         LI      R0,>8000                value for file not found
2249  54BA 8000  
2250  54BC C104         MOV     R4,R4                   found?
2251  54BE 1649         JNE     H212                    no: return with that value
2252  54C0 C069         MOV     @>0056(R9),R1           yes: ptr to FDR
2252  54C2 0056  
2253  54C4 04C2         CLR     R2                      
2254  54C6 0429         BLWP    @>005A(R9)              set VDP to write
2254  54C8 005A  
2255  54CA 0023         DATA    >0023                   address in R1
2256  54CC DBC2         MOVB    R2,@-2(R15)             invalidate that FDR (file not open)
2256  54CE FFFE  
2257  54D0 1036         JMP     H213                    transfer FDR status to PAB status byte
2258            *                                       
2259  54D2 06A0 H211    BL      @CALSUB                 file is open: call subroutine
2259  54D4 430E  
2260  54D6 5194         DATA    AFPGPF                  adjust FDR ptr, get PAB file type into R4
2261  54D8 06A0         BL      @RFDRST                 get status byte from FDR
2261  54DA 51B0  
2262  54DC 1101         JLT     H214                    var
2263  54DE 1006         JMP     H215                    fix
2264            *                                       
2265  54E0 06A0 H214    BL      @CALSUB                 var: call subroutine
2265  54E2 430E  
2266  54E4 5016         DATA    RRSEC                   load wanted sector, point to wanted rec in buffer
2267  54E6 1013         JMP     H216                    out of range
2268  54E8 04C2         CLR     R2                      ok: clear flag
2269  54EA 1029         JMP     H213                    copy status byte from FDR into PAB, return
2270            *                                       
2271  54EC D16F H215    MOVB    @-1026(R15),R5          fix: get rec/sect byte
2271  54EE FBFE  
2272  54F0 0985         SRL     R5,8                    make it a word
2273  54F2 1602         JNE     H217                    
2274  54F4 0205         LI      R5,>0100                00 (program files) means 256
2274  54F6 0100  
2275  54F8 06A0 H217    BL      @PABR2B                 get 2 bytes from PAB into R0
2275  54FA 4820  
2276  54FC 0006         DATA    6                       # of wanted record
2277  54FE C0C0         MOV     R0,R3                   save it
2278  5500 111C         JLT     H218                    too big: set memory full bit in PAB status byte
2279  5502 06A0         BL      @RNFISE                 get # recs/file into R2, comp with R3
2279  5504 520E  
2280  5506 04C2         CLR     R2                      
2281  5508 1A1A         JL      H213                    in file: copy file type bits, return
2282  550A 3C85         DIV     R5,R2                   how many sectors do we need?
2283  550C C0C2         MOV     R2,R3                   save result
2284            *                                       
2285  550E 06A0 H216    BL      @FDR2B1                 get 2 bytes from FDR into R0
2285  5510 4826  
2286  5512 000E         DATA    14                      # of sectors/file
2287  5514 0583         INC     R3                      plus 1 sector for FDR
2288  5516 0202         LI      R2,>0100                value for eof reached in PAB status
2288  5518 0100  
2289  551A 60C0         S       R0,R3                   are there enough sectors in file for these recs?
2290  551C 1501         JGT     H219                    
2291  551E 100F         JMP     H213                    yes: we reached the eof
2292  5520 06A0 H219    BL      @CALSUB                 call subroutine
2292  5522 430E  
2293  5524 4988         DATA    RWVIB                   load VIB (sector 0)
2294  5526 C103         MOV     R3,R4                   number of sectors that will be needed
2295  5528 C205         MOV     R5,R8                   VIB ptr
2296  552A 0228         AI      R8,10                   skip 10 bytes (required by CFSVIB)
2296  552C 000A  
2297  552E 06A0         BL      @CFSVIB                 count free sectors in bitmap, into R3
2297  5530 571C  
2298  5532 0202         LI      R2,>0100                value for eof reached
2298  5534 0100  
2299  5536 8103         C       R3,R4                   are there that many free sectors?
2300  5538 1402         JHE     H213                    yes
2301  553A 0202 H218    LI      R2,>0200                value for memory full
2301  553C 0200  
2302            *                                       
2303  553E 06A0 H213    BL      @FDR2B1                 get 2 bytes from FDR into R0
2303  5540 4826  
2304  5542 000C         DATA    12                      file status byte
2305  5544 0240         ANDI    R0,>8F00                mask irrelevant bits
2305  5546 8F00  
2306  5548 1502         JGT     H220                    
2307  554A 0260         ORI     R0,>0080                var: put var bit in PAB status style
2307  554C 0080  
2308  554E 0A30 H220    SLA     R0,3                    get rid of var bit in FDR style
2309  5550 F002         SOCB    R2,R0                   add eof and mem full bits
2310            *                                       
2311  5552 C069 H212    MOV     @>0054(R9),R1           PAB ptr
2311  5554 0054  
2312  5556 0221         AI      R1,8                    point to bias/status return byte
2312  5558 0008  
2313  555A 0429         BLWP    @>005A(R9)              set VDP to write
2313  555C 005A  
2314  555E 0023         DATA    >0023                   address in R1
2315  5560 DBC0         MOVB    R0,@-2(R15)             write file status to PAB
2315  5562 FFFE  
2316  5564 0460         B       @RTURN1                 return to caller
2316  5566 432C  
2317            *
2318            *---------------------------------
2319            * Disk directory access
2320            * ---------------------
2321            * The directory is accessed by omiting the filename in the DSR name: "DSK1."
2322            * It must be opened for input only, as an Int/Fix 38 file.
2323            * It consists in upto 128 records, the first one contains the disk informations,
2324            * the others the informations for upto 127 files (in alphabetical order).
2325            * Each record consists in an ascii string and three floating point numbers.
2326            *
2327            * Record 0 contains:
2328            * - Diskname (an ascii string of upto 10 chars).
2329            * - The number zero.
2330            * - The number of sectors on disk.
2331            * - The number of free sectors on disk.
2332            *
2333            * Other records contain:
2334            * - Filename (an ascii string of upto 10 chars).
2335            * - Filetype: 1=D/F, 2=D/V, 3=I/F, 4=I/V, 5=Prog, 0=end of directory.
2336            *   If the file is protected, this number is negative (-1=D/F, etc).
2337            * - File size in sectors (including the FDR itself).
2338            * - File record length (0 for programs).
2339            *---------------------------------
2340             
2341            *---------------------------------
2342            * Open disk directory pseudo-file
2343            *---------------------------------                                      
2344            *
2345  5568 D02F OPNDIR  MOVB    @-1026(R15),R0          get file type from PAB
2345  556A FBFE  
2346  556C 0240         ANDI    R0,>1E00                mask irrelavant bits (rel/seq)
2346  556E 1E00  
2347  5570 0280         CI      R0,>0C00                is it int/fix in output mode?
2347  5572 0C00  
2348  5574 1303         JEQ     H221                    yes
2349  5576 06A0 H223    BL      @RETERR                 return with error
2349  5578 4954  
2350  557A 4000         DATA    >4000                   bad attributes
2351  557C 06A0 H221    BL      @PABR2B                 get 2 bytes from PAB into R0
2351  557E 4820  
2352  5580 0004         DATA    4                       rec length
2353  5582 0980         SRL     R0,8                    make it a word
2354  5584 1303         JEQ     H222                    >00= default: set it to 38
2355  5586 0280         CI      R0,>0026                is it 38?
2355  5588 0026  
2356  558A 16F5         JNE     H223                    no: return with bad attributes error
2357  558C 0200 H222    LI      R0,>2600                set rec len to 38
2357  558E 2600  
2358  5590 0429         BLWP    @>005A(R9)              set VDP to write
2358  5592 005A  
2359  5594 0103         DATA    >0103                   address in R8 (from PABR2B)
2360  5596 DBC0         MOVB    R0,@-2(R15)             write rec len to PAB
2360  5598 FFFE  
2361            *                                       
2362  559A 04C7         CLR     R7                      
2363  559C 06A0         BL      @FNDRV                  find matching drive in file control blocks
2363  559E 5756  
2364  55A0 55A8         DATA    H224                    go there if not found
2365  55A2 06A0 ERRR10  BL      @ERROR5                 update data then return with error
2365  55A4 4928  
2366  55A6 E000         DATA    >E000                   file error
2367  55A8 C1C7 H224    MOV     R7,R7                   did we find a free slot?
2368  55AA 1603         JNE     H225                    yes
2369  55AC 06A0         BL      @RETERR                 no: return with error
2369  55AE 4954  
2370  55B0 8000         DATA    >8000                   memory full
2371  55B2 0429 H225    BLWP    @>005A(R9)              set VDP to write
2371  55B4 005A  
2372  55B6 00E3         DATA    >00E3                   address in R7
2373  55B8 DBC3         MOVB    R3,@-2(R15)             write drive #
2373  55BA FFFE  
2374  55BC 06C3         SWPB    R3                      
2375  55BE DBC3         MOVB    R3,@-2(R15)             and a space as filename (illegal, indicates dir)
2375  55C0 FFFE  
2376  55C2 0460         B       @RTURN1                 return to caller
2376  55C4 432C  
2377            *
2378            *---------------------------------
2379            * Close disk directory
2380            *---------------------------------                                      
2381  55C6 06A0 CLSDIR  BL      @FNDRV                  find matching drive in file control blocks
2381  55C8 5756  
2382  55CA 55A2         DATA    ERRR10                  go there if not found: return with file error
2383  55CC 04C0         CLR     R0                      
2384  55CE 0429         BLWP    @>005A(R9)              set VDP to write
2384  55D0 005A  
2385  55D2 0103         DATA    >0103                   address in R8
2386  55D4 DBC0         MOVB    R0,@-2(R15)             clear drive #
2386  55D6 FFFE  
2387  55D8 0460         B       @RTURN1                 return to caller
2387  55DA 432C  
2388            *
2389            *---------------------------------
2390            * Read a record from disk directory
2391            *---------------------------------                                      
2392            *
2393  55DC 06A0 RDDIR   BL      @FNDRV                  find matching drive in file control blocks
2393  55DE 5756  
2394  55E0 55A2         DATA    ERRR10                  go ther it not found: return with file error
2395  55E2 0588         INC     R8                      
2396  55E4 C148         MOV     R8,R5                   save ptr to FDR
2397  55E6 06A0         BL      @PABR2B                 get 2 bytes from PAB into R0
2397  55E8 4820  
2398  55EA 0006         DATA    6                       record #
2399  55EC C080         MOV     R0,R2                   save it
2400  55EE 0582         INC     R2                      
2401  55F0 0429         BLWP    @>005A(R9)              set VDP to write
2401  55F2 005A  
2402  55F4 0103         DATA    >0103                   address in R8
2403  55F6 DBC2         MOVB    R2,@-2(R15)             write record number in FDR
2403  55F8 FFFE  
2404  55FA 06C2         SWPB    R2                      after first char of filename!
2405  55FC DBC2         MOVB    R2,@-2(R15)                     
2405  55FE FFFE  
2406  5600 0A10         SLA     R0,1                    since two byte per file ptr
2407  5602 D000         MOVB    R0,R0                   is rec # greater than 128?
2408  5604 1303         JEQ     H226                    no
2409  5606 06A0         BL      @ERROR5                 yes: update data then return with error
2409  5608 4928  
2410  560A A000         DATA    >A000                   past eof
2411  560C 0702 H226    SETO    R2                      code for read
2412  560E C100         MOV     R0,R4                   record #
2413  5610 133B         JEQ     H227                    0=disk parameters
2414  5612 0204         LI      R4,1                    sector #1
2414  5614 0001  
2415  5616 06A0         BL      @CALSUB                 call subroutine
2415  5618 430E  
2416  561A 4A04         DATA    RWSEC                   read sector into buffer in R5
2417  561C C205         MOV     R5,R8                   buffer ptr
2418  561E 0225         AI      R5,255                  point to data buffer area in this ctrl block
2418  5620 00FF  
2419  5622 0640         DECT    R0                      don't count record 0
2420  5624 A200         A       R0,R8                   point to desired file ptr
2421  5626 06A0         BL      @VDPR2B                 get two byte from VDP at R8 into R0
2421  5628 482C  
2422  562A C100         MOV     R0,R4                   sector where that FDR is to be found
2423  562C 1328         JEQ     H228                    no more
2424  562E 06A0         BL      @CALSUB                 call subroutine
2424  5630 430E  
2425  5632 4A04         DATA    RWSEC                   read FDR sector into data buffer area
2426  5634 06A0         BL      @FDR2B1                 get 2 bytes from FDR into R0
2426  5636 4826  
2427  5638 010E         DATA    270                     # of sect/file
2428  563A C180         MOV     R0,R6                   save it to output file size
2429  563C 0586         INC     R6                      include the FDR itself
2430  563E D0EF         MOVB    @-1026(R15),R3          ignore eof offset
2430  5640 FBFE  
2431  5642 0202         LI      R2,>0A00                10 chars per filename
2431  5644 0A00  
2432  5646 D0EF         MOVB    @-1026(R15),R3          get rec length
2432  5648 FBFE  
2433  564A 0983         SRL     R3,8                    make it a word
2434  564C 0648         DECT    R8                      point to status byte in FDR
2435  564E 0429         BLWP    @>005A(R9)              set VDP to read
2435  5650 005A  
2436  5652 0102         DATA    >0102                   address in R8
2437  5654 D02F         MOVB    @-1026(R15),R0          get file status byte
2437  5656 FBFE  
2438  5658 C1C0         MOV     R0,R7                   
2439  565A 0240         ANDI    R0,>0800                keep only write protected bit
2439  565C 0800  
2440  565E 51C0         SZCB    R0,R7                   clear write protected bit (if it was set)
2441  5660 0987         SRL     R7,8                    make it a word
2442  5662 0587         INC     R7                      types are numbered from 1
2443  5664 0287         CI      R7,>0002                is it a program file?
2443  5666 0002  
2444  5668 1602         JNE     H229                    no
2445  566A 0227         AI      R7,3                    yes: make it type 5
2445  566C 0003  
2446  566E 0287 H229    CI      R7,>0008                is it var?
2446  5670 0008  
2447  5672 1A02         JL      H230                    no
2448  5674 0227         AI      R7,-127                 yes: add 1 and clear var bit
2448  5676 FF81  
2449  5678 0A40 H230    SLA     R0,4                    write protect bit will be >80
2450  567A E1C0         SOC     R0,R7                   add it to file type
2451  567C 1004         JMP     H231                    
2452            *                                       
2453  567E 04C2 H228    CLR     R2                      no more files: filename size = 0
2454  5680 04C6         CLR     R6                      file size = 0
2455  5682 04C3         CLR     R3                      rec length = 0
2456  5684 04C7         CLR     R7                      type = 0
2457  5686 100F H231    JMP     H232                    output that
2458            *                                       
2459  5688 0225 H227    AI      R5,255                  disk info: point to data buffer area in ctrl block
2459  568A 00FF  
2460  568C 06A0         BL      @CALSUB                 call subroutine
2460  568E 430E  
2461  5690 4A04         DATA    RWSEC                   read sector 0
2462  5692 06A0         BL      @FDR2B1                 get 2 bytes from FDR into R0
2462  5694 4826  
2463  5696 010A         DATA    266                     # of sectors on disk
2464  5698 C180         MOV     R0,R6                   duplicate it
2465  569A 0646         DECT    R6                      minus directory itself (sect 0 + 1)
2466  569C 06A0         BL      @CFSVIB                 count free sectors in bitmap, result in R3
2466  569E 571C  
2467  56A0 04C7         CLR     R7                      filetype is not used
2468  56A2 0202         LI      R2,>0A00                diskname is 10 chars
2468  56A4 0A00  
2469            *                                       
2470  56A6 06A0 H232    BL      @PABR2B                 get 2 bytes from PAB into R0
2470  56A8 4820  
2471  56AA 0002         DATA    2                       APEDSK99: error in source listing (was R2)
2472  56AC C200         MOV     R0,R8                   duplicate it
2473  56AE 0588         INC     R8                      skip first byte
2474  56B0 0982         SRL     R2,8                    filename length (or diskname)
2475  56B2 1316         JEQ     H233                    0: skip filename copying
2476  56B4 04C1         CLR     R1                      
2477  56B6 0429 H234    BLWP    @>005A(R9)              set VDP to read
2477  56B8 005A  
2478  56BA 00A2         DATA    >00A2                   address in R5 (FDR ptr)
2479  56BC D06F         MOVB    @-1026(R15),R1          get 1 char from filename in FDR
2479  56BE FBFE  
2480  56C0 0281         CI      R1,>2000                is it a space?
2480  56C2 2000  
2481  56C4 1309         JEQ     H235                    yes: end of name
2482  56C6 0429         BLWP    @>005A(R9)              no: set VDP to write
2482  56C8 005A  
2483  56CA 0103         DATA    >0103                   address in R8 (PAB data buffer ptr)
2484  56CC DBC1         MOVB    R1,@-2(R15)             copy char in PAB data buffer
2484  56CE FFFE  
2485  56D0 0585         INC     R5                      increment source ptr
2486  56D2 0588         INC     R8                      increment destination ptr
2487  56D4 0602         DEC     R2                      next char
2488  56D6 16EF         JNE     H234                    
2489  56D8 0502 H235    NEG     R2                      number of trailing spaces
2490  56DA 0222         AI      R2,10                   number of chars in filename
2490  56DC 000A  
2491  56DE 06C2         SWPB    R2                      
2492  56E0 0429 H233    BLWP    @>005A(R9)              set VDP to write
2492  56E2 005A  
2493  56E4 0003         DATA    >0003                   address in R0 (beg of PAB data buffer)
2494  56E6 DBC2         MOVB    R2,@-2(R15)             write string length byte
2494  56E8 FFFE  
2495            *                                       
2496  56EA 0429         BLWP    @>005A(R9)              set VDP to write
2496  56EC 005A  
2497  56EE 0103         DATA    >0103                   address in R8
2498  56F0 C047         MOV     R7,R1                   file type + protection
2499  56F2 06A0         BL      @INT2FP                 make it a float number
2499  56F4 579A  
2500  56F6 C046         MOV     R6,R1                   file size in sectors, including FDR
2501  56F8 06A0         BL      @INT2FP                 make it a float number
2501  56FA 579A  
2502  56FC C043         MOV     R3,R1                   record length
2503  56FE 06A0         BL      @INT2FP                 make it a float number
2503  5700 579A  
2504  5702 C229         MOV     @>0054(R9),R8           get PAB ptr
2504  5704 0054  
2505  5706 0228         AI      R8,5                    point to character count
2505  5708 0005  
2506  570A 0200         LI      R0,>2600                always 38 bytes
2506  570C 2600  
2507  570E 0429         BLWP    @>005A(R9)              set VDP to write
2507  5710 005A  
2508  5712 0103         DATA    >0103                   address in R8
2509  5714 DBC0         MOVB    R0,@-2(R15)             write # of characters in record
2509  5716 FFFE  
2510  5718 0460         B       @RTURN1                 return to caller
2510  571A 432C  
2511            *                                       
2512  571C 0228 CFSVIB  AI      R8,46                   count free sectors in VIB bitmap
2512  571E 002E  
2513  5720 0202         LI      R2,200                  bitmap size
2513  5722 00C8  
2514  5724 04C3         CLR     R3                      free sectors counter
2515  5726 0429         BLWP    @>005A(R9)              set VDP to read
2515  5728 005A  
2516  572A 0102         DATA    >0102                   address in R8
2517  572C D06F H236    MOVB    @-1026(R15),R1          get a byte from bitmap
2517  572E FBFE  
2518  5730 0221         AI      R1,256                  
2518  5732 0100  
2519  5734 0981         SRL     R1,8                    
2520  5736 130C         JEQ     H237                    was >FF: no free sectors, next byte
2521  5738 0601         DEC     R1                      was it >00?
2522  573A 1603         JNE     H238                    no: count bits
2523  573C 0223         AI      R3,8                    yes: 8 more free sectors
2523  573E 0008  
2524  5740 1007         JMP     H237                    next byte
2525  5742 0200 H238    LI      R0,8                    8 bits per byte
2525  5744 0008  
2526  5746 0911 H239    SRL     R1,1                    test a bit
2527  5748 1801         JOC     H240                    was 1: sector is used
2528  574A 0583         INC     R3                      was 0: one more free sector
2529  574C 0600 H240    DEC     R0                      next bit in byte
2530  574E 16FB         JNE     H239                    more to come
2531  5750 0602 H237    DEC     R2                      next bitmap byte
2532  5752 16EC         JNE     H236                    more to come
2533  5754 045B         B       *R11                    
2534            *                                       
2535  5756 C2BB FNDRV   MOV     *R11+,R10               find drive in file control blocks
2536  5758 C14B         MOV     R11,R5                  save 2 returns
2537  575A C229         MOV     @>0056(R9),R8           top of mem word in VDP buffers header
2537  575C 0056  
2538  575E 0228         AI      R8,3                    point to max # of files
2538  5760 0003  
2539  5762 0429         BLWP    @>005A(R9)              set VDP to read
2539  5764 005A  
2540  5766 0102         DATA    >0102                   address in R8
2541  5768 D0AF         MOVB    @-1026(R15),R2          get # of files
2541  576A FBFE  
2542  576C 0882         SRA     R2,8                    make it a word
2543  576E 0228         AI      R8,6                    point to drive # in file ctrl block
2543  5770 0006  
2544  5772 0203         LI      R3,>0020                filename begin with space (illegal: flag for dir)
2544  5774 0020  
2545  5776 D0C6         MOVB    R6,R3                   APEDSK99: error in original disassembly (was R5)
2546  5778 06A0 H241    BL      @VDPR2B                 read 2 bytes from VDP at R8 into R0
2546  577A 482C  
2547  577C 8003         C       R3,R0                   match with that control block?
2548  577E 1309         JEQ     H242                    yes
2549  5780 0240         ANDI    R0,>00FF                keep only first char of filename
2549  5782 00FF  
2550  5784 1601         JNE     H243                    valid filename: a FDR is loaded here
2551  5786 C1C8         MOV     R8,R7                   this space is free: save ptr
2552  5788 0228 H243    AI      R8,518                  point to next file control block
2552  578A 0206  
2553  578C 0602         DEC     R2                      next file
2554  578E 16F4         JNE     H241                    more to come
2555  5790 045A         B       *R10                    not found: return to address passed in data word
2556  5792 0588 H242    INC     R8                      drive matches: point to FDR
2557  5794 CA48         MOV     R8,@>0056(R9)           save ptr
2557  5796 0056  
2558  5798 0455         B       *R5                     return to caller after data word
2559            *
2560            *--------------------------------------
2561            * Floating point format
2562            * ---------------------
2563            * Float numbers are 8 bytes long: EE 12 34 56 78 9A BC
2564            * EE is the exponent in radix 100 (not in radix 10 as usual!). It is biased
2565            * by 64: >40=0, 41=1 (i.e *100), >42=2 (i.e * 10,000) >3F= -1 (i.e /100), etc
2566            *
2567            * 12 ... BC are the mantissa in binary coded decimal: each byte encodes two
2568            * decimal digits from 00 to 99
2569            *
2570            * For negative numbers, the first word is negated
2571            * For zero, the first word is >0000 the others are irrelevant
2572            *
2573            * Examples: 40 08 00 00 00 00 00 00 is 8.0
2574            *           41 02 37 00 00 00 00 00 is 255.0 (>37 hex = 55 decimal)
2575            *           BF F8 00 00 00 00 00 00 is -8.0
2576            *           43 01 02 03 04 05 06 07 is 1020304.050607
2577            *--------------------------------------                                 
2578            *
2579  579A 0202 INT2FP  LI      R2,>0800                write an integer in floating point format
2579  579C 0800  
2580  579E DBC2         MOVB    R2,@-2(R15)             size=8
2580  57A0 FFFE  
2581  57A2 C141         MOV     R1,R5                   integer is in R1: save it for sign processing
2582  57A4 0241         ANDI    R1,>7FFF                clear sign bit
2582  57A6 7FFF  
2583  57A8 0281         CI      R1,100                  is it less than 100?
2583  57AA 0064  
2584  57AC 1A07         JL      H244                    yes
2585  57AE 04C0         CLR     R0                      100 or over
2586  57B0 0204         LI      R4,100                  
2586  57B2 0064  
2587  57B4 3C04         DIV     R4,R0                   divide by 100
2588  57B6 0260         ORI     R0,>4100                add exponent 2 to hundreths
2588  57B8 4100  
2589  57BA 1005         JMP     H245                    
2590            *                                       
2591  57BC C001 H244    MOV     R1,R0                   is it 0?
2592  57BE 1302         JEQ     H246                    yes: exponent is 0
2593  57C0 0260         ORI     R0,>4000                no: add exponent 1
2593  57C2 4000  
2594  57C4 04C1 H246    CLR     R1                      next digits will be 0
2595            *                                       
2596  57C6 C145 H245    MOV     R5,R5                   test sign bit
2597  57C8 1101         JLT     H247                    negative
2598  57CA 1001         JMP     H248                    positive or zero
2599  57CC 0500 H247    NEG     R0                      negate first word
2600  57CE DBC0 H248    MOVB    R0,@-2(R15)             write exponent to VDP at preset address
2600  57D0 FFFE  
2601  57D2 06C0         SWPB    R0                      
2602  57D4 DBC0         MOVB    R0,@-2(R15)             write first first 2 digits (or hundreths)
2602  57D6 FFFE  
2603  57D8 06C1         SWPB    R1                      
2604  57DA DBC1         MOVB    R1,@-2(R15)             write last 2 digits (if any)
2604  57DC FFFE  
2605  57DE 0202         LI      R2,5                    the remaining bytes are all 0 with integers
2605  57E0 0005  
2606  57E2 DBC2 H249    MOVB    R2,@-2(R15)             write 0 to VDP
2606  57E4 FFFE  
2607  57E6 0602         DEC     R2                      next byte
2608  57E8 16FC         JNE     H249                    more to do
2609  57EA 045B         B       *R11                    
2610            *
2611            *---------------------------------------
2612            * Subprogram >10: sector R/W
2613            * --------------
2614            * >834A: (n/a)      <--- sector #
2615            * >834C: drive #
2616            * >834D: R/W code (write if >00)
2617            * >834E: VDP buffer
2618            * >8350: sector #   <--- error code
2619            *---------------------------------------                                        
2620            *
2621  57EC C1CB ESUB01  MOV     R11,R7                  
2622  57EE 06A0         BL      @PRPFDO                 prepare disk operations
2622  57F0 43DA  
2623  57F2 CA69         MOV     @>0050(R9),@>004A(R9)   copy sector #
2623  57F4 0050  
2623  57F6 004A  
2624  57F8 0460         B       @SECRW1                 
2624  57FA 4164  
2625            *
2626            *---------------------------------------
2627            * Subprogram >11: format disk
2628            * --------------                                        
2629            *
2630  57FC C1CB ESUB02  MOV     R11,R7                  
2631  57FE 06A0         BL      @PRPFDO                 prepare disk operations
2631  5800 43DA  
2632  5802 0460         B       @FMTDSK                 
2632  5804 41E2  
2633            *
2634            *---------------------------------------
2635            * Subprogram >12: file (un)protect
2636            * --------------
2637            * >834C: drive #
2638            * >834D: protect code (>00 unprotect)
2639            * >834E: ptr to filename
2640            * >8350: (n/a)      <--- error code
2641            *---------------------------------------                                
2642            *
2643  5806 C1CB ESUB03  MOV     R11,R7                  
2644  5808 06A0         BL      @PRPFDO                 prepare disk operations
2644  580A 43DA  
2645  580C D029         MOVB    @>004D(R9),R0           get protection code
2645  580E 004D  
2646  5810 0240         ANDI    R0,>0800                keep the bit that will be needed
2646  5812 0800  
2647  5814 0429         BLWP    @>005A(R9)              save R0 on stack
2647  5816 005A  
2648  5818 8000         DATA    >8000                   
2649  581A C029         MOV     @>004E(R9),R0           get pointer to filename
2649  581C 004E  
2650  581E 06A0         BL      @CALSUB                 call subroutine
2650  5820 430E  
2651  5822 5908         DATA    RFDRVB                  load FDR in VDP buffer
2652  5824 0429         BLWP    @>005A(R9)              retrieve old R0, in R2
2652  5826 005A  
2653  5828 2001         DATA    >2001                   
2654  582A 06A0         BL      @FDR2B1                 read two bytes in R0 from top of FDR + offset
2654  582C 4826  
2655  582E 000C         DATA    12                      file status byte
2656  5830 0240         ANDI    R0,>F700                clear protection flag
2656  5832 F700  
2657  5834 F002         SOCB    R2,R0                   set it if needed
2658  5836 0429         BLWP    @>005A(R9)              set VDP for write
2658  5838 005A  
2659  583A 0103         DATA    >0103                   address in R8
2660  583C DBC0         MOVB    R0,@-2(R15)             write back file status to FDR
2660  583E FFFE  
2661            *                                       
2662  5840 C229 UWFLVB  MOV     @>0056(R9),R8           FDR address in VDP mem
2662  5842 0056  
2663  5844 0429         BLWP    @>005A(R9)              set VDP for read
2663  5846 005A  
2664  5848 0102         DATA    >0102                   address in R8
2665  584A D02F         MOVB    @-1026(R15),R0          get drive # in ctrl block
2665  584C FBFE  
2666  584E 0260         ORI     R0,>8000                flag it
2666  5850 8000  
2667  5852 0429         BLWP    @>005A(R9)              set VDP for write
2667  5854 005A  
2668  5856 0103         DATA    >0103                   address in R8
2669  5858 DBC0         MOVB    R0,@-2(R15)             write it back
2669  585A FFFE  
2670  585C 0460         B       @UPDFDR                 update FDR, load VIB
2670  585E 452C  
2671            *
2672            *---------------------------------
2673            * Subprogram >13: file rename
2674            * --------------
2675            * >834C: drive #
2676            * >834E: ptr to new name
2677            * >8350: ptr to old name <--- error code
2678            *---------------------------------                                      
2679            *
2680  5860 C1CB ESUB04  MOV     R11,R7                  
2681  5862 06A0         BL      @PRPFDO                 prepare disk operations
2681  5864 43DA  
2682  5866 C029         MOV     @>004E(R9),R0           get ptr to new filename
2682  5868 004E  
2683  586A 0429         BLWP    @>005A(R9)              save R0 on stack
2683  586C 005A  
2684  586E 8000         DATA    >8000                   
2685  5870 C029         MOV     @>0050(R9),R0           get ptr to old filename
2685  5872 0050  
2686  5874 06A0         BL      @CALSUB                 call subroutine
2686  5876 430E  
2687  5878 5908         DATA    RFDRVB                  put FDR in VDP buffer
2688  587A 06A0         BL      @RMFPTR                 remove FDR ptr from sector 1
2688  587C 4790  
2689  587E 06A0         BL      @FDR2B1                 get 2 bytes from FDR
2689  5880 4826  
2690  5882 000C         DATA    12                      file status byte
2691  5884 0240         ANDI    R0,>0800                protected?
2691  5886 0800  
2692  5888 1303         JEQ     H250                    no
2693  588A 06A0         BL      @ERROR5                 yes: return with error
2693  588C 4928  
2694  588E 2000         DATA    >2000                   write protected
2695  5890 06A0 H250    BL      @FDR2B1                 get 2 bytes from FDR
2695  5892 4826  
2696  5894 FFFC         DATA    -4                      sector # of FDR
2697  5896 C040         MOV     R0,R1                   
2698  5898 0429         BLWP    @>005A(R9)              retrieve R0 from stack
2698  589A 005A  
2699  589C 8001         DATA    >8001                   ptr to new filename
2700  589E 0429         BLWP    @>005A(R9)              save R1 on stack
2700  58A0 005A  
2701  58A2 4000         DATA    >4000                   sector # of FDR
2702  58A4 06A0         BL      @UFNCB                  write drive # and filename in compare buffer
2702  58A6 5B2A  
2703  58A8 06A0         BL      @CALSUB                 call subroutine
2703  58AA 430E  
2704  58AC 4AEE         DATA    FFDRFN                  find FDR from filename
2705  58AE C104         MOV     R4,R4                   found?
2706  58B0 1338         JEQ     H251                    yes: return with file error (name already exist)
2707  58B2 06A0         BL      @INSFDR                 insert a FDR in sector 1
2707  58B4 47C0  
2708  58B6 0429         BLWP    @>005A(R9)              retrieve sect # of FDR in R4
2708  58B8 005A  
2709  58BA 0801         DATA    >0801                   
2710  58BC 0429         BLWP    @>005A(R9)              set VDP to write
2710  58BE 005A  
2711  58C0 0103         DATA    >0103                   address in R8
2712  58C2 DBC4         MOVB    R4,@-2(R15)             write sector # of FDR
2712  58C4 FFFE  
2713  58C6 06C4         SWPB    R4                      
2714  58C8 DBC4         MOVB    R4,@-2(R15)                     
2714  58CA FFFE  
2715  58CC 06C4         SWPB    R4                      sector #
2716  58CE 0702         SETO    R2                      code for read
2717  58D0 04C5         CLR     R5                      buffer offset: VDP at >8356
2718  58D2 06A0         BL      @CALSUB                 call subroutine
2718  58D4 430E  
2719  58D6 4A00         DATA    RDFDR1                  read FDR
2720  58D8 C045         MOV     R5,R1                   
2721  58DA C029         MOV     @>0058(R9),R0                   
2721  58DC 0058  
2722  58DE 0220         AI      R0,257                  
2722  58E0 0101  
2723  58E2 0601         DEC     R1                      
2724  58E4 06A0         BL      @CFNFDR                 copy filename in compare buffer to FDR
2724  58E6 5B40  
2725  58E8 04C2         CLR     R2                      code for write
2726  58EA 06A0         BL      @CALSUB                 call subroutine
2726  58EC 430E  
2727  58EE 4A04         DATA    RWSEC                   write FDR (with new name in it)
2728  58F0 06A0         BL      @CALSUB                 call subroutine
2728  58F2 430E  
2729  58F4 49EC         DATA    WRSEC1                  write sector 1 (with new FDR ptr in it)
2730  58F6 C069         MOV     @>0056(R9),R1           FDR ptr
2730  58F8 0056  
2731  58FA 0429         BLWP    @>005A(R9)              prepare VDP to write
2731  58FC 005A  
2732  58FE 0023         DATA    >0023                   address in R1
2733  5900 DBC4         MOVB    R4,@-2(R15)             clear first char of FDR in buffer
2733  5902 FFFE  
2734  5904 0460         B       @RTURN1                 return to caller
2734  5906 432C  
2735            *                               
2736  5908 04C6 RFDRVB  CLR     R6                      put FDR in VDP buffer
2737  590A D1A9         MOVB    @>004C(R9),R6           get drive #
2737  590C 004C  
2738  590E 06A0         BL      @UFNCB                  update filename compare buffer
2738  5910 5B2A  
2739  5912 06A0         BL      @CALSUB                 call subroutine
2739  5914 430E  
2740  5916 4A7A         DATA    FFDRVB                  look if FDR already in VDP buffer
2741  5918 06A0         BL      @CALSUB                 call subroutine
2741  591A 430E  
2742  591C 4ABE         DATA    FFDROD                  file FDR on disk
2743  591E C104         MOV     R4,R4                   found?
2744  5920 1303         JEQ     H252                    yes
2745  5922 06A0 H251    BL      @RETERR                 no: return with error code in >8350
2745  5924 4954  
2746  5926 E000         DATA    >E000                   file error
2747  5928 0460 H252    B       @RTURN1                 return to caller
2747  592A 432C  
2748            *
2749            *-------------------------------------
2750            * Subprogram >14: file raw read
2751            * --------------
2752            * >834C: drive #                          <--- >00
2753            * >834D: # of sectors (>00=get file info) <--- sectors read
2754            * >834E: ptr to filename
2755            * >8350: file info buffer (>83xx)         <--- error code
2756            *                              |
2757            * >83xx  : VDP buffer       <--'
2758            * >83xx+2: first sector # (total # of sect when get file info)
2759            * >83xx+4: status flag
2760            * >83xx+5: recs/sector
2761            * >83xx+6: eof offset
2762            * >83xx+7: rec size
2763            * >83xx+8: # of recs
2764            *-------------------------------------                                  
2765            *
2766  592C C1CB ESUB05  MOV     R11,R7                  
2767  592E 06A0         BL      @PRPFDO                 prepare disk operations
2767  5930 43DA  
2768  5932 06A0         BL      @RFNPTR                 load filename and ptrs
2768  5934 5B62  
2769  5936 06A0         BL      @FFFDR                  find file FDR, load some info
2769  5938 5B88  
2770  593A C082         MOV     R2,R2                   # of sectors to read
2771  593C 131E         JEQ     H253                    >00: get file info
2772  593E 6003         S       R3,R0                   sectors in file - first sector to read
2773  5940 1502         JGT     H254                    in file
2774  5942 04C2         CLR     R2                      past eof
2775  5944 1017         JMP     H255                    
2776  5946 8002 H254    C       R2,R0                   sectors past first one vs sectors to load
2777  5948 1A01         JL      H256                    
2778  594A C080         MOV     R0,R2                   load what's left
2779  594C 0429 H256    BLWP    @>005A(R9)                      
2779  594E 005A  
2780  5950 2000         DATA    >2000                   save R2
2781  5952 0429 H257    BLWP    @>005A(R9)                      
2781  5954 005A  
2782  5956 3100         DATA    >3100                   save R2, R3, R7
2783  5958 06A0         BL      @CALSUB                 call subroutine
2783  595A 430E  
2784  595C 45E0         DATA    RDOFSC                  read sector from offset in file
2785  595E 0429         BLWP    @>005A(R9)                      
2785  5960 005A  
2786  5962 3101         DATA    >3101                   retrieve R2, R3, R7
2787  5964 0583         INC     R3                      next sector
2788  5966 0227         AI      R7,256                  increment VDP buffer ptr by 256 bytes
2788  5968 0100  
2789  596A 0602         DEC     R2                      more to do?
2790  596C 16F2         JNE     H257                    yes
2791  596E 0429 H258    BLWP    @>005A(R9)                      
2791  5970 005A  
2792  5972 2001         DATA    >2001                   retrieve R2 (# of sectors read)
2793  5974 CA42 H255    MOV     R2,@>004C(R9)           update # of sectors in parameters
2793  5976 004C  
2794  5978 100A         JMP     H259                    
2795            *                                       
2796  597A CD00 H253    MOV     R0,*R4+                 get file info: sectors in file
2797  597C 0648         DECT    R8                      
2798  597E 05C2         INCT    R2                      copy 2 bytes (status + recs/sector)
2799  5980 06A0         BL      @VDP2SP                 from VDP at R8 to file info structure
2799  5982 5BBC  
2800  5984 0202         LI      R2,4                    copy 4 bytes
2800  5986 0004  
2801  5988 A202         A       R2,R8                   
2802  598A 06A0         BL      @VDP2SP                 eof offset, rec len, # of recs (or # of sect)
2802  598C 5BBC  
2803  598E 06A0 H259    BL      @CALSUB                 call subroutine
2803  5990 430E  
2804  5992 452C         DATA    UPDFDR                  updata FDR (+ data) if needed, read VIB
2805  5994 04E9         CLR     @>0050(R9)              clear error flag
2805  5996 0050  
2806  5998 0460         B       @RTURN1                 return to caller
2806  599A 432C  
2807            *
2808            *--------------------------------------
2809            * Subprogram >15: file raw write
2810            * --------------
2811            * >834C: drive #                                  <--- >00
2812            * >834D: # of sectors (>00=create file from info) <--- # of sectors written
2813            * >834E: ptr to filename
2814            * >8350: file info buffer (>83xx)                 <--- error code
2815            *                              |
2816            * >83xx  : VDP buffer       <--'
2817            * >83xx+2: first sector # (total # of sectors when creating file)
2818            * >83xx+4: status flag
2819            * >83xx+5: recs/sector
2820            * >83xx+6: eof offset
2821            * >83xx+7: rec size
2822            * >83xx+8: # of recs
2823            *--------------------------------------                                 
2824            *
2825  599C C1CB ESUB06  MOV     R11,R7                  
2826  599E 06A0         BL      @PRPFDO                 prepare disk operations
2826  59A0 43DA  
2827  59A2 06A0         BL      @RFNPTR                 load drive + filename, + a few info
2827  59A4 5B62  
2828  59A6 1314         JEQ     H260                    sectors to write=0: create file
2829  59A8 06A0         BL      @FFFDR                  find file FDR
2829  59AA 5B88  
2830  59AC 0429         BLWP    @>005A(R9)                      
2830  59AE 005A  
2831  59B0 2000         DATA    >2000                   save R2 (# of sectors to write)
2832  59B2 0429 H261    BLWP    @>005A(R9)                      
2832  59B4 005A  
2833  59B6 3100         DATA    >3100                   save R2, R3, R7
2834  59B8 06A0         BL      @CALSUB                 call subroutine
2834  59BA 430E  
2835  59BC 4600         DATA    WROFSC                  write sector from offset in file
2836  59BE 0429         BLWP    @>005A(R9)                      
2836  59C0 005A  
2837  59C2 3101         DATA    >3101                   retrieve R2, R3, R7
2838  59C4 0583         INC     R3                      next sector
2839  59C6 0227         AI      R7,256                  increment VDP ptr by 256 bytes
2839  59C8 0100  
2840  59CA 0602         DEC     R2                      more to do?
2841  59CC 16F2         JNE     H261                    yes
2842  59CE 10CF         JMP     H258                    update # of sectors written, in param. Then return
2843            *                               
2844  59D0 06A0 H260    BL      @CALSUB                 create file
2844  59D2 430E  
2845  59D4 4A7A         DATA    FFDRVB                  find file FDR in VDP buffers
2846  59D6 06A0         BL      @CALSUB                 call subroutine
2846  59D8 430E  
2847  59DA 4ABE         DATA    FFDROD                  find file FDR on disk
2848  59DC 06A0         BL      @CALSUB                 call subroutine
2848  59DE 430E  
2849  59E0 444C         DATA    CRFIL2                  create file
2850  59E2 0429         BLWP    @>005A(R9)                      
2850  59E4 005A  
2851  59E6 0801         DATA    >0801                   retrieve R4 (file info ptr)
2852  59E8 C229         MOV     @>0056(R9),R8           FDR ptr
2852  59EA 0056  
2853  59EC 05C4         INCT    R4                      skip 2 bytes
2854  59EE C0F4         MOV     *R4+,R3                 # of sector to create
2855  59F0 0228         AI      R8,10                   skip filename
2855  59F2 000A  
2856  59F4 06A0         BL      @SP2VDP                 write 2 bytes in VDP at R8+2
2856  59F6 5BCC  
2857  59F8 0002         DATA    2                       i.e. status + recs/sector
2858  59FA 06A0         BL      @SP2VDP                 write 4 bytes in VDP at new R8+4
2858  59FC 5BCC  
2859  59FE 0004         DATA    4                       i.e. eof offset, rec len, # of recs (or # of
2860  5A00 0603         DEC     R3                      offset = # of sectors-1 (starts from 0)
2861  5A02 1103         JLT     H262                    create an empty file, FDR only
2862  5A04 06A0         BL      @CALSUB                 
2862  5A06 430E  
2863  5A08 4616         DATA    APSCTS                  append enough sectors to reach offset
2864  5A0A 0460 H262    B       @UWFLVB                 modify FDR, write it, load VIB, return
2864  5A0C 5840  
2865            *
2866            *---------------------------------------
2867            * Subprogram FILES: number of files
2868            *---------------------------------------                                        
2869  5A0E C1CB ESUB08  MOV     R11,R7                  
2870  5A10 06A0         BL      @PRPFDO                 prepare disk operation
2870  5A12 43DA  
2871  5A14 C229         MOV     @>002C(R9),R8           ptr to next basic token
2871  5A16 002C  
2872  5A18 0228         AI      R8,7                    skip FILES
2872  5A1A 0007  
2873  5A1C 06A0         BL      @VDPR2B                 get next two bytes in R0
2873  5A1E 482C  
2874  5A20 0280         CI      R0,>C801                >C8=unquoted string, size=1 char
2874  5A22 C801  
2875  5A24 161C         JNE     H263                    return (with error) if different
2876  5A26 05C8         INCT    R8                      increment pointer
2877  5A28 06A0         BL      @VDPR2B                 get next two bytes
2877  5A2A 482C  
2878  5A2C 06C0         SWPB    R0                      
2879  5A2E 0220         AI      R0,>49D0                substact >B630: # of files >B6=closed parenthesis
2879  5A30 49D0  
2880  5A32 0280         CI      R0,>0009                only 9 files allowed in Basic !
2880  5A34 0009  
2881  5A36 1B13         JH      H263                    return with error if more
2882  5A38 06C0         SWPB    R0                      
2883  5A3A DA40         MOVB    R0,@>004C(R9)           put new # of files in scratch-pad memory
2883  5A3C 004C  
2884  5A3E 06A0         BL      @CALSUB                 call subroutine
2884  5A40 430E  
2885  5A42 5A68         DATA    PESB07                  subprogram >16 (private entry point)
2886  5A44 DA69         MOVB    @>0050(R9),@>0050(R9)   test result
2886  5A46 0050  
2886  5A48 0050  
2887  5A4A 1609         JNE     H263                    error
2888  5A4C C229         MOV     @>002C(R9),R8           ok: get ptr to Basic token
2888  5A4E 002C  
2889  5A50 0228         AI      R8,12                   skip the whole statement
2889  5A52 000C  
2890  5A54 CA48         MOV     R8,@>002C(R9)           update ptr
2890  5A56 002C  
2891  5A58 5A69         SZCB    @>0042(R9),@>0042(R9)   clear current token
2891  5A5A 0042  
2891  5A5C 0042  
2892  5A5E 0460 H263    B       @RTURN1                 return to caller (i.e. Basic)
2892  5A60 432C  
2893            *
2894            *---------------------------------------
2895            * Subprogram >16: number of files
2896            * --------------
2897            * >834C: # of files
2898            * >8350: (n/a)      <--- error code
2899            *---------------------------------------                                        
2900            *
2901  5A62 C1CB ESUB07  MOV     R11,R7                  entry point from assembly
2902  5A64 06A0         BL      @PRPFDO                 prepare disk operations
2902  5A66 43DA  
2903  5A68 04C0 PESB07  CLR     R0                      entry point from call files
2904  5A6A D029         MOVB    @>004C(R9),R0           get # of files
2904  5A6C 004C  
2905  5A6E 1359         JEQ     H264                    return with error
2906  5A70 C229         MOV     @>0056(R9),R8           ptr to end of buffer word
2906  5A72 0056  
2907  5A74 0228         AI      R8,3                    point to # of files byte
2907  5A76 0003  
2908  5A78 04C3         CLR     R3                      
2909  5A7A 0429         BLWP    @>005A(R9)              set VDP to read
2909  5A7C 005A  
2910  5A7E 0102         DATA    >0102                   address in R8
2911  5A80 D0EF         MOVB    @-1026(R15),R3          get current # of files
2911  5A82 FBFE  
2912  5A84 0205         LI      R5,518                  size of 1 file control block
2912  5A86 0206  
2913  5A88 90C0         CB      R0,R3                   compare required with current
2914  5A8A 1348         JEQ     H265                    same: return with no error
2915  5A8C 122B         JLE     H266                    less
2916  5A8E C180         MOV     R0,R6                   more files needed
2917  5A90 0280         CI      R0,>1000                maximum is 16
2917  5A92 1000  
2918  5A94 1B46         JH      H264                    return with error
2919  5A96 6003         S       R3,R0                   how many to add
2920  5A98 0980         SRL     R0,8                    make it a word
2921  5A9A 3805         MPY     R5,R0                   # of bytes to add
2922  5A9C C101         MOV     R1,R4                   result in R0:R1
2923  5A9E 0504         NEG     R4                      
2924  5AA0 C0A9         MOV     @>0070(R9),R2           highest free address in VDP mem
2924  5AA2 0070  
2925  5AA4 C002         MOV     R2,R0                   
2926  5AA6 6001         S       R1,R0                   what it would become
2927  5AA8 0280         CI      R0,>0800                is there room enough for VDP?
2927  5AAA 0800  
2928  5AAC 113A         JLT     H264                    no: return with error
2929  5AAE C040         MOV     R0,R1                   ok: new base
2930  5AB0 0582 H267    INC     R2                      increment source ptr
2931  5AB2 0580         INC     R0                      increment destination ptr
2932  5AB4 0429         BLWP    @>005A(R9)              set VDP to read
2932  5AB6 005A  
2933  5AB8 0042         DATA    >0042                   address in R2
2934  5ABA D0EF         MOVB    @-1026(R15),R3          get a byte
2934  5ABC FBFE  
2935  5ABE 0429         BLWP    @>005A(R9)              set VDP to write
2935  5AC0 005A  
2936  5AC2 0003         DATA    >0003                   address in R0
2937  5AC4 DBC3         MOVB    R3,@-2(R15)             copy a byte
2937  5AC6 FFFE  
2938  5AC8 8202         C       R2,R8                   did we copy the whole header?
2939  5ACA 16F2         JNE     H267                    not yet
2940  5ACC 0429         BLWP    @>005A(R9)              set VDP to write
2940  5ACE 005A  
2941  5AD0 0003         DATA    >0003                   address in R0
2942  5AD2 DBC6         MOVB    R6,@-2(R15)             new # of files
2942  5AD4 FFFE  
2943  5AD6 04C6         CLR     R6                      
2944  5AD8 6080         S       R0,R2                   
2945  5ADA DBC6 H268    MOVB    R6,@-2(R15)             clear byte
2945  5ADC FFFE  
2946  5ADE 0602         DEC     R2                      
2947  5AE0 16FC         JNE     H268                    
2948  5AE2 101A         JMP     H269                    
2949            *                                       
2950  5AE4 0429 H266    BLWP    @>005A(R9)              less files needed
2950  5AE6 005A  
2951  5AE8 0103         DATA    >0103                   set VDP to write to address in R8
2952  5AEA DBC0         MOVB    R0,@-2(R15)             new # of files in buffer header
2952  5AEC FFFE  
2953  5AEE 60C0         S       R0,R3                   how many to remove
2954  5AF0 0983         SRL     R3,8                    make it a word
2955  5AF2 38C5         MPY     R5,R3                   # of bytes to remove
2956  5AF4 C044         MOV     R4,R1                   result in R3:R4
2957  5AF6 A048         A       R8,R1                   new address for buffer header
2958  5AF8 C0A9         MOV     @>0070(R9),R2           highest free address in VDP mem
2958  5AFA 0070  
2959  5AFC 0429 H270    BLWP    @>005A(R9)              set VDP to read
2959  5AFE 005A  
2960  5B00 0102         DATA    >0102                   address in R8
2961  5B02 D02F         MOVB    @-1026(R15),R0          read a byte
2961  5B04 FBFE  
2962  5B06 0429         BLWP    @>005A(R9)              set VDP to write
2962  5B08 005A  
2963  5B0A 0023         DATA    >0023                   address in R1
2964  5B0C DBC0         MOVB    R0,@-2(R15)             write byte back
2964  5B0E FFFE  
2965  5B10 0601         DEC     R1                      decrement destination ptr
2966  5B12 0608         DEC     R8                      decrement source ptr
2967  5B14 8088         C       R8,R2                   did we copy the whole header?
2968  5B16 16F2         JNE     H270                    not yet
2969            *                                       
2970  5B18 CA41 H269    MOV     R1,@>0070(R9)           new first free address                                  
2970  5B1A 0070  
2971  5B1C 04E9 H265    CLR     @>0050(R9)              clear error flag
2971  5B1E 0050  
2972  5B20 1002         JMP     H272                    
2973  5B22 0729 H264    SETO    @>0050(R9)              set error flag
2973  5B24 0050  
2974  5B26 0460 H272    B       @RTURN1                 return to caller
2974  5B28 432C  
2975            *                                       
2976  5B2A 04E9 UFNCB   CLR     @>0054(R9)              write drive # and filename in compare buffer
2976  5B2C 0054  
2977  5B2E C069         MOV     @>0058(R9),R1           
2977  5B30 0058  
2978  5B32 0221         AI      R1,256                  ptr to filename compare buffer
2978  5B34 0100  
2979  5B36 0429         BLWP    @>005A(R9)              set VDP to write
2979  5B38 005A  
2980  5B3A 0023         DATA    >0023                   address in R1
2981  5B3C DBC6         MOVB    R6,@-2(R15)             write drive #
2981  5B3E FFFE  
2982  5B40 0202 CFNFDR  LI      R2,10                   filename must be exactly 10 chars
2982  5B42 000A  
2983  5B44 0581 H273    INC     R1                      next char in compare buffer
2984  5B46 0429         BLWP    @>005A(R9)              set VDP to read
2984  5B48 005A  
2985  5B4A 0002         DATA    >0002                   address in R0
2986  5B4C D0EF         MOVB    @-1026(R15),R3          get 1 char from filename
2986  5B4E FBFE  
2987  5B50 0580         INC     R0                      next char in provided filename
2988  5B52 0429         BLWP    @>005A(R9)              set VDP to write
2988  5B54 005A  
2989  5B56 0023         DATA    >0023                   address in R1
2990  5B58 DBC3         MOVB    R3,@-2(R15)             write 1 char to compare buffer
2990  5B5A FFFE  
2991  5B5C 0602         DEC     R2                      
2992  5B5E 16F2         JNE     H273                    next char
2993  5B60 045B         B       *R11                    
2994            *                                       
2995  5B62 C28B RFNPTR  MOV     R11,R10                 load compare buffer and ptrs
2996  5B64 04C6         CLR     R6                      
2997  5B66 D1A9         MOVB    @>004C(R9),R6           drive #
2997  5B68 004C  
2998  5B6A C029         MOV     @>004E(R9),R0           ptr to filename
2998  5B6C 004E  
2999  5B6E 06A0         BL      @UFNCB                  write them in compare buffer
2999  5B70 5B2A  
3000  5B72 D129         MOVB    @>0050(R9),R4           file info structure ptr
3000  5B74 0050  
3001  5B76 0984         SRL     R4,8                    
3002  5B78 A109         A       R9,R4                   make it a PAB address
3003  5B7A D029         MOVB    @>004D(R9),R0           # of sectors (>00=get file info)
3003  5B7C 004D  
3004  5B7E 0429         BLWP    @>005A(R9)                      
3004  5B80 005A  
3005  5B82 0800         DATA    >0800                   save R4
3006  5B84 0980         SRL     R0,8                    
3007  5B86 045A         B       *R10                    EQ set for get file info
3008            *                                       
3009  5B88 0429 FFFDR   BLWP    @>005A(R9)              find file FDR
3009  5B8A 005A  
3010  5B8C 8010         DATA    >8010                   save R0 + R11
3011  5B8E 06A0         BL      @CALSUB                 call subroutine
3011  5B90 430E  
3012  5B92 4A7A         DATA    FFDRVB                  find file FDR in VDP buffers
3013  5B94 06A0         BL      @CALSUB                 call subroutine
3013  5B96 430E  
3014  5B98 4ABE         DATA    FFDROD                  find FDR on disk
3015  5B9A C104         MOV     R4,R4                   found ?
3016  5B9C 1303         JEQ     H274                    yes
3017  5B9E 06A0         BL      @ERROR5                 no: return with error
3017  5BA0 4928  
3018  5BA2 E000         DATA    >E000                   file error
3019  5BA4 06A0 H274    BL      @FDR2B1                 get two bytes from FDR into R0
3019  5BA6 4826  
3020  5BA8 000E         DATA    14                      # of sectors in file
3021  5BAA 0429         BLWP    @>005A(R9)                      
3021  5BAC 005A  
3022  5BAE 2011         DATA    >2011                   retrieve R0 in R2 (# of sect to read), and R11
3023  5BB0 0429         BLWP    @>005A(R9)                      
3023  5BB2 005A  
3024  5BB4 0801         DATA    >0801                   retrieve R4 (ptr to file info structure)
3025  5BB6 C1F4         MOV     *R4+,R7                 VDP buffer
3026  5BB8 C0D4         MOV     *R4,R3                  first sector
3027  5BBA 045B         B       *R11                    
3028            *                                       
3029  5BBC 0429 VDP2SP  BLWP    @>005A(R9)              copy VDP bytes to scratch-pad
3029  5BBE 005A  
3030  5BC0 0102         DATA    >0102                   read from VDP at R8
3031  5BC2 DD2F H275    MOVB    @-1026(R15),*R4+        read bytes into scratch-pad at R4
3031  5BC4 FBFE  
3032  5BC6 0602         DEC     R2                      # of byte in R2
3033  5BC8 16FC         JNE     H275                    next byte
3034  5BCA 045B         B       *R11                    
3035            *                                       
3036  5BCC C0BB SP2VDP  MOV     *R11+,R2                copy scratch-pad bytes to VDP
3037  5BCE A202         A       R2,R8                   
3038  5BD0 0429         BLWP    @>005A(R9)              set VDP to write
3038  5BD2 005A  
3039  5BD4 0103         DATA    >0103                   address in R8 + offset in data word
3040  5BD6 DBF4 H276    MOVB    *R4+,@-2(R15)           write byte from scratch-pad at R4
3040  5BD8 FFFE  
3041  5BDA 0602         DEC     R2                      # of bytes in R2, was in data word
3042  5BDC 16FC         JNE     H276                    next byte
3043  5BDE 045B         B       *R11    
3044            *
3045            *----------------------------------------------------------------------------
3046            * APEDSK99 CALL subprograms
3047            *----------------------------------------------------------------------------
3048            *
3049  5BE0 0206 PDSK    LI      R6,>0200                Protect ACOMND 
3049  5BE2 0200  
3050  5BE4 104C         JMP     ACLPRP                  generic prep
3051  5BE6 0206 UDSK    LI      R6,>0400                Unprotect ACOMND 
3051  5BE8 0400  
3052  5BEA 1049         JMP     ACLPRP                  generic prep
3053  5BEC 0206 MDSK    LI      R6,>0600                Change DSK ACOMND
3053  5BEE 0600  
3054  5BF0 1046         JMP     ACLPRP                  generic prep
3055  5BF2 0206 LDSK    LI      R6,>0800                Show Files on DSKx ACOMND 
3055  5BF4 0800  
3056  5BF6 1043         JMP     ACLPRP                  generic prep
3057  5BF8 0206 RDSK    LI      R6,>0A00                Remove DOAD from SD card ACOMND 
3057  5BFA 0A00  
3058  5BFC 1040         JMP     ACLPRP                  generic prep
3059  5BFE 0206 SDSK    LI      R6,>0C00                Show DSKx mapping ACOMND
3059  5C00 0C00  
3060  5C02 103D         JMP     ACLPRP                  generic prep
3061  5C04 0206 SDIR    LI      R6,>0E00                Show SD dir ACOMND
3061  5C06 0E00  
3062  5C08 103A         JMP     ACLPRP                  generic prep
3063  5C0A 0206 AHLP    LI      R6,>1000                display APEDSK99 CALL()'s help screen
3063  5C0C 1000  
3064  5C0E 1037         JMP     ACLPRP                  generic prep
3065  5C10 0206 TIME    LI      R6,>1200                show NTP time and date
3065  5C12 1200  
3066  5C14 1034         JMP     ACLPRP                  generic prep
3067  5C16 0206 ARST    LI      R6,>1400                reset APEDSK99 ACOMND
3067  5C18 1400  
3068  5C1A 1031         JMP     ACLPRP                  generic prep
3069  5C1C 0206 FGET    LI      R6,>1600                get DOAD from FTP server ACOMND
3069  5C1E 1600  
3070  5C20 102E         JMP     ACLPRP                  generic prep
3071  5C22 0206 FPUT    LI      R6,>1800                save DOAD to FTP server ACOMND 
3071  5C24 1800  
3072  5C26 102B         JMP     ACLPRP                  generic prep
3073  5C28 0206 ADSR    LI      R6,>1A00                load DSR and reset ACOMND
3073  5C2A 1A00  
3074  5C2C 1028         JMP     ACLPRP                  generic prep
3075            *
3076            *-----------------------------------------------------------------
3077            * Subprogram PDSK / UDSK
3078            * ----------------------------------------------------------------
3079            *
3080  5C2E D806 PUDSK2  MOVB    R6,@ACOMND              send U/P DSK command to Arduino
3080  5C30 5FE8  
3081            *
3082  5C32 0208         LI      R8,12                   CALL length
3082  5C34 000C  
3083  5C36 104E         JMP     ACLBAS                  return to TI-BASIC              
3084            *                       
3085            *---------------------------------------------------------------------------------------
3086            * Subprogram MDSK / RDSK / FGET / FPUT / ADSR
3087            * --------------------------------------------------------------------------------------
3088            *
3089  5C38 05C8 MDSK2   INCT    R8                      increment pointer
3090  5C3A 06A0         BL      @VDPR2B                 get next two digits
3090  5C3C 482C  
3091            *
3092  5C3E 0220 RFFA2   AI      R0,>3900                add 2's complement of >C700 =  only keep # of characters
3092  5C40 3900  
3093  5C42 1372         JEQ     ACLERR                  0 characters / empty string -> * INCORRECT COMMAND
3094  5C44 0280         CI      R0,8                    max 8 characters?
3094  5C46 0008  
3095  5C48 1B6F         JH      ACLERR                  no -> * INCORRECT COMMAND
3096            *
3097  5C4A C100         MOV     R0,R4                   save # of characters
3098  5C4C 0205         LI      R5,CALLBF+2             pointer to DOAD / DSR name      
3098  5C4E 5FD8  
3099  5C50 05C8         INCT    R8                      increment pointer
3100  5C52 C088         MOV     R8,R2                   for VDPRD, address must be in R2
3101  5C54 06A0         BL      @VDPRD                  set VDP READ address
3101  5C56 42F6  
3102  5C58 DD6F H9900   MOVB    @-1026(R15),*R5+        get character and save in CALL buffer
3102  5C5A FBFE  
3103  5C5C 0600         DEC     R0                      one less to go
3104  5C5E 16FC         JNE     H9900   
3105            *
3106  5C60 D02F         MOVB    @-1026(R15),R0          get next token
3106  5C62 FBFE  
3107            *
3108  5C64 0280         CI      R0,>B600                is it a ")" ?
3108  5C66 B600  
3109  5C68 165F         JNE     ACLERR                  * INCORRECT COMMAND
3110            *
3111  5C6A 0208         LI      R8,13                   prep RDSK/FGET/FPUT/ADSR CALL length ( CALL_XXXX("") )
3111  5C6C 000D  
3112  5C6E A204         A       R4,R8                   add # of characters in string
3113                    
3114  5C70 0286         CI      R6,>0600                MDSK()?
3114  5C72 0600  
3115  5C74 1B01         JH      H9901                   no; jump and execute RDSK/FGET/FPUT/ADSR
3116            *
3117  5C76 05C8         INCT    R8                      adjust MDSK CALL length
3118            *
3119  5C78 D806 H9901   MOVB    R6,@ACOMND              command to Arduino
3119  5C7A 5FE8  
3120            *
3121  5C7C 102B         JMP     ACLBAS                  return to TI-BASIC
3122            *                       
3123            *----------------------------------------------------------------------------
3124            * Generic prep and return to TI BASIC for APEDSK99 CALL's
3125            *----------------------------------------------------------------------------
3126  5C7E C1CB ACLPRP  MOV     R11,R7                  save return-to-TI BASIC address
3127  5C80 06A0         BL      @PRPFDO                 prepare TI Controller DSR operations
3127  5C82 43DA  
3128  5C84 C229         MOV     @>002C(R9),R8           ptr to next basic token
3128  5C86 002C  
3129  5C88 0228         AI      R8,4                    skip length byte and 3 chars of CALL name
3129  5C8A 0004  
3130  5C8C 06A0         BL      @VDPR2B                 get CALL last char and "(" or "0" in R0
3130  5C8E 482C  
3131  5C90 0A80         SLA     R0,8                    only interested in LSB
3132  5C92 1379         JEQ     SSAA                    0 = no parameters? SDSK, SDIR, AHLP, ARST, TIME
3133            *
3134  5C94 0228         AI      R8,2                    adjust token pointer
3134  5C96 0002  
3135  5C98 06A0         BL      @VDPR2B                 get next two bytes in R0
3135  5C9A 482C  
3136  5C9C 0280         CI      R0,>C801                >C8=unquoted string, size=1 char?
3136  5C9E C801  
3137  5CA0 1304         JEQ     ACLPR2                  yes: PDSK, UDSK, MDSK, LDSK
3138            *
3139  5CA2 0280         CI      R0,>C701                >C7=quoted string, minimum 1 character?
3139  5CA4 C701  
3140  5CA6 14CB         JHE     RFFA2                   yes: RDSK, FGET, FPUT, ADSR 
3141            *
3142  5CA8 103F         JMP     ACLERR                  expect the unexpected                           
3143            *
3144  5CAA 05C8 ACLPR2  INCT    R8                      continue for PDSK, UDSK, MDSK, LDSK; increment pointer
3145  5CAC 06A0         BL      @VDPR2B                 get next two bytes              
3145  5CAE 482C  
3146            *
3147  5CB0 06C0         SWPB    R0
3148  5CB2 0220         AI      R0,>49D0                add 2's complement of >B630: MSB = >B3 / "," or >B6 / ")", LSB= # of files 
3148  5CB4 49D0  
3149  5CB6 1502         JGT     H9902                   >B6
3150  5CB8 0220         AI      R0,768                  >B3, adjust R0 to positive range
3150  5CBA 0300  
3151            *
3152  5CBC 1335 H9902   JEQ     ACLERR                  DSK0 not valid, * INCORRECT COMMAND
3153  5CBE 0280         CI      R0,3                    only 3 DSK's allowed
3153  5CC0 0003  
3154  5CC2 1B32         JH      ACLERR                  if >3 * INCORRECT COMMAND
3155            *
3156  5CC4 06C0         SWPB    R0
3157  5CC6 D800         MOVB    R0,@CALLBF              save DSKx
3157  5CC8 5FD6  
3158            *
3159  5CCA 0286         CI      R6,>0600                MDSK()?
3159  5CCC 0600  
3160  5CCE 13B4         JEQ     MDSK2                   yep
3161  5CD0 1AAE         JL      PUDSK2                  no; PDSK or UDSK                                                
3162  5CD2 102C         JMP     LDSK2                   must be LDSK
3163            *
3164  5CD4 9820 ACLBAS  CB      @CALLST,@K004           "More" or "AllGood" received from Arduino?      
3164  5CD6 5FD4  
3164  5CD8 430A  
3165  5CDA 141A         JHE     H9904                   yep
3166            *       
3167  5CDC 0205         LI      R5,GPLINT               GPL routine
3167  5CDE 006A  
3168  5CE0 06A0         BL      @GPLXML                 
3168  5CE2 5E4C  
3169  5CE4 56CD         DATA    SCROLL                  scroll screen
3170  5CE6 0202         LI      R2,738                  screen starting position for (error) message
3170  5CE8 02E2  
3171  5CEA 06A0         BL      @VDPWRI                 set VDP address
3171  5CEC 42EC  
3172  5CEE 06A0         BL      @DISSTS                 show error or NTP data
3172  5CF0 5DA0  
3173  5CF2 0205         LI      R5,GPLINT               GPL routine
3173  5CF4 006A  
3174  5CF6 06A0         BL      @GPLXML 
3174  5CF8 5E4C  
3175  5CFA 56CD         DATA    SCROLL                  scroll screen
3176            *
3177  5CFC 9820         CB      @CALLST,@K007           error?  
3177  5CFE 5FD4  
3177  5D00 4309  
3178  5D02 1B06         JH      H9904                   no; we can exit 
3179            *
3180  5D04 0205 H9903   LI      R5,GPLINT               yes: let's make some noise
3180  5D06 006A  
3181  5D08 06A0         BL      @GPLXML
3181  5D0A 5E4C  
3182  5D0C 03D6         DATA    HONK                    GPL routine"bad tone"
3183  5D0E 1005         JMP     H9914
3184            *
3185  5D10 0286 H9904   CI      R6,>1200                TIME() ?
3185  5D12 1200  
3186  5D14 1602         JNE     H9914                   no, end the party
3187  5D16 0460         B       @TIME2                  yes; see if we can assign date/time to NTP$ 
3187  5D18 5DE4  
3188            *
3189  5D1A 04E9 H9914   CLR     @>0050(R9)              clear error flag                
3189  5D1C 0050  
3190  5D1E AA48         A       R8, @>002C(R9)          add call length to token pointer                
3190  5D20 002C  
3191  5D22 5A69         SZCB    @>0042(R9),@>0042(R9)   clear current token
3191  5D24 0042  
3191  5D26 0042  
3192  5D28 0460 ACLERR  B       @RTURN1                 return to caller (i.e. TI-BASIC)
3192  5D2A 432C  
3193            *
3194            *-----------------------------------------------------------------
3195            * Subprogram SDSK / LDSK / SDIR/ AHLP / TIME
3196            * ----------------------------------------------------------------
3197            *
3198  5D2C D806 LDSK2   MOVB    R6,@ACOMND              SDSK/LDSK/SDIR/AHLP command to Arduino
3198  5D2E 5FE8  
3199  5D30 9820         CB      @K002,@CALLST
3199  5D32 4308  
3199  5D34 5FD4  
3200  5D36 132C         JEQ     QTLSSA                  LDSK: >00; no DOAD mapped
3201            *
3202  5D38 04C2 LDNXTS  CLR     R2                      clear screen; position 0
3203  5D3A 06A0         BL      @VDPWRI
3203  5D3C 42EC  
3204            *
3205  5D3E 0200         LI      R0,>8000                space + TI BASIC bias
3205  5D40 8000  
3206  5D42 06A0         BL      @VDPRPW
3206  5D44 4234  
3207  5D46 02C0         DATA    704                     704 positions to clear
3208            *
3209  5D48 0202         LI      R2,33                   start 2nd screen line; 1st is lost due to TI BASIC scroll
3209  5D4A 0021  
3210  5D4C 06A0         BL      @VDPWRI                 
3210  5D4E 42EC  
3211            *       
3212  5D50 9820 H9905   CB      @K004,@CALLST           check Arduino LDSK/SDSK/SDIR/AHLP/TIME return code
3212  5D52 430A  
3212  5D54 5FD4  
3213  5D56 131C         JEQ     QTLSSA                  "More" (>F0); blank "floppy" or done last file / help txt
3214            *
3215  5D58 06A0         BL      @DISSTS                 LDSK/SDSK/SDIR/AHLP/TIME output to screen
3215  5D5A 5DA0  
3216            *
3217  5D5C 0222         AI      R2,16                   next screen position
3217  5D5E 0010  
3218  5D60 0282         CI      R2,641                  end of display area?
3218  5D62 0281  
3219  5D64 1303         JEQ     NXTPRP                  yes; show "more" symbol
3220            *
3221  5D66 C802         MOV     R2,@RDINT               generates interrupt for next file
3221  5D68 5FEA  
3222  5D6A 10F2         JMP     H9905   
3223            *       
3224  5D6C 0202 NXTPRP  LI      R2,703
3224  5D6E 02BF  
3225  5D70 06A0         BL      @VDPWRI
3225  5D72 42EC  
3226  5D74 0205         LI      R5,>9E00                ">", more files to display
3226  5D76 9E00  
3227  5D78 DBC5         MOVB    R5,@-2(R15)
3227  5D7A FFFE  
3228            *
3229  5D7C 06A0         BL      @CHKKEY
3229  5D7E 5DB2  
3230            *
3231  5D80 C802         MOV     R2,@RDINT               generates interrupt for next file
3231  5D82 5FEA  
3232  5D84 10D9         JMP     LDNXTS
3233            *
3234            *-----------------------------------------------------------------------------------------
3235            * Subprogram ARST / TIME
3236            * ----------------------------------------------------------------------------------------
3237            *
3238  5D86 0286 SSAA    CI      R6,>1200                TIME() ?        
3238  5D88 1200  
3239  5D8A 1AD0         JL      LDSK2                   no; SDSK/SDIR/AHLP use LDSK display routine
3240            *
3241  5D8C D806 ARST2   MOVB    R6,@ACOMND              execute ARST() or TIME()
3241  5D8E 5FE8  
3242            *
3243  5D90 0208 QTLSSA  LI      R8,9                    current CALL length
3243  5D92 0009  
3244  5D94 0286         CI      R6,>0800                LDSK()?
3244  5D96 0800  
3245  5D98 1B02         JH      H9906                   nope; exit with CALL lenght 9 for SDSK/SDIR/AHLP
3246  5D9A 0228         AI      R8,3                    yep;  exit with CALL length 12 for LDSK
3246  5D9C 0003  
3247            *
3248  5D9E 109A H9906   JMP     ACLBAS  
3249            *
3250            * Display data, status messages and errors
3251            *
3252  5DA0 0205 DISSTS  LI      R5,CALLBF+2             start of file name buffer
3252  5DA2 5FD8  
3253  5DA4 0206         LI      R6,16                   16 bytes of (error) data to display
3253  5DA6 0010  
3254  5DA8 DBF5 H9907   MOVB    *R5+,@-2(R15)           store character in VDP screen memory
3254  5DAA FFFE  
3255  5DAC 0606         DEC     R6
3256  5DAE 16FC         JNE     H9907
3257  5DB0 045B         B       *R11
3258            *
3259            * Quick key test to display next screen after ">"
3260            * Keyboard column 0 (= space enter <nc> fctn shift ctrl <nc>)
3261            * Code copy from Thierry's TI's Tech Pages site
3262            *
3263  5DB2 C10C CHKKEY  MOV     R12,R4                  save R12
3264  5DB4 04C1         CLR     R1                      test column 0
3265  5DB6 020C         LI      R12,>0024               address for column selection
3265  5DB8 0024  
3266  5DBA 30C1 H9908   LDCR    R1,3                    select column
3267  5DBC 1FF2         TB      -14                     test R12 address >0008
3268  5DBE 1607         JNE     H9909                   <SPACE>
3269  5DC0 1FF3         TB      -13                     test R12 address >000A
3270  5DC2 13FB         JEQ     H9908                   no key; test again
3271            *
3272  5DC4 D820         MOVB    @K004,@CALLST           signal ENTER to SDIR() command
3272  5DC6 430A  
3272  5DC8 5FD4  
3273  5DCA 020B         LI      R11,QTLSSA              leave without clearing screen
3273  5DCC 5D90  
3274            *
3275  5DCE C304 H9909   MOV     R4,R12                  restore R12
3276  5DD0 0A24         SLA     R4,2                    debounce delay
3277  5DD2 0604 H9910   DEC     R4                      key debounce
3278  5DD4 16FE         JNE     H9910                   debounce some more
3279            *
3280  5DD6 045B         B       *R11                    we got one; return for next screen
3281            *               
3282            * update FAT time/date for current DOAD after DSR Format / Write / Save
3283            *
3284  5DD8 D820 NTPDT   MOVB    @NTPFAT+1,@ACOMND       "DSK NTP date/time update" command to Arduino           
3284  5DDA 4027  
3284  5DDC 5FE8  
3285  5DDE 045B         B       *R11                    return to Format / Close
3286            *       
3287            * prep for calling XML >16 and update BASIC variable NTP$               
3288            *
3289  5DE0 4E54 VARINF  TEXT    'NTP$'
3289  5DE2 5024  
3290  5DE4 0204 TIME2   LI      R4,VARINF               variable name for XML >16 in FAC
3290  5DE6 5DE0  
3291  5DE8 C149         MOV     R9,R5                   get scratchpad start address
3292  5DEA D974 H9911   MOVB    *R4+,@>004A(R5)         variable name in FAC
3292  5DEC 004A  
3293  5DEE 0585         INC     R5
3294  5DF0 0284         CI      R4,VARINF+4             done all chars?
3294  5DF2 5DE4  
3295  5DF4 16FA         JNE     H9911                   
3296            *
3297  5DF6 0205         LI      R5,>0400                variable length for XML >16 in @>8359
3297  5DF8 0400  
3298  5DFA DA45         MOVB    R5,@>0059(R9)           
3298  5DFC 0059  
3299  5DFE 04E9         CLR     @>0089(R9)      
3299  5E00 0089  
3300            *
3301  5E02 0205         LI      R5,XML16                ROM routine: find NTP$ in VDP symbol table (returns to GPL interpreter)
3301  5E04 15D6  
3302  5E06 06A0         BL      @GPLXML
3302  5E08 5E4C  
3303  5E0A 2244         DATA    XMLRTN                  GPL "RTN", escaping GPL interpreter
3304            *
3305  5E0C 9A60         CB      @VARINF,@>004A(R9)      found NTP$ in VDP symbol table?
3305  5E0E 5DE0  
3305  5E10 004A  
3306  5E12 1318         JEQ     H9913                   no symbol table pointer; back to BASIC
3307            *
3308  5E14 06A0         BL      @XML14                  ROM routine: get NTP$ VDP address and string length (returns through RT)
3308  5E16 164E  
3309  5E18 02A9         STWP    R9                      restore scratchpad pointer
3310  5E1A 0229         AI      R9,-224
3310  5E1C FF20  
3311            *       
3312  5E1E C169         MOV     @>0050(R9),R5           get string length
3312  5E20 0050  
3313  5E22 0285         CI      R5,16                   16 chars?
3313  5E24 0010  
3314  5E26 160E         JNE     H9913                   no NTP$ assignment for you
3315            *
3316  5E28 C0A0         MOV     @>834E,R2               yes
3316  5E2A 834E  
3317  5E2C 06A0         BL      @VDPWRI                 set VDP write address
3317  5E2E 42EC  
3318  5E30 0205         LI      R5,CALLBF+2             CALL TIME data still in buffer
3318  5E32 5FD8  
3319  5E34 D0B5 H9912   MOVB    *R5+,R2                 read character
3320  5E36 0222         AI      R2,>A000                remove TI BASIC bias
3320  5E38 A000  
3321  5E3A DBC2         MOVB    R2,@-2(R15)             save to NTP$ value space
3321  5E3C FFFE  
3322  5E3E 0285         CI      R5,CALLBF+18            done all 16 chars?
3322  5E40 5FE8  
3323  5E42 16F8         JNE     H9912                   no; one more
3324            *
3325  5E44 0460 H9913   B       @H9914                  yes; back to BASIC
3325  5E46 5D1A  
3326            *
3327            * execute GROM or XML routine (SCROLL, "bad sound"/ HONK and XML >16)
3328            * DSR and GPL interpreter use same workspace (>83E0) so we need to save a few things
3329            *
3330  5E48 0000 SAVGRA  BSS     2                       save current GROM address so we can return to BASIC
3331  5E4A 0000 SAVR11  BSS     2                       GPL interpreter uses R11
3332            *
3333  5E4C D820 GPLXML  MOVB    @>9802,@SAVGRA          save current GROM address
3333  5E4E 9802  
3333  5E50 5E48  
3334  5E52 1000         NOP
3335  5E54 D820         MOVB    @>9802,@SAVGRA+1
3335  5E56 9802  
3335  5E58 5E49  
3336  5E5A 0620         DEC     @SAVGRA                 GRMWA returns address + 1; decrease for correct address
3336  5E5C 5E48  
3337            *
3338  5E5E D83B         MOVB    *R11+,@>9C02            set GPL routine address
3338  5E60 9C02  
3339  5E62 1000         NOP
3340  5E64 D83B         MOVB    *R11+,@>9C02
3340  5E66 9C02  
3341  5E68 C80B         MOV     R11,@SAVR11             save final DSR return address
3341  5E6A 5E4A  
3342            *
3343  5E6C 020B         LI      R11,GXRTN               DSR return address after GPL routine
3343  5E6E 5E88  
3344  5E70 C80B         MOV     R11,@RTN5C              @>4028 is where XML >5C returns to
3344  5E72 4028  
3345            *
3346  5E74 05E0         INCT    @>8373                  increase stack pointer
3346  5E76 8373  
3347  5E78 06C9         SWPB    R9                      
3348  5E7A D260         MOVB    @>8373,R9
3348  5E7C 8373  
3349  5E7E 06C9         SWPB    R9                      complete stack pointer in R9
3350  5E80 020B         LI      R11,XML5C               GROM pointer to >0F5C (= XML >5C)
3350  5E82 105C  
3351  5E84 C64B         MOV     R11,*R9                 save GROM pointer on stack
3352            *
3353  5E86 0455         B       *R5                     execute GROM/ROM routine, return through GPL interpreter
3354            *
3355  5E88 D820 GXRTN   MOVB    @SAVGRA,@>9C02          and ... we're back; restore saved GROM address
3355  5E8A 5E48  
3355  5E8C 9C02  
3356  5E8E 1000         NOP
3357  5E90 D820         MOVB    @SAVGRA+1,@>9C02
3357  5E92 5E49  
3357  5E94 9C02  
3358            *
3359  5E96 02A9         STWP    R9                      restore scratchpad pointer
3360  5E98 0229         AI      R9,-224
3360  5E9A FF20  
3361            *
3362  5E9C C2E0         MOV     @SAVR11,R11             restore R11
3362  5E9E 5E4A  
3363  5EA0 045B         B       *R11                    return to instruction after BL @GPLEXEC DATA statement
3364            *
3365            *----------------------------------------------------------------------------------
3366            * >5EA2 - >5FC1: 287 free bytes remaining
3367            * >5FC2 - >5FD3 is DSK1-3 parameters storage
3368            * >5FD4 is the CALL() status byte
3369            * >5FD6 - >5FE7 is buffer storage for APEDSK99 CALL's
3370            * >5FE8 is the Arduino Command Register (TI BASIC CALL support)
3371            * Word >5FEA maps to the read counter (R6, to generate interrupts when reading data) 
3372            * Bytes >5FEE maps to the CRU emulation write register
3373            * Bytes >5FF0 to >5FFE map to the FDC emulation registers
3374            *-----------------------------------------------------------------------------------                                    
3375            *
3376  5EA2 0000         END
3376            


 Assembly Complete - Errors: 0,  Warnings: 0


 ------ Symbol Listing ------

 ACLBAS ABS:5CD4 ACLBAS
 ACLERR ABS:5D28 ACLERR
 ACLPR2 ABS:5CAA ACLPR2
 ACLPRP ABS:5C7E ACLPRP
 ACOMND ABS:5FE8 ACOMND
 ADDSEC ABS:46BA ADDSEC
 ADSR   ABS:5C28 ADSR
 AFDRPT ABS:527E AFDRPT
 AFPGPF ABS:5194 AFPGPF
 AHLP   ABS:5C0A AHLP
 APSCTS ABS:4616 APSCTS
 ARST   ABS:5C16 ARST
 ARST2  ABS:5D8C ARST2
 CALLBF ABS:5FD6 CALLBF
 CALLST ABS:5FD4 CALLST
 CALSUB ABS:430E CALSUB
 CFNFDR ABS:5B40 CFNFDR
 CFSVIB ABS:571C CFSVIB
 CHKKEY ABS:5DB2 CHKKEY
 CLOSE  ABS:4F86 CLOSE
 CLRFBT ABS:4538 CLRFBT
 CLSDIR ABS:55C6 CLSDIR
 CMPFN  ABS:47F2 CMPFN
 CPCKFN ABS:48CA CPCKFN
 CRFIL1 ABS:4446 CRFIL1
 CRFIL2 ABS:444C CRFIL2
 CRFIL3 ABS:4458 CRFIL3
 CRUWRI ABS:5FEE CRUWRI
 DECDCI ABS:4B6C DECDCI
 DELETE ABS:4724 DELETE
 DISSTS ABS:5DA0 DISSTS
 DSDRVS ABS:430C DSDRVS
 DSKPRM ABS:5FC2 DSKPRM
 DSR01  ABS:40CE DSR01
 DSR02  ABS:40D6 DSR02
 DSR03  ABS:40E0 DSR03
 DSR04  ABS:40EA DSR04
 ECUSTM ABS:4346 ECUSTM
 EDSR01 ABS:4D02 EDSR01
 EDSR02 ABS:4D10 EDSR02
 EDSR03 ABS:4D16 EDSR03
 EDSR04 ABS:4D1C EDSR04
 EPWRUP ABS:40F4 EPWRUP
 ERROR1 ABS:42AA ERROR1
 ERROR3 ABS:41DC ERROR3
 ERROR4 ABS:4248 ERROR4
 ERROR5 ABS:4928 ERROR5
 ERROR6 ABS:4ADE ERROR6
 ERROR7 ABS:48CE ERROR7
 ERROR8 ABS:4D6E ERROR8
 ERROR9 ABS:4D8A ERROR9
 ERRR10 ABS:55A2 ERRR10
 ESUB01 ABS:57EC ESUB01
 ESUB02 ABS:57FC ESUB02
 ESUB03 ABS:5806 ESUB03
 ESUB04 ABS:5860 ESUB04
 ESUB05 ABS:592C ESUB05
 ESUB06 ABS:599C ESUB06
 ESUB07 ABS:5A62 ESUB07
 ESUB08 ABS:5A0E ESUB08
 FDR2B1 ABS:4826 FDR2B1
 FDR2B2 ABS:482A FDR2B2
 FDSKDR ABS:4840 FDSKDR
 FFDRDK ABS:4AC2 FFDRDK
 FFDRFN ABS:4AEE FFDRFN
 FFDROD ABS:4ABE FFDROD
 FFDRVB ABS:4A7A FFDRVB
 FFDRVP ABS:5184 FFDRVP
 FFFDR  ABS:5B88 FFFDR
 FFFDRV ABS:4A5A FFFDRV
 FFSBM  ABS:4C72 FFSBM
 FFSBMP ABS:4BAC FFSBMP
 FFSVIB ABS:4590 FFSVIB
 FGET   ABS:5C1C FGET
 FMTDSK ABS:41E2 FMTDSK
 FNDFDR ABS:4AB8 FNDFDR
 FNDRV  ABS:5756 FNDRV
 FPUT   ABS:5C22 FPUT
 FRSCB1 ABS:4C78 FRSCB1
 FSCTOF ABS:4700 FSCTOF
 GPLINT ABS:006A GPLINT
 GPLXML ABS:5E4C GPLXML
 GXRTN  ABS:5E88 GXRTN
 H001   ABS:411A H001
 H005   ABS:417E H005
 H013   ABS:4182 H013
 H014   ABS:41B0 H014
 H015   ABS:4190 H015
 H016   ABS:419E H016
 H019   ABS:41AC H019
 H024   ABS:41C6 H024
 H027   ABS:41E6 H027
 H036   ABS:41FE H036
 H037   ABS:420E H037
 H038   ABS:421C H038
 H044   ABS:4236 H044
 H055   ABS:4258 H055
 H056   ABS:4276 H056
 H057   ABS:426E H057
 H058   ABS:4274 H058
 H061   ABS:4298 H061
 H064   ABS:42BC H064
 H066   ABS:42C2 H066
 H068   ABS:42E6 H068
 H069   ABS:42FA H069
 H070   ABS:438E H070
 H071   ABS:43BC H071
 H072   ABS:436A H072
 H073   ABS:43B8 H073
 H074   ABS:4394 H074
 H075   ABS:43D0 H075
 H076   ABS:43FA H076
 H077   ABS:44E2 H077
 H078   ABS:446E H078
 H079   ABS:44C6 H079
 H080   ABS:44F8 H080
 H081   ABS:4522 H081
 H082   ABS:4502 H082
 H083   ABS:4514 H083
 H084   ABS:4528 H084
 H085   ABS:4560 H085
 H086   ABS:458C H086
 H087   ABS:45AE H087
 H088   ABS:45DC H088
 H089   ABS:45B8 H089
 H090   ABS:45F0 H090
 H091   ABS:45FA H091
 H092   ABS:46AE H092
 H093   ABS:4626 H093
 H094   ABS:464C H094
 H095   ABS:463A H095
 H096   ABS:4682 H096
 H097   ABS:4690 H097
 H098   ABS:468E H098
 H099   ABS:4686 H099
 H100   ABS:469E H100
 H101   ABS:46B6 H101
 H102   ABS:46FE H102
 H103   ABS:4714 H103
 H104   ABS:4720 H104
 H105   ABS:470A H105
 H106   ABS:473C H106
 H107   ABS:475E H107
 H108   ABS:4752 H108
 H109   ABS:47A2 H109
 H110   ABS:47D2 H110
 H111   ABS:47FA H111
 H112   ABS:481E H112
 H113   ABS:4858 H113
 H114   ABS:4862 H114
 H115   ABS:48C0 H115
 H116   ABS:486A H116
 H118   ABS:48B8 H118
 H119   ABS:48D4 H119
 H120   ABS:48E2 H120
 H121   ABS:491E H121
 H122   ABS:48EE H122
 H123   ABS:4952 H123
 H124   ABS:4974 H124
 H125   ABS:4978 H125
 H126   ABS:49DE H126
 H127   ABS:49B0 H127
 H128   ABS:49C4 H128
 H129   ABS:49D4 H129
 H130   ABS:4A52 H130
 H131   ABS:4A34 H131
 H132   ABS:4A4A H132
 H133   ABS:4A44 H133
 H134   ABS:4A94 H134
 H135   ABS:4AB4 H135
 H136   ABS:4A76 H136
 H137   ABS:4AE4 H137
 H138   ABS:4ACA H138
 H139   ABS:4AFA H139
 H140   ABS:4B60 H140
 H141   ABS:4B5C H141
 H142   ABS:4B66 H142
 H143   ABS:4BC0 H143
 H144   ABS:4BD2 H144
 H145   ABS:4BE2 H145
 H146   ABS:4BEE H146
 H147   ABS:4C1E H147
 H148   ABS:4C14 H148
 H149   ABS:4C68 H149
 H150   ABS:4C26 H150
 H151   ABS:4C4C H151
 H152   ABS:4CA4 H152
 H153   ABS:4CB8 H153
 H154   ABS:4CB2 H154
 H155   ABS:4CB4 H155
 H156   ABS:4CBA H156
 H157   ABS:4CE2 H157
 H158   ABS:4CEA H158
 H159   ABS:4D26 H159
 H160   ABS:4D20 H160
 H161   ABS:4D4C H161
 H162   ABS:4D90 H162
 H163   ABS:4DA6 H163
 H164   ABS:4E5A H164
 H165   ABS:4DB2 H165
 H166   ABS:4DE4 H166
 H167   ABS:4DFC H167
 H168   ABS:4E00 H168
 H169   ABS:4E56 H169
 H170   ABS:4E82 H170
 H171   ABS:4E7E H171
 H172   ABS:4EA6 H172
 H173   ABS:4ED4 H173
 H174   ABS:4F2C H174
 H175   ABS:4F52 H175
 H176   ABS:4F56 H176
 H177   ABS:4FA0 H177
 H178   ABS:4FBA H178
 H179   ABS:4F9C H179
 H180   ABS:4FB2 H180
 H181   ABS:4FAC H181
 H182   ABS:4FDC H182
 H183   ABS:5012 H183
 H184   ABS:4FF6 H184
 H185   ABS:5020 H185
 H186   ABS:5044 H186
 H187   ABS:504C H187
 H188   ABS:5070 H188
 H189   ABS:50B6 H189
 H190   ABS:50AE H190
 H191   ABS:515C H191
 H192   ABS:50C0 H192
 H193   ABS:50D6 H193
 H194   ABS:50EC H194
 H195   ABS:51D0 H195
 H196   ABS:51F0 H196
 H197   ABS:51F6 H197
 H198   ABS:5252 H198
 H199   ABS:5262 H199
 H200   ABS:534A H200
 H201   ABS:537E H201
 H202   ABS:538C H202
 H203   ABS:5392 H203
 H204   ABS:53D0 H204
 H205   ABS:53F2 H205
 H206   ABS:53D4 H206
 H207   ABS:53FE H207
 H208   ABS:5420 H208
 H209   ABS:5430 H209
 H210   ABS:54A6 H210
 H211   ABS:54D2 H211
 H212   ABS:5552 H212
 H213   ABS:553E H213
 H214   ABS:54E0 H214
 H215   ABS:54EC H215
 H216   ABS:550E H216
 H217   ABS:54F8 H217
 H218   ABS:553A H218
 H219   ABS:5520 H219
 H220   ABS:554E H220
 H221   ABS:557C H221
 H222   ABS:558C H222
 H223   ABS:5576 H223
 H224   ABS:55A8 H224
 H225   ABS:55B2 H225
 H226   ABS:560C H226
 H227   ABS:5688 H227
 H228   ABS:567E H228
 H229   ABS:566E H229
 H230   ABS:5678 H230
 H231   ABS:5686 H231
 H232   ABS:56A6 H232
 H233   ABS:56E0 H233
 H234   ABS:56B6 H234
 H235   ABS:56D8 H235
 H236   ABS:572C H236
 H237   ABS:5750 H237
 H238   ABS:5742 H238
 H239   ABS:5746 H239
 H240   ABS:574C H240
 H241   ABS:5778 H241
 H242   ABS:5792 H242
 H243   ABS:5788 H243
 H244   ABS:57BC H244
 H245   ABS:57C6 H245
 H246   ABS:57C4 H246
 H247   ABS:57CC H247
 H248   ABS:57CE H248
 H249   ABS:57E2 H249
 H250   ABS:5890 H250
 H251   ABS:5922 H251
 H252   ABS:5928 H252
 H253   ABS:597A H253
 H254   ABS:5946 H254
 H255   ABS:5974 H255
 H256   ABS:594C H256
 H257   ABS:5952 H257
 H258   ABS:596E H258
 H259   ABS:598E H259
 H260   ABS:59D0 H260
 H261   ABS:59B2 H261
 H262   ABS:5A0A H262
 H263   ABS:5A5E H263
 H264   ABS:5B22 H264
 H265   ABS:5B1C H265
 H266   ABS:5AE4 H266
 H267   ABS:5AB0 H267
 H268   ABS:5ADA H268
 H269   ABS:5B18 H269
 H270   ABS:5AFC H270
 H272   ABS:5B26 H272
 H273   ABS:5B44 H273
 H274   ABS:5BA4 H274
 H275   ABS:5BC2 H275
 H276   ABS:5BD6 H276
 H9900  ABS:5C58 H9900
 H9901  ABS:5C78 H9901
 H9902  ABS:5CBC H9902
 H9903  ABS:5D04 H9903
 H9904  ABS:5D10 H9904
 H9905  ABS:5D50 H9905
 H9906  ABS:5D9E H9906
 H9907  ABS:5DA8 H9907
 H9908  ABS:5DBA H9908
 H9909  ABS:5DCE H9909
 H9910  ABS:5DD2 H9910
 H9911  ABS:5DEA H9911
 H9912  ABS:5E34 H9912
 H9913  ABS:5E44 H9913
 H9914  ABS:5D1A H9914
 HONK   ABS:03D6 HONK
 INSFDR ABS:47C0 INSFDR
 INT2FP ABS:579A INT2FP
 K001   ABS:4162 K001
 K002   ABS:4308 K002
 K004   ABS:430A K004
 K005   ABS:430B K005
 K007   ABS:4309 K007
 K013   ABS:42BA K013
 K014   ABS:4926 K014
 LASTRK ABS:42C8 LASTRK
 LDNXTS ABS:5D38 LDNXTS
 LDSK   ABS:5BF2 LDSK
 LDSK2  ABS:5D2C LDSK2
 LOAD   ABS:5382 LOAD
 MDSK   ABS:5BEC MDSK
 MDSK2  ABS:5C38 MDSK2
 NOCRU  ABS:4160 NOCRU
 NTPDT  ABS:5DD8 NTPDT
 NTPFAT ABS:4026 NTPFAT
 NXTPRP ABS:5D6C NXTPRP
 OPCVEC ABS:4D54 OPCVEC
 OPEN   ABS:4D74 OPEN
 OPNDIR ABS:5568 OPNDIR
 PABR2B ABS:4820 PABR2B
 PDSK   ABS:5BE0 PDSK
 PESB07 ABS:5A68 PESB07
 PRFDRS ABS:4F34 PRFDRS
 PRPFDO ABS:43DA PRPFDO
 PRPRTN ABS:43DC PRPRTN
 PUDSK2 ABS:5C2E PUDSK2
 PWRUP  ABS:40C8 PWRUP
 QTLSSA ABS:5D90 QTLSSA
 R0     ABS:0000 R0
 R1     ABS:0001 R1
 R10    ABS:000A R10
 R11    ABS:000B R11
 R12    ABS:000C R12
 R13    ABS:000D R13
 R14    ABS:000E R14
 R15    ABS:000F R15
 R2     ABS:0002 R2
 R3     ABS:0003 R3
 R4     ABS:0004 R4
 R5     ABS:0005 R5
 R6     ABS:0006 R6
 R7     ABS:0007 R7
 R8     ABS:0008 R8
 R9     ABS:0009 R9
 RBANB  ABS:5474 RBANB
 RCOFCB ABS:5304 RCOFCB
 RDATA  ABS:5FF6 RDATA
 RDDIR  ABS:55DC RDDIR
 RDFDR1 ABS:4A00 RDFDR1
 RDFDR2 ABS:49FC RDFDR2
 RDINT  ABS:5FEA RDINT
 RDOFSC ABS:45E0 RDOFSC
 RDSEC1 ABS:49EA RDSEC1
 RDSK   ABS:5BF8 RDSK
 READ   ABS:4F90 READ
 RETERR ABS:4954 RETERR
 RFDRST ABS:51B0 RFDRST
 RFDRVB ABS:5908 RFDRVB
 RFFA2  ABS:5C3E RFFA2
 RFNPTR ABS:5B62 RFNPTR
 RMFPTR ABS:4790 RMFPTR
 RNFISE ABS:520E RNFISE
 RRFDR  ABS:522A RRFDR
 RRNPAB ABS:51C4 RRNPAB
 RRSEC  ABS:5016 RRSEC
 RSTAT  ABS:5FF0 RSTAT
 RSTDRV ABS:427C RSTDRV
 RTN5C  ABS:4028 RTN5C
 RTURN1 ABS:432C RTURN1
 RVRVDP ABS:4392 RVRVDP
 RWIND1 ABS:532E RWIND1
 RWIND2 ABS:535C RWIND2
 RWSEC  ABS:4A04 RWSEC
 RWSECA ABS:4A06 RWSECA
 RWSECB ABS:4A08 RWSECB
 RWVIB  ABS:4988 RWVIB
 SAVE   ABS:5424 SAVE
 SAVGRA ABS:5E48 SAVGRA
 SAVR11 ABS:5E4A SAVR11
 SCROLL ABS:56CD SCROLL
 SDIR   ABS:5C04 SDIR
 SDSK   ABS:5BFE SDSK
 SECRW1 ABS:4164 SECRW1
 SELDRV ABS:424E SELDRV
 SNDCMD ABS:42C0 SNDCMD
 SP2VDP ABS:5BCC SP2VDP
 SSAA   ABS:5D86 SSAA
 STATUS ABS:54A8 STATUS
 SUB01  ABS:4010 SUB01
 SUB02  ABS:4016 SUB02
 SUB03  ABS:401C SUB03
 SUB04  ABS:4022 SUB04
 SUB05  ABS:402A SUB05
 SUB06  ABS:4030 SUB06
 SUB07  ABS:4036 SUB07
 SUB08  ABS:403C SUB08
 SUB09  ABS:4046 SUB09
 SUB10  ABS:4050 SUB10
 SUB11  ABS:405A SUB11
 SUB12  ABS:4064 SUB12
 SUB13  ABS:406E SUB13
 SUB14  ABS:4078 SUB14
 SUB15  ABS:4082 SUB15
 SUB16  ABS:408C SUB16
 SUB17  ABS:4096 SUB17
 SUB18  ABS:40A0 SUB18
 SUB19  ABS:40AA SUB19
 SUB20  ABS:40B4 SUB20
 SUB21  ABS:40BE SUB21
 SVDPRD ABS:43C8 SVDPRD
 SVDPWR ABS:43BE SVDPWR
 SVRVDP ABS:4366 SVRVDP
 TIME   ABS:5C10 TIME
 TIME2  ABS:5DE4 TIME2
 UCOFCB ABS:52A2 UCOFCB
 UDSK   ABS:5BE6 UDSK
 UFNCB  ABS:5B2A UFNCB
 UPDBF  ABS:454C UPDBF
 UPDCLI ABS:4B88 UPDCLI
 UPDFCB ABS:4F5E UPDFCB
 UPDFDR ABS:452C UPDFDR
 URFFDR ABS:52CE URFFDR
 UWFLVB ABS:5840 UWFLVB
 VARINF ABS:5DE0 VARINF
 VDP2SP ABS:5BBC VDP2SP
 VDPR2B ABS:482C VDPR2B
 VDPRD  ABS:42F6 VDPRD
 VDPRPW ABS:4234 VDPRPW
 VDPWRI ABS:42EC VDPWRI
 VECRTN ABS:435E VECRTN
 WCOMND ABS:5FF8 WCOMND
 WDATA  ABS:5FFE WDATA
 WFDRPB ABS:4FF2 WFDRPB
 WRFDR  ABS:49F6 WRFDR
 WRITE  ABS:507A WRITE
 WROFSC ABS:4600 WROFSC
 WRSEC1 ABS:49EC WRSEC1
 WSECTR ABS:5FFC WSECTR
 WTCPT1 ABS:4240 WTCPT1
 XML14  ABS:164E XML14
 XML16  ABS:15D6 XML16
 XML5C  ABS:105C XML5C
 XMLRTN ABS:2244 XMLRTN
