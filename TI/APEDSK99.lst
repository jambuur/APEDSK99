Asm994a TMS99000 Assembler - v3.010

                * Asm994a Generated Register Equates
                *
      0000 0000 R0      EQU     0 
      0000 0001 R1      EQU     1 
      0000 0002 R2      EQU     2 
      0000 0003 R3      EQU     3 
      0000 0004 R4      EQU     4 
      0000 0005 R5      EQU     5 
      0000 0006 R6      EQU     6 
      0000 0007 R7      EQU     7 
      0000 0008 R8      EQU     8 
      0000 0009 R9      EQU     9 
      0000 000A R10     EQU     10
      0000 000B R11     EQU     11
      0000 000C R12     EQU     12
      0000 000D R13     EQU     13
      0000 000E R14     EQU     14
      0000 000F R15     EQU     15
                *
   1            *====================================
   2            * TI DISK CONTROLLER ROM   >4000-5FFF
   3            * 
   4            * initial commented disassembly by Thierry Nouspikel
   5            * (see http://www.unige.ch/medecine/nouspikel/ti99/titechpages.htm)
   6            *
   7            * and
   8            * 
   9            * Monty Schmidt's book: TI Technical Drive
  10            *
  11            * adapted for APEDSK99 by Jochen Buur
  12            * github.com/jambuur/APEDSK99
  13            *====================================
  14  0000 5FD4 CALLST  EQU     >5FD4                   CALL() execution status: finished, still active, error
  15  0000 5FD6 CALLBF  EQU     >5FD6                   2-way buffer for TI BASIC CALL's
  16  0000 5FE8 ACOMND  EQU     >5FE8                   APEDSK99-specific Command register
  17  0000 5FEA RDINT   EQU     >5FEA                   issue read interrupt (R6 counter) 
  18  0000 5FEC CRURD   EQU     >5FEC                   emulated 8 CRU input bits - NOT USED CURRENTLY
  19  0000 5FEE CRUWRI  EQU     >5FEE                   emulated 8 CRU output bits
  20  0000 5FF0 RSTAT   EQU     >5FF0                   read FD1771 Status register
  21  0000 5FF2 RTRACK  EQU     >5FF2                   read FD1771 Track register
  22  0000 5FF4 RSECTR  EQU     >5FF4                   read FD1771 Sector register
  23  0000 5FF6 RDATA   EQU     >5FF6                   read FD1771 Data register
  24  0000 5FF8 WCOMND  EQU     >5FF8                   write FD1771 Command register
  25  0000 5FFA WTRACK  EQU     >5FFA                   write FD1771 Track register
  26  0000 5FFC WSECTR  EQU     >5FFC                   write FD1771 Sector register
  27  0000 5FFE WDATA   EQU     >5FFE                   write FD1771 Data register
  28            *
  29  0000 164E XML14   EQU     >164E                   ROM address for XML >14
  30  0000 15D6 XML16   EQU     >15D6                   ROM address for XML >16
  31  0000 105C XML5C   EQU     >105C                   GROM address for XML >5C        !CHECK GROM ADDRESS CONTENTS (different GROM 0 versions)
  32  0000 006A GPLINT  EQU     >006A                   jump to GROM interpreter for SCROLL / HONK
  33  0000 2244 XMLRTN  EQU     >2244                   jump to GROM interpreter for RTN (after executing XML >14 / >16 routine)
  34  0000 56CD SCROLL  EQU     >56CD                   GROM address for scroll routine
  35  0000 03D6 HONK    EQU     >03D6                   GROM address for "bad tone"     !CHECK GROM ADDRESS CONTENTS (different GROM 0 versions)
  36            *
  37                    AORG    >4000
  38            *
  39  4000 AA           BYTE    >AA                     standard header mark
  40  4001 02           BYTE    >02                     version 2
  41  4002 0000         DATA    >0000                   no programs
  42  4004 40C8         DATA    PWRUP                   power-up chain ptr
  43  4006 0000         DATA    >0000                   programs chain ptr (none)
  44  4008 40CE         DATA    DSR01                   DSR chain ptr
  45  400A 4010         DATA    SUB01                   subprograms chain ptr
  46  400C 0000         DATA    >0000                   ISR chain ptr (none)
  47  400E 0000         DATA    >0000                   
  48            *                                       
  49  4010 4016 SUB01   DATA    SUB02                   link to next subprogram
  50  4012 5910         DATA    ESUB01                  address of that one
  51  4014 0110         DATA    >0110                   subprogram name: >10 (sector R/W)
  52  4016 401C SUB02   DATA    SUB03                   
  53  4018 5920         DATA    ESUB02                  
  54  401A 0111         DATA    >0111                   subprogram >11 (format disk)
  55  401C 4022 SUB03   DATA    SUB04                   
  56  401E 592A         DATA    ESUB03                  
  57  4020 0112         DATA    >0112                   subprogram >12 (file un/protect)
  58  4022 402A SUB04   DATA    SUB05                   
  59  4024 5984         DATA    ESUB04                  
  60  4026 0113 NTPFAT  DATA    >0113                   subprogram >13 (file rename); doubles as FAT update flag
  61  4028 0000 RTN5C   DATA    >0000                   save GPL return address (needs to be @>4028 for XML >5C!)
  62  402A 4030 SUB05   DATA    SUB06                   
  63  402C 5A50         DATA    ESUB05                  
  64  402E 0114         DATA    >0114                   subprogram >14 (file direct input)              
  65  4030 4036 SUB06   DATA    SUB07                   
  66  4032 5AC0         DATA    ESUB06                  
  67  4034 0115         DATA    >0115                   subprogram >15 (file direct output)
  68  4036 403C SUB07   DATA    SUB08                   
  69  4038 5B86         DATA    ESUB07                  
  70  403A 0116         DATA    >0116                   subprogram >16 (number of files)
  71  403C 4046 SUB08   DATA    SUB09                   
  72  403E 5B32         DATA    ESUB08                  
  73  4040 05           BYTE    >05                     
  74  4041 4649         TEXT    'FILES'                 same as >16, called from Basic
  74  4043 4C45  
  74  4045 53    
  75            *
  76  4046 4050 SUB09   DATA    SUB10
  77  4048 5D04         DATA    PDSK
  78  404A 04           BYTE    >04
  79  404B 5044         TEXT    'PDSK'                  Protect DSKx (apply adhesive tab)
  79  404D 534B  
  80  404F 0000         EVEN
  81  4050 405A SUB10   DATA    SUB11                   
  82  4052 5D0A         DATA    UDSK
  83  4054 04           BYTE    >04
  84  4055 5544         TEXT    'UDSK'                  Un-protect DSKx (remove adhesive tab)
  84  4057 534B  
  85  4059 0000         EVEN
  86  405A 4064 SUB11   DATA    SUB12
  87  405C 5D10         DATA    MDSK
  88  405E 04           BYTE    >04
  89  405F 4D44         TEXT    'MDSK'                  Map DOAD to DSKx
  89  4061 534B  
  90  4063 0000         EVEN
  91  4064 406E SUB12   DATA    SUB13
  92  4066 5D16         DATA    LDSK
  93  4068 04           BYTE    >04
  94  4069 4C44         TEXT    'LDSK'                  List files on DSKx
  94  406B 534B  
  95  406D 0000         EVEN
  96  406E 4078 SUB13   DATA    SUB14
  97  4070 5D1C         DATA    RDSK
  98  4072 04           BYTE    >04
  99  4073 5244         TEXT    'RDSK'                  Remove DOAD from SD card
  99  4075 534B  
 100  4077 0000         EVEN
 101  4078 4082 SUB14   DATA    SUB15
 102  407A 5D22         DATA    SDSK
 103  407C 04           BYTE    >04
 104  407D 5344         TEXT    'SDSK'                  Show DOAD mapping for DSKx
 104  407F 534B  
 105  4081 0000         EVEN
 106  4082 408C SUB15   DATA    SUB16
 107  4084 5D28         DATA    SDIR
 108  4086 04           BYTE    >04
 109  4087 5344         TEXT    'SDIR'                  List DOAD files on SD card
 109  4089 4952  
 110  408B 0000         EVEN
 111  408C 4096 SUB16   DATA    SUB17
 112  408E 5D2E         DATA    AHLP
 113  4090 04           BYTE    >04
 114  4091 4148         TEXT    'AHLP'                  APEDSK99 CALL help screen
 114  4093 4C50  
 115  4095 0000         EVEN
 116  4096 40A0 SUB17   DATA    SUB18
 117  4098 5D34         DATA    TIME
 118  409A 04           BYTE    >04
 119  409B 5449         TEXT    'TIME'                  NTP date/time display / assign to NTP$
 119  409D 4D45  
 120  409F 0000         EVEN
 121  40A0 40AA SUB18   DATA    SUB19
 122  40A2 5D3A         DATA    ARST
 123  40A4 04           BYTE    >04
 124  40A5 4152         TEXT    'ARST'                  APEDSK99 Reset
 124  40A7 5354  
 125  40A9 0000         EVEN
 126  40AA 40B4 SUB19   DATA    SUB20
 127  40AC 5D40         DATA    FGET
 128  40AE 04           BYTE    >04
 129  40AF 4647         TEXT    'FGET'                  Load DOAD from FTP server
 129  40B1 4554  
 130  40B3 0000         EVEN
 131  40B4 40BE SUB20   DATA    SUB21
 132  40B6 5D46         DATA    FPUT
 133  40B8 04           BYTE    >04
 134  40B9 4650         TEXT    'FPUT'                  Save DOAD to FTP server
 134  40BB 5554  
 135  40BD 0000         EVEN
 136  40BE 0000 SUB21   DATA    >0000
 137  40C0 5D4C         DATA    ADSR
 138  40C2 04           BYTE    >04
 139  40C3 4144         TEXT    'ADSR'                  APEDSK99 load DSR
 139  40C5 5352  
 140  40C7 0000         EVEN
 141            *
 142  40C8 0000 PWRUP   DATA    >0000                   power-up chain (no more)
 143  40CA 40F4         DATA    EPWRUP                  address of power-up routine
 144  40CC 0000         DATA    >0000                   no name
 145                                                    
 146  40CE 40D6 DSR01   DATA    DSR02                   DSR chain
 147  40D0 4E26         DATA    EDSR01                  address of DSR
 148  40D2 03           BYTE    >03                     name size
 149  40D3 4453         TEXT    'DSK'                   DSR name
 149  40D5 4B    
 150  40D6 40E0 DSR02   DATA    DSR03                   
 151  40D8 4E34         DATA    EDSR02                  
 152  40DA 04           BYTE    >04                     
 153  40DB 4453         TEXT    'DSK1'                  
 153  40DD 4B31  
 154  40DF 0000         EVEN                            
 155  40E0 40EA DSR03   DATA    DSR04                   
 156  40E2 4E3A         DATA    EDSR03                  
 157  40E4 04           BYTE    >04                     
 158  40E5 4453         TEXT    'DSK2'                  
 158  40E7 4B32  
 159  40E9 0000         EVEN                            
 160  40EA 0000 DSR04   DATA    >0000                   no more
 161  40EC 4E40         DATA    EDSR04                  
 162  40EE 04           BYTE    >04                     
 163  40EF 4453         TEXT    'DSK3'                  
 163  40F1 4B33  
 164  40F3 0000         EVEN            
 165            *
 166            *=====================================
 167            * Power-up routine
 168            *=====================================                                          
 169  40F4 028C EPWRUP  CI      R12,>1000               Dhr. F.G. Kaal check: are we powering up 1st CRU (>1000) peripheral?
 169  40F6 1000  
 170  40F8 1633         JNE     NOCRU                   nope; return
 171            
 172  40FA C1CB         MOV     R11,R7                  yes; save return address
 173  40FC 02A9         STWP    R9                      get workspace (should be >83E0)
 174  40FE 0229         AI      R9,-224                 point to top of scratch-pad mem (>8300)
 174  4100 FF20  
 175            *       MOV     @>0070(R9),R0           highest free address in vdp mem (>8370)
 176  4102 C0A9         MOV     @>0070(R9),R2           APEDSK99: use VDPWRI (VDPSET is redundant)
 176  4104 0070  
 177            *       MOV     R0,R2                   save it
 178  4106 C002         MOV     R2,R0                   APEDSK99: use VDPWRI (VDPSET is redundant)
 179            *       AI      R0,-2088                we'll need >828 bytes
 180  4108 0222         AI      R2,-2088                APEDSK99: use VDPWRI (VDPSET is redundant)
 180  410A F7D8  
 181            *       MOV     R0,@>0070(R9)           update address
 182  410C CA42         MOV     R2,@>0070(R9)           APEDSK99: use VDPWRI (VDPSET is redundant)
 182  410E 0070  
 183            *       INC     R0                      
 184  4110 0582         INC     R2                      APEDSK99: use VDPWRI (VDPSET is redundant)
 185            *       BL      @VDPSET                 set VDP address
 186  4112 06A0         BL      @VDPWRI                 APEDSK99: use VDPWRI (VDPSET is redundant)
 186  4114 440C  
 187  4116 0201         LI      R1,2088                 
 187  4118 0828  
 188  411A 04EF H001    CLR     @-2(R15)                clear these >828 bytes
 188  411C FFFE  
 189  411E 0601         DEC     R1                      
 190  4120 16FC         JNE     H001                    
 191            *       BL      @VDPSET                 set VDP address (same)
 192  4122 06A0         BL      @VDPWRI                 APEDSK99: use VDPWRI (VDPSET is redundant)
 192  4124 440C  
 193  4126 0203         LI      R3,>AA03                        
 193  4128 AA03  
 194  412A DBC3         MOVB    R3,@-2(R15)             write buffer ID mark
 194  412C FFFE  
 195  412E 1000         NOP                             
 196            *       MOVB    R2,@-2(R15)             write old highest free address
 197  4130 DBC0         MOVB    R0,@-2(R15)             APEDSK99: use VDPWRI (VDPSET is redundant)
 197  4132 FFFE  
 198            *       SWPB    R2                      
 199  4134 06C0         SWPB    R0                      APEDSK99: use VDPWRI (VDPSET is redundant)
 200            *       MOVB    R2,@-2(R15)                     
 201  4136 DBC0         MOVB    R0,@-2(R15)             APEDSK99: use VDPWRI (VDPSET is redundant)
 201  4138 FFFE  
 202  413A 1000         NOP                             
 203  413C DBCC         MOVB    R12,@-2(R15)            write CRU address (>1000 for APEDSK99)
 203  413E FFFE  
 204  4140 06C3         SWPB    R3                      
 205  4142 DBC3         MOVB    R3,@-2(R15)             write number of files (3)
 205  4144 FFFE  
 206  4146 06A0         BL      @PRPRTN                 preparation routine
 206  4148 4500  
 207  414A 06A0         BL      @CALSUB                 call subroutine
 207  414C 4432  
 208  414E 439C         DATA    RSTDRV                  reset all drives
 209  4150 04E9         CLR     @>0054(R9)              name length = 0 for power-up
 209  4152 0054  
 210  4154 0429         BLWP    @>005A(R9)              retrieve R7 (saved by PRPRTN)
 210  4156 005A  
 211  4158 0011         DATA    >0011                   put it into R11
 212  415A CA60         MOV     @K001,@>006C(R9)        ???
 212  415C 4162  
 212  415E 006C  
 213  4160 045B NOCRU   B       *R11                    return
 214                                                    
 215  4162 0404 K001    DATA    >0404                   
 216                                                    
 217            *VDPSET ORI     R0,>4000                set VDP for a write
 218            *       SWPB    R0                      
 219            *       MOVB    R0,*R15                 pass address
 220            *       SWPB    R0                      
 221            *       MOVB    R0,*R15                 
 222            *       B       *R11                    
 223            
 224            *---------------------------------------
 225            * Sector read/write
 226            *---------------------------------------                                        
 227            *SECRW1 LI      R4,10                   try ten times. APEDSK99: no need to retry
 228  4164 DA60 SECRW1  MOVB    @K002,@>0050(R9)        APEDSK99: no error
 228  4166 4428  
 228  4168 0050  
 229            *SECRW2 MOVB    @K002,@>0050(R9)        no error
 230  416A 06A0         BL      @SELDRV                 select drive
 230  416C 4340  
 231  416E 06A0         BL      @LASTRK                 point to # of last track
 231  4170 43E8  
 232  4172 04C0         CLR     R0                      
 233  4174 D02F         MOVB    @-1026(R15),R0          get # of last track accessed
 233  4176 FBFE  
 234            *       CI      R0,>D700                inverted
 235  4178 0280         CI      R0,>2800                APEDSK99: none of this inverting databus rubbish
 235  417A 2800  
 236            *       JH      H002                    too high: drive was reset
 237  417C 1A03         JL      H002                    APEDSK99: last track within range
 238  417E 06A0         BL      @SKTRK0                 seek track 0
 238  4180 4384  
 239            *       SETO    R0                      
 240  4182 04C0         CLR     R0                      APEDSK99: none of this inverting databus rubbish
 241  4184 D800 H002    MOVB    R0,@WTRACK              place last track or >00 in track register
 241  4186 5FFA  
 242  4188 C069         MOV     @>004A(R9),R1           sector #
 242  418A 004A  
 243            *       SBZ     7                       side 0
 244  418C 5820         SZCB    @K006,@CRUWRI           APEDSK99: side 0 
 244  418E 4429  
 244  4190 5FEE  
 245  4192 04C7         CLR     R7                      
 246  4194 0281         CI      R1,>02D0                max 720 (DS/SD)
 246  4196 02D0  
 247  4198 1424         JHE     H003                    error 7
 248  419A 0281         CI      R1,>0168                on which side is it?
 248  419C 0168  
 249  419E 1A08         JL      H004                    0-359: on side 0 
 250            *       AI      R1,-719                 on side 1: sector # grow from in to out
 251  41A0 0221         AI      R1,-360                 APEDSK99: KISS and use DOAD scheme:
 251  41A2 FE98  
 252            *       ABS     R1                      719 - sector #
 253            *       CLR     R0                      
 254            *       DIV     @K003,R0                sect/track (=9)
 255            *       AI      R1,-8                   invert: 8=0, 0=8, 7=1, etc
 256            *       ABS     R1                      
 257            *       SBO     7                       side 1
 258  41A4 F820         SOCB    @K006,@CRUWRI           APEDSK99: side 1
 258  41A6 4429  
 258  41A8 5FEE  
 259  41AA 0207         LI      R7,>0100                side number = >01
 259  41AC 0100  
 260            *       JMP     H005                    
 261  41AE 1005         JMP     H006                    APEDSK99: skipped DIV above
 262  41B0 0281 H004    CI      R1,>0001                is it sector 0 or 1?
 262  41B2 0001  
 263  41B4 1B02         JH      H006                    no
 264  41B6 06A0         BL      @SKTRK0                 yes: seek track 0
 264  41B8 4384  
 265  41BA 04C0 H006    CLR     R0                      
 266  41BC 3C20         DIV     @K003,R0                R0=track #, R1=sector #
 266  41BE 442A  
 267  41C0 06C0 H005    SWPB    R0                      
 268            *       INV     R0                      APEDSK99: none of this inverted databus rubbish         
 269  41C2 06A0         BL      @VDPWRI                 set VDP to write
 269  41C4 440C  
 270  41C6 DBC0         MOVB    R0,@-2(R15)             save # of last track accessed
 270  41C8 FFFE  
 271  41CA D800         MOVB    R0,@WDATA               pass to data register
 271  41CC 5FFE  
 272  41CE 06C1         SWPB    R1                      
 273            *       INV     R1                      APEDSK99: none of this inverted databus rubbish
 274  41D0 D801         MOVB    R1,@WSECTR              pass new sector # to sector register
 274  41D2 5FFC  
 275  41D4 9800         CB      R0,@RTRACK              new track # same as current?
 275  41D6 5FF2  
 276            *       JEQ     H007                    yes
 277  41D8 1307         JEQ     H013                    APEDSK99: yes (don't need READ ID to check side)
 278  41DA 06A0         BL      @SNDCMD                 send command
 278  41DC 43E0  
 279            *       DATA    >E100                   seek h=1 V=1 r1r0=10
 280  41DE 1E00         DATA    >1E00                   APEDSK99: seek
 281  41E0 1003         JMP     H013                    APEDSK99: don't need READ ID to check side
 282            *       BL      @WTCPT1                 APEDSK99: wait for command completion / error check not relevant
 283            *       SLA     R0,13                   test seek error bit
 284            *       JOC     H008                    try again, then error 11
 285            *H007   LI      R6,5                    APEDSK99: H007 re-arranged to sync proper ID byte read
 286            *       MOV     R6,@RDINT               APEDSK99: interrupt Arduino for read operation
 287            *       BL      @SNDCMD                 send command
 288            *       DATA    >3F00                   read ID E=0
 289            *       DATA    >C000                   APEDSK99: read ID
 290            *       SBO     2                       enable hold
 291            *       MOVB    @RDATA,R0               skip track #
 292            *       DEC     @RDINT          
 293            *       MOVB    @RDATA,R5               side #
 294            *       INV     R5                      APEDSK99: none of this inverted databus rubbish
 295            *H009   MOVB    @RDATA,R0               skip next 4 bytes
 296            *       DEC     R6                      
 297            *       DEC     @RDINT                  APEDSK99: interrupt Arduino for read operation
 298            *       JNE     H009                    
 299            *       BL      @WTCPT2                 SBZ 2, wait for command completion
 300            *       BL      @WTCPT1                 APEDSK99: wait for command completion / error check not relevant
 301            *       SLA     R0,13                   test status bits
 302            *       JOC     H010                    not found: try again, then error 21
 303            *       JLT     H011                    crc error: try again, then error 22
 304            *       SLA     R0,2                    
 305            *       JOC     H012                    lost data: try again, then error 23
 306            *       CB      R7,R5                   side # matches?
 307            *       JEQ     H013                    yes: sector found, now access it
 308                                                    
 309            *       BL      @ERROR1                 no: error 6
 310            *       DATA    >0600                   
 311            *H008   BL      @ERROR2                 gracefull error 11
 312            *       DATA    >1100                   
 313  41E2 06A0 H003    BL      @ERROR1                 error 7
 313  41E4 43CA  
 314  41E6 0700         DATA    >0700                   
 315            *H010   BL      @ERROR2                 gracefull error 21
 316            *       DATA    >2100                   
 317            *H011   BL      @ERROR2                 gracefull error 22
 318            *       DATA    >2200                   
 319            *H012   BL      @ERROR2                 gracefull error 23
 320            *       DATA    >2300                   
 321                                                    
 322            *H013   MOVB    R1,@WSECTR              load sector register APEDSK: already done above
 323  41E8 C0A9 H013    MOV     @>004E(R9),R2           data buffer address
 323  41EA 004E  
 324  41EC D029         MOVB    @>004D(R9),R0           read or write ?
 324  41EE 004D  
 325  41F0 1313         JEQ     H014                    write
 326  41F2 06A0         BL      @VDPWRI                 read FD = write to VDP buffer
 326  41F4 440C  
 327  41F6 0206 H015    LI      R6,256                  APEDSK99: re-arranged H015 to sync reading sector bytes
 327  41F8 0100  
 328  41FA C806         MOV     R6,@RDINT               APEDSK99: interrupt Arduino for read operation 
 328  41FC 5FEA  
 329  41FE 06A0         BL      @SNDCMD                 send command
 329  4200 43E0  
 330            *       DATA    >7700                   read sector m=0 S=1 E=0 C=0
 331  4202 8800         DATA    >8800                   APEDSK99: read sector
 332            *       SETO    R5                      
 333            *       SBO     2       
 334            *       MOVB    @>004D(R9),R0           read or write?
 335            *       JNE     H016                    read
 336            *       CLR     R0                      write: now we must verify
 337            *H017   MOVB    @RDATA,R0               get a byte from FDC 
 338            *       AB      @-1026(R15),R0          compare with byte in data buffer
 339            *       CI      R0,>FF00                
 340            *       JNE     H018                    mismatch
 341            *       SZCB    @RDATA,R0               again
 342            *       SB      @-1026(R15),R0                  
 343            *       JNE     H018                    mismatch
 344            *       DECT    R6                      
 345            *       DEC     R6                      APEDSK99: interrupt Arduino for read operation
 346            *       JNE     H017                    next byte
 347            *       JMP     H019                    done
 348  4204 D020 H016    MOVB    @RDATA,R0               get 1 byte from FDC
 348  4206 5FF6  
 349            *       INV     R0                      APEDSK99: none of that inverted databus rubbish
 350  4208 DBC0         MOVB    R0,@-2(R15)             save it to VDP
 350  420A FFFE  
 351            *       MOVB    @RDATA,R0               again
 352            *       INV     R0                      APEDSK99: none of that inverted databus rubbish
 353            *       MOVB    R0,@-2(R15)                     
 354            *       DECT    R6                      
 355  420C 0620         DEC     @RDINT                  APEDSK99: interrupt Arduino for read operation
 355  420E 5FEA  
 356  4210 16F9         JNE     H016                    next byte
 357  4212 04C5 H019    CLR     R5                      clear flag
 358            *H018   BL      @WTCPT2                 SBZ 2, wait for command completion
 359            *       BL      @WTCPT1                 APEDSK99: no need to wait for command completion
 360            *       SLA     R0,13                   test status bits
 361            *       JOC     H020                    not found: try again, then error 21
 362            *       JLT     H021                    crc error: try again, then error 22
 363            *       MOV     R5,R5                   
 364            *       JNE     H022                    try again, then error 28
 365            *       SLA     R0,2                    
 366            *       JOC     H023                    lost data: try again, then error 23
 367  4214 0460         B       @RTURN1                 return
 367  4216 4450  
 368                                                    
 369            *H020   BL      @ERROR2                 gracefull error 21
 370            *       DATA    >2100                                                           
 371            *H021   BL      @ERROR2                 gracefull error 22
 372            *       DATA    >2200                   
 373            *H023   BL      @ERROR2                 gracefull error 23
 374            *       DATA    >2300                   
 375            *H022   BL      @ERROR2                 gracefull error 28
 376            *       DATA    >2800                   
 377                                                    
 378  4218 06A0 H014    BL      @VDPRD                  write to FD = read from VDP buffer
 378  421A 4416  
 379  421C 0206         LI      R6,256                  256 bytes to write
 379  421E 0100  
 380            * APEDSK99: the first byte to be written 
 381            * needs to be in the data register 
 382            * before the write command is given
 383  4220 D02F         MOVB    @-1026(R15),R0          APEDSK99: get a byte from data buffer
 383  4222 FBFE  
 384  4224 D800         MOVB    R0,@WDATA               APEDSK99: write first byte to data register
 384  4226 5FFE  
 385  4228 06A0         BL      @SNDCMD                 send command
 385  422A 43E0  
 386            *       DATA    >5700                   write sector m=0 S=1 E=0 C=0 a=0
 387  422C A800         DATA    >A800                   APEDSK99: write sector
 388            *       SBO     2                       enable holds
 389  422E D02F H024    MOVB    @-1026(R15),R0          get a byte from data buffer
 389  4230 FBFE  
 390            *       INV     R0                      APEDSK99: none of this inverting databus rubbish
 391  4232 D800         MOVB    R0,@WDATA               pass it to data register
 391  4234 5FFE  
 392            *       MOVB    @-1026(R15),R0          again
 393            *       INV     R0                      APEDSK99: none of this inverting databus rubbish
 394            *       MOVB    R0,@WDATA                       
 395            *       DECT    R6                      
 396  4236 0606         DEC     R6                      
 397  4238 16FA         JNE     H024                    next byte
 398            *       BL      @WTCPT2                 SBZ 2, wait for command completion
 399  423A 06A0         BL      @WTCPT1                 APEDSK99: check for Write Protect
 399  423C 4332  
 400            *       SLA     R0,11                   test status bits
 401  423E 0A20         SLA     R0,2                    APEDSK99: WP bit in Carry
 402  4240 1801         JOC     ERROR3                  write protect: error 34
 403            *       SLA     R0,2                    
 404            *       JOC     H025                    not found: try again, then error 31
 405            *       SLA     R0,2                    
 406            *       JOC     H026                    lost data: try again, then error 33
 407            *       BL      @VDPRD                  now, set VDP to read
 408            *       JMP     H015                    and verify sector
 409  4242 10E7         JMP     H019                    APEDSK99: no need to verify             
 410                                                    
 411  4244 06A0 ERROR3  BL      @ERROR1                 error 34 (Write Protect)
 411  4246 43CA  
 412  4248 3400         DATA    >3400                   
 413            *H025   BL      @ERROR2                 gracefull error 31
 414            *       DATA    >3100                   
 415            *H026   BL      @ERROR2                 gracefull error 33
 416            *       DATA    >3300                   
 417            
 418            *---------------------------------------
 419            * Format disk
 420            *---------------------------------------                                        
 421  424A 04E9 FMTDSK  CLR     @>004A(R9)              called by subprogram >11
 421  424C 004A  
 422            *
 423            * APEDSK: no need to check for DSR version
 424            *       MOVB    @>004C(R9),R8           DSR version + drive #
 425            *       SRL     R8,12                   keep version only
 426            *       JEQ     H027                    0: standard format
 427            *       C       R8,@K002                        
 428            *       JEQ     H027                    1: needs DSR version 2 (this one)
 429            *       BL      @ERROR1                 2: needs another version
 430            *       DATA    >0700                   returns with error 7
 431                                                    
 432  424E 5A60 H027    SZCB    @K004,@>004C(R9)        clear DSR version flags
 432  4250 442D  
 432  4252 004C  
 433  4254 9829         CB      @>0051(R9),@K005        double sided?
 433  4256 0051  
 433  4258 4430  
 434  425A 1602         JNE     H028                    no
 435  425C 0729         SETO    @>004A(R9)              yes: set flag
 435  425E 004A  
 436  4260 DA60 H028    MOVB    @K002,@>0050(R9)        no error
 436  4262 4428  
 436  4264 0050  
 437  4266 06A0         BL      @SELDRV                 select drive
 437  4268 4340  
 438  426A 06A0         BL      @SKTRK0                 seek track 0
 438  426C 4384  
 439  426E 04C3         CLR     R3                      init track counter
 440  4270 CA69 H030    MOV     @>004A(R9),@>004A(R9)   check # of sides flag
 440  4272 004A  
 440  4274 004A  
 441  4276 1307         JEQ     H029                    single-side
 442            *       SBO     7                       set CRU bit for side 1
 443  4278 F820         SOCB    @K006,@CRUWRI           APEDSK99: set CRU bit for side 1
 443  427A 4429  
 443  427C 5FEE  
 444  427E 0207         LI      R7,>0100                value for side 1 in sector ID
 444  4280 0100  
 445  4282 06A0         BL      @FMTTRK                 format one track
 445  4284 42D4  
 446            *H029   SBZ     7                       set CRU bit for side 0
 447  4286 5820 H029    SZCB    @K006,@CRUWRI           APEDSK99: set CRU bit for side 0
 447  4288 4429  
 447  428A 5FEE  
 448  428C 04C7         CLR     R7                      >00 = value for side 0 in sector ID
 449  428E 06A0         BL      @FMTTRK                 format one track
 449  4290 42D4  
 450  4292 06A0         BL      @SNDCMD                 send command
 450  4294 43E0  
 451            *       DATA    >A500                   step-in (T=1, h=1, V=0, r0r1=10)
 452  4296 5A00         DATA    >5A00                   APEDSK99: step-in
 453            *       BL      @WTCPT1                 APEDSK99: wait for command completion and error check not relevant
 454  4298 0223         AI      R3,>0100                one more track
 454  429A 0100  
 455  429C 9A43         CB      R3,@>004D(R9)           all done?
 455  429E 004D  
 456  42A0 16E7         JNE     H030                    no: format next one
 457  42A2 CA69         MOV     @>004A(R9),@>004A(R9)   check # of sides
 457  42A4 004A  
 457  42A6 004A  
 458  42A8 1304         JEQ     H031                    single-side
 459            *       SBO     7                       
 460            *       SOCB    @K006,@CRUWRI           APEDSK99: select side 1
 461            *       LI      R4,10                   try 10 times
 462            *READID BL      @SKTRK0                 seek track 0
 463            *       MOV     @>004E(R9),R2           data buffer address
 464            *       BL      @VDPWRI                 set VDP to write
 465            *       LI      R6,5                    read 6 bytes (APEDSK99: first will be available as part of @SNDCMD 
 466            *       MOV     R6,@RDINT               APEDSK99: slightly re-arranged READID/H032 to sync ID byte reads
 467            *       BL      @SNDCMD                 send command
 468            *       DATA    >3F00                   read ID (E=0)
 469            *       DATA    >C000                   APEDSK99: read ID
 470            *       SBO     2                       enable wait states
 471            *H032   MOVB    @RDATA,R0               read data register
 472            *       INV     R0                      APEDSK99: none of that inverted databus rubbish
 473            *       MOVB    R0,@-2(R15)             write it to data buffer
 474            *       MOVB    @RDATA,R0               again, why write this twice ?
 475            *       INV     R0                      APEDSK99: none of that inverted databus rubbish
 476            *       MOVB    R0,@-2(R15)                     
 477            *       DECT    R6                      
 478            *       DEC     @RDINT                  APEDSK99: generate interrupt for next read
 479            *       JNE     H032                    
 480            *       BL      @WTCPT2                 SBZ 2 then wait for command completion
 481            *       BL      @WTCPT1                 APEDSK99: wait for command completion and error check not relevant
 482            *       SLA     R0,13                   check status bits
 483            *       JOC     H033                    not found
 484            *       JLT     H034                    CRC error
 485            *       SLA     R0,2                    
 486            *       JOC     H035                    lost data
 487            *       MOV     @>004E(R9),R2           address of data buffer
 488            *       INC     R2                      skip track #
 489            *       BL      @VDPRD                  set VDP to read from it
 490            *       CLR     R0                      
 491            *       MOVB    @-1026(R15),R0          read one byte
 492            *       JEQ     H031                    side 0
 493  42AA D029         MOVB    @>004D(R9),R0           side 1: get tracks/side
 493  42AC 004D  
 494  42AE 0A10         SLA     R0,1                    times two (since 2 sides)
 495  42B0 1005         JMP     H036                    
 496  42B2 DA60 H031    MOVB    @K006,@>0051(R9)        single sided (>01) @>8351
 496  42B4 4429  
 496  42B6 0051  
 497  42B8 D029         MOVB    @>004D(R9),R0           get # of tracks
 497  42BA 004D  
 498  42BC 0980 H036    SRL     R0,8                    make it a word
 499  42BE 3820         MPY     @K003,R0                times # of sectors per track
 499  42C0 442A  
 500  42C2 CA41         MOV     R1,@>004A(R9)           pass total # of sectors per disk
 500  42C4 004A  
 501  42C6 DA60         MOVB    @K007,@>004D(R9)        pass # of sectors per track
 501  42C8 442B  
 501  42CA 004D  
 502            *
 503  42CC 06A0         BL      @NTPDT                  APEDSK99: update DOAD FAT time/date
 503  42CE 5EFC  
 504            *
 505  42D0 0460         B       @RTURN1                 return
 505  42D2 4450  
 506                                                    
 507            *       BL      @ERROR2                 try again, or error >21
 508            *       DATA    >2101                   
 509            *H034   BL      @ERROR2                 try again, or error >22
 510            *       DATA    >2201                   
 511            *H035   BL      @ERROR2                 try again, or error >23
 512            *       DATA    >2301                   
 513                                                    
 514  42D4 C20B FMTTRK  MOV     R11,R8                  format a track
 515  42D6 C0A9         MOV     @>004E(R9),R2           
 515  42D8 004E  
 516  42DA 06A0         BL      @VDPWRI                 set VDP to write to data buffer
 516  42DC 440C  
 517            *       LI      R6,22                   write 22 sync bytes >00
 518  42DE 04C2         CLR     R2                      sector counter
 519            *       JMP     H037                    
 520            *H038   LI      R6,6                    write 6 sync bytes >00
 521            *H037   MOVB    @K002,@-2(R15)                  
 522            *       DEC     R6                      
 523            *       JNE     H037                    
 524            *       MOVB    @K015,@-2(R15)          write >FE (will be ID mark)
 525            *       NOP                             
 526            *       MOVB    R3,@-2(R15)             write track #
 527            *       NOP                             
 528            *       MOVB    R7,@-2(R15)             write side #
 529            *       MOVB    R3,R0                   track number
 530            *       SRL     R0,8                    make it a word
 531            *       SWPB    R7                      
 532            *       MPY     @K008(R7),R0            times >00 for side 1, >06 for side 0
 533            *       SWPB    R7                      
 534            *       A       R2,R1                   add # of sectors prepared
 535            *       DIV     @K003,R0                divide by sectors/track
 536            *       MOVB    @K009(R1),@-2(R15)      sector #, according to interlacing pattern
 537            *       LI      R6,-20                  write 20 times
 538            *H039   MOVB    @K010(R6),@-2(R15)      code for a CRC
 539            *       INC     R6                      
 540            *       JNE     H039                    one more
 541  42E0 0200         LI      R0,>E5E5                data to put in empty sectors
 541  42E2 E5E5  
 542  42E4 06A0 H038    BL      @VDPRPW                 write it 256 times
 542  42E6 4326  
 543  42E8 0100         DATA    256                     
 544            *       MOVB    @K010,@-2(R15)          write code to CRC
 545            *       SETO    R0                      >FF filler bytes
 546            *       BL      @VDPRPW                 write it 45 times
 547            *       DATA    45                      
 548  42EA 0582         INC     R2                      # of sectors prepared
 549  42EC 0282         CI      R2,9                    
 549  42EE 0009  
 550  42F0 16F9         JNE     H038                    one more
 551            *       BL      @VDPRPW                 write 231 more >FF at end of track
 552            *       DATA    231                     
 553                                                    
 554            *       LI      R4,3                    try 3 times
 555  42F2 D0A9 H040    MOVB    @>004E(R9),R2           top of data buffer
 555  42F4 004E  
 556  42F6 06A0         BL      @VDPRD                  set VDP to read from it
 556  42F8 4416  
 557            * APEDSK99: the first byte to be written needs to be in the data register 
 558            * before the write command is given
 559  42FA D02F         MOVB    @-1026(R15),R0          read one byte from buffer
 559  42FC FBFE  
 560  42FE D800         MOVB    R0,@WDATA               send it to data register
 560  4300 5FFE  
 561  4302 06A0         BL      @SNDCMD                 send command
 561  4304 43E0  
 562            *       DATA    >0B00                   write track (E=1)
 563  4306 F400         DATA    >F400                   APEDSK99: write track
 564            *       LI      R6,3235                 3235 bytes to write
 565  4308 0206         LI      R6,2303                 APEDSK99: 9*256=2304 bytes to write but 1st has been written already
 565  430A 08FF  
 566            *       SBO     2                       enable wait states
 567  430C D02F H041    MOVB    @-1026(R15),R0          read one byte from buffer
 567  430E FBFE  
 568            *       INV     R0                      APEDSK99: none of this inverting databus rubbish
 569  4310 D800         MOVB    R0,@WDATA               send it to data register
 569  4312 5FFE  
 570            *       MOVB    @-1026(R15),R0          why on earth is it done like that???
 571            *       INV     R0                      APEDSK99: none of this inverting databus rubbish
 572            *       MOVB    R0,@WDATA               send next byte
 573            *       DECT    R6                      
 574  4314 0606         DEC     R6                      
 575            *       JGT     H041                    next byte
 576  4316 16FA         JNE     H041                    APEDSK99: next byte
 577            *       BL      @WTCPT2                 SBZ 2, then wait for command completion
 578  4318 06A0         BL      @WTCPT1                 APEDSK99: check Write Protect
 578  431A 4332  
 579            *       SLA     R0,11                   check write protect bit
 580  431C 0A20         SLA     R0,2                    APEDSK99: WP bit in Carry
 581            *       JNC     H042                    
 582  431E 1702         JNC     H043                    APEDSK99: not set, continue
 583  4320 0460         B       @ERROR3                 error code >34 (Write Protect)
 583  4322 4244  
 584            *H042   SLA     R0,4                    test lost data bit
 585            *       JNC     H043                    ok: return
 586            *       DEC     R4                      shall we try again?
 587            *       JNE     H040                    yes
 588            *       BL      @ERROR1                 no: error code >33
 589            *       DATA    >3300                   
 590  4324 0458 H043    B       *R8                     return
 591                                                    
 592  4326 C1BB VDPRPW  MOV     *R11+,R6                VDP repeated write
 593  4328 DBC0 H044    MOVB    R0,@-2(R15)
 593  432A FFFE  
 594  432C 0606         DEC     R6                      byte in R0
 595  432E 16FC         JNE     H044                    number of repeats in data word
 596  4330 045B         B       *R11                    
 597            
 598            *WTCPT2 SBZ     2                       wait for command completion                             
 599  4332 D020 WTCPT1  MOVB    @RSTAT,R0               get status. APEDSK99: Not Ready >80 / Write Protect >40
 599  4334 5FF0  
 600            *       INV     R0                      APEDSK99: none of that inverted databus rubbish
 601  4336 1101         JLT     ERROR4                  drive not ready. APEDSK99: Not Ready set when DOAD file is unavailable
 602            *       SRC     R0,9                    
 603            *       JOC     WTCPT1                  FDC busy: keep waiting. APEDSK99: no busy condition
 604  4338 045B         B       *R11                    
 605  433A 06A0 ERROR4  BL      @ERROR1                 exit with error code 6, reseting all drives
 605  433C 43CA  
 606  433E 0600         DATA    >0600                   
 607                                                    
 608  4340 C1CB SELDRV  MOV     R11,R7                  select a drive
 609  4342 C0A9         MOV     @>0058(R9),R2
 609  4344 0058  
 610  4346 0222         AI      R2,-10                  point to drive info
 610  4348 FFF6  
 611  434A 06A0         BL      @VDPRD                  set VDP to read
 611  434C 4416  
 612  434E D02F         MOVB    @-1026(R15),R0          get # of last drive accessed
 612  4350 FBFE  
 613  4352 04C5         CLR     R5                      clear flag
 614  4354 9A40         CB      R0,@>004C(R9)           same as the one to be formatted?
 614  4356 004C  
 615  4358 1301         JEQ     H055                    yes
 616  435A 0705         SETO    R5                      no: set flag
 617  435C 04C0 H055    CLR     R0                      
 618  435E D029         MOVB    @>004C(R9),R0           get drive #
 618  4360 004C  
 619  4362 130D         JEQ     H056                    can't be >00: error #7
 620  4364 06A0         BL      @VDPWRI                 set VDP to write, address in R2
 620  4366 440C  
 621  4368 DBC0         MOVB    R0,@-2(R15)             modify last drive accessed
 621  436A FFFE  
 622  436C 06C0         SWPB    R0                      
 623  436E 0280         CI      R0,>0003                        
 623  4370 0003  
 624  4372 1B05         JH      H056                    drive number can't be higher than 3: error #7
 625            *       LI      R2,>0080                        
 626            *       SLA     R2,0                    proper drive selection bit: >01 >02 or >04
 627            *       AI      R12,8                   CRU address of drive selection bits (4-6)
 628            *       MOV     R5,R5                   test same drive flag
 629            *       JEQ     H057                    
 630            *       LDCR    @K011,3                 deselect all drives
 631            *       SZCB    @DSDRVS,@CRUWRI         APEDSK99: deselect all drives + side
 632            *       AI      R12,-6                  selection bits are echoed in CRU bits 1-3
 633            *       STCR    R0,3                    load CRU bits 2-4
 634            *       MOVB    @CRURD,R0               APEDSK99: read drive selection bits etc
 635            *       SRA     R0,4                    APEDSK99: preserve drive selection bits (HLD bit 0 always 0)
 636            *       AI      R12,6                   back to bits 4-6
 637            *       CZC     R2,R0                   echoed properly? HELP
 638            *       JEQ     H057                    yes: go on      
 639            *       CLR     R0                      
 640            *       MOV     @>0058(R9),R2           point to drive info
 641            *       AI      R2,-10                  
 642            *       BL      @VDPWRI                 set VDP to write to address in R2
 643            *       MOVB    R0,@-2(R15)             clear last drive accessed
 644            *       AI      R12,-8                  back to CRU base
 645            *       BL      @ERROR1                 exit with device error
 646            *       BYTE    >06                     
 647            *K011   BYTE    >00                     
 648                                                    
 649            *H057   LDCR    R2,3                    select drive
 650  4374 06C0 H057    SWPB    R0                      APEDSK99: drive # back in MSB
 651  4376 0A10         SLA     R0,1                    APEDSK99: bit 0 is side select, 1-3 is drive #
 652  4378 D800         MOVB    R0,@CRUWRI              APEDSK99: select drive
 652  437A 5FEE  
 653            *       AI      R12,-8                  back to cru base
 654            *       MOV     R5,R5                   test same drive flag
 655            *       JEQ     H058                    same: return
 656            *       LI      R0,3000                 different: wait while drive gets ready
 657            *H059   SRC     R5,4                    APEDSK99: we don't need to wait for no drive
 658            *       SRC     R5,4                    
 659            *       DEC     R0                      
 660            *       JNE     H059                    keep waiting
 661  437C 0457 H058    B       *R7                     
 662                                                    
 663  437E 06A0 H056    BL      @ERROR1                 exit with error #7
 663  4380 43CA  
 664  4382 0700         DATA    >0700                   
 665                                                    
 666  4384 C20B SKTRK0  MOV     R11,R8                  seek track 0
 667  4386 06A0         BL      @SNDCMD
 667  4388 43E0  
 668            *       DATA    >F500                   send restore command (h=1, V=0, r0r1=10)
 669  438A 0A00         DATA    >0A00                   APEDSK99: send Restore command
 670            *       BL      @WTCPT1                 APEDSK not relevant: wait for command completion
 671            *       BL      @CKTRK0                 APEDSK not relevant: test if track 0 reached, error it not
 672  438C 06A0         BL      @LASTRK                 set VDP to read last track #
 672  438E 43E8  
 673  4390 06A0         BL      @VDPWRI                 set VDP to write at same address
 673  4392 440C  
 674  4394 DBE0         MOVB    @K012,@-2(R15)          set last track # as >FF for this drive
 674  4396 442E  
 674  4398 FFFE  
 675  439A 0458         B       *R8                     
 676                                                    
 677            *CKTRK0 MOVB    @RSTAT,R0               check if track 0 reached
 678            *       INV     R0                      APEDSK99: none of that inverted databus rubbish
 679            *       SLA     R0,6                    test the track 0 bit
 680            *       JOC     H060                    
 681            *       B       @ERROR3                 exit with error code 6, reseting all drives
 682            *H060   B       *R11                    
 683            
 684            *RSTDRV AI      R12,8                   reset all drives
 685  439C 5820 RSTDRV  SZCB    @DSDRVS,@CRUWRI         APEDSK99: reset all drives including side
 685  439E 4431  
 685  43A0 5FEE  
 686            *       LDCR    @K002,4                 no drive selected
 687            *       AI      R12,-8                  
 688            *       SBZ     1                       motor strobe
 689            *       SBO     1                       
 690  43A2 D820         MOVB    @K013,@WCOMND           send Force Interrupt with no interrupt flag set
 690  43A4 43DA  
 690  43A6 5FF8  
 691  43A8 C0A9         MOV     @>0058(R9),R2           ptr to VIB buffer
 691  43AA 0058  
 692  43AC 0222         AI      R2,-10                  now points to drive info buffer
 692  43AE FFF6  
 693  43B0 06A0         BL      @VDPWRI                 set VDP to write to address in R2
 693  43B2 440C  
 694  43B4 0200         LI      R0,4                    
 694  43B6 0004  
 695  43B8 DBC0 H061    MOVB    R0,@-2(R15)             write four >00 (i.e. clear drive info)
 695  43BA FFFE  
 696  43BC 0600         DEC     R0                      
 697  43BE 16FC         JNE     H061                    
 698            *       BL      @WTCPT2                 test status, reset drives if not ready
 699            *       BL      @WTCPT1                 APEDSK99: no need to wait for command completion and error check
 700  43C0 DA60         MOVB    @K002,@>0050(R9)        no error
 700  43C2 4428  
 700  43C4 0050  
 701  43C6 0460         B       @RTURN1                 get return address from stack
 701  43C8 4450  
 702                                                    
 703            *ERROR2 DEC     R4                      gracefull error
 704            *       JEQ     ERROR1                  no more tries: error
 705            *ERROR2 JMP     ERROR1                  APEDSK
 706            *       MOV     *R11,R11                try again: get data word
 707            *       SRC     R11,1                   test return flag
 708            *       JNC     H062                    
 709            *       B       @READID                 back to read ID in format routine
 710            *H062   CI      R4,5                    
 711            *       JH      H063                    
 712            *       BL      @SKTRK0                 last 5 tries: seek track 0
 713            *H063   B       @SECRW2                 back to sector r/w routine
 714            *H063   B       @SECRW1                 back to sector r/w routine
 715                                                    
 716  43CA C01B ERROR1  MOV     *R11,R0                 exit with error
 717  43CC DA40         MOVB    R0,@>0050(R9)           place err code in >8350
 717  43CE 0050  
 718  43D0 0280         CI      R0,>0600                check if device error
 718  43D2 0600  
 719  43D4 1603         JNE     H064                    no: exit
 720  43D6 06A0         BL      @SNDCMD                 yes: reset drives
 720  43D8 43E0  
 721            *K013   DATA    >2F00                   send force interrupt, no ints
 722  43DA 0000 K013    DATA    >0000                   APEDSK99: send Restore command
 723            *H065   MOVB    @RSTAT,R0               get status APEDSK99: no need to test for "drive busy"
 724            *       SRC     R0,9                    test busy flag
 725            *       JNC     H065                    wait until done (inverted)
 726            *       JOC     H065                    APEDSK99: wait until done
 727  43DC 0460 H064    B       @RTURN1                 return to caller (address from stack)
 727  43DE 4450  
 728                                                    
 729  43E0 C03B SNDCMD  MOV     *R11+,R0                send command to FDC from data word
 730            *       MOVB    @RSTAT,R6               get status APEDSK99: no need to test for "drive busy" 
 731            *       SLA     R6,1                    test ready bit
 732            *       SBZ     1                       strobe motor. APEDSK99: we don't have to strobe anything
 733            *       SBO     1                       
 734            *       JOC     H066                    ready (inverted)
 735            *       JNC     H066                    APEDSK99: ready
 736            *       JMP     SNDCMD                  APEDSK99: not ready, test again
 737            *       LI      R6,30000                wait a long time
 738            *H067   SRC     R5,4                    
 739            *       SRC     R5,4                    
 740            *       DEC     R6                      
 741            *       JNE     H067                    
 742  43E2 D800 H066    MOVB    R0,@WCOMND              send command
 742  43E4 5FF8  
 743            *       SBO     3                       signal head loaded (HLT pin) APEDSK99: we don't have to load anything
 744            *       SRC     R5,8                    kill time. APEDSK99: we don't have to kill anything
 745            *       SRC     R5,8                    APEDSK99: we don't have to kill anything
 746  43E6 045B         B       *R11                    
 747                                                    
 748  43E8 04C0 LASTRK  CLR     R0                      get last track # for this drive
 749  43EA D029         MOVB    @>004C(R9),R0           get drive #
 749  43EC 004C  
 750  43EE 130B         JEQ     H068                    can't be 0
 751  43F0 06C0         SWPB    R0                      
 752  43F2 0280         CI      R0,3                    
 752  43F4 0003  
 753  43F6 1B07         JH      H068                    can't be higher than 3
 754  43F8 C0A9         MOV     @>0058(R9),R2                   
 754  43FA 0058  
 755  43FC 0222         AI      R2,-10                  point to last drive accessed
 755  43FE FFF6  
 756  4400 A080         A       R0,R2                   point to last track for this drive
 757  4402 0460         B       @VDPRD                  prepare VDP to read from address in R2
 757  4404 4416  
 758                                                    
 759  4406 06A0 H068    BL      @ERROR1                 exit with error code 7
 759  4408 43CA  
 760  440A 0700         DATA    >0700                   
 761                                                    
 762  440C 0262 VDPWRI  ORI     R2,>4000                set VDP address to write
 762  440E 4000  
 763  4410 0242         ANDI    R2,>7FFF                not to a register
 763  4412 7FFF  
 764  4414 1002         JMP     H069                    
 765  4416 0242 VDPRD   ANDI    R2,>3FFF                set VDP address to read
 765  4418 3FFF  
 766  441A 06C2 H069    SWPB    R2                      
 767  441C D7C2         MOVB    R2,*R15                 write address
 768  441E 06C2         SWPB    R2                      
 769  4420 D7C2         MOVB    R2,*R15                 
 770  4422 0242         ANDI    R2,>3FFF                        
 770  4424 3FFF  
 771  4426 045B         B       *R11                    
 772                                                    
 773  4428 00   K002    BYTE    >00                     
 774  4429 01   K006    BYTE    >01                     
 775  442A 00   K003    BYTE    >00                     sectors per track
 776  442B 09   K007    BYTE    >09                     
 777  442C 00           BYTE    >00                     
 778            *K008   BYTE    >06                     
 779            *       DATA    >0003                   
 780  442D F0   K004    BYTE    >F0                     
 781            *K015   BYTE    >FE                     
 782            *       DATA    >01F7                   
 783            *       DATA    >FFFF                   
 784            *       DATA    >FFFF                   
 785  442E FFFF K012    DATA    >FFFF                   
 786            *       DATA    >FFFF                   
 787            *       DATA    >FFFF                   
 788            *       DATA    >FF00                   
 789            *       DATA    >0000                   
 790            *       DATA    >0000                   
 791            *       DATA    >00FB                   
 792            *K010   BYTE    >F7                     code for CRC
 793            *K009   BYTE    0,7,5,3,1,8,6,4         sector interlace pattern
 794  4430 02   K005    BYTE    2
 795  4431 0F   DSDRVS  BYTE    >0F                     APEDSK99: deselect all drives + side (reset CRUWRI bits 7,6,5 and 4)                    
 796                    
 797                    EVEN
 798                                            
 799  4432 0669 CALSUB  DECT    @>0066(R9)              call subroutine, return address in stack
 799  4434 0066  
 800  4436 C2A9         MOV     @>0066(R9),R10
 800  4438 0066  
 801  443A 0429         BLWP    @>005A(R9)              set VDP to write to address in R10
 801  443C 005A  
 802  443E 0143         DATA    >0143                   
 803  4440 C2BB         MOV     *R11+,R10               get next data word
 804  4442 06CB         SWPB    R11                     write return address to VDP
 805  4444 DBCB         MOVB    R11,@-2(R15)                    
 805  4446 FFFE  
 806  4448 06CB         SWPB    R11                     
 807  444A DBCB         MOVB    R11,@-2(R15)                    
 807  444C FFFE  
 808  444E 045A         B       *R10                    branch to address in data word
 809                                                    
 810  4450 C2E9 RTURN1  MOV     @>0066(R9),R11          get return address from VDP stack
 810  4452 0066  
 811  4454 0429         BLWP    @>005A(R9)              
 811  4456 005A  
 812  4458 0162         DATA    >0162                   set VDP to read from address in R11
 813  445A D2EF         MOVB    @-1026(R15),R11                 
 813  445C FBFE  
 814  445E 06CB         SWPB    R11                     
 815  4460 D2EF         MOVB    @-1026(R15),R11                 
 815  4462 FBFE  
 816  4464 05E9         INCT    @>0066(R9)                      
 816  4466 0066  
 817  4468 045B         B       *R11                    
 818            
 819            *---------------------------------------
 820            * Custom routines, dealing with VDP memory
 821            * Format is >pppr where r is routine number (0-3)
 822            * and ppp contains parameters
 823            * The workspace it >8300. Called by BLWP @>005A(9).
 824            *---------------------------------------                                        
 825  446A C28D ECUSTM  MOV     R13,R10                 save wregs ptr
 826  446C C23E         MOV     *R14+,R8                get next data word
 827  446E C248         MOV     R8,R9                   save it
 828  4470 0949         SRL     R9,4                    keep parameter
 829  4472 0248         ANDI    R8,3                    four possible operations
 829  4474 0003  
 830  4476 A208         A       R8,R8                   make it a word ptr
 831  4478 C2ED         MOV     @>001E(R13),R11         get old R15, i.e. VDP port (>8C02)
 831  447A 001E  
 832  447C C228         MOV     @VECRTN(R8),R8          get vector for operation
 832  447E 4482  
 833  4480 0458         B       *R8                     branch to it
 834                                                    
 835  4482 448A VECRTN  DATA    SVRVDP                  save registers to VDP stack
 836  4484 44B6         DATA    RVRVDP                  retrieve registers
 837  4486 44EC         DATA    SVDPRD                  set VDP address to read
 838  4488 44E2         DATA    SVDPWR                  set VDP address to write
 839                                                    
 840  448A 022A SVRVDP  AI      R10,22                  0: save registers in VDP mem
 840  448C 0016  
 841  448E 0919 H072    SRL     R9,1                    start with R12
 842  4490 1710         JNC     H070                    bits in >ppp tell which register to save (R0-R11)
 843  4492 064C         DECT    R12                     previous address in VDP stack (grows down)
 844  4494 C21A         MOV     *R10,R8                 get register contents
 845  4496 06CC         SWPB    R12                     set VDP address to write
 846  4498 D6CC         MOVB    R12,*R11                R12 is >8366: VDP stack ptr
 847  449A 06CC         SWPB    R12                     
 848  449C 026C         ORI     R12,>4000                       
 848  449E 4000  
 849  44A0 D6CC         MOVB    R12,*R11                        
 850  44A2 06C8         SWPB    R8                      save register to VDP mem
 851  44A4 DAC8         MOVB    R8,@-2(R11)                     
 851  44A6 FFFE  
 852  44A8 06C8         SWPB    R8                      
 853  44AA DAC8         MOVB    R8,@-2(R11)                     
 853  44AC FFFE  
 854  44AE C249         MOV     R9,R9                   more to come?
 855  44B0 1317         JEQ     H071                    no:return
 856  44B2 064A H070    DECT    R10                     point to previous register
 857  44B4 10EC         JMP     H072                    
 858                                                    
 859  44B6 0A49 RVRVDP  SLA     R9,4                    1: retrieve registers from VDP mem
 860  44B8 0A19 H074    SLA     R9,1                    each bit tells whether to load
 861  44BA 1710         JNC     H073                    don't retrieve that one
 862  44BC 06CC         SWPB    R12                     set VDP address to read
 863  44BE D6CC         MOVB    R12,*R11                R12 is >8366: VDP stack ptr
 864  44C0 06CC         SWPB    R12                     
 865  44C2 024C         ANDI    R12,>3FFF                       
 865  44C4 3FFF  
 866  44C6 D6CC         MOVB    R12,*R11                        
 867  44C8 1000         NOP                             
 868  44CA D22B         MOVB    @-1026(R11),R8          get a 2-byte value from VDP
 868  44CC FBFE  
 869  44CE 06C8         SWPB    R8                      
 870  44D0 D22B         MOVB    @-1026(R11),R8                  
 870  44D2 FBFE  
 871  44D4 C688         MOV     R8,*R10                 save it to register
 872  44D6 05CC         INCT    R12                     increment ptr (stack grows downwards)
 873  44D8 C249         MOV     R9,R9                   more to come?
 874  44DA 1302         JEQ     H071                    no: return
 875  44DC 05CA H073    INCT    R10                     next register
 876  44DE 10EC         JMP     H074                    
 877  44E0 0380 H071    RTWP                            
 878                                                    
 879  44E2 A24D SVDPWR  A       R13,R9                  2: set VDP for a write
 880  44E4 C219         MOV     *R9,R8                  
 881  44E6 0268         ORI     R8,>4000                get address from reg in >..p2 (*2)
 881  44E8 4000  
 882  44EA 1004         JMP     H075                    
 883                                                    
 884  44EC A24D SVDPRD  A       R13,R9                  3: set VDP for a read
 885  44EE C219         MOV     *R9,R8
 886  44F0 0248         ANDI    R8,>3FFF                get register from reg in >..p3 (*2)
 886  44F2 3FFF  
 887  44F4 06C8 H075    SWPB    R8                      set VDP address
 888  44F6 D6C8         MOVB    R8,*R11                 
 889  44F8 06C8         SWPB    R8                      
 890  44FA D6C8         MOVB    R8,*R11                 
 891  44FC 0380         RTWP                            
 892            
 893            *---------------------------------------
 894            * Preparation subroutine
 895            * Sets up the 4 custom subroutines
 896            * Gets a few pointers to VDP buffers
 897            *  >8358: copy of VIB  >8366: VDP stack ptr (grows down from drive info)
 898            *  >8354: PAB          >8356: ptr to end-of-buffer
 899            *---------------------------------------                                        
 900  44FE 05C7 PRPFDO  INCT    R7                      stop scanning upon return
 901  4500 C28B PRPRTN  MOV     R11,R10                 save return address
 902  4502 02A9         STWP    R9                      get workspace (should be >83E0)
 903  4504 0229         AI      R9,-224                 top of scratch/pad mem (>8300)
 903  4506 FF20  
 904  4508 0200         LI      R0,ECUSTM               entry to 4 custom routines
 904  450A 446A  
 905  450C CA40         MOV     R0,@>005C(R9)           put it in >835C
 905  450E 005C  
 906  4510 C009         MOV     R9,R0                   
 907  4512 0220         AI      R0,>004E                workspace for these four (>834E)
 907  4514 004E  
 908  4516 CA40         MOV     R0,@>005A(R9)           put it in >835A
 908  4518 005A  
 909                                                    
 910  451A C229         MOV     @>0070(R9),R8           highest free address in VDP mem
 910  451C 0070  
 911  451E 05C8 H076    INCT    R8                      point to end-of-buffer word
 912  4520 06A0         BL      @VDPR2B                 read 2 bytes from VDP address R8, into R0
 912  4522 4950  
 913  4524 C088         MOV     R8,R2                   save current R8
 914  4526 C200         MOV     R0,R8                   get end-of-buffer word
 915            * APEDSK99: we don't need to check 
 916            * for additional controllers
 917            *       MOVB    @-1026(R15),R1          get CRU of controller that reserved this mem                            
 918            *       CB      R12,R1                  same as ours?
 919            *       JNE     H076                    no: use end-of-buffer to link to next buffer
 920  4528 0228         AI      R8,-266                 yes: point to volume information block
 920  452A FEF6  
 921  452C CA48         MOV     R8,@>0058(R9)           save it in >8358
 921  452E 0058  
 922  4530 0228         AI      R8,-10                  point to disk drive info (drive #, last tracks)
 922  4532 FFF6  
 923  4534 CA48         MOV     R8,@>0066(R9)           save in >8366: VDP stack ptr (DECT before writing)
 923  4536 0066  
 924  4538 0429         BLWP    @>005A(R9)              save R7 (return address)
 924  453A 005A  
 925  453C 0100         DATA    >0100                   
 926  453E C1E9         MOV     @>0056(R9),R7           ptr to PAB: end of DSR name
 926  4540 0056  
 927  4542 C0C7         MOV     R7,R3                   save it
 928  4544 61E9         S       @>0054(R9),R7           start of DSR name
 928  4546 0054  
 929  4548 CA42         MOV     R2,@>0056(R9)           >8356: ptr to end-of-buffer word in VDP mem
 929  454A 0056  
 930  454C 0607         DEC     R7                      point to name length byte
 931  454E 04C2         CLR     R2                      
 932  4550 0429         BLWP    @>005A(R9)              set VDP to read from address in R2
 932  4552 005A  
 933  4554 00E2         DATA    >00E2                   
 934  4556 D0AF         MOVB    @-1026(R15),R2          get name length byte
 934  4558 FBFE  
 935  455A 06C2         SWPB    R2                      make it a word
 936  455C 60A9         S       @>0054(R9),R2           minus DSR name size: lenght of .parameters
 936  455E 0054  
 937  4560 0227         AI      R7,-9                   point to top of PAB
 937  4562 FFF7  
 938  4564 CA47         MOV     R7,@>0054(R9)           save it in >8354
 938  4566 0054  
 939  4568 045A         B       *R10                    
 940                                                    
 941  456A 06A0 CRFIL1  BL      @CALSUB                 create file
 941  456C 4432  
 942  456E 4BDC         DATA    FNDFDR                  find a FDR in disk
 943  4570 C104 CRFIL2  MOV     R4,R4                   found?
 944  4572 1604         JNE     CRFIL3                  no
 945  4574 06A0         BL      @CALSUB                 yes: delete old file
 945  4576 4432  
 946  4578 46B4         DATA    FFSVIB                  free file sector in VIB bitmap
 947  457A 1045         JMP     H077                    clear its FDR
 948                                                    
 949  457C 06A0 CRFIL3  BL      @INSFDR                 new file: insert a FDR in sector 1
 949  457E 48E4  
 950  4580 0701         SETO    R1                      
 951  4582 06A0         BL      @CALSUB                 call subroutine
 951  4584 4432  
 952  4586 4CD0         DATA    FFSBMP                  find a free sector in VIB bitmap
 953  4588 C000         MOV     R0,R0                   found?
 954  458A 1603         JNE     H078                    yes: # in R0
 955  458C 06A0         BL      @ERROR5                 no: update data, then return with error
 955  458E 4A4C  
 956  4590 8000         DATA    >8000                   memory full
 957                                                    
 958  4592 0429 H078    BLWP    @>005A(R9)              set VDP to write
 958  4594 005A  
 959  4596 0103         DATA    >0103                   address in R8
 960  4598 DBC0         MOVB    R0,@-2(R15)             write sector # for FDR in sector 1
 960  459A FFFE  
 961  459C 06C0         SWPB    R0                      
 962  459E DBC0         MOVB    R0,@-2(R15)                     
 962  45A0 FFFE  
 963  45A2 06C0         SWPB    R0                      
 964  45A4 C069         MOV     @>0056(R9),R1           ptr to FDR in VDP buffers
 964  45A6 0056  
 965  45A8 0221         AI      R1,-4                   ptr to sector # for FDR
 965  45AA FFFC  
 966  45AC 0429         BLWP    @>005A(R9)              set VDP to write
 966  45AE 005A  
 967  45B0 0023         DATA    >0023                   address in R1
 968  45B2 DBC0         MOVB    R0,@-2(R15)             write sector # for FDR in VDP buffer
 968  45B4 FFFE  
 969  45B6 06C0         SWPB    R0                      
 970  45B8 DBC0         MOVB    R0,@-2(R15)                     
 970  45BA FFFE  
 971  45BC 0221         AI      R1,3                    ptr to drive #
 971  45BE 0003  
 972  45C0 0429         BLWP    @>005A(R9)              set VDP to write
 972  45C2 005A  
 973  45C4 0023         DATA    >0023                   address in R1
 974  45C6 DBC6         MOVB    R6,@-2(R15)             write drive # before FDR in VDP buffer
 974  45C8 FFFE  
 975  45CA 04C2         CLR     R2                      code for write
 976  45CC 0581         INC     R1                      
 977  45CE 06A0         BL      @CALSUB                 call subroutine
 977  45D0 4432  
 978  45D2 4B10         DATA    WRSEC1                  write sector 1
 979  45D4 C169         MOV     @>0058(R9),R5           ptr to VIB in VDP buffers
 979  45D6 0058  
 980  45D8 04C4         CLR     R4                      sector 0
 981  45DA 06A0         BL      @CALSUB                 call subroutine
 981  45DC 4432  
 982  45DE 4B28         DATA    RWSEC                   write VIB to sector 0
 983  45E0 C0C5         MOV     R5,R3                   copy filename from compare buffer to FDR
 984  45E2 0223         AI      R3,257                  ptr to file compare buffer
 984  45E4 0101  
 985  45E6 0202         LI      R2,10                   10 chars per filename
 985  45E8 000A  
 986  45EA 0429 H079    BLWP    @>005A(R9)              set VDP to read
 986  45EC 005A  
 987  45EE 0062         DATA    >0062                   address in R3
 988  45F0 D02F         MOVB    @-1026(R15),R0          get 1 char
 988  45F2 FBFE  
 989  45F4 0583         INC     R3                      increment source ptr
 990  45F6 0429         BLWP    @>005A(R9)              set VDP to write
 990  45F8 005A  
 991  45FA 0023         DATA    >0023                   address in R1
 992  45FC DBC0         MOVB    R0,@-2(R15)             copy 1 char
 992  45FE FFFE  
 993  4600 0581         INC     R1                      increment destination ptr
 994  4602 0602         DEC     R2                      # of chars in R2
 995  4604 16F2         JNE     H079                    next
 996            *
 997  4606 06A0 H077    BL      @NTPDT                  APEDSK99: update DOAD FAT time/date
 997  4608 5EFC  
 998            *
 999  460A C069         MOV     @>0056(R9),R1           FDR ptr
 999  460C 0056  
1000  460E 0221         AI      R1,10                   skip filename
1000  4610 000A  
1001  4612 0202         LI      R2,246                  remaining bytes in FDR
1001  4614 00F6  
1002  4616 0429         BLWP    @>005A(R9)              set VDP to write
1002  4618 005A  
1003  461A 0023         DATA    >0023                   address in R1
1004  461C DBC2 H080    MOVB    R2,@-2(R15)             write >00
1004  461E FFFE  
1005  4620 0602         DEC     R2                      clear remainder of new FDR
1006  4622 16FC         JNE     H080                    next byte
1007  4624 1010         JMP     H081                    write FDR to disk return to caller
1008                                                    
1009  4626 C169 H082    MOV     @>0056(R9),R5           check if FDR must be updated
1009  4628 0056  
1010  462A 0429         BLWP    @>005A(R9)              set VDP to read
1010  462C 005A  
1011  462E 00A2         DATA    >00A2                   address in R5
1012  4630 D12F         MOVB    @-1026(R15),R4          get filename in file ctrl block
1012  4632 FBFE  
1013  4634 1101         JLT     H083                    flag: FDR was modified, update it
1014  4636 100A         JMP     H084                    
1015  4638 0244 H083    ANDI    R4,>7F00                clear flag bit
1015  463A 7F00  
1016  463C 0429         BLWP    @>005A(R9)              st VDP to write
1016  463E 005A  
1017  4640 00A3         DATA    >00A3                   address in R5
1018  4642 DBC4         MOVB    R4,@-2(R15)             write back filename without flag bit
1018  4644 FFFE  
1019  4646 04C2 H081    CLR     R2                      code for write
1020  4648 0460         B       @WRFDR                  write FDR to disk
1020  464A 4B1A  
1021  464C 0460 H084    B       @RTURN1                 return to caller
1021  464E 4450  
1022                                                    
1023  4650 06A0 UPDFDR  BL      @CALSUB                 update FDR + data
1023  4652 4432  
1024  4654 4670         DATA    UPDBF                   update data buffer if necessary
1025  4656 06A0         BL      @CALSUB                 call subroutine
1025  4658 4432  
1026  465A 4626         DATA    H082                    update FDR if necessary
1027  465C C169 CLRFBT  MOV     @>0056(R9),R5                   
1027  465E 0056  
1028  4660 04C6         CLR     R6                      
1029  4662 0429         BLWP    @>005A(R9)              set VDP to write
1029  4664 005A  
1030  4666 00A3         DATA    >00A3                   address in R5
1031  4668 DBC6         MOVB    R6,@-2(R15)             clr first byte of filename in FDR
1031  466A FFFE  
1032  466C 0460         B       @RWVIB                  
1032  466E 4AAC  
1033                                                    
1034  4670 C129 UPDBF   MOV     @>0056(R9),R4           check if data buffer must be updated
1034  4672 0056  
1035  4674 0604         DEC     R4                      
1036  4676 0429         BLWP    @>005A(R9)              set VDP to read
1036  4678 005A  
1037  467A 0082         DATA    >0082                   address in R4
1038  467C D06F         MOVB    @-1026(R15),R1          get drive #
1038  467E FBFE  
1039  4680 1101         JLT     H085                    flag: must be updated
1040  4682 1016         JMP     H086                    no need to update: return
1041  4684 0241 H085    ANDI    R1,>7F00                erase flag
1041  4686 7F00  
1042  4688 0429         BLWP    @>005A(R9)              set VDP to write
1042  468A 005A  
1043  468C 0083         DATA    >0083                   address in R4
1044  468E DBC1         MOVB    R1,@-2(R15)             write back drive # without flag
1044  4690 FFFE  
1045  4692 0224         AI      R4,-5                   point to current logical record offset
1045  4694 FFFB  
1046  4696 0429         BLWP    @>005A(R9)              set VDP to read
1046  4698 005A  
1047  469A 0082         DATA    >0082                   address in R4
1048  469C D0EF         MOVB    @-1026(R15),R3          get current logical record offset
1048  469E FBFE  
1049  46A0 06C3         SWPB    R3                      
1050  46A2 D0EF         MOVB    @-1026(R15),R3                  
1050  46A4 FBFE  
1051  46A6 06C3         SWPB    R3                      
1052  46A8 C1C4         MOV     R4,R7                   
1053  46AA 0227         AI      R7,262                  point to data buffer area
1053  46AC 0106  
1054  46AE 103A         JMP     WROFSC                  
1055  46B0 0460 H086    B       @RTURN1                 return to caller
1055  46B2 4450  
1056                                                    
1057  46B4 C0A9 FFSVIB  MOV     @>0056(R9),R2           free file sectors in VIB bitmap
1057  46B6 0056  
1058  46B8 0222         AI      R2,12                   
1058  46BA 000C  
1059  46BC 0429         BLWP    @>005A(R9)              set VDP to read
1059  46BE 005A  
1060  46C0 0042         DATA    >0042                   address in R2
1061  46C2 D02F         MOVB    @-1026(R15),R0          get file status byte from FDR
1061  46C4 FBFE  
1062  46C6 0240         ANDI    R0,>0800                write protected?
1062  46C8 0800  
1063  46CA 1303         JEQ     H087                    no
1064  46CC 06A0         BL      @ERROR5                 update data if needed, the return with error
1064  46CE 4A4C  
1065  46D0 2000         DATA    >2000                   write protected
1066                                                    
1067  46D2 C229 H087    MOV     @>0056(R9),R8           get ptr to FDR
1067  46D4 0056  
1068  46D6 0228         AI      R8,28                   point to clusters list
1068  46D8 001C  
1069  46DA 0704         SETO    R4                      previous offset
1070  46DC 06A0 H089    BL      @DECDCI                 decode cluster info: sector in R1, offset in R2
1070  46DE 4C90  
1071  46E0 0228         AI      R8,3                    next cluster ptr
1071  46E2 0003  
1072  46E4 C041         MOV     R1,R1                   
1073  46E6 130C         JEQ     H088                    sector 0 = no more clusters
1074  46E8 C002         MOV     R2,R0                   total offset
1075  46EA 6084         S       R4,R2                   minus previous cluster offset = cluster size
1076  46EC C100         MOV     R0,R4                   new previous cluster offset
1077  46EE 06A0         BL      @CALSUB                 call subroutine
1077  46F0 4432  
1078  46F2 4D9C         DATA    FRSCB1                  free sectors in bitmap (from R1, # in R2)
1079  46F4 C048         MOV     R8,R1                   
1080  46F6 6069         S       @>0056(R9),R1                   
1080  46F8 0056  
1081  46FA 0281         CI      R1,>0100                end of FDR reached?
1081  46FC 0100  
1082  46FE 16EE         JNE     H089                    not yet
1083  4700 0460 H088    B       @RTURN1                 return to caller
1083  4702 4450  
1084                                                    
1085  4704 06A0 RDOFSC  BL      @FDR2B1                 read a sector from offset in file
1085  4706 494A  
1086  4708 000E         DATA    14                      get # of sectors
1087  470A 80C0         C       R0,R3                   is desired sector in file?
1088  470C 1B03         JH      H090                    yes
1089  470E 06A0         BL      @ERROR5                 no: update data, then return with error
1089  4710 4A4C  
1090  4712 A000         DATA    >A000                   past end-of-file
1091  4714 06A0 H090    BL      @CALSUB                 call subroutine
1091  4716 4432  
1092  4718 4824         DATA    FSCTOF                  find sector from cluster list
1093  471A A101         A       R1,R4                   put sector in R4
1094  471C 0702         SETO    R2                      code for read
1095  471E C147 H091    MOV     R7,R5                   buffer ptr
1096  4720 0460         B       @RWSEC                  read/write sector
1096  4722 4B28  
1097                                                    
1098  4724 0429 WROFSC  BLWP    @>005A(R9)              write sector to offset in file offset in R3
1098  4726 005A  
1099  4728 8100         DATA    >8100                   save R0 and R7
1100  472A 06A0         BL      @CALSUB                 call subroutine
1100  472C 4432  
1101  472E 473A         DATA    APSCTS                  append enough sectors to reach that offset
1102  4730 0429         BLWP    @>005A(R9)              retrieve R0 and R7
1102  4732 005A  
1103  4734 8101         DATA    >8101                   
1104  4736 04C2         CLR     R2                      code for write
1105  4738 10F2         JMP     H091                    write sector
1106                                                    
1107  473A 06A0 APSCTS  BL      @FDR2B1                 append sector(s) to a file to get offset in R3
1107  473C 494A  
1108  473E 000E         DATA    14                      get # of sect from FDR
1109                                                    
1110  4740 80C0         C       R0,R3                   is desired sector in file?
1111  4742 1B47         JH      H092                    yes: find it and return
1112  4744 C000         MOV     R0,R0                   
1113  4746 1301         JEQ     H093                    empty file
1114  4748 0600         DEC     R0                      last sector #
1115  474A C143 H093    MOV     R3,R5                   save desired sector offset
1116  474C C0C0         MOV     R0,R3                   last sector in file
1117  474E 06A0         BL      @CALSUB                 call subroutine
1117  4750 4432  
1118  4752 4824         DATA    FSCTOF                  find sector # from offset in file
1119  4754 0429         BLWP    @>005A(R9)              save R1 (sector #)
1119  4756 005A  
1120  4758 4000         DATA    >4000                   
1121  475A A044         A       R4,R1                   # of last sector in cluster
1122  475C C105         MOV     R5,R4                   offset of desired sector
1123  475E 06A0 H095    BL      @CALSUB                 call subroutine
1123  4760 4432  
1124  4762 4CD0         DATA    FFSBMP                  find free sector in bitmap, starting from R1
1125  4764 C000         MOV     R0,R0                   found?
1126  4766 1604         JNE     H094                    yes: # in R0
1127  4768 C142         MOV     R2,R5                   no: save # of sectors
1128  476A 06A0         BL      @ADDSEC                 update FDR
1128  476C 47DE  
1129  476E 101B         JMP     H096                    return with memory full
1130                                                    
1131  4770 C041 H094    MOV     R1,R1                   
1132  4772 1320         JEQ     H097                    empty cluster
1133  4774 0581         INC     R1                      one more sector in cluster
1134  4776 8040         C       R0,R1                   same as the one found in bitmap?
1135  4778 131C         JEQ     H098                    yes: just increase cluster size
1136  477A 0429         BLWP    @>005A(R9)              no: retrieve R1 (sector #)
1136  477C 005A  
1137  477E 4001         DATA    >4001                   
1138  4780 0429         BLWP    @>005A(R9)              save R0 + R2
1138  4782 005A  
1139  4784 A000         DATA    >A000                   
1140  4786 06A0         BL      @UPDCLI                 update current cluster info
1140  4788 4CAC  
1141  478A 0429         BLWP    @>005A(R9)              retrieve R0 + R2
1141  478C 005A  
1142  478E A001         DATA    >A001                   
1143  4790 0228         AI      R8,3                    ptr to next cluster info
1143  4792 0003  
1144  4794 C048         MOV     R8,R1                   
1145  4796 6069         S       @>0056(R9),R1           current FDR size
1145  4798 0056  
1146  479A 0281         CI      R1,>0100                room enough?
1146  479C 0100  
1147  479E 1605         JNE     H099                    yes
1148  47A0 06A0         BL      @CALSUB                 no: call subroutine
1148  47A2 4432  
1149  47A4 4D96         DATA    FFSBM                   free sector in bitmap
1150  47A6 0460 H096    B       @ERROR6                 return with memory full
1150  47A8 4C02  
1151                                                    
1152  47AA C040 H099    MOV     R0,R1                   new sector #
1153  47AC 0429         BLWP    @>005A(R9)              save R1
1153  47AE 005A  
1154  47B0 4000         DATA    >4000                   
1155  47B2 1007 H098    JMP     H100                    make a new cluster
1156                                                    
1157  47B4 0429 H097    BLWP    @>005A(R9)              retrieve R1
1157  47B6 005A  
1158  47B8 4001         DATA    >4001                   
1159  47BA 0429         BLWP    @>005A(R9)              save R0
1159  47BC 005A  
1160  47BE 8000         DATA    >8000                   
1161  47C0 0702         SETO    R2                      empty file: start from offset 0
1162  47C2 C040 H100    MOV     R0,R1                   sector #
1163  47C4 0582         INC     R2                      increment cluster size
1164  47C6 8102         C       R2,R4                   enough?
1165  47C8 16CA         JNE     H095                    no: get one more sector
1166  47CA C144         MOV     R4,R5                   
1167  47CC 06A0         BL      @ADDSEC                 add sector to FDR
1167  47CE 47DE  
1168  47D0 1004         JMP     H101                    done
1169                                                    
1170  47D2 06A0 H092    BL      @CALSUB                 call subroutine
1170  47D4 4432  
1171  47D6 4824         DATA    FSCTOF                  find a sector from offset in file
1172  47D8 A101         A       R1,R4                   last sector in cluster
1173  47DA 0460 H101    B       @RTURN1                 return to caller
1173  47DC 4450  
1174                                                    
1175  47DE C28B ADDSEC  MOV     R11,R10                 add sector to FDR
1176  47E0 C101         MOV     R1,R4                   
1177  47E2 0429         BLWP    @>005A(R9)              retrieve R1
1177  47E4 005A  
1178  47E6 4001         DATA    >4001                   
1179  47E8 C041         MOV     R1,R1                   sector #
1180  47EA 131B         JEQ     H102                    none: return
1181  47EC 06A0         BL      @UPDCLI                 write info for R1 cluster
1181  47EE 4CAC  
1182  47F0 C0A9         MOV     @>0056(R9),R2           pointer to FDR
1182  47F2 0056  
1183  47F4 0429         BLWP    @>005A(R9)              set VDP to read
1183  47F6 005A  
1184  47F8 0042         DATA    >0042                   address in R2
1185  47FA D06F         MOVB    @-1026(R15),R1          first char of filename
1185  47FC FBFE  
1186  47FE 0261         ORI     R1,>8000                flag
1186  4800 8000  
1187  4802 0429         BLWP    @>005A(R9)              set VDP to write
1187  4804 005A  
1188  4806 0043         DATA    >0043                   address in R2
1189  4808 DBC1         MOVB    R1,@-2(R15)                     
1189  480A FFFE  
1190  480C 0222         AI      R2,14                   ptr to # of sectors
1190  480E 000E  
1191  4810 0585         INC     R5                      new # of sectors
1192  4812 0429         BLWP    @>005A(R9)              set VDP to write
1192  4814 005A  
1193  4816 0043         DATA    >0043                   address in R2
1194  4818 DBC5         MOVB    R5,@-2(R15)             update # of sectors
1194  481A FFFE  
1195  481C 06C5         SWPB    R5                      
1196  481E DBC5         MOVB    R5,@-2(R15)                     
1196  4820 FFFE  
1197  4822 045A H102    B       *R10                    
1198                                                    
1199  4824 C229 FSCTOF  MOV     @>0056(R9),R8           find sector from offset in file
1199  4826 0056  
1200  4828 0228         AI      R8,28                   cluster list
1200  482A 001C  
1201  482C C103         MOV     R3,R4                   desired sector offset is in R3
1202  482E 06A0 H105    BL      @DECDCI                 decode info: sector in R1, offset in R2
1202  4830 4C90  
1203  4832 80C2         C       R2,R3                   reached yet?
1204  4834 1101         JLT     H103                    no
1205  4836 1006         JMP     H104                    yes: return
1206  4838 0228 H103    AI      R8,3                    point to next cluster info
1206  483A 0003  
1207  483C C103         MOV     R3,R4                   
1208  483E 6102         S       R2,R4                   
1209  4840 0604         DEC     R4                      size of the desired cluster (if it's the next)
1210  4842 10F5         JMP     H105                    keep trying
1211  4844 0460 H104    B       @RTURN1                 return to caller
1211  4846 4450  
1212            
1213            *---------------------------------
1214            * Opcode 7: Delete
1215            * ----------------
1216            * PAB 0: >07
1217            *     1:            <--- error code
1218            *   2-3:
1219            *     4:
1220            *     5:
1221            *   6-7:
1222            *     8:
1223            *---------------------------------                                      
1224  4848 06A0 DELETE  BL      @CALSUB                 delete file
1224  484A 4432  
1225  484C 4B7E         DATA    FFFDRV                  find file FDR in VDP buffers
1226  484E C104         MOV     R4,R4                   found?
1227  4850 1307         JEQ     H106                    yes
1228  4852 06A0         BL      @CALSUB                 no: call subroutine
1228  4854 4432  
1229  4856 4BE6         DATA    FFDRDK                  find FDR on disk
1230  4858 C104         MOV     R4,R4                   found?
1231  485A 1313         JEQ     H107                    yes
1232  485C 0460         B       @RTURN1                 no: return to caller
1232  485E 4450  
1233                                                    
1234  4860 0581 H106    INC     R1                      FDR found, point to it
1235  4862 CA41         MOV     R1,@>0056(R9)           save it for other routines
1235  4864 0056  
1236  4866 06A0         BL      @CALSUB                 call subroutine
1236  4868 4432  
1237  486A 4B0E         DATA    RDSEC1                  read sector 1
1238  486C 06A0         BL      @FDR2B1                 read 2 bytes from VDP at >8356+offset
1238  486E 494A  
1239  4870 FFFC         DATA    -4                      i.e. get sector # of FRD in R0
1240  4872 C0C0         MOV     R0,R3                   save it for later
1241  4874 C205         MOV     R5,R8                   ptr to top of sector 1
1242  4876 06A0 H108    BL      @VDPR2B                 read 2 bytes from VDP at R8 into R0
1242  4878 4950  
1243  487A 05C8         INCT    R8                      next FDR ptr in sector 1
1244  487C 80C0         C       R0,R3                   is this the one we want?
1245  487E 16FB         JNE     H108                    not yet
1246  4880 0648         DECT    R8                      yes: point back to it
1247            *
1248  4882 06A0 H107    BL      @NTPDT                  APEDSK99: update DOAD FAT time/date
1248  4884 5EFC  
1249            *
1250  4886 0429         BLWP    @>005A(R9)              save R8
1250  4888 005A  
1251  488A 0080         DATA    >0080                   
1252  488C 06A0         BL      @CALSUB                 call subroutine
1252  488E 4432  
1253  4890 46B4         DATA    FFSVIB                  free file sectors in VIB bitmap
1254  4892 0429         BLWP    @>005A(R9)              retrieve R8
1254  4894 005A  
1255  4896 0081         DATA    >0081                   
1256  4898 06A0         BL      @RMFPTR                 remove FDR ptr from sector 1
1256  489A 48B4  
1257  489C 04C2         CLR     R2                      code for write
1258  489E 06A0         BL      @CALSUB                 call subroutine
1258  48A0 4432  
1259  48A2 4B10         DATA    WRSEC1                  write sector 1
1260  48A4 06A0         BL      @FDR2B1                 get 2 bytes from VDP at >8356+offset in R0
1260  48A6 494A  
1261  48A8 FFFC         DATA    -4                      i.e. sector # of FDR
1262  48AA 06A0         BL      @CALSUB                 call subroutine
1262  48AC 4432  
1263  48AE 4D96         DATA    FFSBM                   free sector in R0 in VIB bitmap
1264  48B0 0460         B       @CLRFBT                 clear 1rst byte of filename in VDP
1264  48B2 465C  
1265            
1266            * Sector 1 contains an alphabetically sorted list of FDR pointers
1267            * Each pointer is 2 bytes long and contains the sector # of this FDR
1268            * The list must end with a >0000 mark. Thus there can be 127 files at most
1269  48B4 C169 RMFPTR  MOV     @>0056(R9),R5           remove FDR ptr from sector 1
1269  48B6 0056  
1270  48B8 0225         AI      R5,256                  
1270  48BA 0100  
1271  48BC C0C5         MOV     R5,R3                   pointer to data buffer
1272  48BE 0223         AI      R3,256                  point to next ctrl block
1272  48C0 0100  
1273  48C2 C088         MOV     R8,R2                   shift up FDR list, erasing FDR pointed by R8
1274  48C4 05C2         INCT    R2                      point to next FDR ptr in sector 1
1275  48C6 0429 H109    BLWP    @>005A(R9)              set VDP to read
1275  48C8 005A  
1276  48CA 0042         DATA    >0042                   address in R2
1277  48CC D02F         MOVB    @-1026(R15),R0          get 1 byte
1277  48CE FBFE  
1278  48D0 0582         INC     R2                      inc source ptr
1279  48D2 0429         BLWP    @>005A(R9)              set VDP to write
1279  48D4 005A  
1280  48D6 0103         DATA    >0103                   address in R8
1281  48D8 DBC0         MOVB    R0,@-2(R15)             copy 1 byte
1281  48DA FFFE  
1282  48DC 0588         INC     R8                      inc dest pointer
1283  48DE 80C2         C       R2,R3                   done?
1284  48E0 16F2         JNE     H109                    not yet
1285  48E2 045B         B       *R11                    
1286                                                    
1287  48E4 C28B INSFDR  MOV     R11,R10                 insert a FDR in sector 1
1288  48E6 C048         MOV     R8,R1                   
1289  48E8 06A0         BL      @FDR2B1                 get 2 bytes from VDP at >8356+offset
1289  48EA 494A  
1290  48EC 01FC         DATA    508                     i.e. last FDR slot in sector 1 (list ends with 0)
1291  48EE C000         MOV     R0,R0                   
1292  48F0 1302         JEQ     H110                    
1293  48F2 0460         B       @ERROR6                 memory full error
1293  48F4 4C02  
1294  48F6 0608 H110    DEC     R8                      previous byte
1295  48F8 0429         BLWP    @>005A(R9)              set VDP to read
1295  48FA 005A  
1296  48FC 0102         DATA    >0102                   address in R8
1297  48FE D02F         MOVB    @-1026(R15),R0          get 1 byte
1297  4900 FBFE  
1298  4902 05C8         INCT    R8                      
1299  4904 0429         BLWP    @>005A(R9)              set VDP to write
1299  4906 005A  
1300  4908 0103         DATA    >0103                   address in R8
1301  490A DBC0         MOVB    R0,@-2(R15)             copy byte two bytes further down
1301  490C FFFE  
1302  490E 0648         DECT    R8                      
1303  4910 8048         C       R8,R1                   done ?
1304  4912 16F1         JNE     H110                    not yet
1305  4914 045A         B       *R10                    
1306                                                    
1307  4916 C0A9 CMPFN   MOV     @>0058(R9),R2           compare filenames
1307  4918 0058  
1308  491A 0222         AI      R2,256                  
1308  491C 0100  
1309  491E 0429 H111    BLWP    @>005A(R9)              set VDP to read
1309  4920 005A  
1310  4922 0022         DATA    >0022                   address in R1 (ptr to filename)
1311  4924 D02F         MOVB    @-1026(R15),R0          get 1 char
1311  4926 FBFE  
1312  4928 0240         ANDI    R0,>7FFF                clear flag (on drive #)
1312  492A 7FFF  
1313  492C 0429         BLWP    @>005A(R9)              set VDP to read
1313  492E 005A  
1314  4930 0042         DATA    >0042                   address in R2 (filename compare buffer)
1315  4932 D0EF         MOVB    @-1026(R15),R3          get 1 char
1315  4934 FBFE  
1316  4936 90C0         CB      R0,R3                   compare chars
1317  4938 1604         JNE     H112                    mismatch
1318  493A 0581         INC     R1                      match: increment pointers
1319  493C 0582         INC     R2                      
1320  493E 0604         DEC     R4                      
1321  4940 16EE         JNE     H111                    next char
1322  4942 045B H112    B       *R11                    if complete match: ret with EQ set
1323                                                    
1324  4944 C229 PABR2B  MOV     @>0054(R9),R8           get two bytes from PAB
1324  4946 0054  
1325  4948 1002         JMP     FDR2B2                  
1326                                                    
1327  494A C229 FDR2B1  MOV     @>0056(R9),R8           get two bytes from FDR
1327  494C 0056  
1328  494E A23B FDR2B2  A       *R11+,R8                offset in data word
1329                                                    
1330  4950 0429 VDPR2B  BLWP    @>005A(R9)              get two byte from VDP at R8
1330  4952 005A  
1331  4954 0102         DATA    >0102                   set VDP to read at R8
1332  4956 D02F         MOVB    @-1026(R15),R0          get two bytes of data
1332  4958 FBFE  
1333  495A 06C0         SWPB    R0                      
1334  495C D02F         MOVB    @-1026(R15),R0                  
1334  495E FBFE  
1335  4960 0B80         SRC     R0,8                    why not swpb ?
1336  4962 045B         B       *R11                    
1337                                                    
1338  4964 C069 FDSKDR  MOV     @>0058(R9),R1           find disk from name (ptr in R3)
1338  4966 0058  
1339  4968 0221         AI      R1,256                  
1339  496A 0100  
1340  496C 06A0         BL      @CPCKFN                 copy filename from VDP at R3 to compare buffer
1340  496E 49EE  
1341  4970 0429         BLWP    @>005A(R9)              save R2 + R3
1341  4972 005A  
1342  4974 3000         DATA    >3000                   
1343  4976 C000         MOV     R0,R0                   last char copied
1344  4978 1101         JLT     H113                    flagged
1345  497A 1005         JMP     H114                    
1346  497C C180 H113    MOV     R0,R6                   
1347  497E 0246         ANDI    R6,>0300                        
1347  4980 0300  
1348  4982 1337         JEQ     ERROR7                  return with file error
1349  4984 102F         JMP     H115                    return to caller
1350  4986 04C6 H114    CLR     R6                      don't read any drive
1351  4988 06A0         BL      @CALSUB                 call subroutine
1351  498A 4432  
1352  498C 4AAC         DATA    RWVIB                   save current VIB
1353  498E 0226 H116    AI      R6,>0100                next drive
1353  4990 0100  
1354  4992 0707         SETO    R7                      error flags
1355  4994 0702         SETO    R2                      code for read
1356  4996 04C4         CLR     R4                      sector 0
1357  4998 06A0         BL      @CALSUB                 call subroutine
1357  499A 4432  
1358  499C 4B2A         DATA    RWSECA                  read sector 0
1359  499E C1C7         MOV     R7,R7                   ok?
1360  49A0 161D         JNE     H118                    no: try next drive
1361  49A2 0204         LI      R4,10                   yes: diskname size
1361  49A4 000A  
1362  49A6 C069         MOV     @>0058(R9),R1           VIB ptr
1362  49A8 0058  
1363  49AA 0429         BLWP    @>005A(R9)              save R1-R3
1363  49AC 005A  
1364  49AE 7000         DATA    >7000                   
1365  49B0 06A0         BL      @CMPFN                  compare names (ptr in R1 + compare buffer)
1365  49B2 4916  
1366  49B4 0429         BLWP    @>005A(R9)                      
1366  49B6 005A  
1367  49B8 7001         DATA    >7001                   retrieve R1-R3
1368  49BA C104         MOV     R4,R4                   name matched?
1369  49BC 160F         JNE     H118                    no: try next drive
1370  49BE C006         MOV     R6,R0                   drive #
1371  49C0 0260         ORI     R0,>8000                add update flag
1371  49C2 8000  
1372  49C4 0429         BLWP    @>005A(R9)              set VDP to write
1372  49C6 005A  
1373  49C8 0063         DATA    >0063                   address in R3
1374  49CA DBC0         MOVB    R0,@-2(R15)             copy drive+flag before diskname in source
1374  49CC FFFE  
1375  49CE 0605         DEC     R5                      before sector 0 copy
1376  49D0 0429         BLWP    @>005A(R9)              set VDP to write
1376  49D2 005A  
1377  49D4 00A3         DATA    >00A3                   address in R5
1378  49D6 DBC6         MOVB    R6,@-2(R15)             copy drive # before VIB
1378  49D8 FFFE  
1379  49DA 1004         JMP     H115                    done
1380                                                    
1381  49DC 0286 H118    CI      R6,>0300                did we do all drives?
1381  49DE 0300  
1382  49E0 16D6         JNE     H116                    no: try next on
1383  49E2 1007         JMP     ERROR7                  return with file error
1384                                                    
1385  49E4 0429 H115    BLWP    @>005A(R9)              retrieve R2 + R3
1385  49E6 005A  
1386  49E8 3001         DATA    >3001                   
1387  49EA 0460         B       @RTURN1                 return to caller
1387  49EC 4450  
1388                                                    
1389  49EE 0602 CPCKFN  DEC     R2                      
1390  49F0 1B03         JH      H119                    
1391  49F2 06A0 ERROR7  BL      @RETERR                 return with error
1391  49F4 4A78  
1392  49F6 E000         DATA    >E000                   file error
1393                                                    
1394  49F8 0200 H119    LI      R0,>2000                copy (+check) filename in VDP from R3 to R1 (space)
1394  49FA 2000  
1395  49FC 0429         BLWP    @>005A(R9)              set VDP to write
1395  49FE 005A  
1396  4A00 0023         DATA    >0023                   address in R1
1397  4A02 0208         LI      R8,10                   10 chars per filename
1397  4A04 000A  
1398  4A06 DBC0 H120    MOVB    R0,@-2(R15)             fill filename with spaces
1398  4A08 FFFE  
1399  4A0A 0608         DEC     R8                      
1400  4A0C 16FC         JNE     H120                    
1401  4A0E 0208         LI      R8,11                   11 chars countring drive #
1401  4A10 000B  
1402  4A12 0583 H122    INC     R3                      increment source ptr
1403  4A14 0429         BLWP    @>005A(R9)              set VDP to read
1403  4A16 005A  
1404  4A18 0062         DATA    >0062                   address in R3
1405  4A1A D02F         MOVB    @-1026(R15),R0          get a char
1405  4A1C FBFE  
1406  4A1E 13E9         JEQ     ERROR7                  >00: return with file error
1407  4A20 1110         JLT     H121                    flag bit set
1408  4A22 0280         CI      R0,>2E00                        
1408  4A24 2E00  
1409  4A26 130D         JEQ     H121                    '.'
1410  4A28 0608         DEC     R8                      
1411  4A2A 13E3         JEQ     ERROR7                  name to long: return with file error
1412  4A2C 0280         CI      R0,>2000                        
1412  4A2E 2000  
1413  4A30 13E0         JEQ     ERROR7                  name can't contain spaces: file error again
1414  4A32 0429         BLWP    @>005A(R9)              set VDP to write
1414  4A34 005A  
1415  4A36 0023         DATA    >0023                   address in R1
1416  4A38 DBC0         MOVB    R0,@-2(R15)             copy 1 char
1416  4A3A FFFE  
1417  4A3C 0581         INC     R1                      increment destination pointer
1418  4A3E 0602         DEC     R2                      more?
1419  4A40 16E8         JNE     H122                    yes
1420  4A42 0288 H121    CI      R8,>000B                name can't be 0 chars long
1420  4A44 000B  
1421  4A46 13D5         JEQ     ERROR7                  else return with file error
1422  4A48 045B         B       *R11                    
1423                                                    
1424  4A4A AA00 K014    DATA    >AA00                   
1425                                                    
1426  4A4C C00B ERROR5  MOV     R11,R0                  update data, then error
1427  4A4E C0E9         MOV     @>0056(R9),R3           
1427  4A50 0056  
1428  4A52 0603         DEC     R3                      see what >8356 is pointing at
1429  4A54 0429         BLWP    @>005A(R9)              set VDP to read
1429  4A56 005A  
1430  4A58 0062         DATA    >0062                   address in R3
1431  4A5A D0AF         MOVB    @-1026(R15),R2          get 1 byte
1431  4A5C FBFE  
1432  4A5E 9802         CB      R2,@K014                is it >AA (disk buffer area mark)
1432  4A60 4A4A  
1433  4A62 1309         JEQ     H123                    yes: announce error (code in data word)
1434  4A64 0429         BLWP    @>005A(R9)              no: >8356 points to a FDR. Save R0
1434  4A66 005A  
1435  4A68 8000         DATA    >8000                   
1436  4A6A 06A0         BL      @CALSUB                 call subroutine
1436  4A6C 4432  
1437  4A6E 4650         DATA    UPDFDR                  update FRD and data buffer if needed
1438  4A70 0429         BLWP    @>005A(R9)              retrieve R0
1438  4A72 005A  
1439  4A74 8001         DATA    >8001                   
1440  4A76 C2C0 H123    MOV     R0,R11                  
1441                                                    
1442  4A78 C069 RETERR  MOV     @>0054(R9),R1           annouce error
1442  4A7A 0054  
1443  4A7C 130D         JEQ     H124                    no PAB
1444  4A7E 0581         INC     R1                      for DSRs: ptr to status byte
1445  4A80 0429         BLWP    @>005A(R9)              set VDP to read
1445  4A82 005A  
1446  4A84 0022         DATA    >0022                   address in R2
1447  4A86 D0AF         MOVB    @-1026(R15),R2          get file status byte
1447  4A88 FBFE  
1448  4A8A E0BB         SOC     *R11+,R2                add error code
1449  4A8C 0429         BLWP    @>005A(R9)              set VDP to write
1449  4A8E 005A  
1450  4A90 0023         DATA    >0023                   address in R2
1451  4A92 DBC2         MOVB    R2,@-2(R15)             write back status byte
1451  4A94 FFFE  
1452  4A96 1002         JMP     H125                    
1453  4A98 CA7B H124    MOV     *R11+,@>0050(R9)        for subs: error code in >8350
1453  4A9A 0050  
1454  4A9C C229 H125    MOV     @>0058(R9),R8           get stack ptr
1454  4A9E 0058  
1455  4AA0 0228         AI      R8,-12                  point back to initial caller
1455  4AA2 FFF4  
1456  4AA4 CA48         MOV     R8,@>0066(R9)           update pointer
1456  4AA6 0066  
1457  4AA8 0460         B       @RTURN1                 return to caller
1457  4AAA 4450  
1458                                                    
1459  4AAC 0429 RWVIB   BLWP    @>005A(R9)              read VIB (drive # in R6)
1459  4AAE 005A  
1460  4AB0 3000         DATA    >3000                   save R2 + R3
1461  4AB2 C169         MOV     @>0058(R9),R5           pointer to VIB in ctrl block
1461  4AB4 0058  
1462  4AB6 0605         DEC     R5                      ptr to drive #
1463  4AB8 0429         BLWP    @>005A(R9)              set VDP for read
1463  4ABA 005A  
1464  4ABC 00A2         DATA    >00A2                   address in R5
1465  4ABE D0AF         MOVB    @-1026(R15),R2          get drive #
1465  4AC0 FBFE  
1466  4AC2 C0C2         MOV     R2,R3                   
1467  4AC4 04C4         CLR     R4                      sector 0 for VIB
1468  4AC6 0242         ANDI    R2,>0300                clear flag (>80 = update data)
1468  4AC8 0300  
1469  4ACA 9182         CB      R2,R6                   wanted drive?
1470  4ACC 131A         JEQ     H126                    yes: return
1471  4ACE C0C3         MOV     R3,R3                   no: shall we update VIB?
1472  4AD0 1101         JLT     H127                    yes
1473  4AD2 100A         JMP     H128                    no
1474  4AD4 0429 H127    BLWP    @>005A(R9)              set VDP to write
1474  4AD6 005A  
1475  4AD8 00A3         DATA    >00A3                   address in R5
1476  4ADA DBC4         MOVB    R4,@-2(R15)             clr drive #
1476  4ADC FFFE  
1477  4ADE 0585         INC     R5                      point back to VIB buffer
1478  4AE0 06A0         BL      @CALSUB                 call subroutine
1478  4AE2 4432  
1479  4AE4 4B2C         DATA    RWSECB                  write sector 0 to old drive (in R2)
1480  4AE6 0605         DEC     R5                      point to drive #
1481  4AE8 0702 H128    SETO    R2                      flag for read
1482            *       MOVB    R5,R2                   add wanted drive
1483  4AEA D086         MOVB    R6,R2                   APEDSK99: error in original disassembly
1484  4AEC 1305         JEQ     H129                    none
1485  4AEE 0585         INC     R5                      point at VIB buffer
1486  4AF0 06A0         BL      @CALSUB                 call subroutine
1486  4AF2 4432  
1487  4AF4 4B2A         DATA    RWSECA                  read sector (in R4) to buffer (in R5)
1488  4AF6 0605         DEC     R5                      point at drive #
1489  4AF8 0429 H129    BLWP    @>005A(R9)              set VDP to write
1489  4AFA 005A  
1490  4AFC 00A3         DATA    >00A3                   address in R5
1491  4AFE DBC6         MOVB    R6,@-2(R15)             write drive # in control block, before FDR
1491  4B00 FFFE  
1492  4B02 0585 H126    INC     R5                      point back to FDR
1493  4B04 0429         BLWP    @>005A(R9)                      
1493  4B06 005A  
1494  4B08 3001         DATA    >3001                   retrieve R2 + R3 from stack
1495  4B0A 0460         B       @RTURN1                 branch to address on stack
1495  4B0C 4450  
1496                                                    
1497  4B0E 0702 RDSEC1  SETO    R2                      read sector 1
1498  4B10 0204 WRSEC1  LI      R4,1
1498  4B12 0001  
1499  4B14 0205         LI      R5,>0100                into data buffer area of current ctrl block
1499  4B16 0100  
1500  4B18 1005         JMP     RDFDR1                  
1501                                                    
1502  4B1A 06A0 WRFDR   BL      @FDR2B1                 read FDR
1502  4B1C 494A  
1503  4B1E FFFC         DATA    -4                      -------- get sector # of FDR from control block
1504                                                    
1505  4B20 C100 RDFDR2  MOV     R0,R4                   sector read/write
1506  4B22 04C5         CLR     R5
1507  4B24 A169 RDFDR1  A       @>0056(R9),R5           point to FDR or data buffer
1507  4B26 0056  
1508  4B28 04C7 RWSEC   CLR     R7                      
1509  4B2A D086 RWSECA  MOVB    R6,R2                   add drive # for r/w flag
1510  4B2C 0429 RWSECB  BLWP    @>005A(R9)              save R0-R8
1510  4B2E 005A  
1511  4B30 FF80         DATA    >FF80                   
1512  4B32 CA44         MOV     R4,@>004A(R9)           sector #
1512  4B34 004A  
1513  4B36 CA42         MOV     R2,@>004C(R9)           drive | r/w flag
1513  4B38 004C  
1514  4B3A CA45         MOV     R5,@>004E(R9)           buffer ptr
1514  4B3C 004E  
1515  4B3E 06A0         BL      @CALSUB                 call subroutine
1515  4B40 4432  
1516  4B42 4164         DATA    SECRW1                  sector read/write
1517  4B44 0429         BLWP    @>005A(R9)              retrieve R0-R8
1517  4B46 005A  
1518  4B48 FF81         DATA    >FF81                   
1519  4B4A D1E9         MOVB    @>0050(R9),R7           get error code | flags
1519  4B4C 0050  
1520  4B4E 06C7         SWPB    R7                      
1521  4B50 1312         JEQ     H130                    
1522  4B52 C1C7         MOV     R7,R7                   
1523  4B54 1501         JGT     H131                    
1524  4B56 100B         JMP     H132                    
1525  4B58 0247 H131    ANDI    R7,>00FF                        
1525  4B5A 00FF  
1526  4B5C 0287         CI      R7,>0034                        
1526  4B5E 0034  
1527  4B60 1603         JNE     H133                    
1528  4B62 06A0         BL      @ERROR5                 
1528  4B64 4A4C  
1529  4B66 2000         DATA    >2000                   write protected
1530  4B68 06A0 H133    BL      @ERROR5                 
1530  4B6A 4A4C  
1531  4B6C C000         DATA    >C000                   device error
1532  4B6E DA69 H132    MOVB    @>004D(R9),@>004D(R9)   read or write?
1532  4B70 004D  
1532  4B72 004D  
1533  4B74 13F1         JEQ     H131                    write
1534  4B76 0247 H130    ANDI    R7,>00FF                        
1534  4B78 00FF  
1535  4B7A 0460         B       @RTURN1                 return to caller
1535  4B7C 4450  
1536                                                    
1537  4B7E C069 FFFDRV  MOV     @>0058(R9),R1           save filename in compare buffer and find its FDR
1537  4B80 0058  
1538  4B82 0221         AI      R1,256                  
1538  4B84 0100  
1539  4B86 0429         BLWP    @>005A(R9)              set VDP to write
1539  4B88 005A  
1540  4B8A 0023         DATA    >0023                   address in R1: filename compare buffer
1541  4B8C DBC6         MOVB    R6,@-2(R15)             write drive #
1541  4B8E FFFE  
1542  4B90 0581         INC     R1                      
1543  4B92 06A0         BL      @CPCKFN                 copy (+ check) filename from R3 to R1
1543  4B94 49EE  
1544  4B96 C082         MOV     R2,R2                   all chars copied (or was there a . or a >00
1545  4B98 1302         JEQ     FFDRVB                  
1546  4B9A 0460 H136    B       @ERROR7                 return with file error
1546  4B9C 49F2  
1547                                                    
1548  4B9E C069 FFDRVB  MOV     @>0056(R9),R1           find filename in buffered FDRs
1548  4BA0 0056  
1549  4BA2 0221         AI      R1,3                    
1549  4BA4 0003  
1550  4BA6 0429         BLWP    @>005A(R9)              set VDP to read
1550  4BA8 005A  
1551  4BAA 0022         DATA    >0022                   address in R1
1552  4BAC D0AF         MOVB    @-1026(R15),R2          get # of files
1552  4BAE FBFE  
1553  4BB0 0982         SRL     R2,8                    make it a word
1554  4BB2 C0C2         MOV     R2,R3                   save it
1555  4BB4 0221         AI      R1,6                    ptr to drive #
1555  4BB6 0006  
1556  4BB8 0204 H134    LI      R4,11                   compare 11 bytes (drive + filename)
1556  4BBA 000B  
1557  4BBC 0429         BLWP    @>005A(R9)              save R1-R3
1557  4BBE 005A  
1558  4BC0 7000         DATA    >7000                   
1559  4BC2 06A0         BL      @CMPFN                  compare with name in compare buffer
1559  4BC4 4916  
1560  4BC6 0429         BLWP    @>005A(R9)              retrieve R1-R3
1560  4BC8 005A  
1561  4BCA 7001         DATA    >7001                   
1562  4BCC C104         MOV     R4,R4                   fully compared?
1563  4BCE 1304         JEQ     H135                    yes: done
1564  4BD0 0221         AI      R1,518                  move to next FDR in VDP mem
1564  4BD2 0206  
1565  4BD4 0602         DEC     R2                      
1566  4BD6 16F0         JNE     H134                    next file
1567  4BD8 0460 H135    B       @RTURN1                 return to caller (R4=0 if successfull)
1567  4BDA 4450  
1568                                                    
1569  4BDC 06A0 FNDFDR  BL      @CALSUB                 
1569  4BDE 4432  
1570  4BE0 4B7E         DATA    FFFDRV                  save name in comp buffer, find FDR in VDP buffers
1571                                                    
1572  4BE2 C104 FFDROD  MOV     R4,R4                   find FDR on disk (from filename)
1573  4BE4 13DA         JEQ     H136                    file error
1574  4BE6 C169 FFDRDK  MOV     @>0056(R9),R5           ptr to top of disk buffer in VDP mem
1574  4BE8 0056  
1575  4BEA 0225         AI      R5,10                   ptr to drive # in first file control block
1575  4BEC 000A  
1576  4BEE 0429 H138    BLWP    @>005A(R9)              set VDP to read
1576  4BF0 005A  
1577  4BF2 00A2         DATA    >00A2                   address in R5
1578  4BF4 D0AF         MOVB    @-1026(R15),R2          get drive #
1578  4BF6 FBFE  
1579  4BF8 1307         JEQ     H137                    free control block found
1580  4BFA 0225         AI      R5,518                  ptr to file control block
1580  4BFC 0206  
1581  4BFE 0603         DEC     R3                      
1582  4C00 16F6         JNE     H138                    more files ?
1583  4C02 06A0 ERROR6  BL      @ERROR5                 no:
1583  4C04 4A4C  
1584  4C06 8000         DATA    >8000                   memory full
1585                                                    
1586  4C08 CA45 H137    MOV     R5,@>0056(R9)           save ptr to free ctrl block (drive #)
1586  4C0A 0056  
1587  4C0C 06A0         BL      @CALSUB                 call subroutine
1587  4C0E 4432  
1588  4C10 4B0E         DATA    RDSEC1                  read sector 1
1589  4C12 C229 FFDRFN  MOV     @>0056(R9),R8           entry point if sector 1 already read
1589  4C14 0056  
1590  4C16 0228         AI      R8,382                  point to middle of sector 1
1590  4C18 017E  
1591  4C1A 0202         LI      R2,64                   distance: start with 1/4 sector
1591  4C1C 0040  
1592  4C1E 0704 H139    SETO    R4                      
1593  4C20 06A0         BL      @VDPR2B                 read 2 bytes in R0 from VDP address in R8
1593  4C22 4950  
1594  4C24 C000         MOV     R0,R0                   
1595  4C26 132E         JEQ     H140                    no file here: move up
1596  4C28 0429         BLWP    @>005A(R9)              save R2
1596  4C2A 005A  
1597  4C2C 2000         DATA    >2000                   
1598  4C2E 0702         SETO    R2                      code for read
1599  4C30 06A0         BL      @CALSUB                 call subroutine
1599  4C32 4432  
1600  4C34 4B20         DATA    RDFDR2                  read FDR, sector # in R0
1601  4C36 C045         MOV     R5,R1                   RDFDR2 sets R5 as FDR ptr
1602  4C38 0225         AI      R5,-4                   point to sector # of FDR in ctrl block
1602  4C3A FFFC  
1603  4C3C 0429         BLWP    @>005A(R9)              set VDP to write
1603  4C3E 005A  
1604  4C40 00A3         DATA    >00A3                   address in R5
1605  4C42 DBC4         MOVB    R4,@-2(R15)             RDFDR2 puts sector # in R4
1605  4C44 FFFE  
1606  4C46 06C4         SWPB    R4                      copy it to ctrl block
1607  4C48 DBC4         MOVB    R4,@-2(R15)                     
1607  4C4A FFFE  
1608  4C4C C141         MOV     R1,R5                   FDR ptr
1609  4C4E 0601         DEC     R1                      now point to drive #
1610  4C50 0429         BLWP    @>005A(R9)              set VDP to write
1610  4C52 005A  
1611  4C54 0023         DATA    >0023                   address in R1
1612  4C56 DBC6         MOVB    R6,@-2(R15)             save drive #
1612  4C58 FFFE  
1613  4C5A 0204         LI      R4,11                   size to compare (drive # + filename)
1613  4C5C 000B  
1614  4C5E 06A0         BL      @CMPFN                  compare filenames
1614  4C60 4916  
1615  4C62 0429         BLWP    @>005A(R9)              retrieve R2
1615  4C64 005A  
1616  4C66 2001         DATA    >2001                   
1617  4C68 130B         JEQ     H141                    compared ok: return
1618  4C6A 0429         BLWP    @>005A(R9)              set VDP to write
1618  4C6C 005A  
1619  4C6E 00A3         DATA    >00A3                   address in R5
1620  4C70 DBC4         MOVB    R4,@-2(R15)             remaining chars to compare
1620  4C72 FFFE  
1621  4C74 80C0         C       R0,R3                   what kind of mismatch occured?
1622  4C76 1B06         JH      H140                    too far down the alphabet
1623  4C78 A202         A       R2,R8                   too far up: move half-way down
1624  4C7A C082         MOV     R2,R2                   
1625  4C7C 1606         JNE     H142                    then divide distance by 2
1626  4C7E 05C8         INCT    R8                      already checked: reset EQ
1627  4C80 0460 H141    B       @RTURN1                 return (from stack)
1627  4C82 4450  
1628                                                    
1629  4C84 6202 H140    S       R2,R8                   move half-way up
1630  4C86 C082         MOV     R2,R2                   
1631  4C88 13FB         JEQ     H141                    can't: already checked
1632  4C8A 0922 H142    SRL     R2,2                    divide distance by 2
1633  4C8C A082         A       R2,R2                   but keep it even
1634  4C8E 10C7         JMP     H139                    
1635            
1636            * The cluster info list is located in the FDR, bytes >1C to >FF
1637            * A cluster info consists in 3 bytes, i.e 6 nibbles
1638            * 3 nibbles specify the beginning sector for that cluster, and
1639            * 3 nibbles specify the total file offset in sectors, including this cluster.
1640            * The nibbles are arranged as EG SB OF, to be combined as BEG OFS
1641  4C90 C28B DECDCI  MOV     R11,R10                 decode cluster info
1642  4C92 06A0         BL      @VDPR2B                 read 2 bytes VDP at R8 in R0
1642  4C94 4950  
1643  4C96 06C0         SWPB    R0                      
1644  4C98 D0AF         MOVB    @-1026(R15),R2          get third byte from cluster list
1644  4C9A FBFE  
1645  4C9C C040         MOV     R0,R1                   
1646  4C9E 0241         ANDI    R1,>0FFF                start sector in R1
1646  4CA0 0FFF  
1647  4CA2 4001         SZC     R1,R0                   remove it from R0
1648  4CA4 0982         SRL     R2,8                    
1649  4CA6 E080         SOC     R0,R2                   combine offset nibbles
1650  4CA8 0BC2         SRC     R2,12                   offset in R2
1651  4CAA 045A         B       *R10                    
1652                                                    
1653  4CAC 0B42 UPDCLI  SRC     R2,4                    write info for 1 cluster
1654  4CAE C002         MOV     R2,R0                   
1655  4CB0 0240         ANDI    R0,>F000                sector in R1, offset in R2
1655  4CB2 F000  
1656  4CB4 E040         SOC     R0,R1                   copy nibble 3 of offset before nibble 1 of sector
1657  4CB6 0429         BLWP    @>005A(R9)              set VDP to write
1657  4CB8 005A  
1658  4CBA 0103         DATA    >0103                   address in R8
1659  4CBC 06C1         SWPB    R1                      write cluster info
1660  4CBE DBC1         MOVB    R1,@-2(R15)             as 3 bytes
1660  4CC0 FFFE  
1661  4CC2 06C1         SWPB    R1                      
1662  4CC4 DBC1         MOVB    R1,@-2(R15)                     
1662  4CC6 FFFE  
1663  4CC8 06C2         SWPB    R2                      
1664  4CCA DBC2         MOVB    R2,@-2(R15)                     
1664  4CCC FFFE  
1665  4CCE 045B         B       *R11                    
1666            
1667            * The sector bitmap is located in the VIB (i.e. sector 0) at bytes >38 to >FF
1668            * In each byte a bit defines a sector, from right to left: "0"=free, "1"=used                                   
1669  4CD0 0429 FFSBMP  BLWP    @>005A(R9)              find a free sector in bitmap
1669  4CD2 005A  
1670  4CD4 7800         DATA    >7800                   
1671  4CD6 06A0         BL      @CALSUB                 call subroutine
1671  4CD8 4432  
1672  4CDA 4AAC         DATA    RWVIB                   load VIB for drive in R6
1673  4CDC C041         MOV     R1,R1                   first sector specified in R1 ?
1674  4CDE 1602         JNE     H143                    yes
1675  4CE0 0201         LI      R1,33                   no: start with sector 34
1675  4CE2 0021  
1676  4CE4 0581 H143    INC     R1                      
1677  4CE6 C001         MOV     R1,R0                   
1678  4CE8 0931         SRL     R1,3                    div by 8 since 8 sect/byte in bitmap
1679  4CEA 0202         LI      R2,>00FF                        
1679  4CEC 00FF  
1680  4CEE 0240         ANDI    R0,>0007                bit number in bitmap byte
1680  4CF0 0007  
1681  4CF2 1301         JEQ     H144                    
1682  4CF4 0A02         SLA     R2,0                    get that bit
1683  4CF6 C0C1 H144    MOV     R1,R3                   byte #
1684  4CF8 A0C5         A       R5,R3                   add VIB ptr
1685  4CFA 0223         AI      R3,56                   ptr to sector in bitmap
1685  4CFC 0038  
1686  4CFE 0281         CI      R1,>00C8                end of VIB?
1686  4D00 00C8  
1687  4D02 1101         JLT     H145                    no
1688  4D04 04C1         CLR     R1                      yes: top of bitmap
1689  4D06 A045 H145    A       R5,R1                   
1690  4D08 0221         AI      R1,56                   make another bitmap ptr
1690  4D0A 0038  
1691  4D0C 0429         BLWP    @>005A(R9)              set VDP to read
1691  4D0E 005A  
1692  4D10 0022         DATA    >0022                   address in R1
1693  4D12 0700 H146    SETO    R0                      
1694  4D14 D02F         MOVB    @-1026(R15),R0          get bitmap byte
1694  4D16 FBFE  
1695  4D18 C100         MOV     R0,R4                   save it
1696  4D1A E002         SOC     R2,R0                   mask previous sectors
1697  4D1C 04C2         CLR     R2                      
1698  4D1E 0580         INC     R0                      get 1 more sector
1699  4D20 1610         JNE     H147                    ok
1700  4D22 0581         INC     R1                      byte full: try next
1701  4D24 C001         MOV     R1,R0                   
1702  4D26 0220         AI      R0,-256                 won't change if byte # became >100
1702  4D28 FF00  
1703  4D2A 8140         C       R0,R5                   still in VIB?
1704  4D2C 1605         JNE     H148                    yes
1705  4D2E 0221         AI      R1,-200                 no: to top of bitmap
1705  4D30 FF38  
1706  4D32 0429         BLWP    @>005A(R9)              set VDP to read
1706  4D34 005A  
1707  4D36 0022         DATA    >0022                   address in R1
1708  4D38 80C1 H148    C       R1,R3                   are we back to where we started?
1709  4D3A 16EB         JNE     H146                    no: seach that byte for a free sector
1710  4D3C C004         MOV     R4,R0                   get original byte
1711  4D3E 0580         INC     R0                      try sectors just before ours (no mask this time)
1712  4D40 1325         JEQ     H149                    full: return with EQ
1713  4D42 0600 H147    DEC     R0                      restore original byte
1714  4D44 C080         MOV     R0,R2                   
1715  4D46 04C0         CLR     R0                      bit counter
1716  4D48 06C2         SWPB    R2                      
1717  4D4A 0580 H150    INC     R0                      increment bit count
1718  4D4C 0B12         SRC     R2,1                    find first 0 bit from the right
1719  4D4E 18FD         JOC     H150                    not yet
1720  4D50 0202         LI      R2,>0080                        
1720  4D52 0080  
1721  4D54 0A02         SLA     R2,0                    make a mask for that bit
1722  4D56 0600         DEC     R0                      bit # (0-7)
1723  4D58 E102         SOC     R2,R4                   mark sector as used in bitmap byte
1724  4D5A 0429         BLWP    @>005A(R9)              set VDP to write
1724  4D5C 005A  
1725  4D5E 0023         DATA    >0023                   address in R1
1726  4D60 DBC4         MOVB    R4,@-2(R15)             update bitmap
1726  4D62 FFFE  
1727  4D64 0221         AI      R1,-56                  
1727  4D66 FFC8  
1728  4D68 6045         S       R5,R1                   byte # in bitmap
1729  4D6A 0A31         SLA     R1,3                    times 8 (8 sect per byte)
1730  4D6C E040         SOC     R0,R1                   add bit #: = sector #
1731  4D6E C001         MOV     R1,R0                   save it
1732                                                    
1733  4D70 0605 H151    DEC     R5                      point to drive #
1734  4D72 0429         BLWP    @>005A(R9)              set VDP to read
1734  4D74 005A  
1735  4D76 00A2         DATA    >00A2                   address in R5
1736  4D78 D06F         MOVB    @-1026(R15),R1          get drive #
1736  4D7A FBFE  
1737  4D7C 0261         ORI     R1,>8000                add flag: update VIB
1737  4D7E 8000  
1738  4D80 0429         BLWP    @>005A(R9)              set VDP to write
1738  4D82 005A  
1739  4D84 00A3         DATA    >00A3                   address in R5
1740  4D86 DBC1         MOVB    R1,@-2(R15)             write back flagged drive #
1740  4D88 FFFE  
1741  4D8A 0585         INC     R5                      point to VIB (& return with NEQ)
1742  4D8C 0429 H149    BLWP    @>005A(R9)              retrieve R1-R4
1742  4D8E 005A  
1743  4D90 7801         DATA    >7801                   
1744  4D92 0460         B       @RTURN1                 return to caller
1744  4D94 4450  
1745                                                    
1746  4D96 C040 FFSBM   MOV     R0,R1                   free sector(s) in bitmap
1747  4D98 0202         LI      R2,1                    1 sector only
1747  4D9A 0001  
1748  4D9C 0429 FRSCB1  BLWP    @>005A(R9)              entry point if more than 1 sector
1748  4D9E 005A  
1749  4DA0 7800         DATA    >7800                   save R1-R4
1750  4DA2 06A0         BL      @CALSUB                 call subroutine
1750  4DA4 4432  
1751  4DA6 4AAC         DATA    RWVIB                   load VIB for drive in R6
1752  4DA8 C001         MOV     R1,R0                   sector #
1753  4DAA 0240         ANDI    R0,>0007                bit in bitmap byte (8 per byte)
1753  4DAC 0007  
1754  4DAE 0931         SRL     R1,3                    byte in bitmap
1755  4DB0 A045         A       R5,R1                   add VIB buffer
1756  4DB2 0221         AI      R1,56                   add bitmap offset in VIB
1756  4DB4 0038  
1757  4DB6 C0C0         MOV     R0,R3                   
1758  4DB8 0500         NEG     R0                      
1759  4DBA 0220         AI      R0,8                    change 0-7 into 8-1
1759  4DBC 0008  
1760  4DBE 0204         LI      R4,>00FF                mask to erase
1760  4DC0 00FF  
1761  4DC2 8002         C       R2,R0                   how many to erase?
1762  4DC4 1101         JLT     H152                    less than in that byte
1763  4DC6 100A         JMP     H153                    
1764                                                    
1765  4DC8 0200 H152    LI      R0,8                    free sectors in first byte
1765  4DCA 0008  
1766  4DCC 6002         S       R2,R0                   
1767  4DCE 0B04         SRC     R4,0                    adjust mask
1768  4DD0 C003         MOV     R3,R0                   original bit # of starting sector
1769  4DD2 1301         JEQ     H154                    
1770  4DD4 0A04         SLA     R4,0                    don't erase before starting sector
1771  4DD6 1000 H154    JMP     H155                    
1772                                                    
1773            *       SRL     R9,3                    what the heck is that??? 
1774                                                    
1775  4DD8 06C4 H155    SWPB    R4                      
1776  4DDA 1019         JMP     H158                    goto erase last byte
1777                                                    
1778  4DDC 0B04 H153    SRC     R4,0                    adjust mask
1779  4DDE 6080 H156    S       R0,R2                   that many will be freed
1780  4DE0 0429         BLWP    @>005A(R9)              set VDP to read
1780  4DE2 005A  
1781  4DE4 0022         DATA    >0022                   address in R1
1782  4DE6 D02F         MOVB    @-1026(R15),R0          get bitmap byte
1782  4DE8 FBFE  
1783  4DEA 4004         SZC     R4,R0                   mark sectors as free
1784  4DEC 0429         BLWP    @>005A(R9)              set VDP to write
1784  4DEE 005A  
1785  4DF0 0023         DATA    >0023                   address in R1
1786  4DF2 DBC0         MOVB    R0,@-2(R15)             write it back
1786  4DF4 FFFE  
1787  4DF6 0204         LI      R4,>FF00                clear full byte
1787  4DF8 FF00  
1788  4DFA 0581         INC     R1                      next byte
1789  4DFC 0200         LI      R0,8                    i.e. 8 sectors
1789  4DFE 0008  
1790  4E00 8002         C       R2,R0                   how many more sectors?
1791  4E02 1101         JLT     H157                    less than 8
1792  4E04 10EC         JMP     H156                    8 or more: next byte
1793                                                    
1794  4E06 C002 H157    MOV     R2,R0                   remaining sectors
1795  4E08 0204         LI      R4,>00FF                        
1795  4E0A 00FF  
1796  4E0C 0A04         SLA     R4,0                    coin mask
1797  4E0E 0429 H158    BLWP    @>005A(R9)              set VDP to read
1797  4E10 005A  
1798  4E12 0022         DATA    >0022                   address in R1
1799  4E14 D02F         MOVB    @-1026(R15),R0          get bitmap byte
1799  4E16 FBFE  
1800  4E18 4004         SZC     R4,R0                   mark sectors as free
1801  4E1A 0429         BLWP    @>005A(R9)              set VDP to write
1801  4E1C 005A  
1802  4E1E 0023         DATA    >0023                   address in R1
1803  4E20 DBC0         MOVB    R0,@-2(R15)             write it back
1803  4E22 FFFE  
1804  4E24 10A5         JMP     H151                    done: flag drive # and return
1805            
1806            *===================================
1807            * DSR entry points
1808            *===================================                                    
1809  4E26 C1CB EDSR01  MOV     R11,R7                  DSK
1810  4E28 06A0         BL      @PRPFDO                 --- prepare file operations
1810  4E2A 44FE  
1811  4E2C 06A0         BL      @CALSUB                 call subroutine
1811  4E2E 4432  
1812  4E30 4964         DATA    FDSKDR                  find disk in drive (name ptr in R3)
1813  4E32 100B         JMP     H159                    
1814                                                    
1815  4E34 0206 EDSR02  LI      R6,>0100                DSK1
1815  4E36 0100  
1816  4E38 1005         JMP     H160                    ----
1817                                                    
1818  4E3A 0206 EDSR03  LI      R6,>0200                DSK2
1818  4E3C 0200  
1819  4E3E 1002         JMP     H160                    ----
1820                                                    
1821  4E40 0206 EDSR04  LI      R6,>0300                DSK3
1821  4E42 0300  
1822                                                    
1823  4E44 C1CB H160    MOV     R11,R7                  save return address
1824  4E46 06A0         BL      @PRPFDO                 prepare file operations
1824  4E48 44FE  
1825  4E4A C029 H159    MOV     @>0054(R9),R0           PAB ptr
1825  4E4C 0054  
1826  4E4E 0429         BLWP    @>005A(R9)              set VDP to read
1826  4E50 005A  
1827  4E52 0002         DATA    >0002                   address in R0
1828  4E54 D06F         MOVB    @-1026(R15),R1          get opcode
1828  4E56 FBFE  
1829  4E58 0981         SRL     R1,8                    
1830  4E5A 0281         CI      R1,>0009                check range
1830  4E5C 0009  
1831  4E5E 1B19         JH      ERROR8                  illegal opcode
1832  4E60 0282         CI      R2,>0001                filename lenght (including . )
1832  4E62 0001  
1833  4E64 1605         JNE     H161                    no filename: dir
1834  4E66 0221         AI      R1,10                   only allow open, close and read
1834  4E68 000A  
1835  4E6A 0281         CI      R1,>000C                        
1835  4E6C 000C  
1836  4E6E 1B11         JH      ERROR8                  others are illegal
1837  4E70 A041 H161    A       R1,R1                   make it a word ptr
1838  4E72 C061         MOV     @OPCVEC(R1),R1          get vector
1838  4E74 4E78  
1839  4E76 0451         B       *R1                     branch to it
1840                                                    
1841  4E78 4E98 OPCVEC  DATA    OPEN                    open
1842  4E7A 50AA         DATA    CLOSE                   close
1843  4E7C 50B4         DATA    READ                    read
1844  4E7E 519E         DATA    WRITE                   write
1845  4E80 5452         DATA    RWIND1                  rewind
1846  4E82 54A6         DATA    LOAD                    load
1847  4E84 5548         DATA    SAVE                    save
1848  4E86 4848         DATA    DELETE                  delete
1849  4E88 4A78         DATA    RETERR                  scratch record: return with bad attribute error
1850  4E8A 55CC         DATA    STATUS                  status
1851                                                    
1852  4E8C 568C         DATA    OPNDIR                  open directory
1853  4E8E 56EA         DATA    CLSDIR                  close directory
1854  4E90 5700         DATA    RDDIR                   read directory
1855                                                    
1856  4E92 06A0 ERROR8  BL      @ERROR5                 return with error
1856  4E94 4A4C  
1857  4E96 6000         DATA    >6000                   illegal opcode
1858            
1859            *---------------------------------
1860            * Opcode 0: Open
1861            * --------------
1862            * PAB 0: >00
1863            *     1: file type  <--- error code
1864            *   2-3:
1865            *     4: record length
1866            *     5:
1867            *   6-7: # of records (if output)
1868            *     8:
1869            *---------------------------------                                      
1870  4E98 04C0 OPEN    CLR     R0                      
1871  4E9A D02F         MOVB    @-1026(R15),R0          get file attributes
1871  4E9C FBFE  
1872  4E9E 0429         BLWP    @>005A(R9)                      
1872  4EA0 005A  
1873  4EA2 8000         DATA    >8000                   save R0
1874  4EA4 0240         ANDI    R0,>1600                keep fix/var and access mode
1874  4EA6 1600  
1875  4EA8 0280         CI      R0,>0600                        
1875  4EAA 0600  
1876  4EAC 1603         JNE     H162                    
1877  4EAE 06A0 ERROR9  BL      @ERROR5                 dis/fix, open as append: return with error
1877  4EB0 4A4C  
1878  4EB2 4000         DATA    >4000                   bad attribute
1879                                                    
1880  4EB4 120A H162    JLE     H163                    
1881  4EB6 C040         MOV     R0,R1                   var
1882  4EB8 06A0         BL      @PABR2B                 get 2 bytes from PAB into R0
1882  4EBA 4944  
1883  4EBC 0004         DATA    4                       rec len and char count
1884  4EBE 0280         CI      R0,>FF00                is rec len 255?
1884  4EC0 FF00  
1885  4EC2 14F5         JHE     ERROR9                  yes: bad attribute
1886  4EC4 C001         MOV     R1,R0                   retrieve attributes
1887  4EC6 0240         ANDI    R0,>0600                keep only access mode
1887  4EC8 0600  
1888                                                    
1889  4ECA 0280 H163    CI      R0,>0200                is it output?
1889  4ECC 0200  
1890  4ECE 1657         JNE     H164                    no
1891  4ED0 06A0         BL      @CALSUB                 call subroutine
1891  4ED2 4432  
1892  4ED4 456A         DATA    CRFIL1                  create file
1893  4ED6 06A0 H165    BL      @PRFDRS                 coin status byte in FDR style
1893  4ED8 5058  
1894  4EDA 0429         BLWP    @>005A(R9)              set VDP to write
1894  4EDC 005A  
1895  4EDE 0083         DATA    >0083                   address in R4: status byte in FDR buffer
1896  4EE0 DBC2         MOVB    R2,@-2(R15)             write file status in FDR
1896  4EE2 FFFE  
1897  4EE4 C0E9         MOV     @>0054(R9),R3           PAB ptr
1897  4EE6 0054  
1898  4EE8 0223         AI      R3,4                    ptr to rec len
1898  4EEA 0004  
1899  4EEC 04C5         CLR     R5                      
1900  4EEE 0429         BLWP    @>005A(R9)              set VDP to read
1900  4EF0 005A  
1901  4EF2 0062         DATA    >0062                   address in R3
1902  4EF4 D16F         MOVB    @-1026(R15),R5          get record length
1902  4EF6 FBFE  
1903  4EF8 1607         JNE     H166                    
1904  4EFA 0205         LI      R5,>5000                >00: default it 80
1904  4EFC 5000  
1905  4EFE 0429         BLWP    @>005A(R9)              set VDP to write
1905  4F00 005A  
1906  4F02 0063         DATA    >0063                   address in R3
1907  4F04 DBC5         MOVB    R5,@-2(R15)             write default rec len
1907  4F06 FFFE  
1908  4F08 0224 H166    AI      R4,5                    point to rec len byte in FDR
1908  4F0A 0005  
1909  4F0C 0429         BLWP    @>005A(R9)              set VDP to write
1909  4F0E 005A  
1910  4F10 0083         DATA    >0083                   address in R4
1911  4F12 DBC5         MOVB    R5,@-2(R15)             write rec len in FDR buffer
1911  4F14 FFFE  
1912  4F16 0201         LI      R1,256                  256 bytes/sector
1912  4F18 0100  
1913  4F1A C082         MOV     R2,R2                   var or dis?
1914  4F1C 1101         JLT     H167                    var
1915  4F1E 1002         JMP     H168                    dis
1916  4F20 A141 H167    A       R1,R5                   var: rec len +1
1917  4F22 0601         DEC     R1                      254 bytes only (needs size byte)
1918  4F24 06C5 H168    SWPB    R5                      make it a word
1919  4F26 04C0         CLR     R0                      
1920  4F28 3C05         DIV     R5,R0                   how many times in 254/255 bytes?
1921  4F2A 0224         AI      R4,-4                   point to # of rec/sect in FDR
1921  4F2C FFFC  
1922  4F2E C040         MOV     R0,R1                   save result for later
1923  4F30 06C0         SWPB    R0                      
1924  4F32 0429         BLWP    @>005A(R9)              set VDP to write
1924  4F34 005A  
1925  4F36 0083         DATA    >0083                   address in R4
1926  4F38 DBC0         MOVB    R0,@-2(R15)             write # of rec/sect in FDR
1926  4F3A FFFE  
1927  4F3C C229         MOV     @>0056(R9),R8           point to filename in FDR
1927  4F3E 0056  
1928  4F40 0429         BLWP    @>005A(R9)              set VDP to read
1928  4F42 005A  
1929  4F44 0102         DATA    >0102                   address in R8
1930  4F46 D02F         MOVB    @-1026(R15),R0          get first char
1930  4F48 FBFE  
1931  4F4A 0260         ORI     R0,>8000                flag it: update FDR before leaving
1931  4F4C 8000  
1932  4F4E 0429         BLWP    @>005A(R9)              set VDP to write
1932  4F50 005A  
1933  4F52 0103         DATA    >0103                   address in R8
1934  4F54 DBC0         MOVB    R0,@-2(R15)             write it back
1934  4F56 FFFE  
1935  4F58 0429         BLWP    @>005A(R9)                      
1935  4F5A 005A  
1936  4F5C 8001         DATA    >8001                   retrieve R0 (access mode)
1937  4F5E 06A0         BL      @PABR2B                 get 2 bytes from PAB into R0
1937  4F60 4944  
1938  4F62 0006         DATA    6                       required size in records
1939  4F64 C100         MOV     R0,R4                   
1940  4F66 1309         JEQ     H169                    no size specified
1941  4F68 11A2         JLT     ERROR9                  return with bad attribute error
1942  4F6A A101         A       R1,R4                   round up to record size
1943  4F6C 0604         DEC     R4                      
1944  4F6E 04C3         CLR     R3                      
1945  4F70 3CC1         DIV     R1,R3                   how many sectors will this be?
1946  4F72 0603         DEC     R3                      offset start from 0
1947  4F74 06A0         BL      @CALSUB                 call subroutine
1947  4F76 4432  
1948  4F78 473A         DATA    APSCTS                  add sectors to FDR to match offset in R3
1949  4F7A 0460 H169    B       @RWIND2                 initialise file control block and return to caller
1949  4F7C 5480  
1950                                                    
1951  4F7E 0429 H164    BLWP    @>005A(R9)              not output
1951  4F80 005A  
1952  4F82 8000         DATA    >8000                   save R0
1953  4F84 06A0         BL      @CALSUB                 call subroutine
1953  4F86 4432  
1954  4F88 4BDC         DATA    FNDFDR                  find FDR on disk
1955  4F8A 0429         BLWP    @>005A(R9)                      
1955  4F8C 005A  
1956  4F8E 8001         DATA    >8001                   retrieve R0 (access mode)
1957  4F90 C104         MOV     R4,R4                   found FDR?
1958  4F92 1309         JEQ     H170                    yes
1959  4F94 0280         CI      R0,>0400                no: is file open as input?
1959  4F96 0400  
1960  4F98 1304         JEQ     H171                    yes: must exist
1961  4F9A 06A0         BL      @CALSUB                 no: call subroutine
1961  4F9C 4432  
1962  4F9E 457C         DATA    CRFIL3                  create file
1963  4FA0 109A         JMP     H165                    
1964                                                    
1965  4FA2 0460 H171    B       @ERROR9                 return with bad attribute error
1965  4FA4 4EAE  
1966                                                    
1967  4FA6 C1C0 H170    MOV     R0,R7                   save access mode
1968  4FA8 06A0         BL      @PRFDRS                 prepare status byte for FDR
1968  4FAA 5058  
1969  4FAC 0429         BLWP    @>005A(R9)              set VDP to read
1969  4FAE 005A  
1970  4FB0 0082         DATA    >0082                   address in R4 (status byte in FDR)
1971  4FB2 D02F         MOVB    @-1026(R15),R0          get current file status
1971  4FB4 FBFE  
1972  4FB6 C0C0         MOV     R0,R3                   save it
1973  4FB8 0243         ANDI    R3,>0800                is file write protected?
1973  4FBA 0800  
1974  4FBC 1306         JEQ     H172                    no
1975  4FBE 0287         CI      R7,>0400                yes: is it open as input?
1975  4FC0 0400  
1976  4FC2 1303         JEQ     H172                    no
1977  4FC4 06A0         BL      @ERROR5                 yes: return with error
1977  4FC6 4A4C  
1978  4FC8 2000         DATA    >2000                   write protected
1979                                                    
1980  4FCA 0240 H172    ANDI    R0,>8300                keep only file type bits (V/F, D/I, Prg/Data)
1980  4FCC 8300  
1981  4FCE 2802         XOR     R2,R0                   compare with new (coined by PRFDRS)
1982  4FD0 16E8         JNE     H171                    different: bad attribute
1983  4FD2 C0E9         MOV     @>0054(R9),R3           PAB ptr
1983  4FD4 0054  
1984  4FD6 0223         AI      R3,4                    ptr to rec len in PAB
1984  4FD8 0004  
1985  4FDA 0224         AI      R4,5                    ptr to rec len in FDR
1985  4FDC 0005  
1986  4FDE 0429         BLWP    @>005A(R9)              set VDP to read
1986  4FE0 005A  
1987  4FE2 0082         DATA    >0082                   address in R4
1988  4FE4 D02F         MOVB    @-1026(R15),R0          get rec len from FDR
1988  4FE6 FBFE  
1989  4FE8 0429         BLWP    @>005A(R9)              set VDP to read
1989  4FEA 005A  
1990  4FEC 0062         DATA    >0062                   address in R3
1991  4FEE D0AF         MOVB    @-1026(R15),R2          get rec len from PAB
1991  4FF0 FBFE  
1992  4FF2 1302         JEQ     H173                    0 = keep current one
1993  4FF4 9080         CB      R0,R2                   are they identical?
1994  4FF6 16D5         JNE     H171                    no: bad attribute
1995  4FF8 0429 H173    BLWP    @>005A(R9)              set VDP to write
1995  4FFA 005A  
1996  4FFC 0063         DATA    >0063                   address in R3
1997  4FFE DBC0         MOVB    R0,@-2(R15)             update rec len in PAB (in case it was 0)
1997  5000 FFFE  
1998  5002 0429         BLWP    @>005A(R9)              retrieve R0 (open mode)
1998  5004 005A  
1999  5006 8001         DATA    >8001                   
2000  5008 0240         ANDI    R0,>0600                keep only access mode
2000  500A 0600  
2001  500C 04C2         CLR     R2                      
2002  500E 0703         SETO    R3                      
2003  5010 0280         CI      R0,>0600                is it append
2003  5012 0600  
2004  5014 161D         JNE     H174                    no
2005  5016 C129         MOV     @>0056(R9),R4           yes: get FDR ptr
2005  5018 0056  
2006  501A C1C4         MOV     R4,R7                   save it
2007  501C 0224         AI      R4,14                   ptr to # of sectors
2007  501E 000E  
2008  5020 0429         BLWP    @>005A(R9)              set VDP to read
2008  5022 005A  
2009  5024 0082         DATA    >0082                   address in R4
2010  5026 D0EF         MOVB    @-1026(R15),R3          get # of sectors in file
2010  5028 FBFE  
2011  502A 06C3         SWPB    R3                      
2012  502C D0EF         MOVB    @-1026(R15),R3                  
2012  502E FBFE  
2013  5030 06C3         SWPB    R3                      
2014  5032 D0AF         MOVB    @-1026(R15),R2          get eof offset
2014  5034 FBFE  
2015  5036 0603         DEC     R3                      offset starts from 0
2016  5038 110B         JLT     H174                    file is empty (0 sectors)
2017  503A 0429         BLWP    @>005A(R9)                      
2017  503C 005A  
2018  503E 3000         DATA    >3000                   save R2 + R3
2019  5040 0227         AI      R7,256                  ptr to data buffer area for this file
2019  5042 0100  
2020  5044 06A0         BL      @CALSUB                 call subroutine
2020  5046 4432  
2021  5048 4704         DATA    RDOFSC                  read a sector, from offset in R3
2022  504A 0429         BLWP    @>005A(R9)                      
2022  504C 005A  
2023  504E 3001         DATA    >3001                   retrieve R2 + R3
2024  5050 06A0 H174    BL      @UPDFCB                 update current record offset in file ctrl block
2024  5052 5082  
2025  5054 0460         B       @RTURN1                 return to caller
2025  5056 4450  
2026                                                    
2027  5058 0429 PRFDRS  BLWP    @>005A(R9)              prepare file status byte for FDR
2027  505A 005A  
2028  505C 8001         DATA    >8001                   access mode in R0
2029  505E 0429         BLWP    @>005A(R9)                      
2029  5060 005A  
2030  5062 8000         DATA    >8000                   save it back
2031  5064 0202         LI      R2,2                    int in FDR status byte
2031  5066 0002  
2032  5068 C129         MOV     @>0056(R9),R4           FDR pointer
2032  506A 0056  
2033  506C 0A40         SLA     R0,4                    fix or var?
2034  506E 1703         JNC     H175                    fix
2035  5070 0202         LI      R2,>0082                int var in FDR
2035  5072 0082  
2036  5074 C000         MOV     R0,R0                   dis or int?
2037  5076 1101 H175    JLT     H176                    int
2038  5078 0642         DECT    R2                      dis: remove the int from FDR status
2039  507A 0224 H176    AI      R4,12                   point at file status byte in FDR
2039  507C 000C  
2040  507E 06C2         SWPB    R2                      
2041  5080 045B         B       *R11                    
2042                                                    
2043  5082 C129 UPDFCB  MOV     @>0056(R9),R4           update sect + rec offsets in file control block
2043  5084 0056  
2044  5086 0224         AI      R4,-6                   
2044  5088 FFFA  
2045  508A 0429         BLWP    @>005A(R9)              set VDP to write
2045  508C 005A  
2046  508E 0083         DATA    >0083                   address in R4
2047  5090 DBC3         MOVB    R3,@-2(R15)             write current sect offset
2047  5092 FFFE  
2048  5094 06C3         SWPB    R3                      
2049  5096 DBC3         MOVB    R3,@-2(R15)                     
2049  5098 FFFE  
2050  509A 0224         AI      R4,4                    point to logical rec offset (for var files)
2050  509C 0004  
2051  509E 0429         BLWP    @>005A(R9)              set VDP to write
2051  50A0 005A  
2052  50A2 0083         DATA    >0083                   address in R4
2053  50A4 DBC2         MOVB    R2,@-2(R15)             write record offset
2053  50A6 FFFE  
2054  50A8 045B         B       *R11                    
2055            
2056            *----------------------------------
2057            * Opcode 1: Close
2058            * --------------
2059            * PAB 0: >01
2060            *     1:           <--- error code
2061            *   2-3:
2062            *     4:
2063            *     5:
2064            *   6-7:
2065            *     8:
2066            *----------------------------------                                     
2067  50AA 06A0 CLOSE   BL      @CALSUB                 call subroutine
2067  50AC 4432  
2068  50AE 52A8         DATA    FFDRVP                  find file FDR
2069  50B0 0460         B       @UPDFDR                 update FDR + data area, get VIB, return to caller
2069  50B2 4650  
2070            
2071            *----------------------------------
2072            * Opcode 2: Read
2073            * --------------
2074            * PAB 0: >02
2075            *     1: file type <--- error code
2076            *   2-3: data buffer address in VDP mem
2077            *     4:
2078            *     5: bytes read
2079            *   6-7: record #
2080            *     8:
2081            *
2082            * Logical records organisation whithin sectors
2083            *
2084            * Fixed records (e.g. rec length = 6)
2085            * 11 11 11 11 11 11 22 22 22 22 22 22 33 33 33 33 33 33 xx xx xx
2086            * Where 11=data for record 1, 22=record 2, 33=record 3, xx=junk bytes
2087            *
2088            * Variable records:
2089            * sz 11 11 11 11 11 11 11 sz 22 22 22 22 22 sz 33 33 FF xx xx xx
2090            * Where sz=record size, 11,22,33=record data, FF=end-of-sector mark, xx=junk
2091            *----------------------------------                                     
2092  50B4 06A0 READ    BL      @CALSUB                 call subroutine
2092  50B6 4432  
2093  50B8 52A8         DATA    FFDRVP                  find FDR in VDP buffers, get status from PAB
2094  50BA 0240         ANDI    R0,>0200                what type of access?
2094  50BC 0200  
2095  50BE 1302         JEQ     H177                    update or input: ok
2096  50C0 0460 H179    B       @ERROR8                 append or output: error illegal opcode
2096  50C2 4E92  
2097  50C4 06A0 H177    BL      @RFDRST                 get status byte in R0, from FDR
2097  50C6 52D4  
2098  50C8 110A         JLT     H178                    var
2099  50CA 06A0         BL      @RRNPAB                 fix: get rec # compare to # of recs/file
2099  50CC 52E8  
2100  50CE 1A03         JL      H180                    ok: in file
2101  50D0 06A0 H181    BL      @ERROR5                 update data and return with error
2101  50D2 4A4C  
2102  50D4 A000         DATA    >A000                   eof reached
2103  50D6 06A0 H180    BL      @CALSUB                 call subroutine
2103  50D8 4432  
2104  50DA 534E         DATA    RRFDR                   load record from disk into FDR data buffer area
2105  50DC 1011         JMP     H182                    
2106                                                    
2107  50DE 06A0 H178    BL      @CALSUB                 var: call subroutine
2107  50E0 4432  
2108  50E2 513A         DATA    RRSEC                   load proper sector, point to rec in it
2109  50E4 10F5         JMP     H181                    skipped if ok: return with eof reached
2110                                                    
2111  50E6 0582         INC     R2                      next byte in data buffer
2112  50E8 A004         A       R4,R0                   add rec size to offset
2113  50EA 0580         INC     R0                      room for end-of-sector mark
2114  50EC C169         MOV     @>0056(R9),R5           FDR ptr
2114  50EE 0056  
2115  50F0 0645         DECT    R5                      point to var record offset in sector
2116  50F2 06C0         SWPB    R0                      
2117  50F4 0429         BLWP    @>005A(R9)              set VDP to write
2117  50F6 005A  
2118  50F8 00A3         DATA    >00A3                   address in R5
2119  50FA DBC0         MOVB    R0,@-2(R15)             update var record offset in sector
2119  50FC FFFE  
2120  50FE C004         MOV     R4,R0                   save # of bytes to be read
2121  5100 C129 H182    MOV     @>0054(R9),R4           PAB ptr
2121  5102 0054  
2122  5104 0224         AI      R4,5                    point to char count
2122  5106 0005  
2123  5108 06C0         SWPB    R0                      
2124  510A 0429         BLWP    @>005A(R9)              set VDP to write
2124  510C 005A  
2125  510E 0083         DATA    >0083                   address in R4
2126  5110 DBC0         MOVB    R0,@-2(R15)             write # of char to be read
2126  5112 FFFE  
2127  5114 06C0         SWPB    R0                      make it a word
2128                                                    
2129  5116 C000 WFDRPB  MOV     R0,R0                   check it
2130  5118 130E         JEQ     H183                    none: return
2131  511A 0429 H184    BLWP    @>005A(R9)              set VDP to read
2131  511C 005A  
2132  511E 0042         DATA    >0042                   address in R2
2133  5120 D0EF         MOVB    @-1026(R15),R3          read 1 byte from FDR data buffer area
2133  5122 FBFE  
2134  5124 0582         INC     R2                      increment source ptr
2135  5126 0429         BLWP    @>005A(R9)              set VDP to write
2135  5128 005A  
2136  512A 0023         DATA    >0023                   address in R1
2137  512C DBC3         MOVB    R3,@-2(R15)             write the byte in PAB data buffer
2137  512E FFFE  
2138  5130 0581         INC     R1                      increment destination ptr
2139  5132 0600         DEC     R0                      more to read?
2140  5134 16F2         JNE     H184                    yes
2141  5136 0460 H183    B       @RTURN1                 return to caller
2141  5138 4450  
2142                                                    
2143  513A 06A0 RRSEC   BL      @RCOFCB                 load sector, point to record in it
2143  513C 5428  
2144  513E C0C3         MOV     R3,R3                   sector offset
2145  5140 1101         JLT     H185                    -1: top of file
2146  5142 1012         JMP     H186                    in file
2147  5144 C003 H185    MOV     R3,R0                   
2148  5146 0580         INC     R0                      next sector
2149  5148 8080         C       R0,R2                   compare to # of sect/file
2150  514A 13F5         JEQ     H183                    end-of-file reached: return to caller (JMP to err)
2151  514C 06A0         BL      @CALSUB                 call subroutine
2151  514E 4432  
2152  5150 4670         DATA    UPDBF                   update data buffer, if needed
2153  5152 C0C0         MOV     R0,R3                   desired offset
2154  5154 04C5         CLR     R5                      
2155  5156 06A0         BL      @UCOFCB                 update sect + rec offsets in control block
2155  5158 53C6  
2156  515A 0227         AI      R7,256                  point to data buffer area (R7 set by UCOFCB)
2156  515C 0100  
2157  515E 06A0         BL      @CALSUB                 call subroutine
2157  5160 4432  
2158  5162 4704         DATA    RDOFSC                  read a sector, from offset in file (in R3)
2159  5164 04C0         CLR     R0                      
2160  5166 1004         JMP     H187                    
2161                                                    
2162  5168 C000 H186    MOV     R0,R0                   in file: test var rec offset (from RCOFCB)
2163  516A 1602         JNE     H187                    inside sector
2164  516C 8080         C       R0,R2                   at beg of sector
2165  516E 13E3         JEQ     H183                    file is empty: return
2166  5170 C080 H187    MOV     R0,R2                   FDR data buffer will be added to R2 by AFDRPT
2167  5172 06A0         BL      @CALSUB                 call subroutine
2167  5174 4432  
2168  5176 53A2         DATA    AFDRPT                  R2=byte in FDR data buf, R1=top of PAB data buf
2169  5178 0429         BLWP    @>005A(R9)              set VDP to read
2169  517A 005A  
2170  517C 0042         DATA    >0042                   address in R2
2171  517E D12F         MOVB    @-1026(R15),R4          get first byte (rec length)
2171  5180 FBFE  
2172  5182 0984         SRL     R4,8                    make it a word
2173  5184 C000         MOV     R0,R0                   var rec offset
2174  5186 1306         JEQ     H188                    
2175  5188 0284         CI      R4,>00FF                is it >FF (end of sector mark) ?
2175  518A 00FF  
2176  518C 1603         JNE     H188                    no
2177  518E 06A0         BL      @RCOFCB                 yes: get sect + rec offsets from control block
2177  5190 5428  
2178  5192 10D8         JMP     H185                    try again with next sector
2179                                                    
2180  5194 0429 H188    BLWP    @>005A(R9)                      
2180  5196 005A  
2181  5198 0011         DATA    >0011                   retrieve return address from stack in R11
2182  519A 05CB         INCT    R11                     skip the JMP to eof reached error
2183  519C 045B         B       *R11                    
2184            
2185            *------------------------------------
2186            * Opcode 3: Write
2187            * --------------
2188            * PAB 0: >03
2189            *     1: file type <--- error code
2190            *   2-3: data buffer address in VDP mem
2191            *     4:
2192            *     5: bytes to write
2193            *   6-7: record #
2194            *     8:
2195            *------------------------------------                                   
2196  519E 06A0 WRITE   BL      @CALSUB                 call subroutine
2196  51A0 4432  
2197  51A2 52A8         DATA    FFDRVP                  find FDR in VDP buffers
2198  51A4 0240         ANDI    R0,>0600                keep only access mode
2198  51A6 0600  
2199  51A8 0280         CI      R0,>0400                is it input
2199  51AA 0400  
2200  51AC 1389         JEQ     H179                    yes: return with error illegal opcode
2201  51AE 06A0         BL      @RFDRST                 get file status byte from FDR
2201  51B0 52D4  
2202  51B2 1113         JLT     H189                    var                     
2203  51B4 06A0         BL      @RRNPAB                 fix: get rec # from PAB, sect # in R0
2203  51B6 52E8  
2204  51B8 1A0C         JL      H190                    less that total rec/file
2205  51BA 0429         BLWP    @>005A(R9)              past eof: expand file
2205  51BC 005A  
2206  51BE D800         DATA    >D800                   save R0, R1, R3, R4
2207  51C0 C0C0         MOV     R0,R3                   desired sector offset
2208  51C2 06A0         BL      @CALSUB                 call subroutine
2208  51C4 4432  
2209  51C6 473A         DATA    APSCTS                  append enough sectors to reach offset in R3
2210  51C8 0429         BLWP    @>005A(R9)                      
2210  51CA 005A  
2211  51CC D801         DATA    >D801                   restore R0, R1, R3, R4
2212  51CE 06A0         BL      @URFFDR                 update # of rec/file in FDR
2212  51D0 53F2  
2213                                                    
2214  51D2 06A0 H190    BL      @CALSUB                 in file: call subroutine
2214  51D4 4432  
2215  51D6 534E         DATA    RRFDR                   fetch rec from disk into FDR data buffer area
2216  51D8 1053         JMP     H191                    set update data flag, write data, return
2217                                                    
2218  51DA 06A0 H189    BL      @RCOFCB                 var: R2=sect/file R3=sect offset R0=rec offset
2218  51DC 5428  
2219  51DE C0C3         MOV     R3,R3                   sector offset in file
2220  51E0 1101         JLT     H192                    -1: top of file
2221  51E2 100B         JMP     H193                    in file
2222  51E4 0429 H192    BLWP    @>005A(R9)              next sector loop
2222  51E6 005A  
2223  51E8 3000         DATA    >3000                   save R2 + R3
2224  51EA 06A0         BL      @CALSUB                 call subroutine
2224  51EC 4432  
2225  51EE 4670         DATA    UPDBF                   update data buffer if needed
2226  51F0 0429         BLWP    @>005A(R9)                      
2226  51F2 005A  
2227  51F4 3001         DATA    >3001                   retrieve R2 + R3
2228  51F6 0583         INC     R3                      next sector
2229  51F8 04C0         CLR     R0                      init char offset in sector
2230                                                    
2231  51FA 8083 H193    C       R3,R2                   did we reach last sector?
2232  51FC 1609         JNE     H194                    no
2233  51FE 0429         BLWP    @>005A(R9)              yes: expand file
2233  5200 005A  
2234  5202 9000         DATA    >9000                   save R0 + R4
2235  5204 06A0         BL      @CALSUB                 call subroutine
2235  5206 4432  
2236  5208 473A         DATA    APSCTS                  get last sector then append sectors to reach R3
2237  520A 0429         BLWP    @>005A(R9)                      
2237  520C 005A  
2238  520E 9001         DATA    >9001                   retrieve R0 + R4
2239                                                    
2240  5210 C169 H194    MOV     @>0054(R9),R5           PAB ptr
2240  5212 0054  
2241  5214 0225         AI      R5,5                    point to char count
2241  5216 0005  
2242  5218 0429         BLWP    @>005A(R9)              set VDP to read
2242  521A 005A  
2243  521C 00A2         DATA    >00A2                   address in R5
2244  521E D12F         MOVB    @-1026(R15),R4          get # of chars to write
2244  5220 FBFE  
2245  5222 0984         SRL     R4,8                    make it a word
2246  5224 C144         MOV     R4,R5                   
2247  5226 A140         A       R0,R5                   add current char offset in sector
2248  5228 0585         INC     R5                      make room for size byte
2249  522A 0285         CI      R5,>00FF                past end of sector?
2249  522C 00FF  
2250  522E 1BDA         JH      H192                    yes: not enough room, try next sector
2251  5230 0702         SETO    R2                      ok: rec will fit in sector
2252  5232 C069         MOV     @>0056(R9),R1           FDR ptr
2252  5234 0056  
2253  5236 A045         A       R5,R1                   past-last-byte offset
2254  5238 0221         AI      R1,256                  ptr to data buffer area
2254  523A 0100  
2255  523C 0429         BLWP    @>005A(R9)              set VDP to write
2255  523E 005A  
2256  5240 0023         DATA    >0023                   address in R1
2257  5242 DBC2         MOVB    R2,@-2(R15)             write end-of-sect mark to FDR data buffer area
2257  5244 FFFE  
2258  5246 0429         BLWP    @>005A(R9)                      
2258  5248 005A  
2259  524A 8000         DATA    >8000                   save R0 (current byte offset in sector)
2260  524C C003         MOV     R3,R0                   
2261  524E 06A0         BL      @UCOFCB                 update sect + rec offsets in control block
2261  5250 53C6  
2262  5252 0221         AI      R1,18                   point to eof offset in FDR (R1 modified by UCOFCB)
2262  5254 0012  
2263  5256 0429         BLWP    @>005A(R9)              set VDP to write
2263  5258 005A  
2264  525A 0023         DATA    >0023                   address in R1
2265  525C DBC5         MOVB    R5,@-2(R15)             update eof offset in last sector, in FDR
2265  525E FFFE  
2266  5260 06A0         BL      @URFFDR                 update # of rec/file in FDR
2266  5262 53F2  
2267  5264 0429         BLWP    @>005A(R9)                      
2267  5266 005A  
2268  5268 2001         DATA    >2001                   retrieve old R0 in R2 (current byte offset)
2269  526A C004         MOV     R4,R0                   record size
2270  526C 06A0         BL      @CALSUB                 call subroutine
2270  526E 4432  
2271  5270 53A2         DATA    AFDRPT                  get FDR data buffer in R2, PAB data buffer in R1
2272  5272 06C4         SWPB    R4                      
2273  5274 0429         BLWP    @>005A(R9)              set VDP to write
2273  5276 005A  
2274  5278 0043         DATA    >0043                   address in R2
2275  527A DBC4         MOVB    R4,@-2(R15)             write size byte to FDR data buffer
2275  527C FFFE  
2276  527E 0582         INC     R2                      increment dest pointer
2277                                                    
2278  5280 C0C2 H191    MOV     R2,R3                   invert source and dest
2279  5282 C081         MOV     R1,R2                   so we can use the same read-write loop
2280  5284 C043         MOV     R3,R1                   than the read opcode
2281  5286 C129         MOV     @>0056(R9),R4           FDR ptr
2281  5288 0056  
2282  528A 0604         DEC     R4                      pointer to drive # for that file
2283  528C 0429         BLWP    @>005A(R9)              set VDP to read
2283  528E 005A  
2284  5290 0082         DATA    >0082                   address in R4
2285  5292 D16F         MOVB    @-1026(R15),R5          get drive #
2285  5294 FBFE  
2286  5296 0265         ORI     R5,>8000                add update data area flag
2286  5298 8000  
2287  529A 0429         BLWP    @>005A(R9)              set VDP to write
2287  529C 005A  
2288  529E 0083         DATA    >0083                   address in R4
2289  52A0 DBC5         MOVB    R5,@-2(R15)             write back flagged byte
2289  52A2 FFFE  
2290  52A4 0460         B       @WFDRPB                 to read-write loop
2290  52A6 5116  
2291                                                    
2292  52A8 06A0 FFDRVP  BL      @CALSUB                 find FDR in VDP buffer
2292  52AA 4432  
2293  52AC 4B7E         DATA    FFFDRV                  find file FDR
2294  52AE C104         MOV     R4,R4                   found?
2295  52B0 1303         JEQ     AFPGPF                  yes
2296  52B2 06A0         BL      @ERROR5                 no: return with error
2296  52B4 4A4C  
2297  52B6 E000         DATA    >E000                   file error
2298  52B8 0581 AFPGPF  INC     R1                      point to filename in FDR
2299  52BA CA41         MOV     R1,@>0056(R9)           new FDR ptr
2299  52BC 0056  
2300  52BE C129         MOV     @>0054(R9),R4           get PAB ptr
2300  52C0 0054  
2301  52C2 0584         INC     R4                      point to status byte
2302  52C4 04C0         CLR     R0                      
2303  52C6 0429         BLWP    @>005A(R9)              set VDP to read
2303  52C8 005A  
2304  52CA 0082         DATA    >0082                   address in R4
2305  52CC D02F         MOVB    @-1026(R15),R0          get file status
2305  52CE FBFE  
2306  52D0 0460         B       @RTURN1                 return to caller
2306  52D2 4450  
2307                                                    
2308  52D4 C129 RFDRST  MOV     @>0056(R9),R4           get status byte from FDR
2308  52D6 0056  
2309  52D8 0224         AI      R4,12                   point to status byte
2309  52DA 000C  
2310  52DC 0429         BLWP    @>005A(R9)              set VDP to read
2310  52DE 005A  
2311  52E0 0082         DATA    >0082                   address in R4
2312  52E2 D02F         MOVB    @-1026(R15),R0          read status byte
2312  52E4 FBFE  
2313  52E6 045B         B       *R11                    
2314                                                    
2315  52E8 D16F RRNPAB  MOVB    @-1026(R15),R5          get record # from PAB, check if valid
2315  52EA FBFE  
2316  52EC 0985         SRL     R5,8                    
2317  52EE 1602         JNE     H195                    get # of rec/sector from FDR
2318  52F0 0205         LI      R5,256                  0: default to 256
2318  52F2 0100  
2319  52F4 C0E9 H195    MOV     @>0054(R9),R3           PAB ptr
2319  52F6 0054  
2320  52F8 0223         AI      R3,6                    point to rec #
2320  52FA 0006  
2321  52FC 0429         BLWP    @>005A(R9)              set VDP to read
2321  52FE 005A  
2322  5300 0062         DATA    >0062                   address in R3
2323  5302 D06F         MOVB    @-1026(R15),R1          get record # from PAB
2323  5304 FBFE  
2324  5306 06C1         SWPB    R1                      
2325  5308 D06F         MOVB    @-1026(R15),R1                  
2325  530A FBFE  
2326  530C 06C1         SWPB    R1                      
2327  530E C001         MOV     R1,R0                   save it
2328  5310 1101         JLT     H196                    too big
2329  5312 1003         JMP     H197                    ok
2330  5314 06A0 H196    BL      @ERROR5                 update data then return with error
2330  5316 4A4C  
2331  5318 8000         DATA    >8000                   memory full
2332  531A 0580 H197    INC     R0                      next record
2333  531C 0429         BLWP    @>005A(R9)              set VDP to write
2333  531E 005A  
2334  5320 0063         DATA    >0063                   address in R3
2335  5322 DBC0         MOVB    R0,@-2(R15)             write back # of future record
2335  5324 FFFE  
2336  5326 06C0         SWPB    R0                      
2337  5328 DBC0         MOVB    R0,@-2(R15)                     
2337  532A FFFE  
2338  532C 04C0         CLR     R0                      
2339  532E C0C1         MOV     R1,R3                   save # of desired rec
2340  5330 3C05         DIV     R5,R0                   divide by # of rec/sector = sect # in R0
2341  5332 C0A9 RNFISE  MOV     @>0056(R9),R2           FDR ptr
2341  5334 0056  
2342  5336 0222         AI      R2,18                   point to total # of rec (# of sectors for var)
2342  5338 0012  
2343  533A 0429         BLWP    @>005A(R9)              set VDP to read
2343  533C 005A  
2344  533E 0042         DATA    >0042                   address in R2
2345  5340 D0AF         MOVB    @-1026(R15),R2          get total # of recs/file (sect/file for var)
2345  5342 FBFE  
2346  5344 06C2         SWPB    R2                      
2347  5346 D0AF         MOVB    @-1026(R15),R2          remember: bytes are swapped
2347  5348 FBFE  
2348  534A 8083         C       R3,R2                   compare with desired record (ignored by var)
2349  534C 045B         B       *R11                    
2350                                                    
2351  534E 0429 RRFDR   BLWP    @>005A(R9)              fetch record into FDR data buffer area
2351  5350 005A  
2352  5352 4000         DATA    >4000                   save R1
2353  5354 0224         AI      R4,-18                  ptr to top of control block
2353  5356 FFEE  
2354  5358 0429         BLWP    @>005A(R9)              set VDP to read
2354  535A 005A  
2355  535C 0082         DATA    >0082                   address in R4
2356  535E D16F         MOVB    @-1026(R15),R5          get current sector offset in file
2356  5360 FBFE  
2357  5362 06C5         SWPB    R5                      
2358  5364 D16F         MOVB    @-1026(R15),R5                  
2358  5366 FBFE  
2359  5368 0B85         SRC     R5,8                    
2360  536A 1105         JLT     H198                    -1: top of file
2361  536C 8005         C       R5,R0                   compare with desired offset (from RRNPAB)
2362  536E 130B         JEQ     H199                    same
2363  5370 06A0         BL      @CALSUB                 call subroutine
2363  5372 4432  
2364  5374 4670         DATA    UPDBF                   update data buffer if needed
2365  5376 C0C0 H198    MOV     R0,R3                   desired sector offset in file
2366  5378 06A0         BL      @UCOFCB                 update sect + rec offsets in control block
2366  537A 53C6  
2367  537C 0227         AI      R7,256                  point to data buffer area (R7 set by UCOFCB)
2367  537E 0100  
2368  5380 06A0         BL      @CALSUB                 call subroutine
2368  5382 4432  
2369  5384 4704         DATA    RDOFSC                  read a sector from offset in file (in R3)
2370  5386 0429 H199    BLWP    @>005A(R9)                      
2370  5388 005A  
2371  538A 4001         DATA    >4001                   retrieve R1
2372  538C C0E9         MOV     @>0056(R9),R3           FDR ptr
2372  538E 0056  
2373  5390 0223         AI      R3,17                   point to record length
2373  5392 0011  
2374  5394 0429         BLWP    @>005A(R9)              set VDP to read
2374  5396 005A  
2375  5398 0062         DATA    >0062                   address in R3
2376  539A D02F         MOVB    @-1026(R15),R0          get rec length in bytes
2376  539C FBFE  
2377  539E 0980         SRL     R0,8                    make it a word
2378  53A0 3840         MPY     R0,R1                   calc file offset in bytes
2379  53A2 A0A9 AFDRPT  A       @>0056(R9),R2           add FDR ptr
2379  53A4 0056  
2380  53A6 0222         AI      R2,256                  point inside data buffer area
2380  53A8 0100  
2381  53AA C0E9         MOV     @>0054(R9),R3           PAB ptr
2381  53AC 0054  
2382  53AE 05C3         INCT    R3                      point to data buffer address
2383  53B0 0429         BLWP    @>005A(R9)              set VDP to read
2383  53B2 005A  
2384  53B4 0062         DATA    >0062                   address in R3
2385  53B6 D06F         MOVB    @-1026(R15),R1          get PAB data buffer address
2385  53B8 FBFE  
2386  53BA 06C1         SWPB    R1                      
2387  53BC D06F         MOVB    @-1026(R15),R1                  
2387  53BE FBFE  
2388  53C0 06C1         SWPB    R1                      
2389  53C2 0460         B       @RTURN1                 return
2389  53C4 4450  
2390                                                    
2391  53C6 C1E9 UCOFCB  MOV     @>0056(R9),R7           update sect + rec offsets in control block
2391  53C8 0056  
2392  53CA C047         MOV     R7,R1                   FDR ptr
2393  53CC 0221         AI      R1,-6                   top of file control block
2393  53CE FFFA  
2394  53D0 0429         BLWP    @>005A(R9)              set VDP to write
2394  53D2 005A  
2395  53D4 0023         DATA    >0023                   address in R1
2396  53D6 DBC0         MOVB    R0,@-2(R15)             current sector offset in file
2396  53D8 FFFE  
2397  53DA 06C0         SWPB    R0                      
2398  53DC DBC0         MOVB    R0,@-2(R15)                     
2398  53DE FFFE  
2399  53E0 0221         AI      R1,4                    point to var rec offset in sector
2399  53E2 0004  
2400  53E4 06C5         SWPB    R5                      
2401  53E6 0429         BLWP    @>005A(R9)              set VDP to write
2401  53E8 005A  
2402  53EA 0023         DATA    >0023                   address in R1
2403  53EC DBC5         MOVB    R5,@-2(R15)             first free byte in current sector
2403  53EE FFFE  
2404  53F0 045B         B       *R11                    
2405                                                    
2406  53F2 C0A9 URFFDR  MOV     @>0056(R9),R2           update # of rec/file in FDR
2406  53F4 0056  
2407  53F6 0429         BLWP    @>005A(R9)              set VDP to read
2407  53F8 005A  
2408  53FA 0042         DATA    >0042                   address in R2 (FDR ptr)
2409  53FC D2AF         MOVB    @-1026(R15),R10         get first char of filename
2409  53FE FBFE  
2410  5400 026A         ORI     R10,>8000               set was modified flag
2410  5402 8000  
2411  5404 0429         BLWP    @>005A(R9)              set VDP to write
2411  5406 005A  
2412  5408 0043         DATA    >0043                   address in R2
2413  540A DBCA         MOVB    R10,@-2(R15)            write flagged char back
2413  540C FFFE  
2414  540E 0222         AI      R2,18                   point to # of recs/file in FDR
2414  5410 0012  
2415  5412 0583         INC     R3                      one more
2416  5414 0429         BLWP    @>005A(R9)              set VDP to write
2416  5416 005A  
2417  5418 0043         DATA    >0043                   address in R2
2418  541A 06C3         SWPB    R3                      update # of recs/file
2419  541C DBC3         MOVB    R3,@-2(R15)                     
2419  541E FFFE  
2420  5420 06C3         SWPB    R3                      
2421  5422 DBC3         MOVB    R3,@-2(R15)                     
2421  5424 FFFE  
2422  5426 045B         B       *R11                    
2423                                                    
2424  5428 C229 RCOFCB  MOV     @>0056(R9),R8           get rec offset, compare sect with total
2424  542A 0056  
2425  542C C108         MOV     R8,R4                   FDR ptr
2426  542E 0224         AI      R4,256                  point to data buffer area
2426  5430 0100  
2427  5432 0648         DECT    R8                      point to var record offset
2428  5434 0429         BLWP    @>005A(R9)              set VDP to read
2428  5436 005A  
2429  5438 0102         DATA    >0102                   address in R8
2430  543A D0AF         MOVB    @-1026(R15),R2          get var rec offset in current sector
2430  543C FBFE  
2431  543E 0982         SRL     R2,8                    make it a word
2432  5440 C28B         MOV     R11,R10                 save return point
2433  5442 06A0         BL      @FDR2B2                 get 2 bytes from FDR (at R8-4) into R0
2433  5444 494E  
2434  5446 FFFC         DATA    -4                      current sector offset in file
2435  5448 C0C0         MOV     R0,R3                   save it
2436  544A C2CA         MOV     R10,R11                 restore return point
2437  544C C002         MOV     R2,R0                   var record offset
2438  544E 0460         B       @RNFISE                 get # of sect/file from FDR, return
2438  5450 5332  
2439            
2440            *------------------------------------
2441            * Opcode 4: Rewind
2442            * --------------
2443            * PAB 0: >04
2444            *     1: file type <--- error code
2445            *   2-3:
2446            *     4:
2447            *     5:
2448            *   6-7: record #  <--- >0000 if sequential
2449            *     8:
2450            *------------------------------------                                   
2451  5452 06A0 RWIND1  BL      @CALSUB                 call subroutine
2451  5454 4432  
2452  5456 52A8         DATA    FFDRVP                  find FDR in VDP buffers, read status from PAB
2453  5458 0429         BLWP    @>005A(R9)                      
2453  545A 005A  
2454  545C 8000         DATA    >8000                   save R0 (status from PAB)
2455  545E 0240         ANDI    R0,>0600                keep only access mode
2455  5460 0600  
2456  5462 1305         JEQ     H200                    update is ok
2457  5464 0280         CI      R0,>0400                is it input?
2457  5466 0400  
2458  5468 1302         JEQ     H200                    yes: ok
2459  546A 0460         B       @ERROR8                 output or append: return with illegal opcode
2459  546C 4E92  
2460  546E 06A0 H200    BL      @CALSUB                 call subroutine
2460  5470 4432  
2461  5472 4670         DATA    UPDBF                   update data buffer if needed
2462  5474 0429         BLWP    @>005A(R9)                      
2462  5476 005A  
2463  5478 8001         DATA    >8001                   retrieve R0 (status from PAB)
2464  547A 0240         ANDI    R0,>0100                sequential or reloc?
2464  547C 0100  
2465  547E 1611         JNE     H201                    reloc: don't do anything, return
2466                                                    
2467  5480 04C2 RWIND2  CLR     R2                      rewind file: record offset = 0
2468  5482 0703         SETO    R3                      current record = -1 (none)
2469  5484 06A0         BL      @UPDFCB                 update file control block
2469  5486 5082  
2470  5488 04C0         CLR     R0                      record 0
2471  548A C229         MOV     @>0054(R9),R8           get PAB ptr
2471  548C 0054  
2472  548E 0228         AI      R8,6                    point to record #
2472  5490 0006  
2473  5492 0429         BLWP    @>005A(R9)              set VDP to write
2473  5494 005A  
2474  5496 0103         DATA    >0103                   address in R8
2475  5498 DBC0         MOVB    R0,@-2(R15)             write record #
2475  549A FFFE  
2476  549C 1000         NOP                             
2477  549E DBC0         MOVB    R0,@-2(R15)                     
2477  54A0 FFFE  
2478  54A2 0460 H201    B       @RTURN1                 return to caller
2478  54A4 4450  
2479            
2480            *------------------------------------
2481            * Opcode 5: Load
2482            * --------------
2483            * PAB 0: >05
2484            *     1: file type  <--- error code
2485            *   2-3: data buffer address in VDP mem
2486            *     4:
2487            *     5:
2488            *   6-7: maximum # of bytes (size of buffer)
2489            *     8:
2490            *------------------------------------                                   
2491  54A6 06A0 LOAD    BL      @CALSUB                 call subroutine
2491  54A8 4432  
2492  54AA 4BDC         DATA    FNDFDR                  find FDR on disk
2493  54AC C104         MOV     R4,R4                   found?
2494  54AE 1303         JEQ     H203                    yes
2495  54B0 06A0 H202    BL      @ERROR5                 no: return with error
2495  54B2 4A4C  
2496  54B4 E000         DATA    >E000                   file error
2497  54B6 06A0 H203    BL      @FDR2B1                 get 2 bytes from FDR into R0
2497  54B8 494A  
2498  54BA 000C         DATA    12                      file status byte
2499  54BC 0240         ANDI    R0,>0100                is it program?
2499  54BE 0100  
2500  54C0 13F7         JEQ     H202                    no: file error
2501  54C2 05C8         INCT    R8                      point to # of sect/file in FDR
2502  54C4 0429         BLWP    @>005A(R9)              set VDP to read
2502  54C6 005A  
2503  54C8 0102         DATA    >0102                   address in R8
2504  54CA D06F         MOVB    @-1026(R15),R1          get # of sectors in file
2504  54CC FBFE  
2505  54CE 06C1         SWPB    R1                      
2506  54D0 D06F         MOVB    @-1026(R15),R1                  
2506  54D2 FBFE  
2507  54D4 0B81         SRC     R1,8                    
2508  54D6 13EC         JEQ     H202                    0=empty file: return with file error
2509  54D8 06A0         BL      @RBANB                  get data buffer address in R7, # of sectors in R2
2509  54DA 5598  
2510  54DC 05C8         INCT    R8                      point to eof offset in FDR
2511  54DE 04C4         CLR     R4                      
2512  54E0 0429         BLWP    @>005A(R9)              set VDP to read
2512  54E2 005A  
2513  54E4 0102         DATA    >0102                   address in R8
2514  54E6 D12F         MOVB    @-1026(R15),R4          get # of bytes in last sector
2514  54E8 FBFE  
2515  54EA 8081         C       R1,R2                   compare # of sect with max in PAB
2516  54EC 1BE1         JH      H202                    file is too big: return with file error
2517  54EE 1602         JNE     H204                    file is smaller
2518  54F0 8100         C       R0,R4                   same # of sect: check bytes in last sector
2519  54F2 1ADE         JL      H202                    file is too big: file error
2520  54F4 04C3 H204    CLR     R3                      sector offset in file
2521  54F6 06C4         SWPB    R4                      
2522  54F8 0601 H206    DEC     R1                      next sector
2523  54FA 130D         JEQ     H205                    done
2524  54FC 0429         BLWP    @>005A(R9)                      
2524  54FE 005A  
2525  5500 D900         DATA    >D900                   save R0, R1, R3, R4, R7
2526  5502 06A0         BL      @CALSUB                 call subroutine
2526  5504 4432  
2527  5506 4704         DATA    RDOFSC                  read a sector from offset in R3
2528  5508 0429         BLWP    @>005A(R9)              restore R0, R1, R3, R4, R7
2528  550A 005A  
2529  550C D901         DATA    >D901                   
2530  550E 0583         INC     R3                      next sector
2531  5510 0227         AI      R7,256                  256 bytes further in PAB buffer
2531  5512 0100  
2532  5514 10F1         JMP     H206                    keep going
2533                                                    
2534  5516 C104 H205    MOV     R4,R4                   
2535  5518 1604         JNE     H207                    
2536  551A 06A0         BL      @CALSUB                 call subroutine
2536  551C 4432  
2537  551E 4704         DATA    RDOFSC                  read a sector from offset in R3
2538  5520 1011         JMP     H208                    done
2539                                                    
2540  5522 C147 H207    MOV     R7,R5                   save PAB data buffer ptr
2541  5524 C1E9         MOV     @>0056(R9),R7           FDR ptr
2541  5526 0056  
2542  5528 0227         AI      R7,256                  point to FDR data area
2542  552A 0100  
2543  552C 0429         BLWP    @>005A(R9)                      
2543  552E 005A  
2544  5530 0D00         DATA    >0D00                   save R4, R5, R7
2545  5532 06A0         BL      @CALSUB                 call subroutine
2545  5534 4432  
2546  5536 4704         DATA    RDOFSC                  read a sector from offset in R3
2547  5538 0429         BLWP    @>005A(R9)              restore R4 in R0, R5 in R1, R7 in R2
2547  553A 005A  
2548  553C E001         DATA    >E001                   
2549  553E 06A0         BL      @CALSUB                 call subroutine
2549  5540 4432  
2550  5542 5116         DATA    WFDRPB                  write bytes from FDR data buffer to PAB data buf
2551  5544 0460 H208    B       @UPDFDR                 update FDR, data buffer, VIB and return to caller
2551  5546 4650  
2552            
2553            *------------------------------------
2554            * Opcode 6: Save
2555            * --------------
2556            * PAB 0: >06
2557            *     1: file type  <--- error code
2558            *   2-3: data buffer address in VDP mem
2559            *     4:
2560            *     5:
2561            *   6-7: # of bytes to save
2562            *     8:
2563            *------------------------------------                                   
2564  5548 06A0 SAVE    BL      @CALSUB                 call subroutine
2564  554A 4432  
2565  554C 456A         DATA    CRFIL1                  create file
2566  554E 06A0         BL      @RBANB                  get PAB buffer ptr + # of bytes
2566  5550 5598  
2567  5552 04C3         CLR     R3                      sector offset 0
2568  5554 0429 H209    BLWP    @>005A(R9)                      
2568  5556 005A  
2569  5558 B100         DATA    >B100                   save R0, R2, R3, R7
2570  555A 06A0         BL      @CALSUB                 call subroutine
2570  555C 4432  
2571  555E 4724         DATA    WROFSC                  write sector to offset in R3
2572  5560 0429         BLWP    @>005A(R9)                      
2572  5562 005A  
2573  5564 B101         DATA    >B101                   retrieve R0, R2, R3, R7
2574  5566 0583         INC     R3                      next sector
2575  5568 0227         AI      R7,256                  256 bytes further in PAB data buffer
2575  556A 0100  
2576  556C 0602         DEC     R2                      next sector
2577  556E 16F2         JNE     H209                    more to do
2578                                                    
2579  5570 C069         MOV     @>0056(R9),R1           FDR ptr
2579  5572 0056  
2580  5574 0221         AI      R1,12                   point to file status byte
2580  5576 000C  
2581  5578 0202         LI      R2,>0100                value for program file
2581  557A 0100  
2582  557C 0429         BLWP    @>005A(R9)              set VDP to write
2582  557E 005A  
2583  5580 0023         DATA    >0023                   address in R1
2584  5582 DBC2         MOVB    R2,@-2(R15)             write file status byte in FDR
2584  5584 FFFE  
2585  5586 0221         AI      R1,4                    point to eof offset byte in FDR
2585  5588 0004  
2586  558A 0429         BLWP    @>005A(R9)              set VDP to write
2586  558C 005A  
2587  558E 0023         DATA    >0023                   address in R1
2588  5590 DBC0         MOVB    R0,@-2(R15)             # of bytes in last sector
2588  5592 FFFE  
2589  5594 0460         B       @UPDFDR                 update FDR, data buffer, VIB then return to caller
2589  5596 4650  
2590                                                    
2591  5598 C029 RBANB   MOV     @>0054(R9),R0           get buffer address + # of bytes
2591  559A 0054  
2592  559C 05C0         INCT    R0                      data buffer in PAB
2593  559E 0429         BLWP    @>005A(R9)              set VDP to read
2593  55A0 005A  
2594  55A2 0002         DATA    >0002                   address in R0
2595  55A4 D1EF         MOVB    @-1026(R15),R7          get data buffer address
2595  55A6 FBFE  
2596  55A8 06C7         SWPB    R7                      
2597  55AA D1EF         MOVB    @-1026(R15),R7                  
2597  55AC FBFE  
2598  55AE 06C7         SWPB    R7                      
2599  55B0 0220         AI      R0,4                    point to # of bytes to transfer
2599  55B2 0004  
2600  55B4 0429         BLWP    @>005A(R9)              set VDP to read
2600  55B6 005A  
2601  55B8 0002         DATA    >0002                   address in R0
2602  55BA D0AF         MOVB    @-1026(R15),R2          get # of bytes to be transfered
2602  55BC FBFE  
2603  55BE 0982         SRL     R2,8                    make it # of sectors (256 bytes each)
2604  55C0 04C0         CLR     R0                      
2605  55C2 D02F         MOVB    @-1026(R15),R0          see if one more is needed
2605  55C4 FBFE  
2606  55C6 1301         JEQ     H210                    no
2607  55C8 0582         INC     R2                      yes: one more sector
2608  55CA 045B H210    B       *R11                    
2609            
2610            *-------------------------------------
2611            * Opcode 9: Status
2612            * --------------
2613            * PAB 0: >09
2614            *     1:
2615            *   2-3:
2616            *     4:
2617            *     5:
2618            *   6-7: record #
2619            *     8:           <--- file status
2620            *
2621            * Status bits, returned in PAB byte 8:
2622            * >80: file not found
2623            * >40: file is protected
2624            * >20:
2625            * >10: internal (else display or program)
2626            * >08: program file
2627            * >04: variable (else fixed or program)
2628            * >02: memory full
2629            * >01: end-of-file reached
2630            *-------------------------------------                                  
2631  55CC 06A0 STATUS  BL      @CALSUB                 call subroutine
2631  55CE 4432  
2632  55D0 4B7E         DATA    FFFDRV                  save filename in comp buf, then find FDR in VDP
2633  55D2 C104         MOV     R4,R4                   found?
2634  55D4 1310         JEQ     H211                    yes
2635                                                    
2636  55D6 06A0         BL      @CALSUB                 no: call subroutine
2636  55D8 4432  
2637  55DA 4BE6         DATA    FFDRDK                  find FDR on disk
2638  55DC 0200         LI      R0,>8000                value for file not found
2638  55DE 8000  
2639  55E0 C104         MOV     R4,R4                   found?
2640  55E2 1649         JNE     H212                    no: return with that value
2641  55E4 C069         MOV     @>0056(R9),R1           yes: ptr to FDR
2641  55E6 0056  
2642  55E8 04C2         CLR     R2                      
2643  55EA 0429         BLWP    @>005A(R9)              set VDP to write
2643  55EC 005A  
2644  55EE 0023         DATA    >0023                   address in R1
2645  55F0 DBC2         MOVB    R2,@-2(R15)             invalidate that FDR (file not open)
2645  55F2 FFFE  
2646  55F4 1036         JMP     H213                    transfer FDR status to PAB status byte
2647                                                    
2648  55F6 06A0 H211    BL      @CALSUB                 file is open: call subroutine
2648  55F8 4432  
2649  55FA 52B8         DATA    AFPGPF                  adjust FDR ptr, get PAB file type into R4
2650  55FC 06A0         BL      @RFDRST                 get status byte from FDR
2650  55FE 52D4  
2651  5600 1101         JLT     H214                    var
2652  5602 1006         JMP     H215                    fix
2653                                                    
2654  5604 06A0 H214    BL      @CALSUB                 var: call subroutine
2654  5606 4432  
2655  5608 513A         DATA    RRSEC                   load wanted sector, point to wanted rec in buffer
2656  560A 1013         JMP     H216                    out of range
2657  560C 04C2         CLR     R2                      ok: clear flag
2658  560E 1029         JMP     H213                    copy status byte from FDR into PAB, return
2659                                                    
2660  5610 D16F H215    MOVB    @-1026(R15),R5          fix: get rec/sect byte
2660  5612 FBFE  
2661  5614 0985         SRL     R5,8                    make it a word
2662  5616 1602         JNE     H217                    
2663  5618 0205         LI      R5,>0100                00 (program files) means 256
2663  561A 0100  
2664  561C 06A0 H217    BL      @PABR2B                 get 2 bytes from PAB into R0
2664  561E 4944  
2665  5620 0006         DATA    6                       # of wanted record
2666  5622 C0C0         MOV     R0,R3                   save it
2667  5624 111C         JLT     H218                    too big: set memory full bit in PAB status byte
2668  5626 06A0         BL      @RNFISE                 get # recs/file into R2, comp with R3
2668  5628 5332  
2669  562A 04C2         CLR     R2                      
2670  562C 1A1A         JL      H213                    in file: copy file type bits, return
2671  562E 3C85         DIV     R5,R2                   how many sectors do we need?
2672  5630 C0C2         MOV     R2,R3                   save result
2673                                                    
2674  5632 06A0 H216    BL      @FDR2B1                 get 2 bytes from FDR into R0
2674  5634 494A  
2675  5636 000E         DATA    14                      # of sectors/file
2676  5638 0583         INC     R3                      plus 1 sector for FDR
2677  563A 0202         LI      R2,>0100                value for eof reached in PAB status
2677  563C 0100  
2678  563E 60C0         S       R0,R3                   are there enough sectors in file for these recs?
2679  5640 1501         JGT     H219                    
2680  5642 100F         JMP     H213                    yes: we reached the eof
2681  5644 06A0 H219    BL      @CALSUB                 call subroutine
2681  5646 4432  
2682  5648 4AAC         DATA    RWVIB                   load VIB (sector 0)
2683  564A C103         MOV     R3,R4                   number of sectors that will be needed
2684  564C C205         MOV     R5,R8                   VIB ptr
2685  564E 0228         AI      R8,10                   skip 10 bytes (required by CFSVIB)
2685  5650 000A  
2686  5652 06A0         BL      @CFSVIB                 count free sectors in bitmap, into R3
2686  5654 5840  
2687  5656 0202         LI      R2,>0100                value for eof reached
2687  5658 0100  
2688  565A 8103         C       R3,R4                   are there that many free sectors?
2689  565C 1402         JHE     H213                    yes
2690  565E 0202 H218    LI      R2,>0200                value for memory full
2690  5660 0200  
2691                                                    
2692  5662 06A0 H213    BL      @FDR2B1                 get 2 bytes from FDR into R0
2692  5664 494A  
2693  5666 000C         DATA    12                      file status byte
2694  5668 0240         ANDI    R0,>8F00                mask irrelevant bits
2694  566A 8F00  
2695  566C 1502         JGT     H220                    
2696  566E 0260         ORI     R0,>0080                var: put var bit in PAB status style
2696  5670 0080  
2697  5672 0A30 H220    SLA     R0,3                    get rid of var bit in FDR style
2698  5674 F002         SOCB    R2,R0                   add eof and mem full bits
2699                                                    
2700  5676 C069 H212    MOV     @>0054(R9),R1           PAB ptr
2700  5678 0054  
2701  567A 0221         AI      R1,8                    point to bias/status return byte
2701  567C 0008  
2702  567E 0429         BLWP    @>005A(R9)              set VDP to write
2702  5680 005A  
2703  5682 0023         DATA    >0023                   address in R1
2704  5684 DBC0         MOVB    R0,@-2(R15)             write file status to PAB
2704  5686 FFFE  
2705  5688 0460         B       @RTURN1                 return to caller
2705  568A 4450  
2706            
2707            *---------------------------------
2708            * Disk directory access
2709            * ---------------------
2710            * The directory is accessed by omiting the filename in the DSR name: "DSK1."
2711            * It must be opened for input only, as an Int/Fix 38 file.
2712            * It consists in upto 128 records, the first one contains the disk informations,
2713            * the others the informations for upto 127 files (in alphabetical order).
2714            * Each record consists in an ascii string and three floating point numbers.
2715            *
2716            * Record 0 contains:
2717            * - Diskname (an ascii string of upto 10 chars).
2718            * - The number zero.
2719            * - The number of sectors on disk.
2720            * - The number of free sectors on disk.
2721            *
2722            * Other records contain:
2723            * - Filename (an ascii string of upto 10 chars).
2724            * - Filetype: 1=D/F, 2=D/V, 3=I/F, 4=I/V, 5=Prog, 0=end of directory.
2725            *   If the file is protected, this number is negative (-1=D/F, etc).
2726            * - File size in sectors (including the FDR itself).
2727            * - File record length (0 for programs).
2728            *---------------------------------
2729             
2730            *---------------------------------
2731            * Open disk directory pseudo-file
2732            *---------------------------------                                      
2733  568C D02F OPNDIR  MOVB    @-1026(R15),R0          get file type from PAB
2733  568E FBFE  
2734  5690 0240         ANDI    R0,>1E00                mask irrelavant bits (rel/seq)
2734  5692 1E00  
2735  5694 0280         CI      R0,>0C00                is it int/fix in output mode?
2735  5696 0C00  
2736  5698 1303         JEQ     H221                    yes
2737  569A 06A0 H223    BL      @RETERR                 return with error
2737  569C 4A78  
2738  569E 4000         DATA    >4000                   bad attributes
2739  56A0 06A0 H221    BL      @PABR2B                 get 2 bytes from PAB into R0
2739  56A2 4944  
2740  56A4 0004         DATA    4                       rec length
2741  56A6 0980         SRL     R0,8                    make it a word
2742  56A8 1303         JEQ     H222                    >00= default: set it to 38
2743  56AA 0280         CI      R0,>0026                is it 38?
2743  56AC 0026  
2744  56AE 16F5         JNE     H223                    no: return with bad attributes error
2745  56B0 0200 H222    LI      R0,>2600                set rec len to 38
2745  56B2 2600  
2746  56B4 0429         BLWP    @>005A(R9)              set VDP to write
2746  56B6 005A  
2747  56B8 0103         DATA    >0103                   address in R8 (from PABR2B)
2748  56BA DBC0         MOVB    R0,@-2(R15)             write rec len to PAB
2748  56BC FFFE  
2749                                                    
2750  56BE 04C7         CLR     R7                      
2751  56C0 06A0         BL      @FNDRV                  find matching drive in file control blocks
2751  56C2 587A  
2752  56C4 56CC         DATA    H224                    go there if not found
2753  56C6 06A0 ERRR10  BL      @ERROR5                 update data then return with error
2753  56C8 4A4C  
2754  56CA E000         DATA    >E000                   file error
2755  56CC C1C7 H224    MOV     R7,R7                   did we find a free slot?
2756  56CE 1603         JNE     H225                    yes
2757  56D0 06A0         BL      @RETERR                 no: return with error
2757  56D2 4A78  
2758  56D4 8000         DATA    >8000                   memory full
2759  56D6 0429 H225    BLWP    @>005A(R9)              set VDP to write
2759  56D8 005A  
2760  56DA 00E3         DATA    >00E3                   address in R7
2761  56DC DBC3         MOVB    R3,@-2(R15)             write drive #
2761  56DE FFFE  
2762  56E0 06C3         SWPB    R3                      
2763  56E2 DBC3         MOVB    R3,@-2(R15)             and a space as filename (illegal, indicates dir)
2763  56E4 FFFE  
2764  56E6 0460         B       @RTURN1                 return to caller
2764  56E8 4450  
2765            
2766            *---------------------------------
2767            * Close disk directory
2768            *---------------------------------                                      
2769  56EA 06A0 CLSDIR  BL      @FNDRV                  find matching drive in file control blocks
2769  56EC 587A  
2770  56EE 56C6         DATA    ERRR10                  go there if not found: return with file error
2771  56F0 04C0         CLR     R0                      
2772  56F2 0429         BLWP    @>005A(R9)              set VDP to write
2772  56F4 005A  
2773  56F6 0103         DATA    >0103                   address in R8
2774  56F8 DBC0         MOVB    R0,@-2(R15)             clear drive #
2774  56FA FFFE  
2775  56FC 0460         B       @RTURN1                 return to caller
2775  56FE 4450  
2776            
2777            *---------------------------------
2778            * Read a record from disk directory
2779            *---------------------------------                                      
2780  5700 06A0 RDDIR   BL      @FNDRV                  find matching drive in file control blocks
2780  5702 587A  
2781  5704 56C6         DATA    ERRR10                  go ther it not found: return with file error
2782  5706 0588         INC     R8                      
2783  5708 C148         MOV     R8,R5                   save ptr to FDR
2784  570A 06A0         BL      @PABR2B                 get 2 bytes from PAB into R0
2784  570C 4944  
2785  570E 0006         DATA    6                       record #
2786  5710 C080         MOV     R0,R2                   save it
2787  5712 0582         INC     R2                      
2788  5714 0429         BLWP    @>005A(R9)              set VDP to write
2788  5716 005A  
2789  5718 0103         DATA    >0103                   address in R8
2790  571A DBC2         MOVB    R2,@-2(R15)             write record number in FDR
2790  571C FFFE  
2791  571E 06C2         SWPB    R2                      after first char of filename!
2792  5720 DBC2         MOVB    R2,@-2(R15)                     
2792  5722 FFFE  
2793  5724 0A10         SLA     R0,1                    since two byte per file ptr
2794  5726 D000         MOVB    R0,R0                   is rec # greater than 128?
2795  5728 1303         JEQ     H226                    no
2796  572A 06A0         BL      @ERROR5                 yes: update data then return with error
2796  572C 4A4C  
2797  572E A000         DATA    >A000                   past eof
2798  5730 0702 H226    SETO    R2                      code for read
2799  5732 C100         MOV     R0,R4                   record #
2800  5734 133B         JEQ     H227                    0=disk parameters
2801  5736 0204         LI      R4,1                    sector #1
2801  5738 0001  
2802  573A 06A0         BL      @CALSUB                 call subroutine
2802  573C 4432  
2803  573E 4B28         DATA    RWSEC                   read sector into buffer in R5
2804  5740 C205         MOV     R5,R8                   buffer ptr
2805  5742 0225         AI      R5,255                  point to data buffer area in this ctrl block
2805  5744 00FF  
2806  5746 0640         DECT    R0                      don't count record 0
2807  5748 A200         A       R0,R8                   point to desired file ptr
2808  574A 06A0         BL      @VDPR2B                 get two byte from VDP at R8 into R0
2808  574C 4950  
2809  574E C100         MOV     R0,R4                   sector where that FDR is to be found
2810  5750 1328         JEQ     H228                    no more
2811  5752 06A0         BL      @CALSUB                 call subroutine
2811  5754 4432  
2812  5756 4B28         DATA    RWSEC                   read FDR sector into data buffer area
2813  5758 06A0         BL      @FDR2B1                 get 2 bytes from FDR into R0
2813  575A 494A  
2814  575C 010E         DATA    270                     # of sect/file
2815  575E C180         MOV     R0,R6                   save it to output file size
2816  5760 0586         INC     R6                      include the FDR itself
2817  5762 D0EF         MOVB    @-1026(R15),R3          ignore eof offset
2817  5764 FBFE  
2818  5766 0202         LI      R2,>0A00                10 chars per filename
2818  5768 0A00  
2819  576A D0EF         MOVB    @-1026(R15),R3          get rec length
2819  576C FBFE  
2820  576E 0983         SRL     R3,8                    make it a word
2821  5770 0648         DECT    R8                      point to status byte in FDR
2822  5772 0429         BLWP    @>005A(R9)              set VDP to read
2822  5774 005A  
2823  5776 0102         DATA    >0102                   address in R8
2824  5778 D02F         MOVB    @-1026(R15),R0          get file status byte
2824  577A FBFE  
2825  577C C1C0         MOV     R0,R7                   
2826  577E 0240         ANDI    R0,>0800                keep only write protected bit
2826  5780 0800  
2827  5782 51C0         SZCB    R0,R7                   clear write protected bit (if it was set)
2828  5784 0987         SRL     R7,8                    make it a word
2829  5786 0587         INC     R7                      types are numbered from 1
2830  5788 0287         CI      R7,>0002                is it a program file?
2830  578A 0002  
2831  578C 1602         JNE     H229                    no
2832  578E 0227         AI      R7,3                    yes: make it type 5
2832  5790 0003  
2833  5792 0287 H229    CI      R7,>0008                is it var?
2833  5794 0008  
2834  5796 1A02         JL      H230                    no
2835  5798 0227         AI      R7,-127                 yes: add 1 and clear var bit
2835  579A FF81  
2836  579C 0A40 H230    SLA     R0,4                    write protect bit will be >80
2837  579E E1C0         SOC     R0,R7                   add it to file type
2838  57A0 1004         JMP     H231                    
2839                                                    
2840  57A2 04C2 H228    CLR     R2                      no more files: filename size = 0
2841  57A4 04C6         CLR     R6                      file size = 0
2842  57A6 04C3         CLR     R3                      rec length = 0
2843  57A8 04C7         CLR     R7                      type = 0
2844  57AA 100F H231    JMP     H232                    output that
2845                                                    
2846  57AC 0225 H227    AI      R5,255                  disk info: point to data buffer area in ctrl block
2846  57AE 00FF  
2847  57B0 06A0         BL      @CALSUB                 call subroutine
2847  57B2 4432  
2848  57B4 4B28         DATA    RWSEC                   read sector 0
2849  57B6 06A0         BL      @FDR2B1                 get 2 bytes from FDR into R0
2849  57B8 494A  
2850  57BA 010A         DATA    266                     # of sectors on disk
2851  57BC C180         MOV     R0,R6                   duplicate it
2852  57BE 0646         DECT    R6                      minus directory itself (sect 0 + 1)
2853  57C0 06A0         BL      @CFSVIB                 count free sectors in bitmap, result in R3
2853  57C2 5840  
2854  57C4 04C7         CLR     R7                      filetype is not used
2855  57C6 0202         LI      R2,>0A00                diskname is 10 chars
2855  57C8 0A00  
2856                                                    
2857  57CA 06A0 H232    BL      @PABR2B                 get 2 bytes from PAB into R0
2857  57CC 4944  
2858            *       DATA    R2                      data buffer address
2859  57CE 0002         DATA    2                       APEDSK99: error in source listing
2860  57D0 C200         MOV     R0,R8                   duplicate it
2861  57D2 0588         INC     R8                      skip first byte
2862  57D4 0982         SRL     R2,8                    filename length (or diskname)
2863  57D6 1316         JEQ     H233                    0: skip filename copying
2864  57D8 04C1         CLR     R1                      
2865  57DA 0429 H234    BLWP    @>005A(R9)              set VDP to read
2865  57DC 005A  
2866  57DE 00A2         DATA    >00A2                   address in R5 (FDR ptr)
2867  57E0 D06F         MOVB    @-1026(R15),R1          get 1 char from filename in FDR
2867  57E2 FBFE  
2868  57E4 0281         CI      R1,>2000                is it a space?
2868  57E6 2000  
2869  57E8 1309         JEQ     H235                    yes: end of name
2870  57EA 0429         BLWP    @>005A(R9)              no: set VDP to write
2870  57EC 005A  
2871  57EE 0103         DATA    >0103                   address in R8 (PAB data buffer ptr)
2872  57F0 DBC1         MOVB    R1,@-2(R15)             copy char in PAB data buffer
2872  57F2 FFFE  
2873  57F4 0585         INC     R5                      increment source ptr
2874  57F6 0588         INC     R8                      increment destination ptr
2875  57F8 0602         DEC     R2                      next char
2876  57FA 16EF         JNE     H234                    
2877  57FC 0502 H235    NEG     R2                      number of trailing spaces
2878  57FE 0222         AI      R2,10                   number of chars in filename
2878  5800 000A  
2879  5802 06C2         SWPB    R2                      
2880  5804 0429 H233    BLWP    @>005A(R9)              set VDP to write
2880  5806 005A  
2881  5808 0003         DATA    >0003                   address in R0 (beg of PAB data buffer)
2882  580A DBC2         MOVB    R2,@-2(R15)             write string length byte
2882  580C FFFE  
2883                                                    
2884  580E 0429         BLWP    @>005A(R9)              set VDP to write
2884  5810 005A  
2885  5812 0103         DATA    >0103                   address in R8
2886  5814 C047         MOV     R7,R1                   file type + protection
2887  5816 06A0         BL      @INT2FP                 make it a float number
2887  5818 58BE  
2888  581A C046         MOV     R6,R1                   file size in sectors, including FDR
2889  581C 06A0         BL      @INT2FP                 make it a float number
2889  581E 58BE  
2890  5820 C043         MOV     R3,R1                   record length
2891  5822 06A0         BL      @INT2FP                 make it a float number
2891  5824 58BE  
2892  5826 C229         MOV     @>0054(R9),R8           get PAB ptr
2892  5828 0054  
2893  582A 0228         AI      R8,5                    point to character count
2893  582C 0005  
2894  582E 0200         LI      R0,>2600                always 38 bytes
2894  5830 2600  
2895  5832 0429         BLWP    @>005A(R9)              set VDP to write
2895  5834 005A  
2896  5836 0103         DATA    >0103                   address in R8
2897  5838 DBC0         MOVB    R0,@-2(R15)             write # of characters in record
2897  583A FFFE  
2898  583C 0460         B       @RTURN1                 return to caller
2898  583E 4450  
2899                                                    
2900  5840 0228 CFSVIB  AI      R8,46                   count free sectors in VIB bitmap
2900  5842 002E  
2901  5844 0202         LI      R2,200                  bitmap size
2901  5846 00C8  
2902  5848 04C3         CLR     R3                      free sectors counter
2903  584A 0429         BLWP    @>005A(R9)              set VDP to read
2903  584C 005A  
2904  584E 0102         DATA    >0102                   address in R8
2905  5850 D06F H236    MOVB    @-1026(R15),R1          get a byte from bitmap
2905  5852 FBFE  
2906  5854 0221         AI      R1,256                  
2906  5856 0100  
2907  5858 0981         SRL     R1,8                    
2908  585A 130C         JEQ     H237                    was >FF: no free sectors, next byte
2909  585C 0601         DEC     R1                      was it >00?
2910  585E 1603         JNE     H238                    no: count bits
2911  5860 0223         AI      R3,8                    yes: 8 more free sectors
2911  5862 0008  
2912  5864 1007         JMP     H237                    next byte
2913  5866 0200 H238    LI      R0,8                    8 bits per byte
2913  5868 0008  
2914  586A 0911 H239    SRL     R1,1                    test a bit
2915  586C 1801         JOC     H240                    was 1: sector is used
2916  586E 0583         INC     R3                      was 0: one more free sector
2917  5870 0600 H240    DEC     R0                      next bit in byte
2918  5872 16FB         JNE     H239                    more to come
2919  5874 0602 H237    DEC     R2                      next bitmap byte
2920  5876 16EC         JNE     H236                    more to come
2921  5878 045B         B       *R11                    
2922                                                    
2923  587A C2BB FNDRV   MOV     *R11+,R10               find drive in file control blocks
2924  587C C14B         MOV     R11,R5                  save 2 returns
2925  587E C229         MOV     @>0056(R9),R8           top of mem word in VDP buffers header
2925  5880 0056  
2926  5882 0228         AI      R8,3                    point to max # of files
2926  5884 0003  
2927  5886 0429         BLWP    @>005A(R9)              set VDP to read
2927  5888 005A  
2928  588A 0102         DATA    >0102                   address in R8
2929  588C D0AF         MOVB    @-1026(R15),R2          get # of files
2929  588E FBFE  
2930  5890 0882         SRA     R2,8                    make it a word
2931  5892 0228         AI      R8,6                    point to drive # in file ctrl block
2931  5894 0006  
2932  5896 0203         LI      R3,>0020                filename begin with space (illegal: flag for dir)
2932  5898 0020  
2933            *       MOVB    R5,R3                   add drive #
2934  589A D0C6         MOVB    R6,R3                   APEDSK99: error in original disassembly
2935  589C 06A0 H241    BL      @VDPR2B                 read 2 bytes from VDP at R8 into R0
2935  589E 4950  
2936  58A0 8003         C       R3,R0                   match with that control block?
2937  58A2 1309         JEQ     H242                    yes
2938  58A4 0240         ANDI    R0,>00FF                keep only first char of filename
2938  58A6 00FF  
2939  58A8 1601         JNE     H243                    valid filename: a FDR is loaded here
2940  58AA C1C8         MOV     R8,R7                   this space is free: save ptr
2941  58AC 0228 H243    AI      R8,518                  point to next file control block
2941  58AE 0206  
2942  58B0 0602         DEC     R2                      next file
2943  58B2 16F4         JNE     H241                    more to come
2944  58B4 045A         B       *R10                    not found: return to address passed in data word
2945  58B6 0588 H242    INC     R8                      drive matches: point to FDR
2946  58B8 CA48         MOV     R8,@>0056(R9)           save ptr
2946  58BA 0056  
2947  58BC 0455         B       *R5                     return to caller after data word
2948            
2949            *--------------------------------------
2950            * Floating point format
2951            * ---------------------
2952            * Float numbers are 8 bytes long: EE 12 34 56 78 9A BC
2953            * EE is the exponent in radix 100 (not in radix 10 as usual!). It is biased
2954            * by 64: >40=0, 41=1 (i.e *100), >42=2 (i.e * 10,000) >3F= -1 (i.e /100), etc
2955            *
2956            * 12 ... BC are the mantissa in binary coded decimal: each byte encodes two
2957            * decimal digits from 00 to 99
2958            *
2959            * For negative numbers, the first word is negated
2960            * For zero, the first word is >0000 the others are irrelevant
2961            *
2962            * Examples: 40 08 00 00 00 00 00 00 is 8.0
2963            *           41 02 37 00 00 00 00 00 is 255.0 (>37 hex = 55 decimal)
2964            *           BF F8 00 00 00 00 00 00 is -8.0
2965            *           43 01 02 03 04 05 06 07 is 1020304.050607
2966            *--------------------------------------                                 
2967  58BE 0202 INT2FP  LI      R2,>0800                write an integer in floating point format
2967  58C0 0800  
2968  58C2 DBC2         MOVB    R2,@-2(R15)             size=8
2968  58C4 FFFE  
2969  58C6 C141         MOV     R1,R5                   integer is in R1: save it for sign processing
2970  58C8 0241         ANDI    R1,>7FFF                clear sign bit
2970  58CA 7FFF  
2971  58CC 0281         CI      R1,100                  is it less than 100?
2971  58CE 0064  
2972  58D0 1A07         JL      H244                    yes
2973  58D2 04C0         CLR     R0                      100 or over
2974  58D4 0204         LI      R4,100                  
2974  58D6 0064  
2975  58D8 3C04         DIV     R4,R0                   divide by 100
2976  58DA 0260         ORI     R0,>4100                add exponent 2 to hundreths
2976  58DC 4100  
2977  58DE 1005         JMP     H245                    
2978                                                    
2979  58E0 C001 H244    MOV     R1,R0                   is it 0?
2980  58E2 1302         JEQ     H246                    yes: exponent is 0
2981  58E4 0260         ORI     R0,>4000                no: add exponent 1
2981  58E6 4000  
2982  58E8 04C1 H246    CLR     R1                      next digits will be 0
2983                                                    
2984  58EA C145 H245    MOV     R5,R5                   test sign bit
2985  58EC 1101         JLT     H247                    negative
2986  58EE 1001         JMP     H248                    positive or zero
2987  58F0 0500 H247    NEG     R0                      negate first word
2988  58F2 DBC0 H248    MOVB    R0,@-2(R15)             write exponent to VDP at preset address
2988  58F4 FFFE  
2989  58F6 06C0         SWPB    R0                      
2990  58F8 DBC0         MOVB    R0,@-2(R15)             write first first 2 digits (or hundreths)
2990  58FA FFFE  
2991  58FC 06C1         SWPB    R1                      
2992  58FE DBC1         MOVB    R1,@-2(R15)             write last 2 digits (if any)
2992  5900 FFFE  
2993  5902 0202         LI      R2,5                    the remaining bytes are all 0 with integers
2993  5904 0005  
2994  5906 DBC2 H249    MOVB    R2,@-2(R15)             write 0 to VDP
2994  5908 FFFE  
2995  590A 0602         DEC     R2                      next byte
2996  590C 16FC         JNE     H249                    more to do
2997  590E 045B         B       *R11                    
2998            
2999            *---------------------------------------
3000            * Subprogram >10: sector R/W
3001            * --------------
3002            * >834A: (n/a)      <--- sector #
3003            * >834C: drive #
3004            * >834D: R/W code (write if >00)
3005            * >834E: VDP buffer
3006            * >8350: sector #   <--- error code
3007            *---------------------------------------                                        
3008  5910 C1CB ESUB01  MOV     R11,R7                  
3009  5912 06A0         BL      @PRPFDO                 prepare disk operations
3009  5914 44FE  
3010  5916 CA69         MOV     @>0050(R9),@>004A(R9)   copy sector #
3010  5918 0050  
3010  591A 004A  
3011  591C 0460         B       @SECRW1                 
3011  591E 4164  
3012            
3013            *---------------------------------------
3014            * Subprogram >11: format disk
3015            * --------------                                        
3016  5920 C1CB ESUB02  MOV     R11,R7                  
3017  5922 06A0         BL      @PRPFDO                 prepare disk operations
3017  5924 44FE  
3018  5926 0460         B       @FMTDSK                 
3018  5928 424A  
3019            
3020            *---------------------------------------
3021            * Subprogram >12: file (un)protect
3022            * --------------
3023            * >834C: drive #
3024            * >834D: protect code (>00 unprotect)
3025            * >834E: ptr to filename
3026            * >8350: (n/a)      <--- error code
3027            *---------------------------------------                                
3028  592A C1CB ESUB03  MOV     R11,R7                  
3029  592C 06A0         BL      @PRPFDO                 prepare disk operations
3029  592E 44FE  
3030  5930 D029         MOVB    @>004D(R9),R0           get protection code
3030  5932 004D  
3031  5934 0240         ANDI    R0,>0800                keep the bit that will be needed
3031  5936 0800  
3032  5938 0429         BLWP    @>005A(R9)              save R0 on stack
3032  593A 005A  
3033  593C 8000         DATA    >8000                   
3034  593E C029         MOV     @>004E(R9),R0           get pointer to filename
3034  5940 004E  
3035  5942 06A0         BL      @CALSUB                 call subroutine
3035  5944 4432  
3036  5946 5A2C         DATA    RFDRVB                  load FDR in VDP buffer
3037  5948 0429         BLWP    @>005A(R9)              retrieve old R0, in R2
3037  594A 005A  
3038  594C 2001         DATA    >2001                   
3039  594E 06A0         BL      @FDR2B1                 read two bytes in R0 from top of FDR + offset
3039  5950 494A  
3040  5952 000C         DATA    12                      file status byte
3041  5954 0240         ANDI    R0,>F700                clear protection flag
3041  5956 F700  
3042  5958 F002         SOCB    R2,R0                   set it if needed
3043  595A 0429         BLWP    @>005A(R9)              set VDP for write
3043  595C 005A  
3044  595E 0103         DATA    >0103                   address in R8
3045  5960 DBC0         MOVB    R0,@-2(R15)             write back file status to FDR
3045  5962 FFFE  
3046                                                    
3047  5964 C229 UWFLVB  MOV     @>0056(R9),R8           FDR address in VDP mem
3047  5966 0056  
3048  5968 0429         BLWP    @>005A(R9)              set VDP for read
3048  596A 005A  
3049  596C 0102         DATA    >0102                   address in R8
3050  596E D02F         MOVB    @-1026(R15),R0          get drive # in ctrl block
3050  5970 FBFE  
3051  5972 0260         ORI     R0,>8000                flag it
3051  5974 8000  
3052  5976 0429         BLWP    @>005A(R9)              set VDP for write
3052  5978 005A  
3053  597A 0103         DATA    >0103                   address in R8
3054  597C DBC0         MOVB    R0,@-2(R15)             write it back
3054  597E FFFE  
3055  5980 0460         B       @UPDFDR                 update FDR, load VIB
3055  5982 4650  
3056            
3057            *---------------------------------
3058            * Subprogram >13: file rename
3059            * --------------
3060            * >834C: drive #
3061            * >834E: ptr to new name
3062            * >8350: ptr to old name <--- error code
3063            *---------------------------------                                      
3064  5984 C1CB ESUB04  MOV     R11,R7                  
3065  5986 06A0         BL      @PRPFDO                 prepare disk operations
3065  5988 44FE  
3066  598A C029         MOV     @>004E(R9),R0           get ptr to new filename
3066  598C 004E  
3067  598E 0429         BLWP    @>005A(R9)              save R0 on stack
3067  5990 005A  
3068  5992 8000         DATA    >8000                   
3069  5994 C029         MOV     @>0050(R9),R0           get ptr to old filename
3069  5996 0050  
3070  5998 06A0         BL      @CALSUB                 call subroutine
3070  599A 4432  
3071  599C 5A2C         DATA    RFDRVB                  put FDR in VDP buffer
3072  599E 06A0         BL      @RMFPTR                 remove FDR ptr from sector 1
3072  59A0 48B4  
3073  59A2 06A0         BL      @FDR2B1                 get 2 bytes from FDR
3073  59A4 494A  
3074  59A6 000C         DATA    12                      file status byte
3075  59A8 0240         ANDI    R0,>0800                protected?
3075  59AA 0800  
3076  59AC 1303         JEQ     H250                    no
3077  59AE 06A0         BL      @ERROR5                 yes: return with error
3077  59B0 4A4C  
3078  59B2 2000         DATA    >2000                   write protected
3079  59B4 06A0 H250    BL      @FDR2B1                 get 2 bytes from FDR
3079  59B6 494A  
3080  59B8 FFFC         DATA    -4                      sector # of FDR
3081  59BA C040         MOV     R0,R1                   
3082  59BC 0429         BLWP    @>005A(R9)              retrieve R0 from stack
3082  59BE 005A  
3083  59C0 8001         DATA    >8001                   ptr to new filename
3084  59C2 0429         BLWP    @>005A(R9)              save R1 on stack
3084  59C4 005A  
3085  59C6 4000         DATA    >4000                   sector # of FDR
3086  59C8 06A0         BL      @UFNCB                  write drive # and filename in compare buffer
3086  59CA 5C4E  
3087  59CC 06A0         BL      @CALSUB                 call subroutine
3087  59CE 4432  
3088  59D0 4C12         DATA    FFDRFN                  find FDR from filename
3089  59D2 C104         MOV     R4,R4                   found?
3090  59D4 1338         JEQ     H251                    yes: return with file error (name already exist)
3091  59D6 06A0         BL      @INSFDR                 insert a FDR in sector 1
3091  59D8 48E4  
3092  59DA 0429         BLWP    @>005A(R9)              retrieve sect # of FDR in R4
3092  59DC 005A  
3093  59DE 0801         DATA    >0801                   
3094  59E0 0429         BLWP    @>005A(R9)              set VDP to write
3094  59E2 005A  
3095  59E4 0103         DATA    >0103                   address in R8
3096  59E6 DBC4         MOVB    R4,@-2(R15)             write sector # of FDR
3096  59E8 FFFE  
3097  59EA 06C4         SWPB    R4                      
3098  59EC DBC4         MOVB    R4,@-2(R15)                     
3098  59EE FFFE  
3099  59F0 06C4         SWPB    R4                      sector #
3100  59F2 0702         SETO    R2                      code for read
3101  59F4 04C5         CLR     R5                      buffer offset: VDP at >8356
3102  59F6 06A0         BL      @CALSUB                 call subroutine
3102  59F8 4432  
3103  59FA 4B24         DATA    RDFDR1                  read FDR
3104  59FC C045         MOV     R5,R1                   
3105  59FE C029         MOV     @>0058(R9),R0                   
3105  5A00 0058  
3106  5A02 0220         AI      R0,257                  
3106  5A04 0101  
3107  5A06 0601         DEC     R1                      
3108  5A08 06A0         BL      @CFNFDR                 copy filename in compare buffer to FDR
3108  5A0A 5C64  
3109  5A0C 04C2         CLR     R2                      code for write
3110  5A0E 06A0         BL      @CALSUB                 call subroutine
3110  5A10 4432  
3111  5A12 4B28         DATA    RWSEC                   write FDR (with new name in it)
3112  5A14 06A0         BL      @CALSUB                 call subroutine
3112  5A16 4432  
3113  5A18 4B10         DATA    WRSEC1                  write sector 1 (with new FDR ptr in it)
3114  5A1A C069         MOV     @>0056(R9),R1           FDR ptr
3114  5A1C 0056  
3115  5A1E 0429         BLWP    @>005A(R9)              prepare VDP to write
3115  5A20 005A  
3116  5A22 0023         DATA    >0023                   address in R1
3117  5A24 DBC4         MOVB    R4,@-2(R15)             clear first char of FDR in buffer
3117  5A26 FFFE  
3118  5A28 0460         B       @RTURN1                 return to caller
3118  5A2A 4450  
3119                                                    
3120  5A2C 04C6 RFDRVB  CLR     R6                      put FDR in VDP buffer
3121  5A2E D1A9         MOVB    @>004C(R9),R6           get drive #
3121  5A30 004C  
3122  5A32 06A0         BL      @UFNCB                  update filename compare buffer
3122  5A34 5C4E  
3123  5A36 06A0         BL      @CALSUB                 call subroutine
3123  5A38 4432  
3124  5A3A 4B9E         DATA    FFDRVB                  look if FDR already in VDP buffer
3125  5A3C 06A0         BL      @CALSUB                 call subroutine
3125  5A3E 4432  
3126  5A40 4BE2         DATA    FFDROD                  file FDR on disk
3127  5A42 C104         MOV     R4,R4                   found?
3128  5A44 1303         JEQ     H252                    yes
3129  5A46 06A0 H251    BL      @RETERR                 no: return with error code in >8350
3129  5A48 4A78  
3130  5A4A E000         DATA    >E000                   file error
3131  5A4C 0460 H252    B       @RTURN1                 return to caller
3131  5A4E 4450  
3132            
3133            *-------------------------------------
3134            * Subprogram >14: file raw read
3135            * --------------
3136            * >834C: drive #                          <--- >00
3137            * >834D: # of sectors (>00=get file info) <--- sectors read
3138            * >834E: ptr to filename
3139            * >8350: file info buffer (>83xx)         <--- error code
3140            *                              |
3141            * >83xx  : VDP buffer       <--'
3142            * >83xx+2: first sector # (total # of sect when get file info)
3143            * >83xx+4: status flag
3144            * >83xx+5: recs/sector
3145            * >83xx+6: eof offset
3146            * >83xx+7: rec size
3147            * >83xx+8: # of recs
3148            *-------------------------------------                                  
3149  5A50 C1CB ESUB05  MOV     R11,R7                  
3150  5A52 06A0         BL      @PRPFDO                 prepare disk operations
3150  5A54 44FE  
3151  5A56 06A0         BL      @RFNPTR                 load filename and ptrs
3151  5A58 5C86  
3152  5A5A 06A0         BL      @FFFDR                  find file FDR, load some info
3152  5A5C 5CAC  
3153  5A5E C082         MOV     R2,R2                   # of sectors to read
3154  5A60 131E         JEQ     H253                    >00: get file info
3155  5A62 6003         S       R3,R0                   sectors in file - first sector to read
3156  5A64 1502         JGT     H254                    in file
3157  5A66 04C2         CLR     R2                      past eof
3158  5A68 1017         JMP     H255                    
3159  5A6A 8002 H254    C       R2,R0                   sectors past first one vs sectors to load
3160  5A6C 1A01         JL      H256                    
3161  5A6E C080         MOV     R0,R2                   load what's left
3162  5A70 0429 H256    BLWP    @>005A(R9)                      
3162  5A72 005A  
3163  5A74 2000         DATA    >2000                   save R2
3164  5A76 0429 H257    BLWP    @>005A(R9)                      
3164  5A78 005A  
3165  5A7A 3100         DATA    >3100                   save R2, R3, R7
3166  5A7C 06A0         BL      @CALSUB                 call subroutine
3166  5A7E 4432  
3167  5A80 4704         DATA    RDOFSC                  read sector from offset in file
3168  5A82 0429         BLWP    @>005A(R9)                      
3168  5A84 005A  
3169  5A86 3101         DATA    >3101                   retrieve R2, R3, R7
3170  5A88 0583         INC     R3                      next sector
3171  5A8A 0227         AI      R7,256                  increment VDP buffer ptr by 256 bytes
3171  5A8C 0100  
3172  5A8E 0602         DEC     R2                      more to do?
3173  5A90 16F2         JNE     H257                    yes
3174  5A92 0429 H258    BLWP    @>005A(R9)                      
3174  5A94 005A  
3175  5A96 2001         DATA    >2001                   retrieve R2 (# of sectors read)
3176  5A98 CA42 H255    MOV     R2,@>004C(R9)           update # of sectors in parameters
3176  5A9A 004C  
3177  5A9C 100A         JMP     H259                    
3178                                                    
3179  5A9E CD00 H253    MOV     R0,*R4+                 get file info: sectors in file
3180  5AA0 0648         DECT    R8                      
3181  5AA2 05C2         INCT    R2                      copy 2 bytes (status + recs/sector)
3182  5AA4 06A0         BL      @VDP2SP                 from VDP at R8 to file info structure
3182  5AA6 5CE0  
3183  5AA8 0202         LI      R2,4                    copy 4 bytes
3183  5AAA 0004  
3184  5AAC A202         A       R2,R8                   
3185  5AAE 06A0         BL      @VDP2SP                 eof offset, rec len, # of recs (or # of sect)
3185  5AB0 5CE0  
3186  5AB2 06A0 H259    BL      @CALSUB                 call subroutine
3186  5AB4 4432  
3187  5AB6 4650         DATA    UPDFDR                  updata FDR (+ data) if needed, read VIB
3188  5AB8 04E9         CLR     @>0050(R9)              clear error flag
3188  5ABA 0050  
3189  5ABC 0460         B       @RTURN1                 return to caller
3189  5ABE 4450  
3190            
3191            *--------------------------------------
3192            * Subprogram >15: file raw write
3193            * --------------
3194            * >834C: drive #                                  <--- >00
3195            * >834D: # of sectors (>00=create file from info) <--- # of sectors written
3196            * >834E: ptr to filename
3197            * >8350: file info buffer (>83xx)                 <--- error code
3198            *                              |
3199            * >83xx  : VDP buffer       <--'
3200            * >83xx+2: first sector # (total # of sectors when creating file)
3201            * >83xx+4: status flag
3202            * >83xx+5: recs/sector
3203            * >83xx+6: eof offset
3204            * >83xx+7: rec size
3205            * >83xx+8: # of recs
3206            *--------------------------------------                                 
3207  5AC0 C1CB ESUB06  MOV     R11,R7                  
3208  5AC2 06A0         BL      @PRPFDO                 prepare disk operations
3208  5AC4 44FE  
3209  5AC6 06A0         BL      @RFNPTR                 load drive + filename, + a few info
3209  5AC8 5C86  
3210  5ACA 1314         JEQ     H260                    sectors to write=0: create file
3211  5ACC 06A0         BL      @FFFDR                  find file FDR
3211  5ACE 5CAC  
3212  5AD0 0429         BLWP    @>005A(R9)                      
3212  5AD2 005A  
3213  5AD4 2000         DATA    >2000                   save R2 (# of sectors to write)
3214  5AD6 0429 H261    BLWP    @>005A(R9)                      
3214  5AD8 005A  
3215  5ADA 3100         DATA    >3100                   save R2, R3, R7
3216  5ADC 06A0         BL      @CALSUB                 call subroutine
3216  5ADE 4432  
3217  5AE0 4724         DATA    WROFSC                  write sector from offset in file
3218  5AE2 0429         BLWP    @>005A(R9)                      
3218  5AE4 005A  
3219  5AE6 3101         DATA    >3101                   retrieve R2, R3, R7
3220  5AE8 0583         INC     R3                      next sector
3221  5AEA 0227         AI      R7,256                  increment VDP ptr by 256 bytes
3221  5AEC 0100  
3222  5AEE 0602         DEC     R2                      more to do?
3223  5AF0 16F2         JNE     H261                    yes
3224  5AF2 10CF         JMP     H258                    update # of sectors written, in param. Then return
3225                                                    
3226  5AF4 06A0 H260    BL      @CALSUB                 create file
3226  5AF6 4432  
3227  5AF8 4B9E         DATA    FFDRVB                  find file FDR in VDP buffers
3228  5AFA 06A0         BL      @CALSUB                 call subroutine
3228  5AFC 4432  
3229  5AFE 4BE2         DATA    FFDROD                  find file FDR on disk
3230  5B00 06A0         BL      @CALSUB                 call subroutine
3230  5B02 4432  
3231  5B04 4570         DATA    CRFIL2                  create file
3232  5B06 0429         BLWP    @>005A(R9)                      
3232  5B08 005A  
3233  5B0A 0801         DATA    >0801                   retrieve R4 (file info ptr)
3234  5B0C C229         MOV     @>0056(R9),R8           FDR ptr
3234  5B0E 0056  
3235  5B10 05C4         INCT    R4                      skip 2 bytes
3236  5B12 C0F4         MOV     *R4+,R3                 # of sector to create
3237  5B14 0228         AI      R8,10                   skip filename
3237  5B16 000A  
3238  5B18 06A0         BL      @SP2VDP                 write 2 bytes in VDP at R8+2
3238  5B1A 5CF0  
3239  5B1C 0002         DATA    2                       i.e. status + recs/sector
3240  5B1E 06A0         BL      @SP2VDP                 write 4 bytes in VDP at new R8+4
3240  5B20 5CF0  
3241  5B22 0004         DATA    4                       i.e. eof offset, rec len, # of recs (or # of
3242  5B24 0603         DEC     R3                      offset = # of sectors-1 (starts from 0)
3243  5B26 1103         JLT     H262                    create an empty file, FDR only
3244  5B28 06A0         BL      @CALSUB                 
3244  5B2A 4432  
3245  5B2C 473A         DATA    APSCTS                  append enough sectors to reach offset
3246  5B2E 0460 H262    B       @UWFLVB                 modify FDR, write it, load VIB, return
3246  5B30 5964  
3247            
3248            *---------------------------------------
3249            * Subprogram FILES: number of files
3250            *---------------------------------------                                        
3251  5B32 C1CB ESUB08  MOV     R11,R7                  
3252  5B34 06A0         BL      @PRPFDO                 prepare disk operation
3252  5B36 44FE  
3253  5B38 C229         MOV     @>002C(R9),R8           ptr to next basic token
3253  5B3A 002C  
3254  5B3C 0228         AI      R8,7                    skip FILES
3254  5B3E 0007  
3255  5B40 06A0         BL      @VDPR2B                 get next two bytes in R0
3255  5B42 4950  
3256  5B44 0280         CI      R0,>C801                >C8=unquoted string, size=1 char
3256  5B46 C801  
3257  5B48 161C         JNE     H263                    return (with error) if different
3258  5B4A 05C8         INCT    R8                      increment pointer
3259  5B4C 06A0         BL      @VDPR2B                 get next two bytes
3259  5B4E 4950  
3260  5B50 06C0         SWPB    R0                      
3261  5B52 0220         AI      R0,>49D0                substact >B630: # of files >B6=closed parenthesis
3261  5B54 49D0  
3262  5B56 0280         CI      R0,>0009                only 9 files allowed in Basic !
3262  5B58 0009  
3263  5B5A 1B13         JH      H263                    return with error if more
3264  5B5C 06C0         SWPB    R0                      
3265  5B5E DA40         MOVB    R0,@>004C(R9)           put new # of files in scratch-pad memory
3265  5B60 004C  
3266  5B62 06A0         BL      @CALSUB                 call subroutine
3266  5B64 4432  
3267  5B66 5B8C         DATA    PESB07                  subprogram >16 (private entry point)
3268  5B68 DA69         MOVB    @>0050(R9),@>0050(R9)   test result
3268  5B6A 0050  
3268  5B6C 0050  
3269  5B6E 1609         JNE     H263                    error
3270  5B70 C229         MOV     @>002C(R9),R8           ok: get ptr to Basic token
3270  5B72 002C  
3271  5B74 0228         AI      R8,12                   skip the whole statement
3271  5B76 000C  
3272  5B78 CA48         MOV     R8,@>002C(R9)           update ptr
3272  5B7A 002C  
3273  5B7C 5A69         SZCB    @>0042(R9),@>0042(R9)   clear current token
3273  5B7E 0042  
3273  5B80 0042  
3274  5B82 0460 H263    B       @RTURN1                 return to caller (i.e. Basic)
3274  5B84 4450  
3275            
3276            *---------------------------------------
3277            * Subprogram >16: number of files
3278            * --------------
3279            * >834C: # of files
3280            * >8350: (n/a)      <--- error code
3281            *---------------------------------------                                        
3282  5B86 C1CB ESUB07  MOV     R11,R7                  entry point from assembly
3283  5B88 06A0         BL      @PRPFDO                 prepare disk operations
3283  5B8A 44FE  
3284  5B8C 04C0 PESB07  CLR     R0                      entry point from call files
3285  5B8E D029         MOVB    @>004C(R9),R0           get # of files
3285  5B90 004C  
3286  5B92 1359         JEQ     H264                    return with error
3287  5B94 C229         MOV     @>0056(R9),R8           ptr to end of buffer word
3287  5B96 0056  
3288  5B98 0228         AI      R8,3                    point to # of files byte
3288  5B9A 0003  
3289  5B9C 04C3         CLR     R3                      
3290  5B9E 0429         BLWP    @>005A(R9)              set VDP to read
3290  5BA0 005A  
3291  5BA2 0102         DATA    >0102                   address in R8
3292  5BA4 D0EF         MOVB    @-1026(R15),R3          get current # of files
3292  5BA6 FBFE  
3293  5BA8 0205         LI      R5,518                  size of 1 file control block
3293  5BAA 0206  
3294  5BAC 90C0         CB      R0,R3                   compare required with current
3295  5BAE 1348         JEQ     H265                    same: return with no error
3296  5BB0 122B         JLE     H266                    less
3297  5BB2 C180         MOV     R0,R6                   more files needed
3298  5BB4 0280         CI      R0,>1000                maximum is 16
3298  5BB6 1000  
3299  5BB8 1B46         JH      H264                    return with error
3300  5BBA 6003         S       R3,R0                   how many to add
3301  5BBC 0980         SRL     R0,8                    make it a word
3302  5BBE 3805         MPY     R5,R0                   # of bytes to add
3303  5BC0 C101         MOV     R1,R4                   result in R0:R1
3304  5BC2 0504         NEG     R4                      
3305  5BC4 C0A9         MOV     @>0070(R9),R2           highest free address in VDP mem
3305  5BC6 0070  
3306  5BC8 C002         MOV     R2,R0                   
3307  5BCA 6001         S       R1,R0                   what it would become
3308  5BCC 0280         CI      R0,>0800                is there room enough for VDP?
3308  5BCE 0800  
3309  5BD0 113A         JLT     H264                    no: return with error
3310  5BD2 C040         MOV     R0,R1                   ok: new base
3311  5BD4 0582 H267    INC     R2                      increment source ptr
3312  5BD6 0580         INC     R0                      increment destination ptr
3313  5BD8 0429         BLWP    @>005A(R9)              set VDP to read
3313  5BDA 005A  
3314  5BDC 0042         DATA    >0042                   address in R2
3315  5BDE D0EF         MOVB    @-1026(R15),R3          get a byte
3315  5BE0 FBFE  
3316  5BE2 0429         BLWP    @>005A(R9)              set VDP to write
3316  5BE4 005A  
3317  5BE6 0003         DATA    >0003                   address in R0
3318  5BE8 DBC3         MOVB    R3,@-2(R15)             copy a byte
3318  5BEA FFFE  
3319  5BEC 8202         C       R2,R8                   did we copy the whole header?
3320  5BEE 16F2         JNE     H267                    not yet
3321  5BF0 0429         BLWP    @>005A(R9)              set VDP to write
3321  5BF2 005A  
3322  5BF4 0003         DATA    >0003                   address in R0
3323  5BF6 DBC6         MOVB    R6,@-2(R15)             new # of files
3323  5BF8 FFFE  
3324  5BFA 04C6         CLR     R6                      
3325  5BFC 6080         S       R0,R2                   
3326  5BFE DBC6 H268    MOVB    R6,@-2(R15)             clear byte
3326  5C00 FFFE  
3327  5C02 0602         DEC     R2                      
3328  5C04 16FC         JNE     H268                    
3329  5C06 101A         JMP     H269                    
3330                                                    
3331  5C08 0429 H266    BLWP    @>005A(R9)              less files needed
3331  5C0A 005A  
3332  5C0C 0103         DATA    >0103                   set VDP to write to address in R8
3333  5C0E DBC0         MOVB    R0,@-2(R15)             new # of files in buffer header
3333  5C10 FFFE  
3334  5C12 60C0         S       R0,R3                   how many to remove
3335  5C14 0983         SRL     R3,8                    make it a word
3336  5C16 38C5         MPY     R5,R3                   # of bytes to remove
3337  5C18 C044         MOV     R4,R1                   result in R3:R4
3338  5C1A A048         A       R8,R1                   new address for buffer header
3339  5C1C C0A9         MOV     @>0070(R9),R2           highest free address in VDP mem
3339  5C1E 0070  
3340  5C20 0429 H270    BLWP    @>005A(R9)              set VDP to read
3340  5C22 005A  
3341  5C24 0102         DATA    >0102                   address in R8
3342  5C26 D02F         MOVB    @-1026(R15),R0          read a byte
3342  5C28 FBFE  
3343  5C2A 0429         BLWP    @>005A(R9)              set VDP to write
3343  5C2C 005A  
3344  5C2E 0023         DATA    >0023                   address in R1
3345  5C30 DBC0         MOVB    R0,@-2(R15)             write byte back
3345  5C32 FFFE  
3346  5C34 0601         DEC     R1                      decrement destination ptr
3347  5C36 0608         DEC     R8                      decrement source ptr
3348  5C38 8088         C       R8,R2                   did we copy the whole header?
3349  5C3A 16F2         JNE     H270                    not yet
3350                                                    
3351  5C3C CA41 H269    MOV     R1,@>0070(R9)           new first free address
3351  5C3E 0070  
3352            *       MOV     R1,R8                   
3353            *H271   INCT    R8                      point to end of buffer word
3354            *       BL      @VDPR2B                 read it in R0
3355            *       MOVB    @-1026(R15),R1          get CRU base byte
3356            *       CB      R12,R1                  same as current controller?
3357            *       JEQ     H265                    yes: return with no error
3358            *       A       R4,R0                   no: coin address of next buffer
3359            *       BLWP    @>005A(R9)              set VDP to write
3360            *       DATA    >0103                   address in R8
3361            *       MOVB    R0,@-2(R15)             write new end of buffer word
3362            *       MOV     R0,R8                   and make it new address
3363            *       SWPB    R0                      
3364            *       MOVB    R0,@-2(R15)                     
3365            *       JMP     H271                    now, try again
3366                                                    
3367  5C40 04E9 H265    CLR     @>0050(R9)              clear error flag
3367  5C42 0050  
3368  5C44 1002         JMP     H272                    
3369  5C46 0729 H264    SETO    @>0050(R9)              set error flag
3369  5C48 0050  
3370  5C4A 0460 H272    B       @RTURN1                 return to caller
3370  5C4C 4450  
3371                                                    
3372  5C4E 04E9 UFNCB   CLR     @>0054(R9)              write drive # and filename in compare buffer
3372  5C50 0054  
3373  5C52 C069         MOV     @>0058(R9),R1           
3373  5C54 0058  
3374  5C56 0221         AI      R1,256                  ptr to filename compare buffer
3374  5C58 0100  
3375  5C5A 0429         BLWP    @>005A(R9)              set VDP to write
3375  5C5C 005A  
3376  5C5E 0023         DATA    >0023                   address in R1
3377  5C60 DBC6         MOVB    R6,@-2(R15)             write drive #
3377  5C62 FFFE  
3378  5C64 0202 CFNFDR  LI      R2,10                   filename must be exactly 10 chars
3378  5C66 000A  
3379  5C68 0581 H273    INC     R1                      next char in compare buffer
3380  5C6A 0429         BLWP    @>005A(R9)              set VDP to read
3380  5C6C 005A  
3381  5C6E 0002         DATA    >0002                   address in R0
3382  5C70 D0EF         MOVB    @-1026(R15),R3          get 1 char from filename
3382  5C72 FBFE  
3383  5C74 0580         INC     R0                      next char in provided filename
3384  5C76 0429         BLWP    @>005A(R9)              set VDP to write
3384  5C78 005A  
3385  5C7A 0023         DATA    >0023                   address in R1
3386  5C7C DBC3         MOVB    R3,@-2(R15)             write 1 char to compare buffer
3386  5C7E FFFE  
3387  5C80 0602         DEC     R2                      
3388  5C82 16F2         JNE     H273                    next char
3389  5C84 045B         B       *R11                    
3390                                                    
3391  5C86 C28B RFNPTR  MOV     R11,R10                 load compare buffer and ptrs
3392  5C88 04C6         CLR     R6                      
3393  5C8A D1A9         MOVB    @>004C(R9),R6           drive #
3393  5C8C 004C  
3394  5C8E C029         MOV     @>004E(R9),R0           ptr to filename
3394  5C90 004E  
3395  5C92 06A0         BL      @UFNCB                  write them in compare buffer
3395  5C94 5C4E  
3396  5C96 D129         MOVB    @>0050(R9),R4           file info structure ptr
3396  5C98 0050  
3397  5C9A 0984         SRL     R4,8                    
3398  5C9C A109         A       R9,R4                   make it a PAB address
3399  5C9E D029         MOVB    @>004D(R9),R0           # of sectors (>00=get file info)
3399  5CA0 004D  
3400  5CA2 0429         BLWP    @>005A(R9)                      
3400  5CA4 005A  
3401  5CA6 0800         DATA    >0800                   save R4
3402  5CA8 0980         SRL     R0,8                    
3403  5CAA 045A         B       *R10                    EQ set for get file info
3404                                                    
3405  5CAC 0429 FFFDR   BLWP    @>005A(R9)              find file FDR
3405  5CAE 005A  
3406  5CB0 8010         DATA    >8010                   save R0 + R11
3407  5CB2 06A0         BL      @CALSUB                 call subroutine
3407  5CB4 4432  
3408  5CB6 4B9E         DATA    FFDRVB                  find file FDR in VDP buffers
3409  5CB8 06A0         BL      @CALSUB                 call subroutine
3409  5CBA 4432  
3410  5CBC 4BE2         DATA    FFDROD                  find FDR on disk
3411  5CBE C104         MOV     R4,R4                   found ?
3412  5CC0 1303         JEQ     H274                    yes
3413  5CC2 06A0         BL      @ERROR5                 no: return with error
3413  5CC4 4A4C  
3414  5CC6 E000         DATA    >E000                   file error
3415  5CC8 06A0 H274    BL      @FDR2B1                 get two bytes from FDR into R0
3415  5CCA 494A  
3416  5CCC 000E         DATA    14                      # of sectors in file
3417  5CCE 0429         BLWP    @>005A(R9)                      
3417  5CD0 005A  
3418  5CD2 2011         DATA    >2011                   retrieve R0 in R2 (# of sect to read), and R11
3419  5CD4 0429         BLWP    @>005A(R9)                      
3419  5CD6 005A  
3420  5CD8 0801         DATA    >0801                   retrieve R4 (ptr to file info structure)
3421  5CDA C1F4         MOV     *R4+,R7                 VDP buffer
3422  5CDC C0D4         MOV     *R4,R3                  first sector
3423  5CDE 045B         B       *R11                    
3424                                                    
3425  5CE0 0429 VDP2SP  BLWP    @>005A(R9)              copy VDP bytes to scratch-pad
3425  5CE2 005A  
3426  5CE4 0102         DATA    >0102                   read from VDP at R8
3427  5CE6 DD2F H275    MOVB    @-1026(R15),*R4+        read bytes into scratch-pad at R4
3427  5CE8 FBFE  
3428  5CEA 0602         DEC     R2                      # of byte in R2
3429  5CEC 16FC         JNE     H275                    next byte
3430  5CEE 045B         B       *R11                    
3431                                                    
3432  5CF0 C0BB SP2VDP  MOV     *R11+,R2                copy scratch-pad bytes to VDP
3433  5CF2 A202         A       R2,R8                   
3434  5CF4 0429         BLWP    @>005A(R9)              set VDP to write
3434  5CF6 005A  
3435  5CF8 0103         DATA    >0103                   address in R8 + offset in data word
3436  5CFA DBF4 H276    MOVB    *R4+,@-2(R15)           write byte from scratch-pad at R4
3436  5CFC FFFE  
3437  5CFE 0602         DEC     R2                      # of bytes in R2, was in data word
3438  5D00 16FC         JNE     H276                    next byte
3439  5D02 045B         B       *R11    
3440            *
3441            *----------------------------------------------------------------------------
3442            * APEDSK99 CALL subprograms
3443            *----------------------------------------------------------------------------
3444            *
3445  5D04 0206 PDSK    LI      R6,>0200                Protect ACOMND 
3445  5D06 0200  
3446  5D08 104C         JMP     ACLPRP                  generic prep
3447  5D0A 0206 UDSK    LI      R6,>0400                Unprotect ACOMND 
3447  5D0C 0400  
3448  5D0E 1049         JMP     ACLPRP                  generic prep
3449  5D10 0206 MDSK    LI      R6,>0600                Change DSK ACOMND
3449  5D12 0600  
3450  5D14 1046         JMP     ACLPRP                  generic prep
3451  5D16 0206 LDSK    LI      R6,>0800                Show Files on DSKx ACOMND 
3451  5D18 0800  
3452  5D1A 1043         JMP     ACLPRP                  generic prep
3453  5D1C 0206 RDSK    LI      R6,>0A00                Remove DOAD from SD card ACOMND 
3453  5D1E 0A00  
3454  5D20 1040         JMP     ACLPRP                  generic prep
3455  5D22 0206 SDSK    LI      R6,>0C00                Show DSKx mapping ACOMND
3455  5D24 0C00  
3456  5D26 103D         JMP     ACLPRP                  generic prep
3457  5D28 0206 SDIR    LI      R6,>0E00                Show SD dir ACOMND
3457  5D2A 0E00  
3458  5D2C 103A         JMP     ACLPRP                  generic prep
3459  5D2E 0206 AHLP    LI      R6,>1000                display APEDSK99 CALL()'s help screen
3459  5D30 1000  
3460  5D32 1037         JMP     ACLPRP                  generic prep
3461  5D34 0206 TIME    LI      R6,>1200                show NTP time and date
3461  5D36 1200  
3462  5D38 1034         JMP     ACLPRP                  generic prep
3463  5D3A 0206 ARST    LI      R6,>1400                reset APEDSK99 ACOMND
3463  5D3C 1400  
3464  5D3E 1031         JMP     ACLPRP                  generic prep
3465  5D40 0206 FGET    LI      R6,>1600                get DOAD from FTP server ACOMND
3465  5D42 1600  
3466  5D44 102E         JMP     ACLPRP                  generic prep
3467  5D46 0206 FPUT    LI      R6,>1800                save DOAD to FTP server ACOMND 
3467  5D48 1800  
3468  5D4A 102B         JMP     ACLPRP                  generic prep
3469  5D4C 0206 ADSR    LI      R6,>1A00                load DSR and reset ACOMND
3469  5D4E 1A00  
3470  5D50 1028         JMP     ACLPRP                  generic prep
3471            *
3472            *-----------------------------------------------------------------
3473            * Subprogram PDSK / UDSK
3474            * ----------------------------------------------------------------
3475            *
3476  5D52 D806 PUDSK2  MOVB    R6,@ACOMND              send U/P DSK command to Arduino
3476  5D54 5FE8  
3477            *
3478  5D56 0208         LI      R8,12                   CALL length
3478  5D58 000C  
3479  5D5A 104E         JMP     ACLBAS                  return to TI-BASIC              
3480            *                       
3481            *---------------------------------------------------------------------------------------
3482            * Subprogram MDSK / RDSK / FGET / FPUT / ADSR
3483            * --------------------------------------------------------------------------------------
3484            *
3485  5D5C 05C8 MDSK2   INCT    R8                      increment pointer
3486  5D5E 06A0         BL      @VDPR2B                 get next two digits
3486  5D60 4950  
3487            *
3488  5D62 0220 RFFA2   AI      R0,>3900                add 2's complement of >C700 =  only keep # of characters
3488  5D64 3900  
3489  5D66 1372         JEQ     ACLERR                  0 characters / empty string -> * INCORRECT COMMAND
3490  5D68 0280         CI      R0,8                    max 8 characters?
3490  5D6A 0008  
3491  5D6C 1B6F         JH      ACLERR                  no -> * INCORRECT COMMAND
3492            *
3493  5D6E C100         MOV     R0,R4                   save # of characters
3494  5D70 0205         LI      R5,CALLBF+2             pointer to DOAD / DSR name      
3494  5D72 5FD8  
3495  5D74 05C8         INCT    R8                      increment pointer
3496  5D76 C088         MOV     R8,R2                   for VDPRD, address must be in R2
3497  5D78 06A0         BL      @VDPRD                  set VDP READ address
3497  5D7A 4416  
3498  5D7C DD6F H9900   MOVB    @-1026(R15),*R5+        get character and save in CALL buffer
3498  5D7E FBFE  
3499  5D80 0600         DEC     R0                      one less to go
3500  5D82 16FC         JNE     H9900   
3501            *
3502  5D84 D02F         MOVB    @-1026(R15),R0          get next token
3502  5D86 FBFE  
3503            *
3504  5D88 0280         CI      R0,>B600                is it a ")" ?
3504  5D8A B600  
3505  5D8C 165F         JNE     ACLERR                  * INCORRECT COMMAND
3506            *
3507  5D8E 0208         LI      R8,13                   prep RDSK/FGET/FPUT/ADSR CALL length ( CALL_XXXX("") )
3507  5D90 000D  
3508  5D92 A204         A       R4,R8                   add # of characters in string
3509                    
3510  5D94 0286         CI      R6,>0600                MDSK()?
3510  5D96 0600  
3511  5D98 1B01         JH      H9901                   no; jump and execute RDSK/FGET/FPUT/ADSR
3512            *
3513  5D9A 05C8         INCT    R8                      adjust MDSK CALL length
3514            *
3515  5D9C D806 H9901   MOVB    R6,@ACOMND              command to Arduino
3515  5D9E 5FE8  
3516            *
3517  5DA0 102B         JMP     ACLBAS                  return to TI-BASIC
3518            *                       
3519            *----------------------------------------------------------------------------
3520            * Generic prep and return to TI BASIC for APEDSK99 CALL's
3521            *----------------------------------------------------------------------------
3522  5DA2 C1CB ACLPRP  MOV     R11,R7                  save return-to-TI BASIC address
3523  5DA4 06A0         BL      @PRPFDO                 prepare TI Controller DSR operations
3523  5DA6 44FE  
3524  5DA8 C229         MOV     @>002C(R9),R8           ptr to next basic token
3524  5DAA 002C  
3525  5DAC 0228         AI      R8,4                    skip length byte and 3 chars of CALL name
3525  5DAE 0004  
3526  5DB0 06A0         BL      @VDPR2B                 get CALL last char and "(" or "0" in R0
3526  5DB2 4950  
3527  5DB4 0A80         SLA     R0,8                    only interested in LSB
3528  5DB6 1379         JEQ     SSAA                    0 = no parameters? SDSK, SDIR, AHLP, ARST, TIME
3529            *
3530  5DB8 0228         AI      R8,2                    adjust token pointer
3530  5DBA 0002  
3531  5DBC 06A0         BL      @VDPR2B                 get next two bytes in R0
3531  5DBE 4950  
3532  5DC0 0280         CI      R0,>C801                >C8=unquoted string, size=1 char?
3532  5DC2 C801  
3533  5DC4 1304         JEQ     ACLPR2                  yes: PDSK, UDSK, MDSK, LDSK
3534            *
3535  5DC6 0280         CI      R0,>C701                >C7=quoted string, minimum 1 character?
3535  5DC8 C701  
3536  5DCA 14CB         JHE     RFFA2                   yes: RDSK, FGET, FPUT, ADSR 
3537            *
3538  5DCC 103F         JMP     ACLERR                  expect the unexpected                           
3539            *
3540  5DCE 05C8 ACLPR2  INCT    R8                      continue for PDSK, UDSK, MDSK, LDSK; increment pointer
3541  5DD0 06A0         BL      @VDPR2B                 get next two bytes              
3541  5DD2 4950  
3542            *
3543  5DD4 06C0         SWPB    R0
3544  5DD6 0220         AI      R0,>49D0                add 2's complement of >B630: MSB = >B3 / "," or >B6 / ")", LSB= # of files 
3544  5DD8 49D0  
3545  5DDA 1502         JGT     H9902                   >B6
3546  5DDC 0220         AI      R0,768                  >B3, adjust R0 to positive range
3546  5DDE 0300  
3547            *
3548  5DE0 1335 H9902   JEQ     ACLERR                  DSK0 not valid, * INCORRECT COMMAND
3549  5DE2 0280         CI      R0,3                    only 3 DSK's allowed
3549  5DE4 0003  
3550  5DE6 1B32         JH      ACLERR                  if >3 * INCORRECT COMMAND
3551            *
3552  5DE8 06C0         SWPB    R0
3553  5DEA D800         MOVB    R0,@CALLBF              save DSKx
3553  5DEC 5FD6  
3554            *
3555  5DEE 0286         CI      R6,>0600                MDSK()?
3555  5DF0 0600  
3556  5DF2 13B4         JEQ     MDSK2                   yep
3557  5DF4 1AAE         JL      PUDSK2                  no; PDSK or UDSK                                                
3558  5DF6 102C         JMP     LDSK2                   must be LDSK
3559            *
3560  5DF8 9820 ACLBAS  CB      @CALLST,@K004           "More" or "AllGood" received from Arduino?      
3560  5DFA 5FD4  
3560  5DFC 442D  
3561  5DFE 141A         JHE     H9904                   yep
3562            *       
3563  5E00 0205         LI      R5,GPLINT               GPL routine
3563  5E02 006A  
3564  5E04 06A0         BL      @GPLXML                 
3564  5E06 5F70  
3565  5E08 56CD         DATA    SCROLL                  scroll screen
3566  5E0A 0202         LI      R2,738                  screen starting position for (error) message
3566  5E0C 02E2  
3567  5E0E 06A0         BL      @VDPWRI                 set VDP address
3567  5E10 440C  
3568  5E12 06A0         BL      @DISSTS                 show error or NTP data
3568  5E14 5EC4  
3569  5E16 0205         LI      R5,GPLINT               GPL routine
3569  5E18 006A  
3570  5E1A 06A0         BL      @GPLXML 
3570  5E1C 5F70  
3571  5E1E 56CD         DATA    SCROLL                  scroll screen
3572            *
3573  5E20 9820         CB      @CALLST,@K007           error?  
3573  5E22 5FD4  
3573  5E24 442B  
3574  5E26 1B06         JH      H9904                   no; we can exit 
3575            *
3576  5E28 0205 H9903   LI      R5,GPLINT               yes: let's make some noise
3576  5E2A 006A  
3577  5E2C 06A0         BL      @GPLXML
3577  5E2E 5F70  
3578  5E30 03D6         DATA    HONK                    GPL routine"bad tone"
3579  5E32 1005         JMP     H9914
3580            *
3581  5E34 0286 H9904   CI      R6,>1200                TIME() ?
3581  5E36 1200  
3582  5E38 1602         JNE     H9914                   no, end the party
3583  5E3A 0460         B       @TIME2                  yes; see if we can assign date/time to NTP$ 
3583  5E3C 5F08  
3584            *
3585  5E3E 04E9 H9914   CLR     @>0050(R9)              clear error flag                
3585  5E40 0050  
3586  5E42 AA48         A       R8, @>002C(R9)          add call length to token pointer                
3586  5E44 002C  
3587  5E46 5A69         SZCB    @>0042(R9),@>0042(R9)   clear current token
3587  5E48 0042  
3587  5E4A 0042  
3588  5E4C 0460 ACLERR  B       @RTURN1                 return to caller (i.e. TI-BASIC)
3588  5E4E 4450  
3589            *
3590            *-----------------------------------------------------------------
3591            * Subprogram SDSK / LDSK / SDIR/ AHLP / TIME
3592            * ----------------------------------------------------------------
3593            *
3594  5E50 D806 LDSK2   MOVB    R6,@ACOMND              SDSK/LDSK/SDIR/AHLP command to Arduino
3594  5E52 5FE8  
3595  5E54 9820         CB      @K002,@CALLST
3595  5E56 4428  
3595  5E58 5FD4  
3596  5E5A 132C         JEQ     QTLSSA                  LDSK: >00; no DOAD mapped
3597            *
3598  5E5C 04C2 LDNXTS  CLR     R2                      clear screen; position 0
3599  5E5E 06A0         BL      @VDPWRI
3599  5E60 440C  
3600            *
3601  5E62 0200         LI      R0,>8000                space + TI BASIC bias
3601  5E64 8000  
3602  5E66 06A0         BL      @VDPRPW
3602  5E68 4326  
3603  5E6A 02C0         DATA    704                     704 positions to clear
3604            *
3605  5E6C 0202         LI      R2,33                   start 2nd screen line; 1st is lost due to TI BASIC scroll
3605  5E6E 0021  
3606  5E70 06A0         BL      @VDPWRI                 
3606  5E72 440C  
3607            *       
3608  5E74 9820 H9905   CB      @K004,@CALLST           check Arduino LDSK/SDSK/SDIR/AHLP/TIME return code
3608  5E76 442D  
3608  5E78 5FD4  
3609  5E7A 131C         JEQ     QTLSSA                  "More" (>F0); blank "floppy" or done last file / help txt
3610            *
3611  5E7C 06A0         BL      @DISSTS                 LDSK/SDSK/SDIR/AHLP/TIME output to screen
3611  5E7E 5EC4  
3612            *
3613  5E80 0222         AI      R2,16                   next screen position
3613  5E82 0010  
3614  5E84 0282         CI      R2,641                  end of display area?
3614  5E86 0281  
3615  5E88 1303         JEQ     NXTPRP                  yes; show "more" symbol
3616            *
3617  5E8A C802         MOV     R2,@RDINT               generates interrupt for next file
3617  5E8C 5FEA  
3618  5E8E 10F2         JMP     H9905   
3619            *       
3620  5E90 0202 NXTPRP  LI      R2,703
3620  5E92 02BF  
3621  5E94 06A0         BL      @VDPWRI
3621  5E96 440C  
3622  5E98 0205         LI      R5,>9E00                ">", more files to display
3622  5E9A 9E00  
3623  5E9C DBC5         MOVB    R5,@-2(R15)
3623  5E9E FFFE  
3624            *
3625  5EA0 06A0         BL      @CHKKEY
3625  5EA2 5ED6  
3626            *
3627  5EA4 C802         MOV     R2,@RDINT               generates interrupt for next file
3627  5EA6 5FEA  
3628  5EA8 10D9         JMP     LDNXTS
3629            *
3630            *-----------------------------------------------------------------------------------------
3631            * Subprogram ARST / TIME
3632            * ----------------------------------------------------------------------------------------
3633            *
3634  5EAA 0286 SSAA    CI      R6,>1200                TIME() ?        
3634  5EAC 1200  
3635  5EAE 1AD0         JL      LDSK2                   no; SDSK/SDIR/AHLP use LDSK display routine
3636            *
3637  5EB0 D806 ARST2   MOVB    R6,@ACOMND              execute ARST() or TIME()
3637  5EB2 5FE8  
3638            *
3639  5EB4 0208 QTLSSA  LI      R8,9                    current CALL length
3639  5EB6 0009  
3640  5EB8 0286         CI      R6,>0800                LDSK()?
3640  5EBA 0800  
3641  5EBC 1B02         JH      H9906                   nope; exit with CALL lenght 9 for SDSK/SDIR/AHLP
3642  5EBE 0228         AI      R8,3                    yep;  exit with CALL length 12 for LDSK
3642  5EC0 0003  
3643            *
3644  5EC2 109A H9906   JMP     ACLBAS  
3645            *
3646            * Display data, status messages and errors
3647            *
3648  5EC4 0205 DISSTS  LI      R5,CALLBF+2             start of file name buffer
3648  5EC6 5FD8  
3649  5EC8 0206         LI      R6,16                   16 bytes of (error) data to display
3649  5ECA 0010  
3650  5ECC DBF5 H9907   MOVB    *R5+,@-2(R15)           store character in VDP screen memory
3650  5ECE FFFE  
3651  5ED0 0606         DEC     R6
3652  5ED2 16FC         JNE     H9907
3653  5ED4 045B         B       *R11
3654            *
3655            * Quick key test to display next screen after ">"
3656            * Keyboard column 0 (= space enter <nc> fctn shift ctrl <nc>)
3657            * Code copy from Thierry's TI's Tech Pages site
3658            *
3659  5ED6 C10C CHKKEY  MOV     R12,R4                  save R12
3660  5ED8 04C1         CLR     R1                      test column 0
3661  5EDA 020C         LI      R12,>0024               address for column selection
3661  5EDC 0024  
3662  5EDE 30C1 H9908   LDCR    R1,3                    select column
3663  5EE0 1FF2         TB      -14                     test R12 address >0008
3664  5EE2 1607         JNE     H9909                   <SPACE>
3665  5EE4 1FF3         TB      -13                     test R12 address >000A
3666  5EE6 13FB         JEQ     H9908                   no key; test again
3667            *
3668  5EE8 D820         MOVB    @K004,@CALLST           signal ENTER to SDIR() command
3668  5EEA 442D  
3668  5EEC 5FD4  
3669  5EEE 020B         LI      R11,QTLSSA              leave without clearing screen
3669  5EF0 5EB4  
3670            *
3671  5EF2 C304 H9909   MOV     R4,R12                  restore R12
3672  5EF4 0A24         SLA     R4,2                    debounce delay
3673  5EF6 0604 H9910   DEC     R4                      key debounce
3674  5EF8 16FE         JNE     H9910                   debounce some more
3675            *
3676  5EFA 045B         B       *R11                    we got one; return for next screen
3677            *               
3678            * update FAT time/date for current DOAD after DSR Format / Write / Save
3679            *
3680  5EFC D820 NTPDT   MOVB    @NTPFAT+1,@ACOMND       "DSK NTP date/time update" command to Arduino           
3680  5EFE 4027  
3680  5F00 5FE8  
3681  5F02 045B         B       *R11                    return to Format / Close
3682            *       
3683            * prep for calling XML >16 and update BASIC variable NTP$               
3684            *
3685  5F04 4E54 VARINF  TEXT    'NTP$'
3685  5F06 5024  
3686  5F08 0204 TIME2   LI      R4,VARINF               variable name for XML >16 in FAC
3686  5F0A 5F04  
3687  5F0C C149         MOV     R9,R5                   get scratchpad start address
3688  5F0E D974 H9911   MOVB    *R4+,@>004A(R5)         variable name in FAC
3688  5F10 004A  
3689  5F12 0585         INC     R5
3690  5F14 0284         CI      R4,VARINF+4             done all chars?
3690  5F16 5F08  
3691  5F18 16FA         JNE     H9911                   
3692            *
3693  5F1A 0205         LI      R5,>0400                variable length for XML >16 in @>8359
3693  5F1C 0400  
3694  5F1E DA45         MOVB    R5,@>0059(R9)           
3694  5F20 0059  
3695  5F22 04E9         CLR     @>0089(R9)      
3695  5F24 0089  
3696            *
3697  5F26 0205         LI      R5,XML16                ROM routine: find NTP$ in VDP symbol table (returns to GPL interpreter)
3697  5F28 15D6  
3698  5F2A 06A0         BL      @GPLXML
3698  5F2C 5F70  
3699  5F2E 2244         DATA    XMLRTN                  GPL "RTN", escaping GPL interpreter
3700            *
3701  5F30 9A60         CB      @VARINF,@>004A(R9)      found NTP$ in VDP symbol table?
3701  5F32 5F04  
3701  5F34 004A  
3702  5F36 1318         JEQ     H9913                   no symbol table pointer; back to BASIC
3703            *
3704  5F38 06A0         BL      @XML14                  ROM routine: get NTP$ VDP address and string length (returns through RT)
3704  5F3A 164E  
3705  5F3C 02A9         STWP    R9                      restore scratchpad pointer
3706  5F3E 0229         AI      R9,-224
3706  5F40 FF20  
3707            *       
3708  5F42 C169         MOV     @>0050(R9),R5           get string length
3708  5F44 0050  
3709  5F46 0285         CI      R5,16                   16 chars?
3709  5F48 0010  
3710  5F4A 160E         JNE     H9913                   no NTP$ assignment for you
3711            *
3712  5F4C C0A0         MOV     @>834E,R2               yes
3712  5F4E 834E  
3713  5F50 06A0         BL      @VDPWRI                 set VDP write address
3713  5F52 440C  
3714  5F54 0205         LI      R5,CALLBF+2             CALL TIME data still in buffer
3714  5F56 5FD8  
3715  5F58 D0B5 H9912   MOVB    *R5+,R2                 read character
3716  5F5A 0222         AI      R2,>A000                remove TI BASIC bias
3716  5F5C A000  
3717  5F5E DBC2         MOVB    R2,@-2(R15)             save to NTP$ value space
3717  5F60 FFFE  
3718  5F62 0285         CI      R5,CALLBF+18            done all 16 chars?
3718  5F64 5FE8  
3719  5F66 16F8         JNE     H9912                   no; one more
3720            *
3721  5F68 0460 H9913   B       @H9914                  yes; back to BASIC
3721  5F6A 5E3E  
3722            *
3723            * execute GROM or XML routine (SCROLL, "bad sound"/ HONK and XML >16)
3724            * DSR and GPL interpreter use same workspace (>83E0) so we need to save a few things
3725            *
3726  5F6C 0000 SAVGRA  BSS     2                       save current GROM address so we can return to BASIC
3727  5F6E 0000 SAVR11  BSS     2                       GPL interpreter uses R11
3728            *
3729  5F70 D820 GPLXML  MOVB    @>9802,@SAVGRA          save current GROM address
3729  5F72 9802  
3729  5F74 5F6C  
3730  5F76 1000         NOP
3731  5F78 D820         MOVB    @>9802,@SAVGRA+1
3731  5F7A 9802  
3731  5F7C 5F6D  
3732  5F7E 0620         DEC     @SAVGRA                 GRMWA returns address + 1; decrease for correct address
3732  5F80 5F6C  
3733            *
3734  5F82 D83B         MOVB    *R11+,@>9C02            set GPL routine address
3734  5F84 9C02  
3735  5F86 1000         NOP
3736  5F88 D83B         MOVB    *R11+,@>9C02
3736  5F8A 9C02  
3737  5F8C C80B         MOV     R11,@SAVR11             save final DSR return address
3737  5F8E 5F6E  
3738            *
3739  5F90 020B         LI      R11,GXRTN               DSR return address after GPL routine
3739  5F92 5FAC  
3740  5F94 C80B         MOV     R11,@RTN5C              @>4028 is where XML >5C returns to
3740  5F96 4028  
3741            *
3742  5F98 05E0         INCT    @>8373                  increase stack pointer
3742  5F9A 8373  
3743  5F9C 06C9         SWPB    R9                      
3744  5F9E D260         MOVB    @>8373,R9
3744  5FA0 8373  
3745  5FA2 06C9         SWPB    R9                      complete stack pointer in R9
3746  5FA4 020B         LI      R11,XML5C               GROM pointer to >0F5C (= XML >5C)
3746  5FA6 105C  
3747  5FA8 C64B         MOV     R11,*R9                 save GROM pointer on stack
3748            *
3749  5FAA 0455         B       *R5                     execute GROM/ROM routine, return through GPL interpreter
3750            *
3751  5FAC D820 GXRTN   MOVB    @SAVGRA,@>9C02          and ... we're back; restore saved GROM address
3751  5FAE 5F6C  
3751  5FB0 9C02  
3752  5FB2 1000         NOP
3753  5FB4 D820         MOVB    @SAVGRA+1,@>9C02
3753  5FB6 5F6D  
3753  5FB8 9C02  
3754            *
3755  5FBA 02A9         STWP    R9                      restore scratchpad pointer
3756  5FBC 0229         AI      R9,-224
3756  5FBE FF20  
3757            *
3758  5FC0 C2E0         MOV     @SAVR11,R11             restore R11
3758  5FC2 5F6E  
3759  5FC4 045B         B       *R11                    return to instruction after BL @GPLEXEC DATA statement
3760            *
3761            *-----------------------------------------
3762            * >5FC6 - >5FD3: 14 free bytes remaining
3763            * >5FD4 is the CALL() status byte
3764            * >5FD6 - >5FE7 is buffer storage for APEDSK99 CALL's
3765            * >5FE8 is the Arduino Command Register (TI BASIC CALL support)
3766            * Word >5FEA maps to the read counter (R6, to generate interrupts when reading data) 
3767            * Bytes >5FEC to >5FEE map to the CRU emulation registers
3768            * Bytes >5FF0 to >5FFE map to the FDC emulation registers
3769            *-----------------------------------------                                      
3770            *
3771  5FC6 0000         END
3771            


 Assembly Complete - Errors: 0,  Warnings: 0


 ------ Symbol Listing ------

 ACLBAS ABS:5DF8 ACLBAS
 ACLERR ABS:5E4C ACLERR
 ACLPR2 ABS:5DCE ACLPR2
 ACLPRP ABS:5DA2 ACLPRP
 ACOMND ABS:5FE8 ACOMND
 ADDSEC ABS:47DE ADDSEC
 ADSR   ABS:5D4C ADSR
 AFDRPT ABS:53A2 AFDRPT
 AFPGPF ABS:52B8 AFPGPF
 AHLP   ABS:5D2E AHLP
 APSCTS ABS:473A APSCTS
 ARST   ABS:5D3A ARST
 ARST2  ABS:5EB0 ARST2
 CALLBF ABS:5FD6 CALLBF
 CALLST ABS:5FD4 CALLST
 CALSUB ABS:4432 CALSUB
 CFNFDR ABS:5C64 CFNFDR
 CFSVIB ABS:5840 CFSVIB
 CHKKEY ABS:5ED6 CHKKEY
 CLOSE  ABS:50AA CLOSE
 CLRFBT ABS:465C CLRFBT
 CLSDIR ABS:56EA CLSDIR
 CMPFN  ABS:4916 CMPFN
 CPCKFN ABS:49EE CPCKFN
 CRFIL1 ABS:456A CRFIL1
 CRFIL2 ABS:4570 CRFIL2
 CRFIL3 ABS:457C CRFIL3
 CRURD  ABS:5FEC CRURD
 CRUWRI ABS:5FEE CRUWRI
 DECDCI ABS:4C90 DECDCI
 DELETE ABS:4848 DELETE
 DISSTS ABS:5EC4 DISSTS
 DSDRVS ABS:4431 DSDRVS
 DSR01  ABS:40CE DSR01
 DSR02  ABS:40D6 DSR02
 DSR03  ABS:40E0 DSR03
 DSR04  ABS:40EA DSR04
 ECUSTM ABS:446A ECUSTM
 EDSR01 ABS:4E26 EDSR01
 EDSR02 ABS:4E34 EDSR02
 EDSR03 ABS:4E3A EDSR03
 EDSR04 ABS:4E40 EDSR04
 EPWRUP ABS:40F4 EPWRUP
 ERROR1 ABS:43CA ERROR1
 ERROR3 ABS:4244 ERROR3
 ERROR4 ABS:433A ERROR4
 ERROR5 ABS:4A4C ERROR5
 ERROR6 ABS:4C02 ERROR6
 ERROR7 ABS:49F2 ERROR7
 ERROR8 ABS:4E92 ERROR8
 ERROR9 ABS:4EAE ERROR9
 ERRR10 ABS:56C6 ERRR10
 ESUB01 ABS:5910 ESUB01
 ESUB02 ABS:5920 ESUB02
 ESUB03 ABS:592A ESUB03
 ESUB04 ABS:5984 ESUB04
 ESUB05 ABS:5A50 ESUB05
 ESUB06 ABS:5AC0 ESUB06
 ESUB07 ABS:5B86 ESUB07
 ESUB08 ABS:5B32 ESUB08
 FDR2B1 ABS:494A FDR2B1
 FDR2B2 ABS:494E FDR2B2
 FDSKDR ABS:4964 FDSKDR
 FFDRDK ABS:4BE6 FFDRDK
 FFDRFN ABS:4C12 FFDRFN
 FFDROD ABS:4BE2 FFDROD
 FFDRVB ABS:4B9E FFDRVB
 FFDRVP ABS:52A8 FFDRVP
 FFFDR  ABS:5CAC FFFDR
 FFFDRV ABS:4B7E FFFDRV
 FFSBM  ABS:4D96 FFSBM
 FFSBMP ABS:4CD0 FFSBMP
 FFSVIB ABS:46B4 FFSVIB
 FGET   ABS:5D40 FGET
 FMTDSK ABS:424A FMTDSK
 FMTTRK ABS:42D4 FMTTRK
 FNDFDR ABS:4BDC FNDFDR
 FNDRV  ABS:587A FNDRV
 FPUT   ABS:5D46 FPUT
 FRSCB1 ABS:4D9C FRSCB1
 FSCTOF ABS:4824 FSCTOF
 GPLINT ABS:006A GPLINT
 GPLXML ABS:5F70 GPLXML
 GXRTN  ABS:5FAC GXRTN
 H001   ABS:411A H001
 H002   ABS:4184 H002
 H003   ABS:41E2 H003
 H004   ABS:41B0 H004
 H005   ABS:41C0 H005
 H006   ABS:41BA H006
 H013   ABS:41E8 H013
 H014   ABS:4218 H014
 H015   ABS:41F6 H015
 H016   ABS:4204 H016
 H019   ABS:4212 H019
 H024   ABS:422E H024
 H027   ABS:424E H027
 H028   ABS:4260 H028
 H029   ABS:4286 H029
 H030   ABS:4270 H030
 H031   ABS:42B2 H031
 H036   ABS:42BC H036
 H038   ABS:42E4 H038
 H040   ABS:42F2 H040
 H041   ABS:430C H041
 H043   ABS:4324 H043
 H044   ABS:4328 H044
 H055   ABS:435C H055
 H056   ABS:437E H056
 H057   ABS:4374 H057
 H058   ABS:437C H058
 H061   ABS:43B8 H061
 H064   ABS:43DC H064
 H066   ABS:43E2 H066
 H068   ABS:4406 H068
 H069   ABS:441A H069
 H070   ABS:44B2 H070
 H071   ABS:44E0 H071
 H072   ABS:448E H072
 H073   ABS:44DC H073
 H074   ABS:44B8 H074
 H075   ABS:44F4 H075
 H076   ABS:451E H076
 H077   ABS:4606 H077
 H078   ABS:4592 H078
 H079   ABS:45EA H079
 H080   ABS:461C H080
 H081   ABS:4646 H081
 H082   ABS:4626 H082
 H083   ABS:4638 H083
 H084   ABS:464C H084
 H085   ABS:4684 H085
 H086   ABS:46B0 H086
 H087   ABS:46D2 H087
 H088   ABS:4700 H088
 H089   ABS:46DC H089
 H090   ABS:4714 H090
 H091   ABS:471E H091
 H092   ABS:47D2 H092
 H093   ABS:474A H093
 H094   ABS:4770 H094
 H095   ABS:475E H095
 H096   ABS:47A6 H096
 H097   ABS:47B4 H097
 H098   ABS:47B2 H098
 H099   ABS:47AA H099
 H100   ABS:47C2 H100
 H101   ABS:47DA H101
 H102   ABS:4822 H102
 H103   ABS:4838 H103
 H104   ABS:4844 H104
 H105   ABS:482E H105
 H106   ABS:4860 H106
 H107   ABS:4882 H107
 H108   ABS:4876 H108
 H109   ABS:48C6 H109
 H110   ABS:48F6 H110
 H111   ABS:491E H111
 H112   ABS:4942 H112
 H113   ABS:497C H113
 H114   ABS:4986 H114
 H115   ABS:49E4 H115
 H116   ABS:498E H116
 H118   ABS:49DC H118
 H119   ABS:49F8 H119
 H120   ABS:4A06 H120
 H121   ABS:4A42 H121
 H122   ABS:4A12 H122
 H123   ABS:4A76 H123
 H124   ABS:4A98 H124
 H125   ABS:4A9C H125
 H126   ABS:4B02 H126
 H127   ABS:4AD4 H127
 H128   ABS:4AE8 H128
 H129   ABS:4AF8 H129
 H130   ABS:4B76 H130
 H131   ABS:4B58 H131
 H132   ABS:4B6E H132
 H133   ABS:4B68 H133
 H134   ABS:4BB8 H134
 H135   ABS:4BD8 H135
 H136   ABS:4B9A H136
 H137   ABS:4C08 H137
 H138   ABS:4BEE H138
 H139   ABS:4C1E H139
 H140   ABS:4C84 H140
 H141   ABS:4C80 H141
 H142   ABS:4C8A H142
 H143   ABS:4CE4 H143
 H144   ABS:4CF6 H144
 H145   ABS:4D06 H145
 H146   ABS:4D12 H146
 H147   ABS:4D42 H147
 H148   ABS:4D38 H148
 H149   ABS:4D8C H149
 H150   ABS:4D4A H150
 H151   ABS:4D70 H151
 H152   ABS:4DC8 H152
 H153   ABS:4DDC H153
 H154   ABS:4DD6 H154
 H155   ABS:4DD8 H155
 H156   ABS:4DDE H156
 H157   ABS:4E06 H157
 H158   ABS:4E0E H158
 H159   ABS:4E4A H159
 H160   ABS:4E44 H160
 H161   ABS:4E70 H161
 H162   ABS:4EB4 H162
 H163   ABS:4ECA H163
 H164   ABS:4F7E H164
 H165   ABS:4ED6 H165
 H166   ABS:4F08 H166
 H167   ABS:4F20 H167
 H168   ABS:4F24 H168
 H169   ABS:4F7A H169
 H170   ABS:4FA6 H170
 H171   ABS:4FA2 H171
 H172   ABS:4FCA H172
 H173   ABS:4FF8 H173
 H174   ABS:5050 H174
 H175   ABS:5076 H175
 H176   ABS:507A H176
 H177   ABS:50C4 H177
 H178   ABS:50DE H178
 H179   ABS:50C0 H179
 H180   ABS:50D6 H180
 H181   ABS:50D0 H181
 H182   ABS:5100 H182
 H183   ABS:5136 H183
 H184   ABS:511A H184
 H185   ABS:5144 H185
 H186   ABS:5168 H186
 H187   ABS:5170 H187
 H188   ABS:5194 H188
 H189   ABS:51DA H189
 H190   ABS:51D2 H190
 H191   ABS:5280 H191
 H192   ABS:51E4 H192
 H193   ABS:51FA H193
 H194   ABS:5210 H194
 H195   ABS:52F4 H195
 H196   ABS:5314 H196
 H197   ABS:531A H197
 H198   ABS:5376 H198
 H199   ABS:5386 H199
 H200   ABS:546E H200
 H201   ABS:54A2 H201
 H202   ABS:54B0 H202
 H203   ABS:54B6 H203
 H204   ABS:54F4 H204
 H205   ABS:5516 H205
 H206   ABS:54F8 H206
 H207   ABS:5522 H207
 H208   ABS:5544 H208
 H209   ABS:5554 H209
 H210   ABS:55CA H210
 H211   ABS:55F6 H211
 H212   ABS:5676 H212
 H213   ABS:5662 H213
 H214   ABS:5604 H214
 H215   ABS:5610 H215
 H216   ABS:5632 H216
 H217   ABS:561C H217
 H218   ABS:565E H218
 H219   ABS:5644 H219
 H220   ABS:5672 H220
 H221   ABS:56A0 H221
 H222   ABS:56B0 H222
 H223   ABS:569A H223
 H224   ABS:56CC H224
 H225   ABS:56D6 H225
 H226   ABS:5730 H226
 H227   ABS:57AC H227
 H228   ABS:57A2 H228
 H229   ABS:5792 H229
 H230   ABS:579C H230
 H231   ABS:57AA H231
 H232   ABS:57CA H232
 H233   ABS:5804 H233
 H234   ABS:57DA H234
 H235   ABS:57FC H235
 H236   ABS:5850 H236
 H237   ABS:5874 H237
 H238   ABS:5866 H238
 H239   ABS:586A H239
 H240   ABS:5870 H240
 H241   ABS:589C H241
 H242   ABS:58B6 H242
 H243   ABS:58AC H243
 H244   ABS:58E0 H244
 H245   ABS:58EA H245
 H246   ABS:58E8 H246
 H247   ABS:58F0 H247
 H248   ABS:58F2 H248
 H249   ABS:5906 H249
 H250   ABS:59B4 H250
 H251   ABS:5A46 H251
 H252   ABS:5A4C H252
 H253   ABS:5A9E H253
 H254   ABS:5A6A H254
 H255   ABS:5A98 H255
 H256   ABS:5A70 H256
 H257   ABS:5A76 H257
 H258   ABS:5A92 H258
 H259   ABS:5AB2 H259
 H260   ABS:5AF4 H260
 H261   ABS:5AD6 H261
 H262   ABS:5B2E H262
 H263   ABS:5B82 H263
 H264   ABS:5C46 H264
 H265   ABS:5C40 H265
 H266   ABS:5C08 H266
 H267   ABS:5BD4 H267
 H268   ABS:5BFE H268
 H269   ABS:5C3C H269
 H270   ABS:5C20 H270
 H272   ABS:5C4A H272
 H273   ABS:5C68 H273
 H274   ABS:5CC8 H274
 H275   ABS:5CE6 H275
 H276   ABS:5CFA H276
 H9900  ABS:5D7C H9900
 H9901  ABS:5D9C H9901
 H9902  ABS:5DE0 H9902
 H9903  ABS:5E28 H9903
 H9904  ABS:5E34 H9904
 H9905  ABS:5E74 H9905
 H9906  ABS:5EC2 H9906
 H9907  ABS:5ECC H9907
 H9908  ABS:5EDE H9908
 H9909  ABS:5EF2 H9909
 H9910  ABS:5EF6 H9910
 H9911  ABS:5F0E H9911
 H9912  ABS:5F58 H9912
 H9913  ABS:5F68 H9913
 H9914  ABS:5E3E H9914
 HONK   ABS:03D6 HONK
 INSFDR ABS:48E4 INSFDR
 INT2FP ABS:58BE INT2FP
 K001   ABS:4162 K001
 K002   ABS:4428 K002
 K003   ABS:442A K003
 K004   ABS:442D K004
 K005   ABS:4430 K005
 K006   ABS:4429 K006
 K007   ABS:442B K007
 K012   ABS:442E K012
 K013   ABS:43DA K013
 K014   ABS:4A4A K014
 LASTRK ABS:43E8 LASTRK
 LDNXTS ABS:5E5C LDNXTS
 LDSK   ABS:5D16 LDSK
 LDSK2  ABS:5E50 LDSK2
 LOAD   ABS:54A6 LOAD
 MDSK   ABS:5D10 MDSK
 MDSK2  ABS:5D5C MDSK2
 NOCRU  ABS:4160 NOCRU
 NTPDT  ABS:5EFC NTPDT
 NTPFAT ABS:4026 NTPFAT
 NXTPRP ABS:5E90 NXTPRP
 OPCVEC ABS:4E78 OPCVEC
 OPEN   ABS:4E98 OPEN
 OPNDIR ABS:568C OPNDIR
 PABR2B ABS:4944 PABR2B
 PDSK   ABS:5D04 PDSK
 PESB07 ABS:5B8C PESB07
 PRFDRS ABS:5058 PRFDRS
 PRPFDO ABS:44FE PRPFDO
 PRPRTN ABS:4500 PRPRTN
 PUDSK2 ABS:5D52 PUDSK2
 PWRUP  ABS:40C8 PWRUP
 QTLSSA ABS:5EB4 QTLSSA
 R0     ABS:0000 R0
 R1     ABS:0001 R1
 R10    ABS:000A R10
 R11    ABS:000B R11
 R12    ABS:000C R12
 R13    ABS:000D R13
 R14    ABS:000E R14
 R15    ABS:000F R15
 R2     ABS:0002 R2
 R3     ABS:0003 R3
 R4     ABS:0004 R4
 R5     ABS:0005 R5
 R6     ABS:0006 R6
 R7     ABS:0007 R7
 R8     ABS:0008 R8
 R9     ABS:0009 R9
 RBANB  ABS:5598 RBANB
 RCOFCB ABS:5428 RCOFCB
 RDATA  ABS:5FF6 RDATA
 RDDIR  ABS:5700 RDDIR
 RDFDR1 ABS:4B24 RDFDR1
 RDFDR2 ABS:4B20 RDFDR2
 RDINT  ABS:5FEA RDINT
 RDOFSC ABS:4704 RDOFSC
 RDSEC1 ABS:4B0E RDSEC1
 RDSK   ABS:5D1C RDSK
 READ   ABS:50B4 READ
 RETERR ABS:4A78 RETERR
 RFDRST ABS:52D4 RFDRST
 RFDRVB ABS:5A2C RFDRVB
 RFFA2  ABS:5D62 RFFA2
 RFNPTR ABS:5C86 RFNPTR
 RMFPTR ABS:48B4 RMFPTR
 RNFISE ABS:5332 RNFISE
 RRFDR  ABS:534E RRFDR
 RRNPAB ABS:52E8 RRNPAB
 RRSEC  ABS:513A RRSEC
 RSECTR ABS:5FF4 RSECTR
 RSTAT  ABS:5FF0 RSTAT
 RSTDRV ABS:439C RSTDRV
 RTN5C  ABS:4028 RTN5C
 RTRACK ABS:5FF2 RTRACK
 RTURN1 ABS:4450 RTURN1
 RVRVDP ABS:44B6 RVRVDP
 RWIND1 ABS:5452 RWIND1
 RWIND2 ABS:5480 RWIND2
 RWSEC  ABS:4B28 RWSEC
 RWSECA ABS:4B2A RWSECA
 RWSECB ABS:4B2C RWSECB
 RWVIB  ABS:4AAC RWVIB
 SAVE   ABS:5548 SAVE
 SAVGRA ABS:5F6C SAVGRA
 SAVR11 ABS:5F6E SAVR11
 SCROLL ABS:56CD SCROLL
 SDIR   ABS:5D28 SDIR
 SDSK   ABS:5D22 SDSK
 SECRW1 ABS:4164 SECRW1
 SELDRV ABS:4340 SELDRV
 SKTRK0 ABS:4384 SKTRK0
 SNDCMD ABS:43E0 SNDCMD
 SP2VDP ABS:5CF0 SP2VDP
 SSAA   ABS:5EAA SSAA
 STATUS ABS:55CC STATUS
 SUB01  ABS:4010 SUB01
 SUB02  ABS:4016 SUB02
 SUB03  ABS:401C SUB03
 SUB04  ABS:4022 SUB04
 SUB05  ABS:402A SUB05
 SUB06  ABS:4030 SUB06
 SUB07  ABS:4036 SUB07
 SUB08  ABS:403C SUB08
 SUB09  ABS:4046 SUB09
 SUB10  ABS:4050 SUB10
 SUB11  ABS:405A SUB11
 SUB12  ABS:4064 SUB12
 SUB13  ABS:406E SUB13
 SUB14  ABS:4078 SUB14
 SUB15  ABS:4082 SUB15
 SUB16  ABS:408C SUB16
 SUB17  ABS:4096 SUB17
 SUB18  ABS:40A0 SUB18
 SUB19  ABS:40AA SUB19
 SUB20  ABS:40B4 SUB20
 SUB21  ABS:40BE SUB21
 SVDPRD ABS:44EC SVDPRD
 SVDPWR ABS:44E2 SVDPWR
 SVRVDP ABS:448A SVRVDP
 TIME   ABS:5D34 TIME
 TIME2  ABS:5F08 TIME2
 UCOFCB ABS:53C6 UCOFCB
 UDSK   ABS:5D0A UDSK
 UFNCB  ABS:5C4E UFNCB
 UPDBF  ABS:4670 UPDBF
 UPDCLI ABS:4CAC UPDCLI
 UPDFCB ABS:5082 UPDFCB
 UPDFDR ABS:4650 UPDFDR
 URFFDR ABS:53F2 URFFDR
 UWFLVB ABS:5964 UWFLVB
 VARINF ABS:5F04 VARINF
 VDP2SP ABS:5CE0 VDP2SP
 VDPR2B ABS:4950 VDPR2B
 VDPRD  ABS:4416 VDPRD
 VDPRPW ABS:4326 VDPRPW
 VDPWRI ABS:440C VDPWRI
 VECRTN ABS:4482 VECRTN
 WCOMND ABS:5FF8 WCOMND
 WDATA  ABS:5FFE WDATA
 WFDRPB ABS:5116 WFDRPB
 WRFDR  ABS:4B1A WRFDR
 WRITE  ABS:519E WRITE
 WROFSC ABS:4724 WROFSC
 WRSEC1 ABS:4B10 WRSEC1
 WSECTR ABS:5FFC WSECTR
 WTCPT1 ABS:4332 WTCPT1
 WTRACK ABS:5FFA WTRACK
 XML14  ABS:164E XML14
 XML16  ABS:15D6 XML16
 XML5C  ABS:105C XML5C
 XMLRTN ABS:2244 XMLRTN
