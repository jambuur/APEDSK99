Asm994a TMS99000 Assembler - v3.010

                * Asm994a Generated Register Equates
                *
      0000 0000 R0      EQU     0 
      0000 0001 R1      EQU     1 
      0000 0002 R2      EQU     2 
      0000 0003 R3      EQU     3 
      0000 0004 R4      EQU     4 
      0000 0005 R5      EQU     5 
      0000 0006 R6      EQU     6 
      0000 0007 R7      EQU     7 
      0000 0008 R8      EQU     8 
      0000 0009 R9      EQU     9 
      0000 000A R10     EQU     10
      0000 000B R11     EQU     11
      0000 000C R12     EQU     12
      0000 000D R13     EQU     13
      0000 000E R14     EQU     14
      0000 000F R15     EQU     15
                *
   1            *===============================================================================================================
   2            * TI DISK CONTROLLER ROM   >4000-5FFF
   3            * 
   4            * initial commented disassembly by Thierry Nouspikel
   5            * (see http://www.unige.ch/medecine/nouspikel/ti99/titechpages.htm)
   6            *
   7            * and
   8            * 
   9            * Monty Schmidt's book: TI Technical Drive
  10            *
  11            * adapted for APEDSK99 by Jochen Buur
  12            * github.com/jambuur/APEDSK99
  13            *
  14            * v12r: support for Double Density / 80 tracks (max 1440 AU's)
  15            *================================================================================================================
  16  0000 5FB4 DSKPRM  EQU     >5FB4                   per DSKx: Mbyte #sectors, Lbyte #sectors, #sectors/track, #tracks, #sides
  17  0000 5FC6 CALLST  EQU     >5FC6                   CALL() execution status: finished, still active, error
  18  0000 5FC8 CALLBF  EQU     >5FC8                   2-way buffer for TI BASIC CALL's (1 screen line, 32 characters)
  19  0000 5FE8 ACOMND  EQU     >5FE8                   APEDSK99-specific Command register
  20  0000 5FEA RDINT   EQU     >5FEA                   issue read interrupt (R6 counter) 
  21  0000 5FEE CRUWRI  EQU     >5FEE                   emulated 8 CRU output bits
  22  0000 5FF0 RSTAT   EQU     >5FF0                   read FD1771 Status register
  23  0000 5FF6 RDATA   EQU     >5FF6                   read FD1771 Data register
  24  0000 5FF8 WCOMND  EQU     >5FF8                   write FD1771 Command register
  25  0000 5FFC WSECTR  EQU     >5FFC                   write FD1771 Sector register
  26  0000 5FFE WDATA   EQU     >5FFE                   write FD1771 Data register
  27            *
  28  0000 164E XML14   EQU     >164E                   ROM address for XML >14
  29  0000 15D6 XML16   EQU     >15D6                   ROM address for XML >16
  30            *
  31            *!!! CHECK GROM ADDRESS CONTENTS, NEEDS TO BE >0F5C; UNCOMMENT RELEVANT LINE (different GROM 0 versions)
  32            *
  33            *XML5C  EQU     >1039                   GROM address for XML >5C; GROM v2.2 consoles
  34            *XML5C  EQU     >1058                   GROM address for XML >5C; GROM - Heiner Martin version
  35  0000 105C XML5C   EQU     >105C                   GROM address for XML >5C; GROM - different pointers to character blocks
  36            *
  37  0000 006A GPLINT  EQU     >006A                   jump to GROM interpreter for SCROLL / HONK
  38  0000 2244 XMLRTN  EQU     >2244                   jump to GROM interpreter for RTN (after executing XML >14 / >16 routine)
  39  0000 56CD SCROLL  EQU     >56CD                   GROM address for scroll routine
  40            *
  41            *!!! CHECK GROM ADDRESS CONTENTS, NEEDS TO BE >BF58; UNCOMMENT RELEVANT LINE (different GROM 0 versions)
  42            *
  43            *HONK   EQU     >03AF                   GROM address for "bad tone"; GROM v2.2 consoles
  44            *HONK   EQU     >03D3                   GROM address for "bad tone"; GROM - Heiner Martin version
  45  0000 03D6 HONK    EQU     >03D6                   GROM address for "bad tone"; GROM - different pointers to character blocks
  46            *
  47                    AORG    >4000
  48            *
  49  4000 AA           BYTE    >AA                     standard header mark
  50  4001 02           BYTE    >02                     version 2
  51  4002 0000         DATA    >0000                   no programs
  52  4004 40DC         DATA    PWRUP                   power-up chain ptr
  53  4006 0000         DATA    >0000                   programs chain ptr (none)
  54  4008 40E2         DATA    DSR01                   DSR chain ptr
  55  400A 4010         DATA    SUB01                   subprograms chain ptr
  56  400C 0000         DATA    >0000                   ISR chain ptr (none)
  57  400E 0000         DATA    >0000                   
  58            *                                       
  59  4010 4016 SUB01   DATA    SUB02                   link to next subprogram
  60  4012 5800         DATA    ESUB01                  address of that one
  61  4014 0110         DATA    >0110                   subprogram name: >10 (sector R/W)
  62  4016 401C SUB02   DATA    SUB03                   
  63  4018 5810         DATA    ESUB02                  
  64  401A 0111         DATA    >0111                   subprogram >11 (format disk)
  65  401C 4022 SUB03   DATA    SUB04                   
  66  401E 581A         DATA    ESUB03                  
  67  4020 0112         DATA    >0112                   subprogram >12 (file un/protect)
  68  4022 402A SUB04   DATA    SUB05                   
  69  4024 5874         DATA    ESUB04                  
  70  4026 0113 NTPFAT  DATA    >0113                   subprogram >13 (file rename); doubles as FAT update flag
  71            *
  72  4028 0000 RTN5C   DATA    >0000                   save GPL return address (needs to be @>4028 for XML >5C!)
  73            *
  74  402A 4030 SUB05   DATA    SUB06                   
  75  402C 5940         DATA    ESUB05                  
  76  402E 0114         DATA    >0114                   subprogram >14 (file direct input)              
  77  4030 4036 SUB06   DATA    SUB07                   
  78  4032 59B0         DATA    ESUB06                  
  79  4034 0115         DATA    >0115                   subprogram >15 (file direct output)
  80  4036 403C SUB07   DATA    SUB08                   
  81  4038 5A76         DATA    ESUB07                  
  82  403A 0116         DATA    >0116                   subprogram >16 (number of files)
  83  403C 4046 SUB08   DATA    SUB09                   
  84  403E 5A22         DATA    ESUB08                  
  85  4040 05           BYTE    >05                     
  86  4041 4649         TEXT    'FILES'                 same as >16, called from Basic
  86  4043 4C45  
  86  4045 53    
  87            *
  88  4046 4050 SUB09   DATA    SUB10
  89  4048 5BF4         DATA    PDSK
  90  404A 04           BYTE    >04
  91  404B 5044         TEXT    'PDSK'                  Protect DSKx (apply adhesive tab)
  91  404D 534B  
  92  404F 0000         EVEN
  93  4050 405A SUB10   DATA    SUB11                   
  94  4052 5BFA         DATA    UDSK
  95  4054 04           BYTE    >04
  96  4055 5544         TEXT    'UDSK'                  Un-protect DSKx (remove adhesive tab)
  96  4057 534B  
  97  4059 0000         EVEN
  98  405A 4064 SUB11   DATA    SUB12
  99  405C 5C00         DATA    LDSK
 100  405E 04           BYTE    >04
 101  405F 4C44         TEXT    'LDSK'                  List files on DSKx
 101  4061 534B  
 102  4063 0000         EVEN
 103  4064 406E SUB12   DATA    SUB13
 104  4066 5C06         DATA    MDSK
 105  4068 04           BYTE    >04
 106  4069 4D44         TEXT    'MDSK'                  Map DOAD to DSKx
 106  406B 534B  
 107  406D 0000         EVEN
 108  406E 4078 SUB13   DATA    SUB14
 109  4070 5C0C         DATA    NDSK
 110  4072 04           BYTE    >04
 111  4073 4E44         TEXT    'NDSK'
 111  4075 534B  
 112  4077 0000         EVEN
 113  4078 4082 SUB14   DATA    SUB15
 114  407A 5C12         DATA    RDSK
 115  407C 04           BYTE    >04
 116  407D 5244         TEXT    'RDSK'                  Remove DOAD from SD card
 116  407F 534B  
 117  4081 0000         EVEN
 118  4082 408C SUB15   DATA    SUB16
 119  4084 5C18         DATA    FGET
 120  4086 04           BYTE    >04
 121  4087 4647         TEXT    'FGET'                  Load DOAD from FTP server
 121  4089 4554  
 122  408B 0000         EVEN
 123  408C 4096 SUB16   DATA    SUB17
 124  408E 5C1E         DATA    FPUT
 125  4090 04           BYTE    >04
 126  4091 4650         TEXT    'FPUT'                  Save DOAD to FTP server
 126  4093 5554  
 127  4095 0000         EVEN
 128  4096 40A0 SUB17   DATA    SUB18
 129  4098 5C24         DATA    ADSR
 130  409A 04           BYTE    >04
 131  409B 4144         TEXT    'ADSR'                  APEDSK99 load DSR
 131  409D 5352  
 132  409F 0000         EVEN
 133  40A0 40AA SUB18   DATA    SUB19
 134  40A2 5C2A         DATA    NDIR
 135  40A4 04           BYTE    >04
 136  40A5 4E44         TEXT    'NDIR'
 136  40A7 4952  
 137  40A9 0000         EVEN
 138  40AA 40B4 SUB19   DATA    SUB20
 139  40AC 5C30         DATA    SDSK
 140  40AE 04           BYTE    >04
 141  40AF 5344         TEXT    'SDSK'                  Show DOAD mapping for DSKx
 141  40B1 534B  
 142  40B3 0000         EVEN
 143  40B4 40BE SUB20   DATA    SUB21
 144  40B6 5C36         DATA    SDIR
 145  40B8 04           BYTE    >04
 146  40B9 5344         TEXT    'SDIR'                  List DOAD files on SD card
 146  40BB 4952  
 147  40BD 0000         EVEN
 148  40BE 40C8 SUB21   DATA    SUB22
 149  40C0 5C3C         DATA    AHLP
 150  40C2 04           BYTE    >04
 151  40C3 4148         TEXT    'AHLP'                  APEDSK99 CALL help screen
 151  40C5 4C50  
 152  40C7 0000         EVEN
 153  40C8 40D2 SUB22   DATA    SUB23
 154  40CA 5C42         DATA    ARST
 155  40CC 04           BYTE    >04
 156  40CD 4152         TEXT    'ARST'                  APEDSK99 Reset
 156  40CF 5354  
 157  40D1 0000         EVEN
 158  40D2 0000 SUB23   DATA    >0000
 159  40D4 5C48         DATA    TIME
 160  40D6 04           BYTE    >04
 161  40D7 5449         TEXT    'TIME'                  NTP date/time display / assign to NTP$
 161  40D9 4D45  
 162  40DB 0000         EVEN
 163            *
 164  40DC 0000 PWRUP   DATA    >0000                   power-up chain (no more)
 165  40DE 4108         DATA    EPWRUP                  address of power-up routine
 166  40E0 0000         DATA    >0000                   no name
 167            *                                       
 168  40E2 40EA DSR01   DATA    DSR02                   DSR chain
 169  40E4 4D16         DATA    EDSR01                  address of DSR
 170  40E6 03           BYTE    >03                     name size
 171  40E7 4453         TEXT    'DSK'                   DSR name
 171  40E9 4B    
 172  40EA 40F4 DSR02   DATA    DSR03                   
 173  40EC 4D24         DATA    EDSR02                  
 174  40EE 04           BYTE    >04                     
 175  40EF 4453         TEXT    'DSK1'                  
 175  40F1 4B31  
 176  40F3 0000         EVEN                            
 177  40F4 40FE DSR03   DATA    DSR04                   
 178  40F6 4D2A         DATA    EDSR03                  
 179  40F8 04           BYTE    >04                     
 180  40F9 4453         TEXT    'DSK2'                  
 180  40FB 4B32  
 181  40FD 0000         EVEN                            
 182  40FE 0000 DSR04   DATA    >0000                   no more
 183  4100 4D30         DATA    EDSR04                  
 184  4102 04           BYTE    >04                     
 185  4103 4453         TEXT    'DSK3'                  
 185  4105 4B33  
 186  4107 0000         EVEN            
 187            *
 188            *=====================================
 189            * Power-up routine
 190            *=====================================                                          
 191            *
 192  4108 028C EPWRUP  CI      R12,>1000               Dhr. F.G. Kaal check: are we powering up 1st CRU (>1000) peripheral?
 192  410A 1000  
 193  410C 1633         JNE     NOCRU                   nope; return
 194            *
 195  410E C1CB         MOV     R11,R7                  yes; save return address
 196  4110 02A9         STWP    R9                      get workspace (should be >83E0)
 197  4112 0229         AI      R9,-224                 point to top of scratch-pad mem (>8300)
 197  4114 FF20  
 198  4116 C0A9         MOV     @>0070(R9),R2           highest free address in vdp mem (>8370)
 198  4118 0070  
 199  411A C002         MOV     R2,R0                   save it
 200  411C 0222         AI      R2,-2088                we'll need >828 bytes
 200  411E F7D8  
 201  4120 CA42         MOV     R2,@>0070(R9)           update address
 201  4122 0070  
 202  4124 0582         INC     R2
 203  4126 06A0         BL      @VDPWRI                 set VDP address
 203  4128 4300  
 204  412A 0201         LI      R1,2088                 
 204  412C 0828  
 205  412E 04EF H001    CLR     @-2(R15)                clear these >828 bytes
 205  4130 FFFE  
 206  4132 0601         DEC     R1                      
 207  4134 16FC         JNE     H001                    
 208  4136 06A0         BL      @VDPWRI                 set VDP address (same)
 208  4138 4300  
 209  413A 0203         LI      R3,>AA03                        
 209  413C AA03  
 210  413E DBC3         MOVB    R3,@-2(R15)             write buffer ID mark
 210  4140 FFFE  
 211  4142 1000         NOP                             
 212  4144 DBC0         MOVB    R0,@-2(R15)             write old highest free address
 212  4146 FFFE  
 213  4148 06C0         SWPB    R0
 214  414A DBC0         MOVB    R0,@-2(R15)
 214  414C FFFE  
 215  414E 1000         NOP                             
 216  4150 DBCC         MOVB    R12,@-2(R15)            write CRU address (>1000 for APEDSK99)
 216  4152 FFFE  
 217  4154 06C3         SWPB    R3                      
 218  4156 DBC3         MOVB    R3,@-2(R15)             write number of files (3)
 218  4158 FFFE  
 219  415A 06A0         BL      @PRPRTN                 preparation routine
 219  415C 43F0  
 220  415E 06A0         BL      @CALSUB                 call subroutine
 220  4160 4322  
 221  4162 4290         DATA    RSTDRV                  reset all drives
 222  4164 04E9         CLR     @>0054(R9)              name length = 0 for power-up
 222  4166 0054  
 223  4168 0429         BLWP    @>005A(R9)              retrieve R7 (saved by PRPRTN)
 223  416A 005A  
 224  416C 0011         DATA    >0011                   put it into R11
 225  416E CA60         MOV     @K001,@>006C(R9)        ???
 225  4170 4176  
 225  4172 006C  
 226  4174 045B NOCRU   B       *R11                    return
 227            *                               
 228  4176 0404 K001    DATA    >0404                   
 229            *
 230            *---------------------------------------
 231            * Sector read/write
 232            *---------------------------------------                                        
 233            *
 234  4178 DA60 SECRW1  MOVB    @K002,@>0050(R9)        APEDSK99: no error
 234  417A 431C  
 234  417C 0050  
 235  417E 06A0         BL      @SELDRV                 select drive
 235  4180 4262  
 236            *
 237  4182 C069         MOV     @>004A(R9),R1           sector #
 237  4184 004A  
 238  4186 0281         CI      R1,>05A0                APEDSK99: max 1440 (DS/DD/40T or DS/SD/80T)?
 238  4188 05A0  
 239  418A 1A03         JL      H005                    APEDSK99: yes; sector# within range
 240  418C 06A0         BL      @ERROR1                 APEDSK99: no -> "device error"
 240  418E 42BE  
 241  4190 0600         DATA    >0600   
 242            
 243  4192 C801 H005    MOV     R1,@WSECTR              APEDSK99: sector# to FD1771 write sector register (16bits)
 243  4194 5FFC  
 244            *
 245  4196 C0A9 H013    MOV     @>004E(R9),R2           data buffer address
 245  4198 004E  
 246  419A D029         MOVB    @>004D(R9),R0           read or write ?
 246  419C 004D  
 247  419E 1312         JEQ     H014                    write
 248  41A0 06A0         BL      @VDPWRI                 read FD = write to VDP buffer
 248  41A2 4300  
 249  41A4 0206 H015    LI      R6,256                  APEDSK99: re-arranged H015 to sync reading sector bytes
 249  41A6 0100  
 250  41A8 C806         MOV     R6,@RDINT               APEDSK99: interrupt Arduino for read operation 
 250  41AA 5FEA  
 251  41AC 06A0         BL      @SNDCMD                 send command
 251  41AE 42D4  
 252  41B0 8800         DATA    >8800                   APEDSK99: read sector
 253            *
 254  41B2 D020 H016    MOVB    @RDATA,R0               get 1 byte from FDC
 254  41B4 5FF6  
 255  41B6 DBC0         MOVB    R0,@-2(R15)             save it to VDP
 255  41B8 FFFE  
 256  41BA 0620         DEC     @RDINT                  APEDSK99: interrupt Arduino for read operation
 256  41BC 5FEA  
 257  41BE 16F9         JNE     H016                    next byte
 258            *
 259  41C0 0460 H019    B       @RTURN1                 return
 259  41C2 4340  
 260            
 261            *       
 262  41C4 06A0 H014    BL      @VDPRD                  write to FD = read from VDP buffer
 262  41C6 430A  
 263  41C8 0206         LI      R6,256                  256 bytes to write
 263  41CA 0100  
 264            *
 265            * APEDSK99: the first byte to be written needs to be in the data register before the write command is given
 266            *
 267  41CC D02F         MOVB    @-1026(R15),R0          APEDSK99: get a byte from data buffer
 267  41CE FBFE  
 268  41D0 D800         MOVB    R0,@WDATA               APEDSK99: write first byte to data register
 268  41D2 5FFE  
 269  41D4 06A0         BL      @SNDCMD                 send command
 269  41D6 42D4  
 270  41D8 A800         DATA    >A800                   APEDSK99: write sector
 271            *
 272  41DA D02F H024    MOVB    @-1026(R15),R0          get a byte from data buffer
 272  41DC FBFE  
 273  41DE D800         MOVB    R0,@WDATA               pass it to data register
 273  41E0 5FFE  
 274  41E2 0606         DEC     R6                      
 275  41E4 16FA         JNE     H024                    next byte
 276            *
 277  41E6 06A0         BL      @WTCPT1                 APEDSK99: check for Write Protect
 277  41E8 4254  
 278  41EA 0A20         SLA     R0,2                    APEDSK99: WP bit in Carry
 279  41EC 1801         JOC     ERROR3                  write protect: error 34
 280  41EE 10E8         JMP     H019                    APEDSK99: no need to verify             
 281            *                                       
 282  41F0 06A0 ERROR3  BL      @ERROR1                 error 34 (Write Protect)
 282  41F2 42BE  
 283  41F4 3400         DATA    >3400                   
 284            *
 285            *--------------------------------------------------------------------
 286            * Format disk - APEDSK99: we don't do any physical formatting anymore
 287            *--------------------------------------------------------------------
 288            *
 289  41F6 04E9 FMTDSK  CLR     @>004A(R9)              called by subprogram >11
 289  41F8 004A  
 290            *                                       
 291  41FA 5A60 H027    SZCB    @K004,@>004C(R9)        clear DSR version flags
 291  41FC 431E  
 291  41FE 004C  
 292            *
 293  4200 06A0         BL      @SELDRV                 select drive
 293  4202 4262  
 294            *
 295  4204 D029         MOVB    @>004D(R9),R0           APEDSK99: get # of tracks
 295  4206 004D  
 296  4208 9829         CB      @>0051(R9),@K005        APEDSK99: double sided?
 296  420A 0051  
 296  420C 431F  
 297  420E 1601         JNE     H036                    APEDSK99: single-side
 298            *
 299  4210 0A10         SLA     R0,1                    times two (since 2 sides)
 300            *
 301  4212 0980 H036    SRL     R0,8                    APEDSK99: make it a byte
 302  4214 0206         LI      R6,9                    APEDSK99: start with single density
 302  4216 0009  
 303  4218 9829         CB      @>0050(R9),@K005        APEDSK99: double density required?
 303  421A 0050  
 303  421C 431F  
 304  421E 1601         JNE     H037                    APEDSK99: no, leave R6 alone
 305  4220 0A16         SLA     R6,1                    APEDSK99: yes, R6*2
 306            *               
 307  4222 3806 H037    MPY     R6,R0                   APEDSK99: #sectors/track * #tracks
 308  4224 0281         CI      R1,>05A0                APEDSK99: >1440 sectors?
 308  4226 05A0  
 309  4228 1203         JLE     H038                    APEDSK99: nope; continue
 310  422A 06A0         BL      @ERROR1                 APEDSK99: yes; "device error"
 310  422C 42BE  
 311  422E 0600         DATA    >0600   
 312            *
 313  4230 CA41 H038    MOV     R1,@>004A(R9)           pass total # of sectors per disk
 313  4232 004A  
 314  4234 06C6         SWPB    R6
 315  4236 DA46         MOVB    R6,@>004D(R9)           APEDSK99: pass # of sectors per track
 315  4238 004D  
 316  423A DA60         MOVB    @K002,@>0050(R9)        no error
 316  423C 431C  
 316  423E 0050  
 317            *
 318  4240 06A0         BL      @NTPDT                  APEDSK99: update DOAD FAT time/date
 318  4242 5E0E  
 319            *
 320  4244 0460         B       @RTURN1                 return
 320  4246 4340  
 321            *                                       
 322                                                    
 323  4248 C1BB VDPRPW  MOV     *R11+,R6                VDP repeated write
 324  424A DBC0 H044    MOVB    R0,@-2(R15)
 324  424C FFFE  
 325  424E 0606         DEC     R6                      byte in R0
 326  4250 16FC         JNE     H044                    number of repeats in data word
 327  4252 045B         B       *R11                    
 328            *
 329  4254 D020 WTCPT1  MOVB    @RSTAT,R0               get status. APEDSK99: Not Ready >80 / Write Protect >40
 329  4256 5FF0  
 330  4258 1101         JLT     ERROR4                  drive not ready. APEDSK99: Not Ready set when DOAD file is unavailable
 331  425A 045B         B       *R11                    
 332            *
 333  425C 06A0 ERROR4  BL      @ERROR1                 exit with error code 6, reseting all drives
 333  425E 42BE  
 334  4260 0600         DATA    >0600                   
 335            *                                       
 336  4262 C1CB SELDRV  MOV     R11,R7                  select a drive
 337  4264 C0A9         MOV     @>0058(R9),R2
 337  4266 0058  
 338  4268 0222         AI      R2,-10                  point to drive info
 338  426A FFF6  
 339  426C 04C0 H055    CLR     R0                      
 340  426E D029         MOVB    @>004C(R9),R0           get drive #
 340  4270 004C  
 341  4272 130B         JEQ     H056                    can't be >00: error #7
 342  4274 0280         CI      R0,>0300                        
 342  4276 0300  
 343  4278 1B08         JH      H056                    drive number can't be higher than 3: error #7
 344  427A 06A0         BL      @VDPWRI                 set VDP to write, address in R2
 344  427C 4300  
 345  427E DBC0         MOVB    R0,@-2(R15)             modify last drive accessed              
 345  4280 FFFE  
 346            *
 347  4282 0A10 H057    SLA     R0,1                    APEDSK99: bit 0 is side select, 1-3 is drive #
 348  4284 D800         MOVB    R0,@CRUWRI              APEDSK99: select drive
 348  4286 5FEE  
 349  4288 0457 H058    B       *R7                     
 350            *                                       
 351  428A 06A0 H056    BL      @ERROR1                 exit with error #7
 351  428C 42BE  
 352  428E 0700         DATA    >0700                   
 353            *                                       
 354  4290 5820 RSTDRV  SZCB    @DSDRVS,@CRUWRI         APEDSK99: reset all drives including side
 354  4292 4320  
 354  4294 5FEE  
 355  4296 D820         MOVB    @K013,@WCOMND           send Force Interrupt with no interrupt flag set
 355  4298 42CE  
 355  429A 5FF8  
 356  429C C0A9         MOV     @>0058(R9),R2           ptr to VIB buffer
 356  429E 0058  
 357  42A0 0222         AI      R2,-10                  now points to drive info buffer
 357  42A2 FFF6  
 358  42A4 06A0         BL      @VDPWRI                 set VDP to write to address in R2
 358  42A6 4300  
 359  42A8 0200         LI      R0,4                    
 359  42AA 0004  
 360  42AC DBC0 H061    MOVB    R0,@-2(R15)             write four >00 (i.e. clear drive info)
 360  42AE FFFE  
 361  42B0 0600         DEC     R0                      
 362  42B2 16FC         JNE     H061                    
 363  42B4 DA60         MOVB    @K002,@>0050(R9)        no error
 363  42B6 431C  
 363  42B8 0050  
 364  42BA 0460         B       @RTURN1                 get return address from stack
 364  42BC 4340  
 365            *                                       
 366  42BE C01B ERROR1  MOV     *R11,R0                 exit with error
 367  42C0 DA40         MOVB    R0,@>0050(R9)           place err code in >8350
 367  42C2 0050  
 368  42C4 0280         CI      R0,>0600                check if device error
 368  42C6 0600  
 369  42C8 1603         JNE     H064                    no: exit
 370  42CA 06A0         BL      @SNDCMD                 yes: reset drives
 370  42CC 42D4  
 371            *
 372  42CE 0000 K013    DATA    >0000                   APEDSK99: send Restore command
 373            *
 374  42D0 0460 H064    B       @RTURN1                 return to caller (address from stack)
 374  42D2 4340  
 375            *                               
 376  42D4 C03B SNDCMD  MOV     *R11+,R0                send command to FDC from data word
 377  42D6 D800 H066    MOVB    R0,@WCOMND              send command
 377  42D8 5FF8  
 378  42DA 045B         B       *R11                    
 379            *                                       
 380  42DC 04C0 LASTRK  CLR     R0                      get last track # for this drive
 381  42DE D029         MOVB    @>004C(R9),R0           get drive #
 381  42E0 004C  
 382  42E2 130B         JEQ     H068                    can't be 0
 383  42E4 06C0         SWPB    R0                      
 384  42E6 0280         CI      R0,3                    
 384  42E8 0003  
 385  42EA 1B07         JH      H068                    can't be higher than 3
 386  42EC C0A9         MOV     @>0058(R9),R2                   
 386  42EE 0058  
 387  42F0 0222         AI      R2,-10                  point to last drive accessed
 387  42F2 FFF6  
 388  42F4 A080         A       R0,R2                   point to last track for this drive
 389  42F6 0460         B       @VDPRD                  prepare VDP to read from address in R2
 389  42F8 430A  
 390            *                                       
 391  42FA 06A0 H068    BL      @ERROR1                 exit with error code 7
 391  42FC 42BE  
 392  42FE 0700         DATA    >0700                   
 393            *                                       
 394  4300 0262 VDPWRI  ORI     R2,>4000                set VDP address to write
 394  4302 4000  
 395  4304 0242         ANDI    R2,>7FFF                not to a register
 395  4306 7FFF  
 396  4308 1002         JMP     H069                    
 397  430A 0242 VDPRD   ANDI    R2,>3FFF                set VDP address to read
 397  430C 3FFF  
 398  430E 06C2 H069    SWPB    R2                      
 399  4310 D7C2         MOVB    R2,*R15                 write address
 400  4312 06C2         SWPB    R2                      
 401  4314 D7C2         MOVB    R2,*R15                 
 402  4316 0242         ANDI    R2,>3FFF                        
 402  4318 3FFF  
 403  431A 045B         B       *R11                    
 404            *                                       
 405  431C 00   K002    BYTE    >00                     
 406  431D 09   K007    BYTE    >09                                             
 407  431E F0   K004    BYTE    >F0                     
 408  431F 02   K005    BYTE    2
 409  4320 0F   DSDRVS  BYTE    >0F                     APEDSK99: deselect all drives + side (reset CRUWRI bits 7,6,5 and 4)                    
 410            *
 411  4321 0000         EVEN
 412            *                               
 413  4322 0669 CALSUB  DECT    @>0066(R9)              call subroutine, return address in stack
 413  4324 0066  
 414  4326 C2A9         MOV     @>0066(R9),R10
 414  4328 0066  
 415  432A 0429         BLWP    @>005A(R9)              set VDP to write to address in R10
 415  432C 005A  
 416  432E 0143         DATA    >0143                   
 417  4330 C2BB         MOV     *R11+,R10               get next data word
 418  4332 06CB         SWPB    R11                     write return address to VDP
 419  4334 DBCB         MOVB    R11,@-2(R15)                    
 419  4336 FFFE  
 420  4338 06CB         SWPB    R11                     
 421  433A DBCB         MOVB    R11,@-2(R15)                    
 421  433C FFFE  
 422  433E 045A         B       *R10                    branch to address in data word
 423            *                               
 424  4340 C2E9 RTURN1  MOV     @>0066(R9),R11          get return address from VDP stack
 424  4342 0066  
 425  4344 0429         BLWP    @>005A(R9)              
 425  4346 005A  
 426  4348 0162         DATA    >0162                   set VDP to read from address in R11
 427  434A D2EF         MOVB    @-1026(R15),R11                 
 427  434C FBFE  
 428  434E 06CB         SWPB    R11                     
 429  4350 D2EF         MOVB    @-1026(R15),R11                 
 429  4352 FBFE  
 430  4354 05E9         INCT    @>0066(R9)                      
 430  4356 0066  
 431  4358 045B         B       *R11                    
 432            *
 433            *---------------------------------------
 434            * Custom routines, dealing with VDP memory
 435            * Format is >pppr where r is routine number (0-3)
 436            * and ppp contains parameters
 437            * The workspace it >8300. Called by BLWP @>005A(9).
 438            *---------------------------------------                                        
 439            *
 440  435A C28D ECUSTM  MOV     R13,R10                 save wregs ptr
 441  435C C23E         MOV     *R14+,R8                get next data word
 442  435E C248         MOV     R8,R9                   save it
 443  4360 0949         SRL     R9,4                    keep parameter
 444  4362 0248         ANDI    R8,3                    four possible operations
 444  4364 0003  
 445  4366 A208         A       R8,R8                   make it a word ptr
 446  4368 C2ED         MOV     @>001E(R13),R11         get old R15, i.e. VDP port (>8C02)
 446  436A 001E  
 447  436C C228         MOV     @VECRTN(R8),R8          get vector for operation
 447  436E 4372  
 448  4370 0458         B       *R8                     branch to it
 449            *                                       
 450  4372 437A VECRTN  DATA    SVRVDP                  save registers to VDP stack
 451  4374 43A6         DATA    RVRVDP                  retrieve registers
 452  4376 43DC         DATA    SVDPRD                  set VDP address to read
 453  4378 43D2         DATA    SVDPWR                  set VDP address to write
 454            *                                       
 455  437A 022A SVRVDP  AI      R10,22                  0: save registers in VDP mem
 455  437C 0016  
 456  437E 0919 H072    SRL     R9,1                    start with R12
 457  4380 1710         JNC     H070                    bits in >ppp tell which register to save (R0-R11)
 458  4382 064C         DECT    R12                     previous address in VDP stack (grows down)
 459  4384 C21A         MOV     *R10,R8                 get register contents
 460  4386 06CC         SWPB    R12                     set VDP address to write
 461  4388 D6CC         MOVB    R12,*R11                R12 is >8366: VDP stack ptr
 462  438A 06CC         SWPB    R12                     
 463  438C 026C         ORI     R12,>4000                       
 463  438E 4000  
 464  4390 D6CC         MOVB    R12,*R11                        
 465  4392 06C8         SWPB    R8                      save register to VDP mem
 466  4394 DAC8         MOVB    R8,@-2(R11)                     
 466  4396 FFFE  
 467  4398 06C8         SWPB    R8                      
 468  439A DAC8         MOVB    R8,@-2(R11)                     
 468  439C FFFE  
 469  439E C249         MOV     R9,R9                   more to come?
 470  43A0 1317         JEQ     H071                    no:return
 471  43A2 064A H070    DECT    R10                     point to previous register
 472  43A4 10EC         JMP     H072                    
 473            *                               
 474  43A6 0A49 RVRVDP  SLA     R9,4                    1: retrieve registers from VDP mem
 475  43A8 0A19 H074    SLA     R9,1                    each bit tells whether to load
 476  43AA 1710         JNC     H073                    don't retrieve that one
 477  43AC 06CC         SWPB    R12                     set VDP address to read
 478  43AE D6CC         MOVB    R12,*R11                R12 is >8366: VDP stack ptr
 479  43B0 06CC         SWPB    R12                     
 480  43B2 024C         ANDI    R12,>3FFF                       
 480  43B4 3FFF  
 481  43B6 D6CC         MOVB    R12,*R11                        
 482  43B8 1000         NOP                             
 483  43BA D22B         MOVB    @-1026(R11),R8          get a 2-byte value from VDP
 483  43BC FBFE  
 484  43BE 06C8         SWPB    R8                      
 485  43C0 D22B         MOVB    @-1026(R11),R8                  
 485  43C2 FBFE  
 486  43C4 C688         MOV     R8,*R10                 save it to register
 487  43C6 05CC         INCT    R12                     increment ptr (stack grows downwards)
 488  43C8 C249         MOV     R9,R9                   more to come?
 489  43CA 1302         JEQ     H071                    no: return
 490  43CC 05CA H073    INCT    R10                     next register
 491  43CE 10EC         JMP     H074                    
 492  43D0 0380 H071    RTWP                            
 493            *                                       
 494  43D2 A24D SVDPWR  A       R13,R9                  2: set VDP for a write
 495  43D4 C219         MOV     *R9,R8                  
 496  43D6 0268         ORI     R8,>4000                get address from reg in >..p2 (*2)
 496  43D8 4000  
 497  43DA 1004         JMP     H075                    
 498            *                                       
 499  43DC A24D SVDPRD  A       R13,R9                  3: set VDP for a read
 500  43DE C219         MOV     *R9,R8
 501  43E0 0248         ANDI    R8,>3FFF                get register from reg in >..p3 (*2)
 501  43E2 3FFF  
 502  43E4 06C8 H075    SWPB    R8                      set VDP address
 503  43E6 D6C8         MOVB    R8,*R11                 
 504  43E8 06C8         SWPB    R8                      
 505  43EA D6C8         MOVB    R8,*R11                 
 506  43EC 0380         RTWP                            
 507            *
 508            *---------------------------------------
 509            * Preparation subroutine
 510            * Sets up the 4 custom subroutines
 511            * Gets a few pointers to VDP buffers
 512            *  >8358: copy of VIB  >8366: VDP stack ptr (grows down from drive info)
 513            *  >8354: PAB          >8356: ptr to end-of-buffer
 514            *---------------------------------------                                        
 515            *
 516  43EE 05C7 PRPFDO  INCT    R7                      stop scanning upon return
 517  43F0 C28B PRPRTN  MOV     R11,R10                 save return address
 518  43F2 02A9         STWP    R9                      get workspace (should be >83E0)
 519  43F4 0229         AI      R9,-224                 top of scratch/pad mem (>8300)
 519  43F6 FF20  
 520  43F8 0200         LI      R0,ECUSTM               entry to 4 custom routines
 520  43FA 435A  
 521  43FC CA40         MOV     R0,@>005C(R9)           put it in >835C
 521  43FE 005C  
 522  4400 C009         MOV     R9,R0                   
 523  4402 0220         AI      R0,>004E                workspace for these four (>834E)
 523  4404 004E  
 524  4406 CA40         MOV     R0,@>005A(R9)           put it in >835A
 524  4408 005A  
 525            *                                       
 526  440A C229         MOV     @>0070(R9),R8           highest free address in VDP mem
 526  440C 0070  
 527  440E 05C8 H076    INCT    R8                      point to end-of-buffer word
 528  4410 06A0         BL      @VDPR2B                 read 2 bytes from VDP address R8, into R0
 528  4412 4840  
 529  4414 C088         MOV     R8,R2                   save current R8
 530  4416 C200         MOV     R0,R8                   get end-of-buffer word
 531  4418 0228         AI      R8,-266                 yes: point to volume information block
 531  441A FEF6  
 532  441C CA48         MOV     R8,@>0058(R9)           save it in >8358
 532  441E 0058  
 533  4420 0228         AI      R8,-10                  point to disk drive info (drive #, last tracks)
 533  4422 FFF6  
 534  4424 CA48         MOV     R8,@>0066(R9)           save in >8366: VDP stack ptr (DECT before writing)
 534  4426 0066  
 535  4428 0429         BLWP    @>005A(R9)              save R7 (return address)
 535  442A 005A  
 536  442C 0100         DATA    >0100                   
 537  442E C1E9         MOV     @>0056(R9),R7           ptr to PAB: end of DSR name
 537  4430 0056  
 538  4432 C0C7         MOV     R7,R3                   save it
 539  4434 61E9         S       @>0054(R9),R7           start of DSR name
 539  4436 0054  
 540  4438 CA42         MOV     R2,@>0056(R9)           >8356: ptr to end-of-buffer word in VDP mem
 540  443A 0056  
 541  443C 0607         DEC     R7                      point to name length byte
 542  443E 04C2         CLR     R2                      
 543  4440 0429         BLWP    @>005A(R9)              set VDP to read from address in R2
 543  4442 005A  
 544  4444 00E2         DATA    >00E2                   
 545  4446 D0AF         MOVB    @-1026(R15),R2          get name length byte
 545  4448 FBFE  
 546  444A 06C2         SWPB    R2                      make it a word
 547  444C 60A9         S       @>0054(R9),R2           minus DSR name size: lenght of .parameters
 547  444E 0054  
 548  4450 0227         AI      R7,-9                   point to top of PAB
 548  4452 FFF7  
 549  4454 CA47         MOV     R7,@>0054(R9)           save it in >8354
 549  4456 0054  
 550  4458 045A         B       *R10                    
 551            *                               
 552  445A 06A0 CRFIL1  BL      @CALSUB                 create file
 552  445C 4322  
 553  445E 4ACC         DATA    FNDFDR                  find a FDR in disk
 554  4460 C104 CRFIL2  MOV     R4,R4                   found?
 555  4462 1604         JNE     CRFIL3                  no
 556  4464 06A0         BL      @CALSUB                 yes: delete old file
 556  4466 4322  
 557  4468 45A4         DATA    FFSVIB                  free file sector in VIB bitmap
 558  446A 1045         JMP     H077                    clear its FDR
 559            *                               
 560  446C 06A0 CRFIL3  BL      @INSFDR                 new file: insert a FDR in sector 1
 560  446E 47D4  
 561  4470 0701         SETO    R1                      
 562  4472 06A0         BL      @CALSUB                 call subroutine
 562  4474 4322  
 563  4476 4BC0         DATA    FFSBMP                  find a free sector in VIB bitmap
 564  4478 C000         MOV     R0,R0                   found?
 565  447A 1603         JNE     H078                    yes: # in R0
 566  447C 06A0         BL      @ERROR5                 no: update data, then return with error
 566  447E 493C  
 567  4480 8000         DATA    >8000                   memory full
 568            *                               
 569  4482 0429 H078    BLWP    @>005A(R9)              set VDP to write
 569  4484 005A  
 570  4486 0103         DATA    >0103                   address in R8
 571  4488 DBC0         MOVB    R0,@-2(R15)             write sector # for FDR in sector 1
 571  448A FFFE  
 572  448C 06C0         SWPB    R0                      
 573  448E DBC0         MOVB    R0,@-2(R15)                     
 573  4490 FFFE  
 574  4492 06C0         SWPB    R0                      
 575  4494 C069         MOV     @>0056(R9),R1           ptr to FDR in VDP buffers
 575  4496 0056  
 576  4498 0221         AI      R1,-4                   ptr to sector # for FDR
 576  449A FFFC  
 577  449C 0429         BLWP    @>005A(R9)              set VDP to write
 577  449E 005A  
 578  44A0 0023         DATA    >0023                   address in R1
 579  44A2 DBC0         MOVB    R0,@-2(R15)             write sector # for FDR in VDP buffer
 579  44A4 FFFE  
 580  44A6 06C0         SWPB    R0                      
 581  44A8 DBC0         MOVB    R0,@-2(R15)                     
 581  44AA FFFE  
 582  44AC 0221         AI      R1,3                    ptr to drive #
 582  44AE 0003  
 583  44B0 0429         BLWP    @>005A(R9)              set VDP to write
 583  44B2 005A  
 584  44B4 0023         DATA    >0023                   address in R1
 585  44B6 DBC6         MOVB    R6,@-2(R15)             write drive # before FDR in VDP buffer
 585  44B8 FFFE  
 586  44BA 04C2         CLR     R2                      code for write
 587  44BC 0581         INC     R1                      
 588  44BE 06A0         BL      @CALSUB                 call subroutine
 588  44C0 4322  
 589  44C2 4A00         DATA    WRSEC1                  write sector 1
 590  44C4 C169         MOV     @>0058(R9),R5           ptr to VIB in VDP buffers
 590  44C6 0058  
 591  44C8 04C4         CLR     R4                      sector 0
 592  44CA 06A0         BL      @CALSUB                 call subroutine
 592  44CC 4322  
 593  44CE 4A18         DATA    RWSEC                   write VIB to sector 0
 594  44D0 C0C5         MOV     R5,R3                   copy filename from compare buffer to FDR
 595  44D2 0223         AI      R3,257                  ptr to file compare buffer
 595  44D4 0101  
 596  44D6 0202         LI      R2,10                   10 chars per filename
 596  44D8 000A  
 597  44DA 0429 H079    BLWP    @>005A(R9)              set VDP to read
 597  44DC 005A  
 598  44DE 0062         DATA    >0062                   address in R3
 599  44E0 D02F         MOVB    @-1026(R15),R0          get 1 char
 599  44E2 FBFE  
 600  44E4 0583         INC     R3                      increment source ptr
 601  44E6 0429         BLWP    @>005A(R9)              set VDP to write
 601  44E8 005A  
 602  44EA 0023         DATA    >0023                   address in R1
 603  44EC DBC0         MOVB    R0,@-2(R15)             copy 1 char
 603  44EE FFFE  
 604  44F0 0581         INC     R1                      increment destination ptr
 605  44F2 0602         DEC     R2                      # of chars in R2
 606  44F4 16F2         JNE     H079                    next
 607            *
 608  44F6 06A0 H077    BL      @NTPDT                  APEDSK99: update DOAD FAT time/date
 608  44F8 5E0E  
 609            *
 610  44FA C069         MOV     @>0056(R9),R1           FDR ptr
 610  44FC 0056  
 611  44FE 0221         AI      R1,10                   skip filename
 611  4500 000A  
 612  4502 0202         LI      R2,246                  remaining bytes in FDR
 612  4504 00F6  
 613  4506 0429         BLWP    @>005A(R9)              set VDP to write
 613  4508 005A  
 614  450A 0023         DATA    >0023                   address in R1
 615  450C DBC2 H080    MOVB    R2,@-2(R15)             write >00
 615  450E FFFE  
 616  4510 0602         DEC     R2                      clear remainder of new FDR
 617  4512 16FC         JNE     H080                    next byte
 618  4514 1010         JMP     H081                    write FDR to disk return to caller
 619            *                                       
 620  4516 C169 H082    MOV     @>0056(R9),R5           check if FDR must be updated
 620  4518 0056  
 621  451A 0429         BLWP    @>005A(R9)              set VDP to read
 621  451C 005A  
 622  451E 00A2         DATA    >00A2                   address in R5
 623  4520 D12F         MOVB    @-1026(R15),R4          get filename in file ctrl block
 623  4522 FBFE  
 624  4524 1101         JLT     H083                    flag: FDR was modified, update it
 625  4526 100A         JMP     H084                    
 626  4528 0244 H083    ANDI    R4,>7F00                clear flag bit
 626  452A 7F00  
 627  452C 0429         BLWP    @>005A(R9)              st VDP to write
 627  452E 005A  
 628  4530 00A3         DATA    >00A3                   address in R5
 629  4532 DBC4         MOVB    R4,@-2(R15)             write back filename without flag bit
 629  4534 FFFE  
 630  4536 04C2 H081    CLR     R2                      code for write
 631  4538 0460         B       @WRFDR                  write FDR to disk
 631  453A 4A0A  
 632  453C 0460 H084    B       @RTURN1                 return to caller
 632  453E 4340  
 633            *                               
 634  4540 06A0 UPDFDR  BL      @CALSUB                 update FDR + data
 634  4542 4322  
 635  4544 4560         DATA    UPDBF                   update data buffer if necessary
 636  4546 06A0         BL      @CALSUB                 call subroutine
 636  4548 4322  
 637  454A 4516         DATA    H082                    update FDR if necessary
 638  454C C169 CLRFBT  MOV     @>0056(R9),R5                   
 638  454E 0056  
 639  4550 04C6         CLR     R6                      
 640  4552 0429         BLWP    @>005A(R9)              set VDP to write
 640  4554 005A  
 641  4556 00A3         DATA    >00A3                   address in R5
 642  4558 DBC6         MOVB    R6,@-2(R15)             clr first byte of filename in FDR
 642  455A FFFE  
 643  455C 0460         B       @RWVIB                  
 643  455E 499C  
 644            *                                       
 645  4560 C129 UPDBF   MOV     @>0056(R9),R4           check if data buffer must be updated
 645  4562 0056  
 646  4564 0604         DEC     R4                      
 647  4566 0429         BLWP    @>005A(R9)              set VDP to read
 647  4568 005A  
 648  456A 0082         DATA    >0082                   address in R4
 649  456C D06F         MOVB    @-1026(R15),R1          get drive #
 649  456E FBFE  
 650  4570 1101         JLT     H085                    flag: must be updated
 651  4572 1016         JMP     H086                    no need to update: return
 652  4574 0241 H085    ANDI    R1,>7F00                erase flag
 652  4576 7F00  
 653  4578 0429         BLWP    @>005A(R9)              set VDP to write
 653  457A 005A  
 654  457C 0083         DATA    >0083                   address in R4
 655  457E DBC1         MOVB    R1,@-2(R15)             write back drive # without flag
 655  4580 FFFE  
 656  4582 0224         AI      R4,-5                   point to current logical record offset
 656  4584 FFFB  
 657  4586 0429         BLWP    @>005A(R9)              set VDP to read
 657  4588 005A  
 658  458A 0082         DATA    >0082                   address in R4
 659  458C D0EF         MOVB    @-1026(R15),R3          get current logical record offset
 659  458E FBFE  
 660  4590 06C3         SWPB    R3                      
 661  4592 D0EF         MOVB    @-1026(R15),R3                  
 661  4594 FBFE  
 662  4596 06C3         SWPB    R3                      
 663  4598 C1C4         MOV     R4,R7                   
 664  459A 0227         AI      R7,262                  point to data buffer area
 664  459C 0106  
 665  459E 103A         JMP     WROFSC                  
 666  45A0 0460 H086    B       @RTURN1                 return to caller
 666  45A2 4340  
 667            *                               
 668  45A4 C0A9 FFSVIB  MOV     @>0056(R9),R2           free file sectors in VIB bitmap
 668  45A6 0056  
 669  45A8 0222         AI      R2,12                   
 669  45AA 000C  
 670  45AC 0429         BLWP    @>005A(R9)              set VDP to read
 670  45AE 005A  
 671  45B0 0042         DATA    >0042                   address in R2
 672  45B2 D02F         MOVB    @-1026(R15),R0          get file status byte from FDR
 672  45B4 FBFE  
 673  45B6 0240         ANDI    R0,>0800                write protected?
 673  45B8 0800  
 674  45BA 1303         JEQ     H087                    no
 675  45BC 06A0         BL      @ERROR5                 update data if needed, the return with error
 675  45BE 493C  
 676  45C0 2000         DATA    >2000                   write protected
 677            *                                       
 678  45C2 C229 H087    MOV     @>0056(R9),R8           get ptr to FDR
 678  45C4 0056  
 679  45C6 0228         AI      R8,28                   point to clusters list
 679  45C8 001C  
 680  45CA 0704         SETO    R4                      previous offset
 681  45CC 06A0 H089    BL      @DECDCI                 decode cluster info: sector in R1, offset in R2
 681  45CE 4B80  
 682  45D0 0228         AI      R8,3                    next cluster ptr
 682  45D2 0003  
 683  45D4 C041         MOV     R1,R1                   
 684  45D6 130C         JEQ     H088                    sector 0 = no more clusters
 685  45D8 C002         MOV     R2,R0                   total offset
 686  45DA 6084         S       R4,R2                   minus previous cluster offset = cluster size
 687  45DC C100         MOV     R0,R4                   new previous cluster offset
 688  45DE 06A0         BL      @CALSUB                 call subroutine
 688  45E0 4322  
 689  45E2 4C8C         DATA    FRSCB1                  free sectors in bitmap (from R1, # in R2)
 690  45E4 C048         MOV     R8,R1                   
 691  45E6 6069         S       @>0056(R9),R1                   
 691  45E8 0056  
 692  45EA 0281         CI      R1,>0100                end of FDR reached?
 692  45EC 0100  
 693  45EE 16EE         JNE     H089                    not yet
 694  45F0 0460 H088    B       @RTURN1                 return to caller
 694  45F2 4340  
 695            *                                       
 696  45F4 06A0 RDOFSC  BL      @FDR2B1                 read a sector from offset in file
 696  45F6 483A  
 697  45F8 000E         DATA    14                      get # of sectors
 698  45FA 80C0         C       R0,R3                   is desired sector in file?
 699  45FC 1B03         JH      H090                    yes
 700  45FE 06A0         BL      @ERROR5                 no: update data, then return with error
 700  4600 493C  
 701  4602 A000         DATA    >A000                   past end-of-file
 702  4604 06A0 H090    BL      @CALSUB                 call subroutine
 702  4606 4322  
 703  4608 4714         DATA    FSCTOF                  find sector from cluster list
 704  460A A101         A       R1,R4                   put sector in R4
 705  460C 0702         SETO    R2                      code for read
 706  460E C147 H091    MOV     R7,R5                   buffer ptr
 707  4610 0460         B       @RWSEC                  read/write sector
 707  4612 4A18  
 708            *                                       
 709  4614 0429 WROFSC  BLWP    @>005A(R9)              write sector to offset in file offset in R3
 709  4616 005A  
 710  4618 8100         DATA    >8100                   save R0 and R7
 711  461A 06A0         BL      @CALSUB                 call subroutine
 711  461C 4322  
 712  461E 462A         DATA    APSCTS                  append enough sectors to reach that offset
 713  4620 0429         BLWP    @>005A(R9)              retrieve R0 and R7
 713  4622 005A  
 714  4624 8101         DATA    >8101                   
 715  4626 04C2         CLR     R2                      code for write
 716  4628 10F2         JMP     H091                    write sector
 717            *                               
 718  462A 06A0 APSCTS  BL      @FDR2B1                 append sector(s) to a file to get offset in R3
 718  462C 483A  
 719  462E 000E         DATA    14                      get # of sect from FDR
 720            *                                       
 721  4630 80C0         C       R0,R3                   is desired sector in file?
 722  4632 1B47         JH      H092                    yes: find it and return
 723  4634 C000         MOV     R0,R0                   
 724  4636 1301         JEQ     H093                    empty file
 725  4638 0600         DEC     R0                      last sector #
 726  463A C143 H093    MOV     R3,R5                   save desired sector offset
 727  463C C0C0         MOV     R0,R3                   last sector in file
 728  463E 06A0         BL      @CALSUB                 call subroutine
 728  4640 4322  
 729  4642 4714         DATA    FSCTOF                  find sector # from offset in file
 730  4644 0429         BLWP    @>005A(R9)              save R1 (sector #)
 730  4646 005A  
 731  4648 4000         DATA    >4000                   
 732  464A A044         A       R4,R1                   # of last sector in cluster
 733  464C C105         MOV     R5,R4                   offset of desired sector
 734  464E 06A0 H095    BL      @CALSUB                 call subroutine
 734  4650 4322  
 735  4652 4BC0         DATA    FFSBMP                  find free sector in bitmap, starting from R1
 736  4654 C000         MOV     R0,R0                   found?
 737  4656 1604         JNE     H094                    yes: # in R0
 738  4658 C142         MOV     R2,R5                   no: save # of sectors
 739  465A 06A0         BL      @ADDSEC                 update FDR
 739  465C 46CE  
 740  465E 101B         JMP     H096                    return with memory full
 741            *                                       
 742  4660 C041 H094    MOV     R1,R1                   
 743  4662 1320         JEQ     H097                    empty cluster
 744  4664 0581         INC     R1                      one more sector in cluster
 745  4666 8040         C       R0,R1                   same as the one found in bitmap?
 746  4668 131C         JEQ     H098                    yes: just increase cluster size
 747  466A 0429         BLWP    @>005A(R9)              no: retrieve R1 (sector #)
 747  466C 005A  
 748  466E 4001         DATA    >4001                   
 749  4670 0429         BLWP    @>005A(R9)              save R0 + R2
 749  4672 005A  
 750  4674 A000         DATA    >A000                   
 751  4676 06A0         BL      @UPDCLI                 update current cluster info
 751  4678 4B9C  
 752  467A 0429         BLWP    @>005A(R9)              retrieve R0 + R2
 752  467C 005A  
 753  467E A001         DATA    >A001                   
 754  4680 0228         AI      R8,3                    ptr to next cluster info
 754  4682 0003  
 755  4684 C048         MOV     R8,R1                   
 756  4686 6069         S       @>0056(R9),R1           current FDR size
 756  4688 0056  
 757  468A 0281         CI      R1,>0100                room enough?
 757  468C 0100  
 758  468E 1605         JNE     H099                    yes
 759  4690 06A0         BL      @CALSUB                 no: call subroutine
 759  4692 4322  
 760  4694 4C86         DATA    FFSBM                   free sector in bitmap
 761  4696 0460 H096    B       @ERROR6                 return with memory full
 761  4698 4AF2  
 762            *                                       
 763  469A C040 H099    MOV     R0,R1                   new sector #
 764  469C 0429         BLWP    @>005A(R9)              save R1
 764  469E 005A  
 765  46A0 4000         DATA    >4000                   
 766  46A2 1007 H098    JMP     H100                    make a new cluster
 767            *                                       
 768  46A4 0429 H097    BLWP    @>005A(R9)              retrieve R1
 768  46A6 005A  
 769  46A8 4001         DATA    >4001                   
 770  46AA 0429         BLWP    @>005A(R9)              save R0
 770  46AC 005A  
 771  46AE 8000         DATA    >8000                   
 772  46B0 0702         SETO    R2                      empty file: start from offset 0
 773  46B2 C040 H100    MOV     R0,R1                   sector #
 774  46B4 0582         INC     R2                      increment cluster size
 775  46B6 8102         C       R2,R4                   enough?
 776  46B8 16CA         JNE     H095                    no: get one more sector
 777  46BA C144         MOV     R4,R5                   
 778  46BC 06A0         BL      @ADDSEC                 add sector to FDR
 778  46BE 46CE  
 779  46C0 1004         JMP     H101                    done
 780            *                               
 781  46C2 06A0 H092    BL      @CALSUB                 call subroutine
 781  46C4 4322  
 782  46C6 4714         DATA    FSCTOF                  find a sector from offset in file
 783  46C8 A101         A       R1,R4                   last sector in cluster
 784  46CA 0460 H101    B       @RTURN1                 return to caller
 784  46CC 4340  
 785            *                                       
 786  46CE C28B ADDSEC  MOV     R11,R10                 add sector to FDR
 787  46D0 C101         MOV     R1,R4                   
 788  46D2 0429         BLWP    @>005A(R9)              retrieve R1
 788  46D4 005A  
 789  46D6 4001         DATA    >4001                   
 790  46D8 C041         MOV     R1,R1                   sector #
 791  46DA 131B         JEQ     H102                    none: return
 792  46DC 06A0         BL      @UPDCLI                 write info for R1 cluster
 792  46DE 4B9C  
 793  46E0 C0A9         MOV     @>0056(R9),R2           pointer to FDR
 793  46E2 0056  
 794  46E4 0429         BLWP    @>005A(R9)              set VDP to read
 794  46E6 005A  
 795  46E8 0042         DATA    >0042                   address in R2
 796  46EA D06F         MOVB    @-1026(R15),R1          first char of filename
 796  46EC FBFE  
 797  46EE 0261         ORI     R1,>8000                flag
 797  46F0 8000  
 798  46F2 0429         BLWP    @>005A(R9)              set VDP to write
 798  46F4 005A  
 799  46F6 0043         DATA    >0043                   address in R2
 800  46F8 DBC1         MOVB    R1,@-2(R15)                     
 800  46FA FFFE  
 801  46FC 0222         AI      R2,14                   ptr to # of sectors
 801  46FE 000E  
 802  4700 0585         INC     R5                      new # of sectors
 803  4702 0429         BLWP    @>005A(R9)              set VDP to write
 803  4704 005A  
 804  4706 0043         DATA    >0043                   address in R2
 805  4708 DBC5         MOVB    R5,@-2(R15)             update # of sectors
 805  470A FFFE  
 806  470C 06C5         SWPB    R5                      
 807  470E DBC5         MOVB    R5,@-2(R15)                     
 807  4710 FFFE  
 808  4712 045A H102    B       *R10                    
 809            *                                       
 810  4714 C229 FSCTOF  MOV     @>0056(R9),R8           find sector from offset in file
 810  4716 0056  
 811  4718 0228         AI      R8,28                   cluster list
 811  471A 001C  
 812  471C C103         MOV     R3,R4                   desired sector offset is in R3
 813  471E 06A0 H105    BL      @DECDCI                 decode info: sector in R1, offset in R2
 813  4720 4B80  
 814  4722 80C2         C       R2,R3                   reached yet?
 815  4724 1101         JLT     H103                    no
 816  4726 1006         JMP     H104                    yes: return
 817  4728 0228 H103    AI      R8,3                    point to next cluster info
 817  472A 0003  
 818  472C C103         MOV     R3,R4                   
 819  472E 6102         S       R2,R4                   
 820  4730 0604         DEC     R4                      size of the desired cluster (if it's the next)
 821  4732 10F5         JMP     H105                    keep trying
 822  4734 0460 H104    B       @RTURN1                 return to caller
 822  4736 4340  
 823            *
 824            *---------------------------------
 825            * Opcode 7: Delete
 826            * ----------------
 827            * PAB 0: >07
 828            *     1:            <--- error code
 829            *   2-3:
 830            *     4:
 831            *     5:
 832            *   6-7:
 833            *     8:
 834            *---------------------------------                                      
 835            *
 836  4738 06A0 DELETE  BL      @CALSUB                 delete file
 836  473A 4322  
 837  473C 4A6E         DATA    FFFDRV                  find file FDR in VDP buffers
 838  473E C104         MOV     R4,R4                   found?
 839  4740 1307         JEQ     H106                    yes
 840  4742 06A0         BL      @CALSUB                 no: call subroutine
 840  4744 4322  
 841  4746 4AD6         DATA    FFDRDK                  find FDR on disk
 842  4748 C104         MOV     R4,R4                   found?
 843  474A 1313         JEQ     H107                    yes
 844  474C 0460         B       @RTURN1                 no: return to caller
 844  474E 4340  
 845            *                                       
 846  4750 0581 H106    INC     R1                      FDR found, point to it
 847  4752 CA41         MOV     R1,@>0056(R9)           save it for other routines
 847  4754 0056  
 848  4756 06A0         BL      @CALSUB                 call subroutine
 848  4758 4322  
 849  475A 49FE         DATA    RDSEC1                  read sector 1
 850  475C 06A0         BL      @FDR2B1                 read 2 bytes from VDP at >8356+offset
 850  475E 483A  
 851  4760 FFFC         DATA    -4                      i.e. get sector # of FRD in R0
 852  4762 C0C0         MOV     R0,R3                   save it for later
 853  4764 C205         MOV     R5,R8                   ptr to top of sector 1
 854  4766 06A0 H108    BL      @VDPR2B                 read 2 bytes from VDP at R8 into R0
 854  4768 4840  
 855  476A 05C8         INCT    R8                      next FDR ptr in sector 1
 856  476C 80C0         C       R0,R3                   is this the one we want?
 857  476E 16FB         JNE     H108                    not yet
 858  4770 0648         DECT    R8                      yes: point back to it
 859            *
 860  4772 06A0 H107    BL      @NTPDT                  APEDSK99: update DOAD FAT time/date
 860  4774 5E0E  
 861            *
 862  4776 0429         BLWP    @>005A(R9)              save R8
 862  4778 005A  
 863  477A 0080         DATA    >0080                   
 864  477C 06A0         BL      @CALSUB                 call subroutine
 864  477E 4322  
 865  4780 45A4         DATA    FFSVIB                  free file sectors in VIB bitmap
 866  4782 0429         BLWP    @>005A(R9)              retrieve R8
 866  4784 005A  
 867  4786 0081         DATA    >0081                   
 868  4788 06A0         BL      @RMFPTR                 remove FDR ptr from sector 1
 868  478A 47A4  
 869  478C 04C2         CLR     R2                      code for write
 870  478E 06A0         BL      @CALSUB                 call subroutine
 870  4790 4322  
 871  4792 4A00         DATA    WRSEC1                  write sector 1
 872  4794 06A0         BL      @FDR2B1                 get 2 bytes from VDP at >8356+offset in R0
 872  4796 483A  
 873  4798 FFFC         DATA    -4                      i.e. sector # of FDR
 874  479A 06A0         BL      @CALSUB                 call subroutine
 874  479C 4322  
 875  479E 4C86         DATA    FFSBM                   free sector in R0 in VIB bitmap
 876  47A0 0460         B       @CLRFBT                 clear 1rst byte of filename in VDP
 876  47A2 454C  
 877            *
 878            * Sector 1 contains an alphabetically sorted list of FDR pointers
 879            * Each pointer is 2 bytes long and contains the sector # of this FDR
 880            * The list must end with a >0000 mark. Thus there can be 127 files at most
 881            *
 882  47A4 C169 RMFPTR  MOV     @>0056(R9),R5           remove FDR ptr from sector 1
 882  47A6 0056  
 883  47A8 0225         AI      R5,256                  
 883  47AA 0100  
 884  47AC C0C5         MOV     R5,R3                   pointer to data buffer
 885  47AE 0223         AI      R3,256                  point to next ctrl block
 885  47B0 0100  
 886  47B2 C088         MOV     R8,R2                   shift up FDR list, erasing FDR pointed by R8
 887  47B4 05C2         INCT    R2                      point to next FDR ptr in sector 1
 888  47B6 0429 H109    BLWP    @>005A(R9)              set VDP to read
 888  47B8 005A  
 889  47BA 0042         DATA    >0042                   address in R2
 890  47BC D02F         MOVB    @-1026(R15),R0          get 1 byte
 890  47BE FBFE  
 891  47C0 0582         INC     R2                      inc source ptr
 892  47C2 0429         BLWP    @>005A(R9)              set VDP to write
 892  47C4 005A  
 893  47C6 0103         DATA    >0103                   address in R8
 894  47C8 DBC0         MOVB    R0,@-2(R15)             copy 1 byte
 894  47CA FFFE  
 895  47CC 0588         INC     R8                      inc dest pointer
 896  47CE 80C2         C       R2,R3                   done?
 897  47D0 16F2         JNE     H109                    not yet
 898  47D2 045B         B       *R11                    
 899            *                                       
 900  47D4 C28B INSFDR  MOV     R11,R10                 insert a FDR in sector 1
 901  47D6 C048         MOV     R8,R1                   
 902  47D8 06A0         BL      @FDR2B1                 get 2 bytes from VDP at >8356+offset
 902  47DA 483A  
 903  47DC 01FC         DATA    508                     i.e. last FDR slot in sector 1 (list ends with 0)
 904  47DE C000         MOV     R0,R0                   
 905  47E0 1302         JEQ     H110                    
 906  47E2 0460         B       @ERROR6                 memory full error
 906  47E4 4AF2  
 907  47E6 0608 H110    DEC     R8                      previous byte
 908  47E8 0429         BLWP    @>005A(R9)              set VDP to read
 908  47EA 005A  
 909  47EC 0102         DATA    >0102                   address in R8
 910  47EE D02F         MOVB    @-1026(R15),R0          get 1 byte
 910  47F0 FBFE  
 911  47F2 05C8         INCT    R8                      
 912  47F4 0429         BLWP    @>005A(R9)              set VDP to write
 912  47F6 005A  
 913  47F8 0103         DATA    >0103                   address in R8
 914  47FA DBC0         MOVB    R0,@-2(R15)             copy byte two bytes further down
 914  47FC FFFE  
 915  47FE 0648         DECT    R8                      
 916  4800 8048         C       R8,R1                   done ?
 917  4802 16F1         JNE     H110                    not yet
 918  4804 045A         B       *R10                    
 919            *                               
 920  4806 C0A9 CMPFN   MOV     @>0058(R9),R2           compare filenames
 920  4808 0058  
 921  480A 0222         AI      R2,256                  
 921  480C 0100  
 922  480E 0429 H111    BLWP    @>005A(R9)              set VDP to read
 922  4810 005A  
 923  4812 0022         DATA    >0022                   address in R1 (ptr to filename)
 924  4814 D02F         MOVB    @-1026(R15),R0          get 1 char
 924  4816 FBFE  
 925  4818 0240         ANDI    R0,>7FFF                clear flag (on drive #)
 925  481A 7FFF  
 926  481C 0429         BLWP    @>005A(R9)              set VDP to read
 926  481E 005A  
 927  4820 0042         DATA    >0042                   address in R2 (filename compare buffer)
 928  4822 D0EF         MOVB    @-1026(R15),R3          get 1 char
 928  4824 FBFE  
 929  4826 90C0         CB      R0,R3                   compare chars
 930  4828 1604         JNE     H112                    mismatch
 931  482A 0581         INC     R1                      match: increment pointers
 932  482C 0582         INC     R2                      
 933  482E 0604         DEC     R4                      
 934  4830 16EE         JNE     H111                    next char
 935  4832 045B H112    B       *R11                    if complete match: ret with EQ set
 936            *                                       
 937  4834 C229 PABR2B  MOV     @>0054(R9),R8           get two bytes from PAB
 937  4836 0054  
 938  4838 1002         JMP     FDR2B2                  
 939            *                                       
 940  483A C229 FDR2B1  MOV     @>0056(R9),R8           get two bytes from FDR
 940  483C 0056  
 941  483E A23B FDR2B2  A       *R11+,R8                offset in data word
 942            *                                       
 943  4840 0429 VDPR2B  BLWP    @>005A(R9)              get two byte from VDP at R8
 943  4842 005A  
 944  4844 0102         DATA    >0102                   set VDP to read at R8
 945  4846 D02F         MOVB    @-1026(R15),R0          get two bytes of data
 945  4848 FBFE  
 946  484A 06C0         SWPB    R0                      
 947  484C D02F         MOVB    @-1026(R15),R0                  
 947  484E FBFE  
 948  4850 0B80         SRC     R0,8                    why not swpb ?
 949  4852 045B         B       *R11                    
 950            *                       
 951  4854 C069 FDSKDR  MOV     @>0058(R9),R1           find disk from name (ptr in R3)
 951  4856 0058  
 952  4858 0221         AI      R1,256                  
 952  485A 0100  
 953  485C 06A0         BL      @CPCKFN                 copy filename from VDP at R3 to compare buffer
 953  485E 48DE  
 954  4860 0429         BLWP    @>005A(R9)              save R2 + R3
 954  4862 005A  
 955  4864 3000         DATA    >3000                   
 956  4866 C000         MOV     R0,R0                   last char copied
 957  4868 1101         JLT     H113                    flagged
 958  486A 1005         JMP     H114                    
 959  486C C180 H113    MOV     R0,R6                   
 960  486E 0246         ANDI    R6,>0300                        
 960  4870 0300  
 961  4872 1337         JEQ     ERROR7                  return with file error
 962  4874 102F         JMP     H115                    return to caller
 963  4876 04C6 H114    CLR     R6                      don't read any drive
 964  4878 06A0         BL      @CALSUB                 call subroutine
 964  487A 4322  
 965  487C 499C         DATA    RWVIB                   save current VIB
 966  487E 0226 H116    AI      R6,>0100                next drive
 966  4880 0100  
 967  4882 0707         SETO    R7                      error flags
 968  4884 0702         SETO    R2                      code for read
 969  4886 04C4         CLR     R4                      sector 0
 970  4888 06A0         BL      @CALSUB                 call subroutine
 970  488A 4322  
 971  488C 4A1A         DATA    RWSECA                  read sector 0
 972  488E C1C7         MOV     R7,R7                   ok?
 973  4890 161D         JNE     H118                    no: try next drive
 974  4892 0204         LI      R4,10                   yes: diskname size
 974  4894 000A  
 975  4896 C069         MOV     @>0058(R9),R1           VIB ptr
 975  4898 0058  
 976  489A 0429         BLWP    @>005A(R9)              save R1-R3
 976  489C 005A  
 977  489E 7000         DATA    >7000                   
 978  48A0 06A0         BL      @CMPFN                  compare names (ptr in R1 + compare buffer)
 978  48A2 4806  
 979  48A4 0429         BLWP    @>005A(R9)                      
 979  48A6 005A  
 980  48A8 7001         DATA    >7001                   retrieve R1-R3
 981  48AA C104         MOV     R4,R4                   name matched?
 982  48AC 160F         JNE     H118                    no: try next drive
 983  48AE C006         MOV     R6,R0                   drive #
 984  48B0 0260         ORI     R0,>8000                add update flag
 984  48B2 8000  
 985  48B4 0429         BLWP    @>005A(R9)              set VDP to write
 985  48B6 005A  
 986  48B8 0063         DATA    >0063                   address in R3
 987  48BA DBC0         MOVB    R0,@-2(R15)             copy drive+flag before diskname in source
 987  48BC FFFE  
 988  48BE 0605         DEC     R5                      before sector 0 copy
 989  48C0 0429         BLWP    @>005A(R9)              set VDP to write
 989  48C2 005A  
 990  48C4 00A3         DATA    >00A3                   address in R5
 991  48C6 DBC6         MOVB    R6,@-2(R15)             copy drive # before VIB
 991  48C8 FFFE  
 992  48CA 1004         JMP     H115                    done
 993            *                               
 994  48CC 0286 H118    CI      R6,>0300                did we do all drives?
 994  48CE 0300  
 995  48D0 16D6         JNE     H116                    no: try next on
 996  48D2 1007         JMP     ERROR7                  return with file error
 997            *                                       
 998  48D4 0429 H115    BLWP    @>005A(R9)              retrieve R2 + R3
 998  48D6 005A  
 999  48D8 3001         DATA    >3001                   
1000  48DA 0460         B       @RTURN1                 return to caller
1000  48DC 4340  
1001            *                               
1002  48DE 0602 CPCKFN  DEC     R2                      
1003  48E0 1B03         JH      H119                    
1004  48E2 06A0 ERROR7  BL      @RETERR                 return with error
1004  48E4 4968  
1005  48E6 E000         DATA    >E000                   file error
1006            *                                       
1007  48E8 0200 H119    LI      R0,>2000                copy (+check) filename in VDP from R3 to R1 (space)
1007  48EA 2000  
1008  48EC 0429         BLWP    @>005A(R9)              set VDP to write
1008  48EE 005A  
1009  48F0 0023         DATA    >0023                   address in R1
1010  48F2 0208         LI      R8,10                   10 chars per filename
1010  48F4 000A  
1011  48F6 DBC0 H120    MOVB    R0,@-2(R15)             fill filename with spaces
1011  48F8 FFFE  
1012  48FA 0608         DEC     R8                      
1013  48FC 16FC         JNE     H120                    
1014  48FE 0208         LI      R8,11                   11 chars countring drive #
1014  4900 000B  
1015  4902 0583 H122    INC     R3                      increment source ptr
1016  4904 0429         BLWP    @>005A(R9)              set VDP to read
1016  4906 005A  
1017  4908 0062         DATA    >0062                   address in R3
1018  490A D02F         MOVB    @-1026(R15),R0          get a char
1018  490C FBFE  
1019  490E 13E9         JEQ     ERROR7                  >00: return with file error
1020  4910 1110         JLT     H121                    flag bit set
1021  4912 0280         CI      R0,>2E00                        
1021  4914 2E00  
1022  4916 130D         JEQ     H121                    '.'
1023  4918 0608         DEC     R8                      
1024  491A 13E3         JEQ     ERROR7                  name to long: return with file error
1025  491C 0280         CI      R0,>2000                        
1025  491E 2000  
1026  4920 13E0         JEQ     ERROR7                  name can't contain spaces: file error again
1027  4922 0429         BLWP    @>005A(R9)              set VDP to write
1027  4924 005A  
1028  4926 0023         DATA    >0023                   address in R1
1029  4928 DBC0         MOVB    R0,@-2(R15)             copy 1 char
1029  492A FFFE  
1030  492C 0581         INC     R1                      increment destination pointer
1031  492E 0602         DEC     R2                      more?
1032  4930 16E8         JNE     H122                    yes
1033  4932 0288 H121    CI      R8,>000B                name can't be 0 chars long
1033  4934 000B  
1034  4936 13D5         JEQ     ERROR7                  else return with file error
1035  4938 045B         B       *R11                    
1036            *                                       
1037  493A AA00 K014    DATA    >AA00                   
1038            *                               
1039  493C C00B ERROR5  MOV     R11,R0                  update data, then error
1040  493E C0E9         MOV     @>0056(R9),R3           
1040  4940 0056  
1041  4942 0603         DEC     R3                      see what >8356 is pointing at
1042  4944 0429         BLWP    @>005A(R9)              set VDP to read
1042  4946 005A  
1043  4948 0062         DATA    >0062                   address in R3
1044  494A D0AF         MOVB    @-1026(R15),R2          get 1 byte
1044  494C FBFE  
1045  494E 9802         CB      R2,@K014                is it >AA (disk buffer area mark)
1045  4950 493A  
1046  4952 1309         JEQ     H123                    yes: announce error (code in data word)
1047  4954 0429         BLWP    @>005A(R9)              no: >8356 points to a FDR. Save R0
1047  4956 005A  
1048  4958 8000         DATA    >8000                   
1049  495A 06A0         BL      @CALSUB                 call subroutine
1049  495C 4322  
1050  495E 4540         DATA    UPDFDR                  update FRD and data buffer if needed
1051  4960 0429         BLWP    @>005A(R9)              retrieve R0
1051  4962 005A  
1052  4964 8001         DATA    >8001                   
1053  4966 C2C0 H123    MOV     R0,R11                  
1054            *                               
1055  4968 C069 RETERR  MOV     @>0054(R9),R1           annouce error
1055  496A 0054  
1056  496C 130D         JEQ     H124                    no PAB
1057  496E 0581         INC     R1                      for DSRs: ptr to status byte
1058  4970 0429         BLWP    @>005A(R9)              set VDP to read
1058  4972 005A  
1059  4974 0022         DATA    >0022                   address in R2
1060  4976 D0AF         MOVB    @-1026(R15),R2          get file status byte
1060  4978 FBFE  
1061  497A E0BB         SOC     *R11+,R2                add error code
1062  497C 0429         BLWP    @>005A(R9)              set VDP to write
1062  497E 005A  
1063  4980 0023         DATA    >0023                   address in R2
1064  4982 DBC2         MOVB    R2,@-2(R15)             write back status byte
1064  4984 FFFE  
1065  4986 1002         JMP     H125                    
1066  4988 CA7B H124    MOV     *R11+,@>0050(R9)        for subs: error code in >8350
1066  498A 0050  
1067  498C C229 H125    MOV     @>0058(R9),R8           get stack ptr
1067  498E 0058  
1068  4990 0228         AI      R8,-12                  point back to initial caller
1068  4992 FFF4  
1069  4994 CA48         MOV     R8,@>0066(R9)           update pointer
1069  4996 0066  
1070  4998 0460         B       @RTURN1                 return to caller
1070  499A 4340  
1071            *                               
1072  499C 0429 RWVIB   BLWP    @>005A(R9)              read VIB (drive # in R6)
1072  499E 005A  
1073  49A0 3000         DATA    >3000                   save R2 + R3
1074  49A2 C169         MOV     @>0058(R9),R5           pointer to VIB in ctrl block
1074  49A4 0058  
1075  49A6 0605         DEC     R5                      ptr to drive #
1076  49A8 0429         BLWP    @>005A(R9)              set VDP for read
1076  49AA 005A  
1077  49AC 00A2         DATA    >00A2                   address in R5
1078  49AE D0AF         MOVB    @-1026(R15),R2          get drive #
1078  49B0 FBFE  
1079  49B2 C0C2         MOV     R2,R3                   
1080  49B4 04C4         CLR     R4                      sector 0 for VIB
1081  49B6 0242         ANDI    R2,>0300                clear flag (>80 = update data)
1081  49B8 0300  
1082  49BA 9182         CB      R2,R6                   wanted drive?
1083  49BC 131A         JEQ     H126                    yes: return
1084  49BE C0C3         MOV     R3,R3                   no: shall we update VIB?
1085  49C0 1101         JLT     H127                    yes
1086  49C2 100A         JMP     H128                    no
1087  49C4 0429 H127    BLWP    @>005A(R9)              set VDP to write
1087  49C6 005A  
1088  49C8 00A3         DATA    >00A3                   address in R5
1089  49CA DBC4         MOVB    R4,@-2(R15)             clr drive #
1089  49CC FFFE  
1090  49CE 0585         INC     R5                      point back to VIB buffer
1091  49D0 06A0         BL      @CALSUB                 call subroutine
1091  49D2 4322  
1092  49D4 4A1C         DATA    RWSECB                  write sector 0 to old drive (in R2)
1093  49D6 0605         DEC     R5                      point to drive #
1094  49D8 0702 H128    SETO    R2                      flag for read
1095  49DA D086         MOVB    R6,R2                   APEDSK99: error in original disassembly (was R5)
1096  49DC 1305         JEQ     H129                    none
1097  49DE 0585         INC     R5                      point at VIB buffer
1098  49E0 06A0         BL      @CALSUB                 call subroutine
1098  49E2 4322  
1099  49E4 4A1A         DATA    RWSECA                  read sector (in R4) to buffer (in R5)
1100  49E6 0605         DEC     R5                      point at drive #
1101  49E8 0429 H129    BLWP    @>005A(R9)              set VDP to write
1101  49EA 005A  
1102  49EC 00A3         DATA    >00A3                   address in R5
1103  49EE DBC6         MOVB    R6,@-2(R15)             write drive # in control block, before FDR
1103  49F0 FFFE  
1104  49F2 0585 H126    INC     R5                      point back to FDR
1105  49F4 0429         BLWP    @>005A(R9)                      
1105  49F6 005A  
1106  49F8 3001         DATA    >3001                   retrieve R2 + R3 from stack
1107  49FA 0460         B       @RTURN1                 branch to address on stack
1107  49FC 4340  
1108            *                               
1109  49FE 0702 RDSEC1  SETO    R2                      read sector 1
1110  4A00 0204 WRSEC1  LI      R4,1
1110  4A02 0001  
1111  4A04 0205         LI      R5,>0100                into data buffer area of current ctrl block
1111  4A06 0100  
1112  4A08 1005         JMP     RDFDR1                  
1113            *                               
1114  4A0A 06A0 WRFDR   BL      @FDR2B1                 read FDR
1114  4A0C 483A  
1115  4A0E FFFC         DATA    -4                      get sector # of FDR from control block
1116            *                               
1117  4A10 C100 RDFDR2  MOV     R0,R4                   sector read/write
1118  4A12 04C5         CLR     R5
1119  4A14 A169 RDFDR1  A       @>0056(R9),R5           point to FDR or data buffer
1119  4A16 0056  
1120  4A18 04C7 RWSEC   CLR     R7                      
1121  4A1A D086 RWSECA  MOVB    R6,R2                   add drive # for r/w flag
1122  4A1C 0429 RWSECB  BLWP    @>005A(R9)              save R0-R8
1122  4A1E 005A  
1123  4A20 FF80         DATA    >FF80                   
1124  4A22 CA44         MOV     R4,@>004A(R9)           sector #
1124  4A24 004A  
1125  4A26 CA42         MOV     R2,@>004C(R9)           drive | r/w flag
1125  4A28 004C  
1126  4A2A CA45         MOV     R5,@>004E(R9)           buffer ptr
1126  4A2C 004E  
1127  4A2E 06A0         BL      @CALSUB                 call subroutine
1127  4A30 4322  
1128  4A32 4178         DATA    SECRW1                  sector read/write
1129  4A34 0429         BLWP    @>005A(R9)              retrieve R0-R8
1129  4A36 005A  
1130  4A38 FF81         DATA    >FF81                   
1131  4A3A D1E9         MOVB    @>0050(R9),R7           get error code | flags
1131  4A3C 0050  
1132  4A3E 06C7         SWPB    R7                      
1133  4A40 1312         JEQ     H130                    
1134  4A42 C1C7         MOV     R7,R7                   
1135  4A44 1501         JGT     H131                    
1136  4A46 100B         JMP     H132                    
1137  4A48 0247 H131    ANDI    R7,>00FF                        
1137  4A4A 00FF  
1138  4A4C 0287         CI      R7,>0034                        
1138  4A4E 0034  
1139  4A50 1603         JNE     H133                    
1140  4A52 06A0         BL      @ERROR5                 
1140  4A54 493C  
1141  4A56 2000         DATA    >2000                   write protected
1142  4A58 06A0 H133    BL      @ERROR5                 
1142  4A5A 493C  
1143  4A5C C000         DATA    >C000                   device error
1144  4A5E DA69 H132    MOVB    @>004D(R9),@>004D(R9)   read or write?
1144  4A60 004D  
1144  4A62 004D  
1145  4A64 13F1         JEQ     H131                    write
1146  4A66 0247 H130    ANDI    R7,>00FF                        
1146  4A68 00FF  
1147  4A6A 0460         B       @RTURN1                 return to caller
1147  4A6C 4340  
1148            *                               
1149  4A6E C069 FFFDRV  MOV     @>0058(R9),R1           save filename in compare buffer and find its FDR
1149  4A70 0058  
1150  4A72 0221         AI      R1,256                  
1150  4A74 0100  
1151  4A76 0429         BLWP    @>005A(R9)              set VDP to write
1151  4A78 005A  
1152  4A7A 0023         DATA    >0023                   address in R1: filename compare buffer
1153  4A7C DBC6         MOVB    R6,@-2(R15)             write drive #
1153  4A7E FFFE  
1154  4A80 0581         INC     R1                      
1155  4A82 06A0         BL      @CPCKFN                 copy (+ check) filename from R3 to R1
1155  4A84 48DE  
1156  4A86 C082         MOV     R2,R2                   all chars copied (or was there a . or a >00
1157  4A88 1302         JEQ     FFDRVB                  
1158  4A8A 0460 H136    B       @ERROR7                 return with file error
1158  4A8C 48E2  
1159            *                                       
1160  4A8E C069 FFDRVB  MOV     @>0056(R9),R1           find filename in buffered FDRs
1160  4A90 0056  
1161  4A92 0221         AI      R1,3                    
1161  4A94 0003  
1162  4A96 0429         BLWP    @>005A(R9)              set VDP to read
1162  4A98 005A  
1163  4A9A 0022         DATA    >0022                   address in R1
1164  4A9C D0AF         MOVB    @-1026(R15),R2          get # of files
1164  4A9E FBFE  
1165  4AA0 0982         SRL     R2,8                    make it a word
1166  4AA2 C0C2         MOV     R2,R3                   save it
1167  4AA4 0221         AI      R1,6                    ptr to drive #
1167  4AA6 0006  
1168  4AA8 0204 H134    LI      R4,11                   compare 11 bytes (drive + filename)
1168  4AAA 000B  
1169  4AAC 0429         BLWP    @>005A(R9)              save R1-R3
1169  4AAE 005A  
1170  4AB0 7000         DATA    >7000                   
1171  4AB2 06A0         BL      @CMPFN                  compare with name in compare buffer
1171  4AB4 4806  
1172  4AB6 0429         BLWP    @>005A(R9)              retrieve R1-R3
1172  4AB8 005A  
1173  4ABA 7001         DATA    >7001                   
1174  4ABC C104         MOV     R4,R4                   fully compared?
1175  4ABE 1304         JEQ     H135                    yes: done
1176  4AC0 0221         AI      R1,518                  move to next FDR in VDP mem
1176  4AC2 0206  
1177  4AC4 0602         DEC     R2                      
1178  4AC6 16F0         JNE     H134                    next file
1179  4AC8 0460 H135    B       @RTURN1                 return to caller (R4=0 if successfull)
1179  4ACA 4340  
1180            *                               
1181  4ACC 06A0 FNDFDR  BL      @CALSUB                 
1181  4ACE 4322  
1182  4AD0 4A6E         DATA    FFFDRV                  save name in comp buffer, find FDR in VDP buffers
1183            *                                       
1184  4AD2 C104 FFDROD  MOV     R4,R4                   find FDR on disk (from filename)
1185  4AD4 13DA         JEQ     H136                    file error
1186  4AD6 C169 FFDRDK  MOV     @>0056(R9),R5           ptr to top of disk buffer in VDP mem
1186  4AD8 0056  
1187  4ADA 0225         AI      R5,10                   ptr to drive # in first file control block
1187  4ADC 000A  
1188  4ADE 0429 H138    BLWP    @>005A(R9)              set VDP to read
1188  4AE0 005A  
1189  4AE2 00A2         DATA    >00A2                   address in R5
1190  4AE4 D0AF         MOVB    @-1026(R15),R2          get drive #
1190  4AE6 FBFE  
1191  4AE8 1307         JEQ     H137                    free control block found
1192  4AEA 0225         AI      R5,518                  ptr to file control block
1192  4AEC 0206  
1193  4AEE 0603         DEC     R3                      
1194  4AF0 16F6         JNE     H138                    more files ?
1195  4AF2 06A0 ERROR6  BL      @ERROR5                 no:
1195  4AF4 493C  
1196  4AF6 8000         DATA    >8000                   memory full
1197            *                               
1198  4AF8 CA45 H137    MOV     R5,@>0056(R9)           save ptr to free ctrl block (drive #)
1198  4AFA 0056  
1199  4AFC 06A0         BL      @CALSUB                 call subroutine
1199  4AFE 4322  
1200  4B00 49FE         DATA    RDSEC1                  read sector 1
1201  4B02 C229 FFDRFN  MOV     @>0056(R9),R8           entry point if sector 1 already read
1201  4B04 0056  
1202  4B06 0228         AI      R8,382                  point to middle of sector 1
1202  4B08 017E  
1203  4B0A 0202         LI      R2,64                   distance: start with 1/4 sector
1203  4B0C 0040  
1204  4B0E 0704 H139    SETO    R4                      
1205  4B10 06A0         BL      @VDPR2B                 read 2 bytes in R0 from VDP address in R8
1205  4B12 4840  
1206  4B14 C000         MOV     R0,R0                   
1207  4B16 132E         JEQ     H140                    no file here: move up
1208  4B18 0429         BLWP    @>005A(R9)              save R2
1208  4B1A 005A  
1209  4B1C 2000         DATA    >2000                   
1210  4B1E 0702         SETO    R2                      code for read
1211  4B20 06A0         BL      @CALSUB                 call subroutine
1211  4B22 4322  
1212  4B24 4A10         DATA    RDFDR2                  read FDR, sector # in R0
1213  4B26 C045         MOV     R5,R1                   RDFDR2 sets R5 as FDR ptr
1214  4B28 0225         AI      R5,-4                   point to sector # of FDR in ctrl block
1214  4B2A FFFC  
1215  4B2C 0429         BLWP    @>005A(R9)              set VDP to write
1215  4B2E 005A  
1216  4B30 00A3         DATA    >00A3                   address in R5
1217  4B32 DBC4         MOVB    R4,@-2(R15)             RDFDR2 puts sector # in R4
1217  4B34 FFFE  
1218  4B36 06C4         SWPB    R4                      copy it to ctrl block
1219  4B38 DBC4         MOVB    R4,@-2(R15)                     
1219  4B3A FFFE  
1220  4B3C C141         MOV     R1,R5                   FDR ptr
1221  4B3E 0601         DEC     R1                      now point to drive #
1222  4B40 0429         BLWP    @>005A(R9)              set VDP to write
1222  4B42 005A  
1223  4B44 0023         DATA    >0023                   address in R1
1224  4B46 DBC6         MOVB    R6,@-2(R15)             save drive #
1224  4B48 FFFE  
1225  4B4A 0204         LI      R4,11                   size to compare (drive # + filename)
1225  4B4C 000B  
1226  4B4E 06A0         BL      @CMPFN                  compare filenames
1226  4B50 4806  
1227  4B52 0429         BLWP    @>005A(R9)              retrieve R2
1227  4B54 005A  
1228  4B56 2001         DATA    >2001                   
1229  4B58 130B         JEQ     H141                    compared ok: return
1230  4B5A 0429         BLWP    @>005A(R9)              set VDP to write
1230  4B5C 005A  
1231  4B5E 00A3         DATA    >00A3                   address in R5
1232  4B60 DBC4         MOVB    R4,@-2(R15)             remaining chars to compare
1232  4B62 FFFE  
1233  4B64 80C0         C       R0,R3                   what kind of mismatch occured?
1234  4B66 1B06         JH      H140                    too far down the alphabet
1235  4B68 A202         A       R2,R8                   too far up: move half-way down
1236  4B6A C082         MOV     R2,R2                   
1237  4B6C 1606         JNE     H142                    then divide distance by 2
1238  4B6E 05C8         INCT    R8                      already checked: reset EQ
1239  4B70 0460 H141    B       @RTURN1                 return (from stack)
1239  4B72 4340  
1240            *                               
1241  4B74 6202 H140    S       R2,R8                   move half-way up
1242  4B76 C082         MOV     R2,R2                   
1243  4B78 13FB         JEQ     H141                    can't: already checked
1244  4B7A 0922 H142    SRL     R2,2                    divide distance by 2
1245  4B7C A082         A       R2,R2                   but keep it even
1246  4B7E 10C7         JMP     H139                    
1247            *
1248            * The cluster info list is located in the FDR, bytes >1C to >FF
1249            * A cluster info consists in 3 bytes, i.e 6 nibbles
1250            * 3 nibbles specify the beginning sector for that cluster, and
1251            * 3 nibbles specify the total file offset in sectors, including this cluster.
1252            * The nibbles are arranged as EG SB OF, to be combined as BEG OFS
1253            *
1254  4B80 C28B DECDCI  MOV     R11,R10                 decode cluster info
1255  4B82 06A0         BL      @VDPR2B                 read 2 bytes VDP at R8 in R0
1255  4B84 4840  
1256  4B86 06C0         SWPB    R0                      
1257  4B88 D0AF         MOVB    @-1026(R15),R2          get third byte from cluster list
1257  4B8A FBFE  
1258  4B8C C040         MOV     R0,R1                   
1259  4B8E 0241         ANDI    R1,>0FFF                start sector in R1
1259  4B90 0FFF  
1260  4B92 4001         SZC     R1,R0                   remove it from R0
1261  4B94 0982         SRL     R2,8                    
1262  4B96 E080         SOC     R0,R2                   combine offset nibbles
1263  4B98 0BC2         SRC     R2,12                   offset in R2
1264  4B9A 045A         B       *R10                    
1265            *                               
1266  4B9C 0B42 UPDCLI  SRC     R2,4                    write info for 1 cluster
1267  4B9E C002         MOV     R2,R0                   
1268  4BA0 0240         ANDI    R0,>F000                sector in R1, offset in R2
1268  4BA2 F000  
1269  4BA4 E040         SOC     R0,R1                   copy nibble 3 of offset before nibble 1 of sector
1270  4BA6 0429         BLWP    @>005A(R9)              set VDP to write
1270  4BA8 005A  
1271  4BAA 0103         DATA    >0103                   address in R8
1272  4BAC 06C1         SWPB    R1                      write cluster info
1273  4BAE DBC1         MOVB    R1,@-2(R15)             as 3 bytes
1273  4BB0 FFFE  
1274  4BB2 06C1         SWPB    R1                      
1275  4BB4 DBC1         MOVB    R1,@-2(R15)                     
1275  4BB6 FFFE  
1276  4BB8 06C2         SWPB    R2                      
1277  4BBA DBC2         MOVB    R2,@-2(R15)                     
1277  4BBC FFFE  
1278  4BBE 045B         B       *R11                    
1279            *
1280            * The sector bitmap is located in the VIB (i.e. sector 0) at bytes >38 to >FF
1281            * In each byte a bit defines a sector, from right to left: "0"=free, "1"=used                                   
1282            *
1283  4BC0 0429 FFSBMP  BLWP    @>005A(R9)              find a free sector in bitmap
1283  4BC2 005A  
1284  4BC4 7800         DATA    >7800                   
1285  4BC6 06A0         BL      @CALSUB                 call subroutine
1285  4BC8 4322  
1286  4BCA 499C         DATA    RWVIB                   load VIB for drive in R6
1287  4BCC C041         MOV     R1,R1                   first sector specified in R1 ?
1288  4BCE 1602         JNE     H143                    yes
1289  4BD0 0201         LI      R1,33                   no: start with sector 34
1289  4BD2 0021  
1290  4BD4 0581 H143    INC     R1                      
1291  4BD6 C001         MOV     R1,R0                   
1292  4BD8 0931         SRL     R1,3                    div by 8 since 8 sect/byte in bitmap
1293  4BDA 0202         LI      R2,>00FF                        
1293  4BDC 00FF  
1294  4BDE 0240         ANDI    R0,>0007                bit number in bitmap byte
1294  4BE0 0007  
1295  4BE2 1301         JEQ     H144                    
1296  4BE4 0A02         SLA     R2,0                    get that bit
1297  4BE6 C0C1 H144    MOV     R1,R3                   byte #
1298  4BE8 A0C5         A       R5,R3                   add VIB ptr
1299  4BEA 0223         AI      R3,56                   ptr to sector in bitmap
1299  4BEC 0038  
1300  4BEE 0281         CI      R1,>00C8                end of VIB?
1300  4BF0 00C8  
1301  4BF2 1101         JLT     H145                    no
1302  4BF4 04C1         CLR     R1                      yes: top of bitmap
1303  4BF6 A045 H145    A       R5,R1                   
1304  4BF8 0221         AI      R1,56                   make another bitmap ptr
1304  4BFA 0038  
1305  4BFC 0429         BLWP    @>005A(R9)              set VDP to read
1305  4BFE 005A  
1306  4C00 0022         DATA    >0022                   address in R1
1307  4C02 0700 H146    SETO    R0                      
1308  4C04 D02F         MOVB    @-1026(R15),R0          get bitmap byte
1308  4C06 FBFE  
1309  4C08 C100         MOV     R0,R4                   save it
1310  4C0A E002         SOC     R2,R0                   mask previous sectors
1311  4C0C 04C2         CLR     R2                      
1312  4C0E 0580         INC     R0                      get 1 more sector
1313  4C10 1610         JNE     H147                    ok
1314  4C12 0581         INC     R1                      byte full: try next
1315  4C14 C001         MOV     R1,R0                   
1316  4C16 0220         AI      R0,-256                 won't change if byte # became >100
1316  4C18 FF00  
1317  4C1A 8140         C       R0,R5                   still in VIB?
1318  4C1C 1605         JNE     H148                    yes
1319  4C1E 0221         AI      R1,-200                 no: to top of bitmap
1319  4C20 FF38  
1320  4C22 0429         BLWP    @>005A(R9)              set VDP to read
1320  4C24 005A  
1321  4C26 0022         DATA    >0022                   address in R1
1322  4C28 80C1 H148    C       R1,R3                   are we back to where we started?
1323  4C2A 16EB         JNE     H146                    no: seach that byte for a free sector
1324  4C2C C004         MOV     R4,R0                   get original byte
1325  4C2E 0580         INC     R0                      try sectors just before ours (no mask this time)
1326  4C30 1325         JEQ     H149                    full: return with EQ
1327  4C32 0600 H147    DEC     R0                      restore original byte
1328  4C34 C080         MOV     R0,R2                   
1329  4C36 04C0         CLR     R0                      bit counter
1330  4C38 06C2         SWPB    R2                      
1331  4C3A 0580 H150    INC     R0                      increment bit count
1332  4C3C 0B12         SRC     R2,1                    find first 0 bit from the right
1333  4C3E 18FD         JOC     H150                    not yet
1334  4C40 0202         LI      R2,>0080                        
1334  4C42 0080  
1335  4C44 0A02         SLA     R2,0                    make a mask for that bit
1336  4C46 0600         DEC     R0                      bit # (0-7)
1337  4C48 E102         SOC     R2,R4                   mark sector as used in bitmap byte
1338  4C4A 0429         BLWP    @>005A(R9)              set VDP to write
1338  4C4C 005A  
1339  4C4E 0023         DATA    >0023                   address in R1
1340  4C50 DBC4         MOVB    R4,@-2(R15)             update bitmap
1340  4C52 FFFE  
1341  4C54 0221         AI      R1,-56                  
1341  4C56 FFC8  
1342  4C58 6045         S       R5,R1                   byte # in bitmap
1343  4C5A 0A31         SLA     R1,3                    times 8 (8 sect per byte)
1344  4C5C E040         SOC     R0,R1                   add bit #: = sector #
1345  4C5E C001         MOV     R1,R0                   save it
1346            *                               
1347  4C60 0605 H151    DEC     R5                      point to drive #
1348  4C62 0429         BLWP    @>005A(R9)              set VDP to read
1348  4C64 005A  
1349  4C66 00A2         DATA    >00A2                   address in R5
1350  4C68 D06F         MOVB    @-1026(R15),R1          get drive #
1350  4C6A FBFE  
1351  4C6C 0261         ORI     R1,>8000                add flag: update VIB
1351  4C6E 8000  
1352  4C70 0429         BLWP    @>005A(R9)              set VDP to write
1352  4C72 005A  
1353  4C74 00A3         DATA    >00A3                   address in R5
1354  4C76 DBC1         MOVB    R1,@-2(R15)             write back flagged drive #
1354  4C78 FFFE  
1355  4C7A 0585         INC     R5                      point to VIB (& return with NEQ)
1356  4C7C 0429 H149    BLWP    @>005A(R9)              retrieve R1-R4
1356  4C7E 005A  
1357  4C80 7801         DATA    >7801                   
1358  4C82 0460         B       @RTURN1                 return to caller
1358  4C84 4340  
1359            *                               
1360  4C86 C040 FFSBM   MOV     R0,R1                   free sector(s) in bitmap
1361  4C88 0202         LI      R2,1                    1 sector only
1361  4C8A 0001  
1362  4C8C 0429 FRSCB1  BLWP    @>005A(R9)              entry point if more than 1 sector
1362  4C8E 005A  
1363  4C90 7800         DATA    >7800                   save R1-R4
1364  4C92 06A0         BL      @CALSUB                 call subroutine
1364  4C94 4322  
1365  4C96 499C         DATA    RWVIB                   load VIB for drive in R6
1366  4C98 C001         MOV     R1,R0                   sector #
1367  4C9A 0240         ANDI    R0,>0007                bit in bitmap byte (8 per byte)
1367  4C9C 0007  
1368  4C9E 0931         SRL     R1,3                    byte in bitmap
1369  4CA0 A045         A       R5,R1                   add VIB buffer
1370  4CA2 0221         AI      R1,56                   add bitmap offset in VIB
1370  4CA4 0038  
1371  4CA6 C0C0         MOV     R0,R3                   
1372  4CA8 0500         NEG     R0                      
1373  4CAA 0220         AI      R0,8                    change 0-7 into 8-1
1373  4CAC 0008  
1374  4CAE 0204         LI      R4,>00FF                mask to erase
1374  4CB0 00FF  
1375  4CB2 8002         C       R2,R0                   how many to erase?
1376  4CB4 1101         JLT     H152                    less than in that byte
1377  4CB6 100A         JMP     H153                    
1378            *                               
1379  4CB8 0200 H152    LI      R0,8                    free sectors in first byte
1379  4CBA 0008  
1380  4CBC 6002         S       R2,R0                   
1381  4CBE 0B04         SRC     R4,0                    adjust mask
1382  4CC0 C003         MOV     R3,R0                   original bit # of starting sector
1383  4CC2 1301         JEQ     H154                    
1384  4CC4 0A04         SLA     R4,0                    don't erase before starting sector
1385  4CC6 1000 H154    JMP     H155                    
1386            *                               
1387  4CC8 06C4 H155    SWPB    R4                      
1388  4CCA 1019         JMP     H158                    goto erase last byte
1389            *                                       
1390  4CCC 0B04 H153    SRC     R4,0                    adjust mask
1391  4CCE 6080 H156    S       R0,R2                   that many will be freed
1392  4CD0 0429         BLWP    @>005A(R9)              set VDP to read
1392  4CD2 005A  
1393  4CD4 0022         DATA    >0022                   address in R1
1394  4CD6 D02F         MOVB    @-1026(R15),R0          get bitmap byte
1394  4CD8 FBFE  
1395  4CDA 4004         SZC     R4,R0                   mark sectors as free
1396  4CDC 0429         BLWP    @>005A(R9)              set VDP to write
1396  4CDE 005A  
1397  4CE0 0023         DATA    >0023                   address in R1
1398  4CE2 DBC0         MOVB    R0,@-2(R15)             write it back
1398  4CE4 FFFE  
1399  4CE6 0204         LI      R4,>FF00                clear full byte
1399  4CE8 FF00  
1400  4CEA 0581         INC     R1                      next byte
1401  4CEC 0200         LI      R0,8                    i.e. 8 sectors
1401  4CEE 0008  
1402  4CF0 8002         C       R2,R0                   how many more sectors?
1403  4CF2 1101         JLT     H157                    less than 8
1404  4CF4 10EC         JMP     H156                    8 or more: next byte
1405            *                                       
1406  4CF6 C002 H157    MOV     R2,R0                   remaining sectors
1407  4CF8 0204         LI      R4,>00FF                        
1407  4CFA 00FF  
1408  4CFC 0A04         SLA     R4,0                    coin mask
1409  4CFE 0429 H158    BLWP    @>005A(R9)              set VDP to read
1409  4D00 005A  
1410  4D02 0022         DATA    >0022                   address in R1
1411  4D04 D02F         MOVB    @-1026(R15),R0          get bitmap byte
1411  4D06 FBFE  
1412  4D08 4004         SZC     R4,R0                   mark sectors as free
1413  4D0A 0429         BLWP    @>005A(R9)              set VDP to write
1413  4D0C 005A  
1414  4D0E 0023         DATA    >0023                   address in R1
1415  4D10 DBC0         MOVB    R0,@-2(R15)             write it back
1415  4D12 FFFE  
1416  4D14 10A5         JMP     H151                    done: flag drive # and return
1417            *
1418            *===================================
1419            * DSR entry points
1420            *===================================                                    
1421            *
1422  4D16 C1CB EDSR01  MOV     R11,R7                  DSK
1423  4D18 06A0         BL      @PRPFDO                 --- prepare file operations
1423  4D1A 43EE  
1424  4D1C 06A0         BL      @CALSUB                 call subroutine
1424  4D1E 4322  
1425  4D20 4854         DATA    FDSKDR                  find disk in drive (name ptr in R3)
1426  4D22 100B         JMP     H159                    
1427            *                                       
1428  4D24 0206 EDSR02  LI      R6,>0100                DSK1
1428  4D26 0100  
1429  4D28 1005         JMP     H160                    ----
1430            *                                       
1431  4D2A 0206 EDSR03  LI      R6,>0200                DSK2
1431  4D2C 0200  
1432  4D2E 1002         JMP     H160                    ----
1433            *                                       
1434  4D30 0206 EDSR04  LI      R6,>0300                DSK3
1434  4D32 0300  
1435            *                                       
1436  4D34 C1CB H160    MOV     R11,R7                  save return address
1437  4D36 06A0         BL      @PRPFDO                 prepare file operations
1437  4D38 43EE  
1438  4D3A C029 H159    MOV     @>0054(R9),R0           PAB ptr
1438  4D3C 0054  
1439  4D3E 0429         BLWP    @>005A(R9)              set VDP to read
1439  4D40 005A  
1440  4D42 0002         DATA    >0002                   address in R0
1441  4D44 D06F         MOVB    @-1026(R15),R1          get opcode
1441  4D46 FBFE  
1442  4D48 0981         SRL     R1,8                    
1443  4D4A 0281         CI      R1,>0009                check range
1443  4D4C 0009  
1444  4D4E 1B19         JH      ERROR8                  illegal opcode
1445  4D50 0282         CI      R2,>0001                filename lenght (including . )
1445  4D52 0001  
1446  4D54 1605         JNE     H161                    no filename: dir
1447  4D56 0221         AI      R1,10                   only allow open, close and read
1447  4D58 000A  
1448  4D5A 0281         CI      R1,>000C                        
1448  4D5C 000C  
1449  4D5E 1B11         JH      ERROR8                  others are illegal
1450  4D60 A041 H161    A       R1,R1                   make it a word ptr
1451  4D62 C061         MOV     @OPCVEC(R1),R1          get vector
1451  4D64 4D68  
1452  4D66 0451         B       *R1                     branch to it
1453            *                                       
1454  4D68 4D88 OPCVEC  DATA    OPEN                    open
1455  4D6A 4F9A         DATA    CLOSE                   close
1456  4D6C 4FA4         DATA    READ                    read
1457  4D6E 508E         DATA    WRITE                   write
1458  4D70 5342         DATA    RWIND1                  rewind
1459  4D72 5396         DATA    LOAD                    load
1460  4D74 5438         DATA    SAVE                    save
1461  4D76 4738         DATA    DELETE                  delete
1462  4D78 4968         DATA    RETERR                  scratch record: return with bad attribute error
1463  4D7A 54BC         DATA    STATUS                  status
1464            *                                       
1465  4D7C 557C         DATA    OPNDIR                  open directory
1466  4D7E 55DA         DATA    CLSDIR                  close directory
1467  4D80 55F0         DATA    RDDIR                   read directory
1468            *                                       
1469  4D82 06A0 ERROR8  BL      @ERROR5                 return with error
1469  4D84 493C  
1470  4D86 6000         DATA    >6000                   illegal opcode
1471            *
1472            *---------------------------------
1473            * Opcode 0: Open
1474            * --------------
1475            * PAB 0: >00
1476            *     1: file type  <--- error code
1477            *   2-3:
1478            *     4: record length
1479            *     5:
1480            *   6-7: # of records (if output)
1481            *     8:
1482            *---------------------------------                                      
1483            *
1484  4D88 04C0 OPEN    CLR     R0                      
1485  4D8A D02F         MOVB    @-1026(R15),R0          get file attributes
1485  4D8C FBFE  
1486  4D8E 0429         BLWP    @>005A(R9)                      
1486  4D90 005A  
1487  4D92 8000         DATA    >8000                   save R0
1488  4D94 0240         ANDI    R0,>1600                keep fix/var and access mode
1488  4D96 1600  
1489  4D98 0280         CI      R0,>0600                        
1489  4D9A 0600  
1490  4D9C 1603         JNE     H162                    
1491  4D9E 06A0 ERROR9  BL      @ERROR5                 dis/fix, open as append: return with error
1491  4DA0 493C  
1492  4DA2 4000         DATA    >4000                   bad attribute
1493            *                                       
1494  4DA4 120A H162    JLE     H163                    
1495  4DA6 C040         MOV     R0,R1                   var
1496  4DA8 06A0         BL      @PABR2B                 get 2 bytes from PAB into R0
1496  4DAA 4834  
1497  4DAC 0004         DATA    4                       rec len and char count
1498  4DAE 0280         CI      R0,>FF00                is rec len 255?
1498  4DB0 FF00  
1499  4DB2 14F5         JHE     ERROR9                  yes: bad attribute
1500  4DB4 C001         MOV     R1,R0                   retrieve attributes
1501  4DB6 0240         ANDI    R0,>0600                keep only access mode
1501  4DB8 0600  
1502            *                                       
1503  4DBA 0280 H163    CI      R0,>0200                is it output?
1503  4DBC 0200  
1504  4DBE 1657         JNE     H164                    no
1505  4DC0 06A0         BL      @CALSUB                 call subroutine
1505  4DC2 4322  
1506  4DC4 445A         DATA    CRFIL1                  create file
1507  4DC6 06A0 H165    BL      @PRFDRS                 coin status byte in FDR style
1507  4DC8 4F48  
1508  4DCA 0429         BLWP    @>005A(R9)              set VDP to write
1508  4DCC 005A  
1509  4DCE 0083         DATA    >0083                   address in R4: status byte in FDR buffer
1510  4DD0 DBC2         MOVB    R2,@-2(R15)             write file status in FDR
1510  4DD2 FFFE  
1511  4DD4 C0E9         MOV     @>0054(R9),R3           PAB ptr
1511  4DD6 0054  
1512  4DD8 0223         AI      R3,4                    ptr to rec len
1512  4DDA 0004  
1513  4DDC 04C5         CLR     R5                      
1514  4DDE 0429         BLWP    @>005A(R9)              set VDP to read
1514  4DE0 005A  
1515  4DE2 0062         DATA    >0062                   address in R3
1516  4DE4 D16F         MOVB    @-1026(R15),R5          get record length
1516  4DE6 FBFE  
1517  4DE8 1607         JNE     H166                    
1518  4DEA 0205         LI      R5,>5000                >00: default it 80
1518  4DEC 5000  
1519  4DEE 0429         BLWP    @>005A(R9)              set VDP to write
1519  4DF0 005A  
1520  4DF2 0063         DATA    >0063                   address in R3
1521  4DF4 DBC5         MOVB    R5,@-2(R15)             write default rec len
1521  4DF6 FFFE  
1522  4DF8 0224 H166    AI      R4,5                    point to rec len byte in FDR
1522  4DFA 0005  
1523  4DFC 0429         BLWP    @>005A(R9)              set VDP to write
1523  4DFE 005A  
1524  4E00 0083         DATA    >0083                   address in R4
1525  4E02 DBC5         MOVB    R5,@-2(R15)             write rec len in FDR buffer
1525  4E04 FFFE  
1526  4E06 0201         LI      R1,256                  256 bytes/sector
1526  4E08 0100  
1527  4E0A C082         MOV     R2,R2                   var or dis?
1528  4E0C 1101         JLT     H167                    var
1529  4E0E 1002         JMP     H168                    dis
1530  4E10 A141 H167    A       R1,R5                   var: rec len +1
1531  4E12 0601         DEC     R1                      254 bytes only (needs size byte)
1532  4E14 06C5 H168    SWPB    R5                      make it a word
1533  4E16 04C0         CLR     R0                      
1534  4E18 3C05         DIV     R5,R0                   how many times in 254/255 bytes?
1535  4E1A 0224         AI      R4,-4                   point to # of rec/sect in FDR
1535  4E1C FFFC  
1536  4E1E C040         MOV     R0,R1                   save result for later
1537  4E20 06C0         SWPB    R0                      
1538  4E22 0429         BLWP    @>005A(R9)              set VDP to write
1538  4E24 005A  
1539  4E26 0083         DATA    >0083                   address in R4
1540  4E28 DBC0         MOVB    R0,@-2(R15)             write # of rec/sect in FDR
1540  4E2A FFFE  
1541  4E2C C229         MOV     @>0056(R9),R8           point to filename in FDR
1541  4E2E 0056  
1542  4E30 0429         BLWP    @>005A(R9)              set VDP to read
1542  4E32 005A  
1543  4E34 0102         DATA    >0102                   address in R8
1544  4E36 D02F         MOVB    @-1026(R15),R0          get first char
1544  4E38 FBFE  
1545  4E3A 0260         ORI     R0,>8000                flag it: update FDR before leaving
1545  4E3C 8000  
1546  4E3E 0429         BLWP    @>005A(R9)              set VDP to write
1546  4E40 005A  
1547  4E42 0103         DATA    >0103                   address in R8
1548  4E44 DBC0         MOVB    R0,@-2(R15)             write it back
1548  4E46 FFFE  
1549  4E48 0429         BLWP    @>005A(R9)                      
1549  4E4A 005A  
1550  4E4C 8001         DATA    >8001                   retrieve R0 (access mode)
1551  4E4E 06A0         BL      @PABR2B                 get 2 bytes from PAB into R0
1551  4E50 4834  
1552  4E52 0006         DATA    6                       required size in records
1553  4E54 C100         MOV     R0,R4                   
1554  4E56 1309         JEQ     H169                    no size specified
1555  4E58 11A2         JLT     ERROR9                  return with bad attribute error
1556  4E5A A101         A       R1,R4                   round up to record size
1557  4E5C 0604         DEC     R4                      
1558  4E5E 04C3         CLR     R3                      
1559  4E60 3CC1         DIV     R1,R3                   how many sectors will this be?
1560  4E62 0603         DEC     R3                      offset start from 0
1561  4E64 06A0         BL      @CALSUB                 call subroutine
1561  4E66 4322  
1562  4E68 462A         DATA    APSCTS                  add sectors to FDR to match offset in R3
1563  4E6A 0460 H169    B       @RWIND2                 initialise file control block and return to caller
1563  4E6C 5370  
1564            *                                       
1565  4E6E 0429 H164    BLWP    @>005A(R9)              not output
1565  4E70 005A  
1566  4E72 8000         DATA    >8000                   save R0
1567  4E74 06A0         BL      @CALSUB                 call subroutine
1567  4E76 4322  
1568  4E78 4ACC         DATA    FNDFDR                  find FDR on disk
1569  4E7A 0429         BLWP    @>005A(R9)                      
1569  4E7C 005A  
1570  4E7E 8001         DATA    >8001                   retrieve R0 (access mode)
1571  4E80 C104         MOV     R4,R4                   found FDR?
1572  4E82 1309         JEQ     H170                    yes
1573  4E84 0280         CI      R0,>0400                no: is file open as input?
1573  4E86 0400  
1574  4E88 1304         JEQ     H171                    yes: must exist
1575  4E8A 06A0         BL      @CALSUB                 no: call subroutine
1575  4E8C 4322  
1576  4E8E 446C         DATA    CRFIL3                  create file
1577  4E90 109A         JMP     H165                    
1578            *                                       
1579  4E92 0460 H171    B       @ERROR9                 return with bad attribute error
1579  4E94 4D9E  
1580            *                                       
1581  4E96 C1C0 H170    MOV     R0,R7                   save access mode
1582  4E98 06A0         BL      @PRFDRS                 prepare status byte for FDR
1582  4E9A 4F48  
1583  4E9C 0429         BLWP    @>005A(R9)              set VDP to read
1583  4E9E 005A  
1584  4EA0 0082         DATA    >0082                   address in R4 (status byte in FDR)
1585  4EA2 D02F         MOVB    @-1026(R15),R0          get current file status
1585  4EA4 FBFE  
1586  4EA6 C0C0         MOV     R0,R3                   save it
1587  4EA8 0243         ANDI    R3,>0800                is file write protected?
1587  4EAA 0800  
1588  4EAC 1306         JEQ     H172                    no
1589  4EAE 0287         CI      R7,>0400                yes: is it open as input?
1589  4EB0 0400  
1590  4EB2 1303         JEQ     H172                    no
1591  4EB4 06A0         BL      @ERROR5                 yes: return with error
1591  4EB6 493C  
1592  4EB8 2000         DATA    >2000                   write protected
1593            *                                       
1594  4EBA 0240 H172    ANDI    R0,>8300                keep only file type bits (V/F, D/I, Prg/Data)
1594  4EBC 8300  
1595  4EBE 2802         XOR     R2,R0                   compare with new (coined by PRFDRS)
1596  4EC0 16E8         JNE     H171                    different: bad attribute
1597  4EC2 C0E9         MOV     @>0054(R9),R3           PAB ptr
1597  4EC4 0054  
1598  4EC6 0223         AI      R3,4                    ptr to rec len in PAB
1598  4EC8 0004  
1599  4ECA 0224         AI      R4,5                    ptr to rec len in FDR
1599  4ECC 0005  
1600  4ECE 0429         BLWP    @>005A(R9)              set VDP to read
1600  4ED0 005A  
1601  4ED2 0082         DATA    >0082                   address in R4
1602  4ED4 D02F         MOVB    @-1026(R15),R0          get rec len from FDR
1602  4ED6 FBFE  
1603  4ED8 0429         BLWP    @>005A(R9)              set VDP to read
1603  4EDA 005A  
1604  4EDC 0062         DATA    >0062                   address in R3
1605  4EDE D0AF         MOVB    @-1026(R15),R2          get rec len from PAB
1605  4EE0 FBFE  
1606  4EE2 1302         JEQ     H173                    0 = keep current one
1607  4EE4 9080         CB      R0,R2                   are they identical?
1608  4EE6 16D5         JNE     H171                    no: bad attribute
1609  4EE8 0429 H173    BLWP    @>005A(R9)              set VDP to write
1609  4EEA 005A  
1610  4EEC 0063         DATA    >0063                   address in R3
1611  4EEE DBC0         MOVB    R0,@-2(R15)             update rec len in PAB (in case it was 0)
1611  4EF0 FFFE  
1612  4EF2 0429         BLWP    @>005A(R9)              retrieve R0 (open mode)
1612  4EF4 005A  
1613  4EF6 8001         DATA    >8001                   
1614  4EF8 0240         ANDI    R0,>0600                keep only access mode
1614  4EFA 0600  
1615  4EFC 04C2         CLR     R2                      
1616  4EFE 0703         SETO    R3                      
1617  4F00 0280         CI      R0,>0600                is it append
1617  4F02 0600  
1618  4F04 161D         JNE     H174                    no
1619  4F06 C129         MOV     @>0056(R9),R4           yes: get FDR ptr
1619  4F08 0056  
1620  4F0A C1C4         MOV     R4,R7                   save it
1621  4F0C 0224         AI      R4,14                   ptr to # of sectors
1621  4F0E 000E  
1622  4F10 0429         BLWP    @>005A(R9)              set VDP to read
1622  4F12 005A  
1623  4F14 0082         DATA    >0082                   address in R4
1624  4F16 D0EF         MOVB    @-1026(R15),R3          get # of sectors in file
1624  4F18 FBFE  
1625  4F1A 06C3         SWPB    R3                      
1626  4F1C D0EF         MOVB    @-1026(R15),R3                  
1626  4F1E FBFE  
1627  4F20 06C3         SWPB    R3                      
1628  4F22 D0AF         MOVB    @-1026(R15),R2          get eof offset
1628  4F24 FBFE  
1629  4F26 0603         DEC     R3                      offset starts from 0
1630  4F28 110B         JLT     H174                    file is empty (0 sectors)
1631  4F2A 0429         BLWP    @>005A(R9)                      
1631  4F2C 005A  
1632  4F2E 3000         DATA    >3000                   save R2 + R3
1633  4F30 0227         AI      R7,256                  ptr to data buffer area for this file
1633  4F32 0100  
1634  4F34 06A0         BL      @CALSUB                 call subroutine
1634  4F36 4322  
1635  4F38 45F4         DATA    RDOFSC                  read a sector, from offset in R3
1636  4F3A 0429         BLWP    @>005A(R9)                      
1636  4F3C 005A  
1637  4F3E 3001         DATA    >3001                   retrieve R2 + R3
1638  4F40 06A0 H174    BL      @UPDFCB                 update current record offset in file ctrl block
1638  4F42 4F72  
1639  4F44 0460         B       @RTURN1                 return to caller
1639  4F46 4340  
1640            *                                       
1641  4F48 0429 PRFDRS  BLWP    @>005A(R9)              prepare file status byte for FDR
1641  4F4A 005A  
1642  4F4C 8001         DATA    >8001                   access mode in R0
1643  4F4E 0429         BLWP    @>005A(R9)                      
1643  4F50 005A  
1644  4F52 8000         DATA    >8000                   save it back
1645  4F54 0202         LI      R2,2                    int in FDR status byte
1645  4F56 0002  
1646  4F58 C129         MOV     @>0056(R9),R4           FDR pointer
1646  4F5A 0056  
1647  4F5C 0A40         SLA     R0,4                    fix or var?
1648  4F5E 1703         JNC     H175                    fix
1649  4F60 0202         LI      R2,>0082                int var in FDR
1649  4F62 0082  
1650  4F64 C000         MOV     R0,R0                   dis or int?
1651  4F66 1101 H175    JLT     H176                    int
1652  4F68 0642         DECT    R2                      dis: remove the int from FDR status
1653  4F6A 0224 H176    AI      R4,12                   point at file status byte in FDR
1653  4F6C 000C  
1654  4F6E 06C2         SWPB    R2                      
1655  4F70 045B         B       *R11                    
1656            *                                       
1657  4F72 C129 UPDFCB  MOV     @>0056(R9),R4           update sect + rec offsets in file control block
1657  4F74 0056  
1658  4F76 0224         AI      R4,-6                   
1658  4F78 FFFA  
1659  4F7A 0429         BLWP    @>005A(R9)              set VDP to write
1659  4F7C 005A  
1660  4F7E 0083         DATA    >0083                   address in R4
1661  4F80 DBC3         MOVB    R3,@-2(R15)             write current sect offset
1661  4F82 FFFE  
1662  4F84 06C3         SWPB    R3                      
1663  4F86 DBC3         MOVB    R3,@-2(R15)                     
1663  4F88 FFFE  
1664  4F8A 0224         AI      R4,4                    point to logical rec offset (for var files)
1664  4F8C 0004  
1665  4F8E 0429         BLWP    @>005A(R9)              set VDP to write
1665  4F90 005A  
1666  4F92 0083         DATA    >0083                   address in R4
1667  4F94 DBC2         MOVB    R2,@-2(R15)             write record offset
1667  4F96 FFFE  
1668  4F98 045B         B       *R11                    
1669            *
1670            *----------------------------------
1671            * Opcode 1: Close
1672            * --------------
1673            * PAB 0: >01
1674            *     1:           <--- error code
1675            *   2-3:
1676            *     4:
1677            *     5:
1678            *   6-7:
1679            *     8:
1680            *----------------------------------                                     
1681            *
1682  4F9A 06A0 CLOSE   BL      @CALSUB                 call subroutine
1682  4F9C 4322  
1683  4F9E 5198         DATA    FFDRVP                  find file FDR
1684  4FA0 0460         B       @UPDFDR                 update FDR + data area, get VIB, return to caller
1684  4FA2 4540  
1685            *
1686            *----------------------------------
1687            * Opcode 2: Read
1688            * --------------
1689            * PAB 0: >02
1690            *     1: file type <--- error code
1691            *   2-3: data buffer address in VDP mem
1692            *     4:
1693            *     5: bytes read
1694            *   6-7: record #
1695            *     8:
1696            *
1697            * Logical records organisation whithin sectors
1698            *
1699            * Fixed records (e.g. rec length = 6)
1700            * 11 11 11 11 11 11 22 22 22 22 22 22 33 33 33 33 33 33 xx xx xx
1701            * Where 11=data for record 1, 22=record 2, 33=record 3, xx=junk bytes
1702            *
1703            * Variable records:
1704            * sz 11 11 11 11 11 11 11 sz 22 22 22 22 22 sz 33 33 FF xx xx xx
1705            * Where sz=record size, 11,22,33=record data, FF=end-of-sector mark, xx=junk
1706            *----------------------------------                                     
1707            *
1708  4FA4 06A0 READ    BL      @CALSUB                 call subroutine
1708  4FA6 4322  
1709  4FA8 5198         DATA    FFDRVP                  find FDR in VDP buffers, get status from PAB
1710  4FAA 0240         ANDI    R0,>0200                what type of access?
1710  4FAC 0200  
1711  4FAE 1302         JEQ     H177                    update or input: ok
1712  4FB0 0460 H179    B       @ERROR8                 append or output: error illegal opcode
1712  4FB2 4D82  
1713  4FB4 06A0 H177    BL      @RFDRST                 get status byte in R0, from FDR
1713  4FB6 51C4  
1714  4FB8 110A         JLT     H178                    var
1715  4FBA 06A0         BL      @RRNPAB                 fix: get rec # compare to # of recs/file
1715  4FBC 51D8  
1716  4FBE 1A03         JL      H180                    ok: in file
1717  4FC0 06A0 H181    BL      @ERROR5                 update data and return with error
1717  4FC2 493C  
1718  4FC4 A000         DATA    >A000                   eof reached
1719  4FC6 06A0 H180    BL      @CALSUB                 call subroutine
1719  4FC8 4322  
1720  4FCA 523E         DATA    RRFDR                   load record from disk into FDR data buffer area
1721  4FCC 1011         JMP     H182                    
1722            *                                       
1723  4FCE 06A0 H178    BL      @CALSUB                 var: call subroutine
1723  4FD0 4322  
1724  4FD2 502A         DATA    RRSEC                   load proper sector, point to rec in it
1725  4FD4 10F5         JMP     H181                    skipped if ok: return with eof reached
1726            *                                       
1727  4FD6 0582         INC     R2                      next byte in data buffer
1728  4FD8 A004         A       R4,R0                   add rec size to offset
1729  4FDA 0580         INC     R0                      room for end-of-sector mark
1730  4FDC C169         MOV     @>0056(R9),R5           FDR ptr
1730  4FDE 0056  
1731  4FE0 0645         DECT    R5                      point to var record offset in sector
1732  4FE2 06C0         SWPB    R0                      
1733  4FE4 0429         BLWP    @>005A(R9)              set VDP to write
1733  4FE6 005A  
1734  4FE8 00A3         DATA    >00A3                   address in R5
1735  4FEA DBC0         MOVB    R0,@-2(R15)             update var record offset in sector
1735  4FEC FFFE  
1736  4FEE C004         MOV     R4,R0                   save # of bytes to be read
1737  4FF0 C129 H182    MOV     @>0054(R9),R4           PAB ptr
1737  4FF2 0054  
1738  4FF4 0224         AI      R4,5                    point to char count
1738  4FF6 0005  
1739  4FF8 06C0         SWPB    R0                      
1740  4FFA 0429         BLWP    @>005A(R9)              set VDP to write
1740  4FFC 005A  
1741  4FFE 0083         DATA    >0083                   address in R4
1742  5000 DBC0         MOVB    R0,@-2(R15)             write # of char to be read
1742  5002 FFFE  
1743  5004 06C0         SWPB    R0                      make it a word
1744            *                                       
1745  5006 C000 WFDRPB  MOV     R0,R0                   check it
1746  5008 130E         JEQ     H183                    none: return
1747  500A 0429 H184    BLWP    @>005A(R9)              set VDP to read
1747  500C 005A  
1748  500E 0042         DATA    >0042                   address in R2
1749  5010 D0EF         MOVB    @-1026(R15),R3          read 1 byte from FDR data buffer area
1749  5012 FBFE  
1750  5014 0582         INC     R2                      increment source ptr
1751  5016 0429         BLWP    @>005A(R9)              set VDP to write
1751  5018 005A  
1752  501A 0023         DATA    >0023                   address in R1
1753  501C DBC3         MOVB    R3,@-2(R15)             write the byte in PAB data buffer
1753  501E FFFE  
1754  5020 0581         INC     R1                      increment destination ptr
1755  5022 0600         DEC     R0                      more to read?
1756  5024 16F2         JNE     H184                    yes
1757  5026 0460 H183    B       @RTURN1                 return to caller
1757  5028 4340  
1758            *                                       
1759  502A 06A0 RRSEC   BL      @RCOFCB                 load sector, point to record in it
1759  502C 5318  
1760  502E C0C3         MOV     R3,R3                   sector offset
1761  5030 1101         JLT     H185                    -1: top of file
1762  5032 1012         JMP     H186                    in file
1763  5034 C003 H185    MOV     R3,R0                   
1764  5036 0580         INC     R0                      next sector
1765  5038 8080         C       R0,R2                   compare to # of sect/file
1766  503A 13F5         JEQ     H183                    end-of-file reached: return to caller (JMP to err)
1767  503C 06A0         BL      @CALSUB                 call subroutine
1767  503E 4322  
1768  5040 4560         DATA    UPDBF                   update data buffer, if needed
1769  5042 C0C0         MOV     R0,R3                   desired offset
1770  5044 04C5         CLR     R5                      
1771  5046 06A0         BL      @UCOFCB                 update sect + rec offsets in control block
1771  5048 52B6  
1772  504A 0227         AI      R7,256                  point to data buffer area (R7 set by UCOFCB)
1772  504C 0100  
1773  504E 06A0         BL      @CALSUB                 call subroutine
1773  5050 4322  
1774  5052 45F4         DATA    RDOFSC                  read a sector, from offset in file (in R3)
1775  5054 04C0         CLR     R0                      
1776  5056 1004         JMP     H187                    
1777            *                                       
1778  5058 C000 H186    MOV     R0,R0                   in file: test var rec offset (from RCOFCB)
1779  505A 1602         JNE     H187                    inside sector
1780  505C 8080         C       R0,R2                   at beg of sector
1781  505E 13E3         JEQ     H183                    file is empty: return
1782  5060 C080 H187    MOV     R0,R2                   FDR data buffer will be added to R2 by AFDRPT
1783  5062 06A0         BL      @CALSUB                 call subroutine
1783  5064 4322  
1784  5066 5292         DATA    AFDRPT                  R2=byte in FDR data buf, R1=top of PAB data buf
1785  5068 0429         BLWP    @>005A(R9)              set VDP to read
1785  506A 005A  
1786  506C 0042         DATA    >0042                   address in R2
1787  506E D12F         MOVB    @-1026(R15),R4          get first byte (rec length)
1787  5070 FBFE  
1788  5072 0984         SRL     R4,8                    make it a word
1789  5074 C000         MOV     R0,R0                   var rec offset
1790  5076 1306         JEQ     H188                    
1791  5078 0284         CI      R4,>00FF                is it >FF (end of sector mark) ?
1791  507A 00FF  
1792  507C 1603         JNE     H188                    no
1793  507E 06A0         BL      @RCOFCB                 yes: get sect + rec offsets from control block
1793  5080 5318  
1794  5082 10D8         JMP     H185                    try again with next sector
1795            *                                       
1796  5084 0429 H188    BLWP    @>005A(R9)                      
1796  5086 005A  
1797  5088 0011         DATA    >0011                   retrieve return address from stack in R11
1798  508A 05CB         INCT    R11                     skip the JMP to eof reached error
1799  508C 045B         B       *R11                    
1800            *
1801            *------------------------------------
1802            * Opcode 3: Write
1803            * --------------
1804            * PAB 0: >03
1805            *     1: file type <--- error code
1806            *   2-3: data buffer address in VDP mem
1807            *     4:
1808            *     5: bytes to write
1809            *   6-7: record #
1810            *     8:
1811            *------------------------------------                                   
1812            *
1813  508E 06A0 WRITE   BL      @CALSUB                 call subroutine
1813  5090 4322  
1814  5092 5198         DATA    FFDRVP                  find FDR in VDP buffers
1815  5094 0240         ANDI    R0,>0600                keep only access mode
1815  5096 0600  
1816  5098 0280         CI      R0,>0400                is it input
1816  509A 0400  
1817  509C 1389         JEQ     H179                    yes: return with error illegal opcode
1818  509E 06A0         BL      @RFDRST                 get file status byte from FDR
1818  50A0 51C4  
1819  50A2 1113         JLT     H189                    var                     
1820  50A4 06A0         BL      @RRNPAB                 fix: get rec # from PAB, sect # in R0
1820  50A6 51D8  
1821  50A8 1A0C         JL      H190                    less that total rec/file
1822  50AA 0429         BLWP    @>005A(R9)              past eof: expand file
1822  50AC 005A  
1823  50AE D800         DATA    >D800                   save R0, R1, R3, R4
1824  50B0 C0C0         MOV     R0,R3                   desired sector offset
1825  50B2 06A0         BL      @CALSUB                 call subroutine
1825  50B4 4322  
1826  50B6 462A         DATA    APSCTS                  append enough sectors to reach offset in R3
1827  50B8 0429         BLWP    @>005A(R9)                      
1827  50BA 005A  
1828  50BC D801         DATA    >D801                   restore R0, R1, R3, R4
1829  50BE 06A0         BL      @URFFDR                 update # of rec/file in FDR
1829  50C0 52E2  
1830            *                                       
1831  50C2 06A0 H190    BL      @CALSUB                 in file: call subroutine
1831  50C4 4322  
1832  50C6 523E         DATA    RRFDR                   fetch rec from disk into FDR data buffer area
1833  50C8 1053         JMP     H191                    set update data flag, write data, return
1834            *                                       
1835  50CA 06A0 H189    BL      @RCOFCB                 var: R2=sect/file R3=sect offset R0=rec offset
1835  50CC 5318  
1836  50CE C0C3         MOV     R3,R3                   sector offset in file
1837  50D0 1101         JLT     H192                    -1: top of file
1838  50D2 100B         JMP     H193                    in file
1839  50D4 0429 H192    BLWP    @>005A(R9)              next sector loop
1839  50D6 005A  
1840  50D8 3000         DATA    >3000                   save R2 + R3
1841  50DA 06A0         BL      @CALSUB                 call subroutine
1841  50DC 4322  
1842  50DE 4560         DATA    UPDBF                   update data buffer if needed
1843  50E0 0429         BLWP    @>005A(R9)                      
1843  50E2 005A  
1844  50E4 3001         DATA    >3001                   retrieve R2 + R3
1845  50E6 0583         INC     R3                      next sector
1846  50E8 04C0         CLR     R0                      init char offset in sector
1847            *                                       
1848  50EA 8083 H193    C       R3,R2                   did we reach last sector?
1849  50EC 1609         JNE     H194                    no
1850  50EE 0429         BLWP    @>005A(R9)              yes: expand file
1850  50F0 005A  
1851  50F2 9000         DATA    >9000                   save R0 + R4
1852  50F4 06A0         BL      @CALSUB                 call subroutine
1852  50F6 4322  
1853  50F8 462A         DATA    APSCTS                  get last sector then append sectors to reach R3
1854  50FA 0429         BLWP    @>005A(R9)                      
1854  50FC 005A  
1855  50FE 9001         DATA    >9001                   retrieve R0 + R4
1856            *                                       
1857  5100 C169 H194    MOV     @>0054(R9),R5           PAB ptr
1857  5102 0054  
1858  5104 0225         AI      R5,5                    point to char count
1858  5106 0005  
1859  5108 0429         BLWP    @>005A(R9)              set VDP to read
1859  510A 005A  
1860  510C 00A2         DATA    >00A2                   address in R5
1861  510E D12F         MOVB    @-1026(R15),R4          get # of chars to write
1861  5110 FBFE  
1862  5112 0984         SRL     R4,8                    make it a word
1863  5114 C144         MOV     R4,R5                   
1864  5116 A140         A       R0,R5                   add current char offset in sector
1865  5118 0585         INC     R5                      make room for size byte
1866  511A 0285         CI      R5,>00FF                past end of sector?
1866  511C 00FF  
1867  511E 1BDA         JH      H192                    yes: not enough room, try next sector
1868  5120 0702         SETO    R2                      ok: rec will fit in sector
1869  5122 C069         MOV     @>0056(R9),R1           FDR ptr
1869  5124 0056  
1870  5126 A045         A       R5,R1                   past-last-byte offset
1871  5128 0221         AI      R1,256                  ptr to data buffer area
1871  512A 0100  
1872  512C 0429         BLWP    @>005A(R9)              set VDP to write
1872  512E 005A  
1873  5130 0023         DATA    >0023                   address in R1
1874  5132 DBC2         MOVB    R2,@-2(R15)             write end-of-sect mark to FDR data buffer area
1874  5134 FFFE  
1875  5136 0429         BLWP    @>005A(R9)                      
1875  5138 005A  
1876  513A 8000         DATA    >8000                   save R0 (current byte offset in sector)
1877  513C C003         MOV     R3,R0                   
1878  513E 06A0         BL      @UCOFCB                 update sect + rec offsets in control block
1878  5140 52B6  
1879  5142 0221         AI      R1,18                   point to eof offset in FDR (R1 modified by UCOFCB)
1879  5144 0012  
1880  5146 0429         BLWP    @>005A(R9)              set VDP to write
1880  5148 005A  
1881  514A 0023         DATA    >0023                   address in R1
1882  514C DBC5         MOVB    R5,@-2(R15)             update eof offset in last sector, in FDR
1882  514E FFFE  
1883  5150 06A0         BL      @URFFDR                 update # of rec/file in FDR
1883  5152 52E2  
1884  5154 0429         BLWP    @>005A(R9)                      
1884  5156 005A  
1885  5158 2001         DATA    >2001                   retrieve old R0 in R2 (current byte offset)
1886  515A C004         MOV     R4,R0                   record size
1887  515C 06A0         BL      @CALSUB                 call subroutine
1887  515E 4322  
1888  5160 5292         DATA    AFDRPT                  get FDR data buffer in R2, PAB data buffer in R1
1889  5162 06C4         SWPB    R4                      
1890  5164 0429         BLWP    @>005A(R9)              set VDP to write
1890  5166 005A  
1891  5168 0043         DATA    >0043                   address in R2
1892  516A DBC4         MOVB    R4,@-2(R15)             write size byte to FDR data buffer
1892  516C FFFE  
1893  516E 0582         INC     R2                      increment dest pointer
1894            *                                       
1895  5170 C0C2 H191    MOV     R2,R3                   invert source and dest
1896  5172 C081         MOV     R1,R2                   so we can use the same read-write loop
1897  5174 C043         MOV     R3,R1                   than the read opcode
1898  5176 C129         MOV     @>0056(R9),R4           FDR ptr
1898  5178 0056  
1899  517A 0604         DEC     R4                      pointer to drive # for that file
1900  517C 0429         BLWP    @>005A(R9)              set VDP to read
1900  517E 005A  
1901  5180 0082         DATA    >0082                   address in R4
1902  5182 D16F         MOVB    @-1026(R15),R5          get drive #
1902  5184 FBFE  
1903  5186 0265         ORI     R5,>8000                add update data area flag
1903  5188 8000  
1904  518A 0429         BLWP    @>005A(R9)              set VDP to write
1904  518C 005A  
1905  518E 0083         DATA    >0083                   address in R4
1906  5190 DBC5         MOVB    R5,@-2(R15)             write back flagged byte
1906  5192 FFFE  
1907  5194 0460         B       @WFDRPB                 to read-write loop
1907  5196 5006  
1908            *                                       
1909  5198 06A0 FFDRVP  BL      @CALSUB                 find FDR in VDP buffer
1909  519A 4322  
1910  519C 4A6E         DATA    FFFDRV                  find file FDR
1911  519E C104         MOV     R4,R4                   found?
1912  51A0 1303         JEQ     AFPGPF                  yes
1913  51A2 06A0         BL      @ERROR5                 no: return with error
1913  51A4 493C  
1914  51A6 E000         DATA    >E000                   file error
1915  51A8 0581 AFPGPF  INC     R1                      point to filename in FDR
1916  51AA CA41         MOV     R1,@>0056(R9)           new FDR ptr
1916  51AC 0056  
1917  51AE C129         MOV     @>0054(R9),R4           get PAB ptr
1917  51B0 0054  
1918  51B2 0584         INC     R4                      point to status byte
1919  51B4 04C0         CLR     R0                      
1920  51B6 0429         BLWP    @>005A(R9)              set VDP to read
1920  51B8 005A  
1921  51BA 0082         DATA    >0082                   address in R4
1922  51BC D02F         MOVB    @-1026(R15),R0          get file status
1922  51BE FBFE  
1923  51C0 0460         B       @RTURN1                 return to caller
1923  51C2 4340  
1924            *                                       
1925  51C4 C129 RFDRST  MOV     @>0056(R9),R4           get status byte from FDR
1925  51C6 0056  
1926  51C8 0224         AI      R4,12                   point to status byte
1926  51CA 000C  
1927  51CC 0429         BLWP    @>005A(R9)              set VDP to read
1927  51CE 005A  
1928  51D0 0082         DATA    >0082                   address in R4
1929  51D2 D02F         MOVB    @-1026(R15),R0          read status byte
1929  51D4 FBFE  
1930  51D6 045B         B       *R11                    
1931            *                                       
1932  51D8 D16F RRNPAB  MOVB    @-1026(R15),R5          get record # from PAB, check if valid
1932  51DA FBFE  
1933  51DC 0985         SRL     R5,8                    
1934  51DE 1602         JNE     H195                    get # of rec/sector from FDR
1935  51E0 0205         LI      R5,256                  0: default to 256
1935  51E2 0100  
1936  51E4 C0E9 H195    MOV     @>0054(R9),R3           PAB ptr
1936  51E6 0054  
1937  51E8 0223         AI      R3,6                    point to rec #
1937  51EA 0006  
1938  51EC 0429         BLWP    @>005A(R9)              set VDP to read
1938  51EE 005A  
1939  51F0 0062         DATA    >0062                   address in R3
1940  51F2 D06F         MOVB    @-1026(R15),R1          get record # from PAB
1940  51F4 FBFE  
1941  51F6 06C1         SWPB    R1                      
1942  51F8 D06F         MOVB    @-1026(R15),R1                  
1942  51FA FBFE  
1943  51FC 06C1         SWPB    R1                      
1944  51FE C001         MOV     R1,R0                   save it
1945  5200 1101         JLT     H196                    too big
1946  5202 1003         JMP     H197                    ok
1947  5204 06A0 H196    BL      @ERROR5                 update data then return with error
1947  5206 493C  
1948  5208 8000         DATA    >8000                   memory full
1949  520A 0580 H197    INC     R0                      next record
1950  520C 0429         BLWP    @>005A(R9)              set VDP to write
1950  520E 005A  
1951  5210 0063         DATA    >0063                   address in R3
1952  5212 DBC0         MOVB    R0,@-2(R15)             write back # of future record
1952  5214 FFFE  
1953  5216 06C0         SWPB    R0                      
1954  5218 DBC0         MOVB    R0,@-2(R15)                     
1954  521A FFFE  
1955  521C 04C0         CLR     R0                      
1956  521E C0C1         MOV     R1,R3                   save # of desired rec
1957  5220 3C05         DIV     R5,R0                   divide by # of rec/sector = sect # in R0
1958  5222 C0A9 RNFISE  MOV     @>0056(R9),R2           FDR ptr
1958  5224 0056  
1959  5226 0222         AI      R2,18                   point to total # of rec (# of sectors for var)
1959  5228 0012  
1960  522A 0429         BLWP    @>005A(R9)              set VDP to read
1960  522C 005A  
1961  522E 0042         DATA    >0042                   address in R2
1962  5230 D0AF         MOVB    @-1026(R15),R2          get total # of recs/file (sect/file for var)
1962  5232 FBFE  
1963  5234 06C2         SWPB    R2                      
1964  5236 D0AF         MOVB    @-1026(R15),R2          remember: bytes are swapped
1964  5238 FBFE  
1965  523A 8083         C       R3,R2                   compare with desired record (ignored by var)
1966  523C 045B         B       *R11                    
1967            *                                       
1968  523E 0429 RRFDR   BLWP    @>005A(R9)              fetch record into FDR data buffer area
1968  5240 005A  
1969  5242 4000         DATA    >4000                   save R1
1970  5244 0224         AI      R4,-18                  ptr to top of control block
1970  5246 FFEE  
1971  5248 0429         BLWP    @>005A(R9)              set VDP to read
1971  524A 005A  
1972  524C 0082         DATA    >0082                   address in R4
1973  524E D16F         MOVB    @-1026(R15),R5          get current sector offset in file
1973  5250 FBFE  
1974  5252 06C5         SWPB    R5                      
1975  5254 D16F         MOVB    @-1026(R15),R5                  
1975  5256 FBFE  
1976  5258 0B85         SRC     R5,8                    
1977  525A 1105         JLT     H198                    -1: top of file
1978  525C 8005         C       R5,R0                   compare with desired offset (from RRNPAB)
1979  525E 130B         JEQ     H199                    same
1980  5260 06A0         BL      @CALSUB                 call subroutine
1980  5262 4322  
1981  5264 4560         DATA    UPDBF                   update data buffer if needed
1982  5266 C0C0 H198    MOV     R0,R3                   desired sector offset in file
1983  5268 06A0         BL      @UCOFCB                 update sect + rec offsets in control block
1983  526A 52B6  
1984  526C 0227         AI      R7,256                  point to data buffer area (R7 set by UCOFCB)
1984  526E 0100  
1985  5270 06A0         BL      @CALSUB                 call subroutine
1985  5272 4322  
1986  5274 45F4         DATA    RDOFSC                  read a sector from offset in file (in R3)
1987  5276 0429 H199    BLWP    @>005A(R9)                      
1987  5278 005A  
1988  527A 4001         DATA    >4001                   retrieve R1
1989  527C C0E9         MOV     @>0056(R9),R3           FDR ptr
1989  527E 0056  
1990  5280 0223         AI      R3,17                   point to record length
1990  5282 0011  
1991  5284 0429         BLWP    @>005A(R9)              set VDP to read
1991  5286 005A  
1992  5288 0062         DATA    >0062                   address in R3
1993  528A D02F         MOVB    @-1026(R15),R0          get rec length in bytes
1993  528C FBFE  
1994  528E 0980         SRL     R0,8                    make it a word
1995  5290 3840         MPY     R0,R1                   calc file offset in bytes
1996  5292 A0A9 AFDRPT  A       @>0056(R9),R2           add FDR ptr
1996  5294 0056  
1997  5296 0222         AI      R2,256                  point inside data buffer area
1997  5298 0100  
1998  529A C0E9         MOV     @>0054(R9),R3           PAB ptr
1998  529C 0054  
1999  529E 05C3         INCT    R3                      point to data buffer address
2000  52A0 0429         BLWP    @>005A(R9)              set VDP to read
2000  52A2 005A  
2001  52A4 0062         DATA    >0062                   address in R3
2002  52A6 D06F         MOVB    @-1026(R15),R1          get PAB data buffer address
2002  52A8 FBFE  
2003  52AA 06C1         SWPB    R1                      
2004  52AC D06F         MOVB    @-1026(R15),R1                  
2004  52AE FBFE  
2005  52B0 06C1         SWPB    R1                      
2006  52B2 0460         B       @RTURN1                 return
2006  52B4 4340  
2007            *                               
2008  52B6 C1E9 UCOFCB  MOV     @>0056(R9),R7           update sect + rec offsets in control block
2008  52B8 0056  
2009  52BA C047         MOV     R7,R1                   FDR ptr
2010  52BC 0221         AI      R1,-6                   top of file control block
2010  52BE FFFA  
2011  52C0 0429         BLWP    @>005A(R9)              set VDP to write
2011  52C2 005A  
2012  52C4 0023         DATA    >0023                   address in R1
2013  52C6 DBC0         MOVB    R0,@-2(R15)             current sector offset in file
2013  52C8 FFFE  
2014  52CA 06C0         SWPB    R0                      
2015  52CC DBC0         MOVB    R0,@-2(R15)                     
2015  52CE FFFE  
2016  52D0 0221         AI      R1,4                    point to var rec offset in sector
2016  52D2 0004  
2017  52D4 06C5         SWPB    R5                      
2018  52D6 0429         BLWP    @>005A(R9)              set VDP to write
2018  52D8 005A  
2019  52DA 0023         DATA    >0023                   address in R1
2020  52DC DBC5         MOVB    R5,@-2(R15)             first free byte in current sector
2020  52DE FFFE  
2021  52E0 045B         B       *R11                    
2022            *                                       
2023  52E2 C0A9 URFFDR  MOV     @>0056(R9),R2           update # of rec/file in FDR
2023  52E4 0056  
2024  52E6 0429         BLWP    @>005A(R9)              set VDP to read
2024  52E8 005A  
2025  52EA 0042         DATA    >0042                   address in R2 (FDR ptr)
2026  52EC D2AF         MOVB    @-1026(R15),R10         get first char of filename
2026  52EE FBFE  
2027  52F0 026A         ORI     R10,>8000               set was modified flag
2027  52F2 8000  
2028  52F4 0429         BLWP    @>005A(R9)              set VDP to write
2028  52F6 005A  
2029  52F8 0043         DATA    >0043                   address in R2
2030  52FA DBCA         MOVB    R10,@-2(R15)            write flagged char back
2030  52FC FFFE  
2031  52FE 0222         AI      R2,18                   point to # of recs/file in FDR
2031  5300 0012  
2032  5302 0583         INC     R3                      one more
2033  5304 0429         BLWP    @>005A(R9)              set VDP to write
2033  5306 005A  
2034  5308 0043         DATA    >0043                   address in R2
2035  530A 06C3         SWPB    R3                      update # of recs/file
2036  530C DBC3         MOVB    R3,@-2(R15)                     
2036  530E FFFE  
2037  5310 06C3         SWPB    R3                      
2038  5312 DBC3         MOVB    R3,@-2(R15)                     
2038  5314 FFFE  
2039  5316 045B         B       *R11                    
2040            *                                       
2041  5318 C229 RCOFCB  MOV     @>0056(R9),R8           get rec offset, compare sect with total
2041  531A 0056  
2042  531C C108         MOV     R8,R4                   FDR ptr
2043  531E 0224         AI      R4,256                  point to data buffer area
2043  5320 0100  
2044  5322 0648         DECT    R8                      point to var record offset
2045  5324 0429         BLWP    @>005A(R9)              set VDP to read
2045  5326 005A  
2046  5328 0102         DATA    >0102                   address in R8
2047  532A D0AF         MOVB    @-1026(R15),R2          get var rec offset in current sector
2047  532C FBFE  
2048  532E 0982         SRL     R2,8                    make it a word
2049  5330 C28B         MOV     R11,R10                 save return point
2050  5332 06A0         BL      @FDR2B2                 get 2 bytes from FDR (at R8-4) into R0
2050  5334 483E  
2051  5336 FFFC         DATA    -4                      current sector offset in file
2052  5338 C0C0         MOV     R0,R3                   save it
2053  533A C2CA         MOV     R10,R11                 restore return point
2054  533C C002         MOV     R2,R0                   var record offset
2055  533E 0460         B       @RNFISE                 get # of sect/file from FDR, return
2055  5340 5222  
2056            *
2057            *------------------------------------
2058            * Opcode 4: Rewind
2059            * --------------
2060            * PAB 0: >04
2061            *     1: file type <--- error code
2062            *   2-3:
2063            *     4:
2064            *     5:
2065            *   6-7: record #  <--- >0000 if sequential
2066            *     8:
2067            *------------------------------------                                   
2068            *
2069  5342 06A0 RWIND1  BL      @CALSUB                 call subroutine
2069  5344 4322  
2070  5346 5198         DATA    FFDRVP                  find FDR in VDP buffers, read status from PAB
2071  5348 0429         BLWP    @>005A(R9)                      
2071  534A 005A  
2072  534C 8000         DATA    >8000                   save R0 (status from PAB)
2073  534E 0240         ANDI    R0,>0600                keep only access mode
2073  5350 0600  
2074  5352 1305         JEQ     H200                    update is ok
2075  5354 0280         CI      R0,>0400                is it input?
2075  5356 0400  
2076  5358 1302         JEQ     H200                    yes: ok
2077  535A 0460         B       @ERROR8                 output or append: return with illegal opcode
2077  535C 4D82  
2078  535E 06A0 H200    BL      @CALSUB                 call subroutine
2078  5360 4322  
2079  5362 4560         DATA    UPDBF                   update data buffer if needed
2080  5364 0429         BLWP    @>005A(R9)                      
2080  5366 005A  
2081  5368 8001         DATA    >8001                   retrieve R0 (status from PAB)
2082  536A 0240         ANDI    R0,>0100                sequential or reloc?
2082  536C 0100  
2083  536E 1611         JNE     H201                    reloc: don't do anything, return
2084            *                                       
2085  5370 04C2 RWIND2  CLR     R2                      rewind file: record offset = 0
2086  5372 0703         SETO    R3                      current record = -1 (none)
2087  5374 06A0         BL      @UPDFCB                 update file control block
2087  5376 4F72  
2088  5378 04C0         CLR     R0                      record 0
2089  537A C229         MOV     @>0054(R9),R8           get PAB ptr
2089  537C 0054  
2090  537E 0228         AI      R8,6                    point to record #
2090  5380 0006  
2091  5382 0429         BLWP    @>005A(R9)              set VDP to write
2091  5384 005A  
2092  5386 0103         DATA    >0103                   address in R8
2093  5388 DBC0         MOVB    R0,@-2(R15)             write record #
2093  538A FFFE  
2094  538C 1000         NOP                             
2095  538E DBC0         MOVB    R0,@-2(R15)                     
2095  5390 FFFE  
2096  5392 0460 H201    B       @RTURN1                 return to caller
2096  5394 4340  
2097            *
2098            *------------------------------------
2099            * Opcode 5: Load
2100            * --------------
2101            * PAB 0: >05
2102            *     1: file type  <--- error code
2103            *   2-3: data buffer address in VDP mem
2104            *     4:
2105            *     5:
2106            *   6-7: maximum # of bytes (size of buffer)
2107            *     8:
2108            *------------------------------------                                   
2109            *
2110  5396 06A0 LOAD    BL      @CALSUB                 call subroutine
2110  5398 4322  
2111  539A 4ACC         DATA    FNDFDR                  find FDR on disk
2112  539C C104         MOV     R4,R4                   found?
2113  539E 1303         JEQ     H203                    yes
2114  53A0 06A0 H202    BL      @ERROR5                 no: return with error
2114  53A2 493C  
2115  53A4 E000         DATA    >E000                   file error
2116  53A6 06A0 H203    BL      @FDR2B1                 get 2 bytes from FDR into R0
2116  53A8 483A  
2117  53AA 000C         DATA    12                      file status byte
2118  53AC 0240         ANDI    R0,>0100                is it program?
2118  53AE 0100  
2119  53B0 13F7         JEQ     H202                    no: file error
2120  53B2 05C8         INCT    R8                      point to # of sect/file in FDR
2121  53B4 0429         BLWP    @>005A(R9)              set VDP to read
2121  53B6 005A  
2122  53B8 0102         DATA    >0102                   address in R8
2123  53BA D06F         MOVB    @-1026(R15),R1          get # of sectors in file
2123  53BC FBFE  
2124  53BE 06C1         SWPB    R1                      
2125  53C0 D06F         MOVB    @-1026(R15),R1                  
2125  53C2 FBFE  
2126  53C4 0B81         SRC     R1,8                    
2127  53C6 13EC         JEQ     H202                    0=empty file: return with file error
2128  53C8 06A0         BL      @RBANB                  get data buffer address in R7, # of sectors in R2
2128  53CA 5488  
2129  53CC 05C8         INCT    R8                      point to eof offset in FDR
2130  53CE 04C4         CLR     R4                      
2131  53D0 0429         BLWP    @>005A(R9)              set VDP to read
2131  53D2 005A  
2132  53D4 0102         DATA    >0102                   address in R8
2133  53D6 D12F         MOVB    @-1026(R15),R4          get # of bytes in last sector
2133  53D8 FBFE  
2134  53DA 8081         C       R1,R2                   compare # of sect with max in PAB
2135  53DC 1BE1         JH      H202                    file is too big: return with file error
2136  53DE 1602         JNE     H204                    file is smaller
2137  53E0 8100         C       R0,R4                   same # of sect: check bytes in last sector
2138  53E2 1ADE         JL      H202                    file is too big: file error
2139  53E4 04C3 H204    CLR     R3                      sector offset in file
2140  53E6 06C4         SWPB    R4                      
2141  53E8 0601 H206    DEC     R1                      next sector
2142  53EA 130D         JEQ     H205                    done
2143  53EC 0429         BLWP    @>005A(R9)                      
2143  53EE 005A  
2144  53F0 D900         DATA    >D900                   save R0, R1, R3, R4, R7
2145  53F2 06A0         BL      @CALSUB                 call subroutine
2145  53F4 4322  
2146  53F6 45F4         DATA    RDOFSC                  read a sector from offset in R3
2147  53F8 0429         BLWP    @>005A(R9)              restore R0, R1, R3, R4, R7
2147  53FA 005A  
2148  53FC D901         DATA    >D901                   
2149  53FE 0583         INC     R3                      next sector
2150  5400 0227         AI      R7,256                  256 bytes further in PAB buffer
2150  5402 0100  
2151  5404 10F1         JMP     H206                    keep going
2152            *                                       
2153  5406 C104 H205    MOV     R4,R4                   
2154  5408 1604         JNE     H207                    
2155  540A 06A0         BL      @CALSUB                 call subroutine
2155  540C 4322  
2156  540E 45F4         DATA    RDOFSC                  read a sector from offset in R3
2157  5410 1011         JMP     H208                    done
2158            *                                       
2159  5412 C147 H207    MOV     R7,R5                   save PAB data buffer ptr
2160  5414 C1E9         MOV     @>0056(R9),R7           FDR ptr
2160  5416 0056  
2161  5418 0227         AI      R7,256                  point to FDR data area
2161  541A 0100  
2162  541C 0429         BLWP    @>005A(R9)                      
2162  541E 005A  
2163  5420 0D00         DATA    >0D00                   save R4, R5, R7
2164  5422 06A0         BL      @CALSUB                 call subroutine
2164  5424 4322  
2165  5426 45F4         DATA    RDOFSC                  read a sector from offset in R3
2166  5428 0429         BLWP    @>005A(R9)              restore R4 in R0, R5 in R1, R7 in R2
2166  542A 005A  
2167  542C E001         DATA    >E001                   
2168  542E 06A0         BL      @CALSUB                 call subroutine
2168  5430 4322  
2169  5432 5006         DATA    WFDRPB                  write bytes from FDR data buffer to PAB data buf
2170  5434 0460 H208    B       @UPDFDR                 update FDR, data buffer, VIB and return to caller
2170  5436 4540  
2171            *
2172            *------------------------------------
2173            * Opcode 6: Save
2174            * --------------
2175            * PAB 0: >06
2176            *     1: file type  <--- error code
2177            *   2-3: data buffer address in VDP mem
2178            *     4:
2179            *     5:
2180            *   6-7: # of bytes to save
2181            *     8:
2182            *------------------------------------                                   
2183            *
2184  5438 06A0 SAVE    BL      @CALSUB                 call subroutine
2184  543A 4322  
2185  543C 445A         DATA    CRFIL1                  create file
2186  543E 06A0         BL      @RBANB                  get PAB buffer ptr + # of bytes
2186  5440 5488  
2187  5442 04C3         CLR     R3                      sector offset 0
2188  5444 0429 H209    BLWP    @>005A(R9)                      
2188  5446 005A  
2189  5448 B100         DATA    >B100                   save R0, R2, R3, R7
2190  544A 06A0         BL      @CALSUB                 call subroutine
2190  544C 4322  
2191  544E 4614         DATA    WROFSC                  write sector to offset in R3
2192  5450 0429         BLWP    @>005A(R9)                      
2192  5452 005A  
2193  5454 B101         DATA    >B101                   retrieve R0, R2, R3, R7
2194  5456 0583         INC     R3                      next sector
2195  5458 0227         AI      R7,256                  256 bytes further in PAB data buffer
2195  545A 0100  
2196  545C 0602         DEC     R2                      next sector
2197  545E 16F2         JNE     H209                    more to do
2198            *                                       
2199  5460 C069         MOV     @>0056(R9),R1           FDR ptr
2199  5462 0056  
2200  5464 0221         AI      R1,12                   point to file status byte
2200  5466 000C  
2201  5468 0202         LI      R2,>0100                value for program file
2201  546A 0100  
2202  546C 0429         BLWP    @>005A(R9)              set VDP to write
2202  546E 005A  
2203  5470 0023         DATA    >0023                   address in R1
2204  5472 DBC2         MOVB    R2,@-2(R15)             write file status byte in FDR
2204  5474 FFFE  
2205  5476 0221         AI      R1,4                    point to eof offset byte in FDR
2205  5478 0004  
2206  547A 0429         BLWP    @>005A(R9)              set VDP to write
2206  547C 005A  
2207  547E 0023         DATA    >0023                   address in R1
2208  5480 DBC0         MOVB    R0,@-2(R15)             # of bytes in last sector
2208  5482 FFFE  
2209  5484 0460         B       @UPDFDR                 update FDR, data buffer, VIB then return to caller
2209  5486 4540  
2210            *                                       
2211  5488 C029 RBANB   MOV     @>0054(R9),R0           get buffer address + # of bytes
2211  548A 0054  
2212  548C 05C0         INCT    R0                      data buffer in PAB
2213  548E 0429         BLWP    @>005A(R9)              set VDP to read
2213  5490 005A  
2214  5492 0002         DATA    >0002                   address in R0
2215  5494 D1EF         MOVB    @-1026(R15),R7          get data buffer address
2215  5496 FBFE  
2216  5498 06C7         SWPB    R7                      
2217  549A D1EF         MOVB    @-1026(R15),R7                  
2217  549C FBFE  
2218  549E 06C7         SWPB    R7                      
2219  54A0 0220         AI      R0,4                    point to # of bytes to transfer
2219  54A2 0004  
2220  54A4 0429         BLWP    @>005A(R9)              set VDP to read
2220  54A6 005A  
2221  54A8 0002         DATA    >0002                   address in R0
2222  54AA D0AF         MOVB    @-1026(R15),R2          get # of bytes to be transfered
2222  54AC FBFE  
2223  54AE 0982         SRL     R2,8                    make it # of sectors (256 bytes each)
2224  54B0 04C0         CLR     R0                      
2225  54B2 D02F         MOVB    @-1026(R15),R0          see if one more is needed
2225  54B4 FBFE  
2226  54B6 1301         JEQ     H210                    no
2227  54B8 0582         INC     R2                      yes: one more sector
2228  54BA 045B H210    B       *R11                    
2229            *
2230            *-------------------------------------
2231            * Opcode 9: Status
2232            * --------------
2233            * PAB 0: >09
2234            *     1:
2235            *   2-3:
2236            *     4:
2237            *     5:
2238            *   6-7: record #
2239            *     8:           <--- file status
2240            *
2241            * Status bits, returned in PAB byte 8:
2242            * >80: file not found
2243            * >40: file is protected
2244            * >20:
2245            * >10: internal (else display or program)
2246            * >08: program file
2247            * >04: variable (else fixed or program)
2248            * >02: memory full
2249            * >01: end-of-file reached
2250            *-------------------------------------                                  
2251            *
2252  54BC 06A0 STATUS  BL      @CALSUB                 call subroutine
2252  54BE 4322  
2253  54C0 4A6E         DATA    FFFDRV                  save filename in comp buf, then find FDR in VDP
2254  54C2 C104         MOV     R4,R4                   found?
2255  54C4 1310         JEQ     H211                    yes
2256            *                                       
2257  54C6 06A0         BL      @CALSUB                 no: call subroutine
2257  54C8 4322  
2258  54CA 4AD6         DATA    FFDRDK                  find FDR on disk
2259  54CC 0200         LI      R0,>8000                value for file not found
2259  54CE 8000  
2260  54D0 C104         MOV     R4,R4                   found?
2261  54D2 1649         JNE     H212                    no: return with that value
2262  54D4 C069         MOV     @>0056(R9),R1           yes: ptr to FDR
2262  54D6 0056  
2263  54D8 04C2         CLR     R2                      
2264  54DA 0429         BLWP    @>005A(R9)              set VDP to write
2264  54DC 005A  
2265  54DE 0023         DATA    >0023                   address in R1
2266  54E0 DBC2         MOVB    R2,@-2(R15)             invalidate that FDR (file not open)
2266  54E2 FFFE  
2267  54E4 1036         JMP     H213                    transfer FDR status to PAB status byte
2268            *                                       
2269  54E6 06A0 H211    BL      @CALSUB                 file is open: call subroutine
2269  54E8 4322  
2270  54EA 51A8         DATA    AFPGPF                  adjust FDR ptr, get PAB file type into R4
2271  54EC 06A0         BL      @RFDRST                 get status byte from FDR
2271  54EE 51C4  
2272  54F0 1101         JLT     H214                    var
2273  54F2 1006         JMP     H215                    fix
2274            *                                       
2275  54F4 06A0 H214    BL      @CALSUB                 var: call subroutine
2275  54F6 4322  
2276  54F8 502A         DATA    RRSEC                   load wanted sector, point to wanted rec in buffer
2277  54FA 1013         JMP     H216                    out of range
2278  54FC 04C2         CLR     R2                      ok: clear flag
2279  54FE 1029         JMP     H213                    copy status byte from FDR into PAB, return
2280            *                                       
2281  5500 D16F H215    MOVB    @-1026(R15),R5          fix: get rec/sect byte
2281  5502 FBFE  
2282  5504 0985         SRL     R5,8                    make it a word
2283  5506 1602         JNE     H217                    
2284  5508 0205         LI      R5,>0100                00 (program files) means 256
2284  550A 0100  
2285  550C 06A0 H217    BL      @PABR2B                 get 2 bytes from PAB into R0
2285  550E 4834  
2286  5510 0006         DATA    6                       # of wanted record
2287  5512 C0C0         MOV     R0,R3                   save it
2288  5514 111C         JLT     H218                    too big: set memory full bit in PAB status byte
2289  5516 06A0         BL      @RNFISE                 get # recs/file into R2, comp with R3
2289  5518 5222  
2290  551A 04C2         CLR     R2                      
2291  551C 1A1A         JL      H213                    in file: copy file type bits, return
2292  551E 3C85         DIV     R5,R2                   how many sectors do we need?
2293  5520 C0C2         MOV     R2,R3                   save result
2294            *                                       
2295  5522 06A0 H216    BL      @FDR2B1                 get 2 bytes from FDR into R0
2295  5524 483A  
2296  5526 000E         DATA    14                      # of sectors/file
2297  5528 0583         INC     R3                      plus 1 sector for FDR
2298  552A 0202         LI      R2,>0100                value for eof reached in PAB status
2298  552C 0100  
2299  552E 60C0         S       R0,R3                   are there enough sectors in file for these recs?
2300  5530 1501         JGT     H219                    
2301  5532 100F         JMP     H213                    yes: we reached the eof
2302  5534 06A0 H219    BL      @CALSUB                 call subroutine
2302  5536 4322  
2303  5538 499C         DATA    RWVIB                   load VIB (sector 0)
2304  553A C103         MOV     R3,R4                   number of sectors that will be needed
2305  553C C205         MOV     R5,R8                   VIB ptr
2306  553E 0228         AI      R8,10                   skip 10 bytes (required by CFSVIB)
2306  5540 000A  
2307  5542 06A0         BL      @CFSVIB                 count free sectors in bitmap, into R3
2307  5544 5730  
2308  5546 0202         LI      R2,>0100                value for eof reached
2308  5548 0100  
2309  554A 8103         C       R3,R4                   are there that many free sectors?
2310  554C 1402         JHE     H213                    yes
2311  554E 0202 H218    LI      R2,>0200                value for memory full
2311  5550 0200  
2312            *                                       
2313  5552 06A0 H213    BL      @FDR2B1                 get 2 bytes from FDR into R0
2313  5554 483A  
2314  5556 000C         DATA    12                      file status byte
2315  5558 0240         ANDI    R0,>8F00                mask irrelevant bits
2315  555A 8F00  
2316  555C 1502         JGT     H220                    
2317  555E 0260         ORI     R0,>0080                var: put var bit in PAB status style
2317  5560 0080  
2318  5562 0A30 H220    SLA     R0,3                    get rid of var bit in FDR style
2319  5564 F002         SOCB    R2,R0                   add eof and mem full bits
2320            *                                       
2321  5566 C069 H212    MOV     @>0054(R9),R1           PAB ptr
2321  5568 0054  
2322  556A 0221         AI      R1,8                    point to bias/status return byte
2322  556C 0008  
2323  556E 0429         BLWP    @>005A(R9)              set VDP to write
2323  5570 005A  
2324  5572 0023         DATA    >0023                   address in R1
2325  5574 DBC0         MOVB    R0,@-2(R15)             write file status to PAB
2325  5576 FFFE  
2326  5578 0460         B       @RTURN1                 return to caller
2326  557A 4340  
2327            *
2328            *---------------------------------
2329            * Disk directory access
2330            * ---------------------
2331            * The directory is accessed by omiting the filename in the DSR name: "DSK1."
2332            * It must be opened for input only, as an Int/Fix 38 file.
2333            * It consists in upto 128 records, the first one contains the disk informations,
2334            * the others the informations for upto 127 files (in alphabetical order).
2335            * Each record consists in an ascii string and three floating point numbers.
2336            *
2337            * Record 0 contains:
2338            * - Diskname (an ascii string of upto 10 chars).
2339            * - The number zero.
2340            * - The number of sectors on disk.
2341            * - The number of free sectors on disk.
2342            *
2343            * Other records contain:
2344            * - Filename (an ascii string of upto 10 chars).
2345            * - Filetype: 1=D/F, 2=D/V, 3=I/F, 4=I/V, 5=Prog, 0=end of directory.
2346            *   If the file is protected, this number is negative (-1=D/F, etc).
2347            * - File size in sectors (including the FDR itself).
2348            * - File record length (0 for programs).
2349            *---------------------------------
2350             
2351            *---------------------------------
2352            * Open disk directory pseudo-file
2353            *---------------------------------                                      
2354            *
2355  557C D02F OPNDIR  MOVB    @-1026(R15),R0          get file type from PAB
2355  557E FBFE  
2356  5580 0240         ANDI    R0,>1E00                mask irrelavant bits (rel/seq)
2356  5582 1E00  
2357  5584 0280         CI      R0,>0C00                is it int/fix in output mode?
2357  5586 0C00  
2358  5588 1303         JEQ     H221                    yes
2359  558A 06A0 H223    BL      @RETERR                 return with error
2359  558C 4968  
2360  558E 4000         DATA    >4000                   bad attributes
2361  5590 06A0 H221    BL      @PABR2B                 get 2 bytes from PAB into R0
2361  5592 4834  
2362  5594 0004         DATA    4                       rec length
2363  5596 0980         SRL     R0,8                    make it a word
2364  5598 1303         JEQ     H222                    >00= default: set it to 38
2365  559A 0280         CI      R0,>0026                is it 38?
2365  559C 0026  
2366  559E 16F5         JNE     H223                    no: return with bad attributes error
2367  55A0 0200 H222    LI      R0,>2600                set rec len to 38
2367  55A2 2600  
2368  55A4 0429         BLWP    @>005A(R9)              set VDP to write
2368  55A6 005A  
2369  55A8 0103         DATA    >0103                   address in R8 (from PABR2B)
2370  55AA DBC0         MOVB    R0,@-2(R15)             write rec len to PAB
2370  55AC FFFE  
2371            *                                       
2372  55AE 04C7         CLR     R7                      
2373  55B0 06A0         BL      @FNDRV                  find matching drive in file control blocks
2373  55B2 576A  
2374  55B4 55BC         DATA    H224                    go there if not found
2375  55B6 06A0 ERRR10  BL      @ERROR5                 update data then return with error
2375  55B8 493C  
2376  55BA E000         DATA    >E000                   file error
2377  55BC C1C7 H224    MOV     R7,R7                   did we find a free slot?
2378  55BE 1603         JNE     H225                    yes
2379  55C0 06A0         BL      @RETERR                 no: return with error
2379  55C2 4968  
2380  55C4 8000         DATA    >8000                   memory full
2381  55C6 0429 H225    BLWP    @>005A(R9)              set VDP to write
2381  55C8 005A  
2382  55CA 00E3         DATA    >00E3                   address in R7
2383  55CC DBC3         MOVB    R3,@-2(R15)             write drive #
2383  55CE FFFE  
2384  55D0 06C3         SWPB    R3                      
2385  55D2 DBC3         MOVB    R3,@-2(R15)             and a space as filename (illegal, indicates dir)
2385  55D4 FFFE  
2386  55D6 0460         B       @RTURN1                 return to caller
2386  55D8 4340  
2387            *
2388            *---------------------------------
2389            * Close disk directory
2390            *---------------------------------                                      
2391  55DA 06A0 CLSDIR  BL      @FNDRV                  find matching drive in file control blocks
2391  55DC 576A  
2392  55DE 55B6         DATA    ERRR10                  go there if not found: return with file error
2393  55E0 04C0         CLR     R0                      
2394  55E2 0429         BLWP    @>005A(R9)              set VDP to write
2394  55E4 005A  
2395  55E6 0103         DATA    >0103                   address in R8
2396  55E8 DBC0         MOVB    R0,@-2(R15)             clear drive #
2396  55EA FFFE  
2397  55EC 0460         B       @RTURN1                 return to caller
2397  55EE 4340  
2398            *
2399            *---------------------------------
2400            * Read a record from disk directory
2401            *---------------------------------                                      
2402            *
2403  55F0 06A0 RDDIR   BL      @FNDRV                  find matching drive in file control blocks
2403  55F2 576A  
2404  55F4 55B6         DATA    ERRR10                  go ther it not found: return with file error
2405  55F6 0588         INC     R8                      
2406  55F8 C148         MOV     R8,R5                   save ptr to FDR
2407  55FA 06A0         BL      @PABR2B                 get 2 bytes from PAB into R0
2407  55FC 4834  
2408  55FE 0006         DATA    6                       record #
2409  5600 C080         MOV     R0,R2                   save it
2410  5602 0582         INC     R2                      
2411  5604 0429         BLWP    @>005A(R9)              set VDP to write
2411  5606 005A  
2412  5608 0103         DATA    >0103                   address in R8
2413  560A DBC2         MOVB    R2,@-2(R15)             write record number in FDR
2413  560C FFFE  
2414  560E 06C2         SWPB    R2                      after first char of filename!
2415  5610 DBC2         MOVB    R2,@-2(R15)                     
2415  5612 FFFE  
2416  5614 0A10         SLA     R0,1                    since two byte per file ptr
2417  5616 D000         MOVB    R0,R0                   is rec # greater than 128?
2418  5618 1303         JEQ     H226                    no
2419  561A 06A0         BL      @ERROR5                 yes: update data then return with error
2419  561C 493C  
2420  561E A000         DATA    >A000                   past eof
2421  5620 0702 H226    SETO    R2                      code for read
2422  5622 C100         MOV     R0,R4                   record #
2423  5624 133B         JEQ     H227                    0=disk parameters
2424  5626 0204         LI      R4,1                    sector #1
2424  5628 0001  
2425  562A 06A0         BL      @CALSUB                 call subroutine
2425  562C 4322  
2426  562E 4A18         DATA    RWSEC                   read sector into buffer in R5
2427  5630 C205         MOV     R5,R8                   buffer ptr
2428  5632 0225         AI      R5,255                  point to data buffer area in this ctrl block
2428  5634 00FF  
2429  5636 0640         DECT    R0                      don't count record 0
2430  5638 A200         A       R0,R8                   point to desired file ptr
2431  563A 06A0         BL      @VDPR2B                 get two byte from VDP at R8 into R0
2431  563C 4840  
2432  563E C100         MOV     R0,R4                   sector where that FDR is to be found
2433  5640 1328         JEQ     H228                    no more
2434  5642 06A0         BL      @CALSUB                 call subroutine
2434  5644 4322  
2435  5646 4A18         DATA    RWSEC                   read FDR sector into data buffer area
2436  5648 06A0         BL      @FDR2B1                 get 2 bytes from FDR into R0
2436  564A 483A  
2437  564C 010E         DATA    270                     # of sect/file
2438  564E C180         MOV     R0,R6                   save it to output file size
2439  5650 0586         INC     R6                      include the FDR itself
2440  5652 D0EF         MOVB    @-1026(R15),R3          ignore eof offset
2440  5654 FBFE  
2441  5656 0202         LI      R2,>0A00                10 chars per filename
2441  5658 0A00  
2442  565A D0EF         MOVB    @-1026(R15),R3          get rec length
2442  565C FBFE  
2443  565E 0983         SRL     R3,8                    make it a word
2444  5660 0648         DECT    R8                      point to status byte in FDR
2445  5662 0429         BLWP    @>005A(R9)              set VDP to read
2445  5664 005A  
2446  5666 0102         DATA    >0102                   address in R8
2447  5668 D02F         MOVB    @-1026(R15),R0          get file status byte
2447  566A FBFE  
2448  566C C1C0         MOV     R0,R7                   
2449  566E 0240         ANDI    R0,>0800                keep only write protected bit
2449  5670 0800  
2450  5672 51C0         SZCB    R0,R7                   clear write protected bit (if it was set)
2451  5674 0987         SRL     R7,8                    make it a word
2452  5676 0587         INC     R7                      types are numbered from 1
2453  5678 0287         CI      R7,>0002                is it a program file?
2453  567A 0002  
2454  567C 1602         JNE     H229                    no
2455  567E 0227         AI      R7,3                    yes: make it type 5
2455  5680 0003  
2456  5682 0287 H229    CI      R7,>0008                is it var?
2456  5684 0008  
2457  5686 1A02         JL      H230                    no
2458  5688 0227         AI      R7,-127                 yes: add 1 and clear var bit
2458  568A FF81  
2459  568C 0A40 H230    SLA     R0,4                    write protect bit will be >80
2460  568E E1C0         SOC     R0,R7                   add it to file type
2461  5690 1004         JMP     H231                    
2462            *                                       
2463  5692 04C2 H228    CLR     R2                      no more files: filename size = 0
2464  5694 04C6         CLR     R6                      file size = 0
2465  5696 04C3         CLR     R3                      rec length = 0
2466  5698 04C7         CLR     R7                      type = 0
2467  569A 100F H231    JMP     H232                    output that
2468            *                                       
2469  569C 0225 H227    AI      R5,255                  disk info: point to data buffer area in ctrl block
2469  569E 00FF  
2470  56A0 06A0         BL      @CALSUB                 call subroutine
2470  56A2 4322  
2471  56A4 4A18         DATA    RWSEC                   read sector 0
2472  56A6 06A0         BL      @FDR2B1                 get 2 bytes from FDR into R0
2472  56A8 483A  
2473  56AA 010A         DATA    266                     # of sectors on disk
2474  56AC C180         MOV     R0,R6                   duplicate it
2475  56AE 0646         DECT    R6                      minus directory itself (sect 0 + 1)
2476  56B0 06A0         BL      @CFSVIB                 count free sectors in bitmap, result in R3
2476  56B2 5730  
2477  56B4 04C7         CLR     R7                      filetype is not used
2478  56B6 0202         LI      R2,>0A00                diskname is 10 chars
2478  56B8 0A00  
2479            *                                       
2480  56BA 06A0 H232    BL      @PABR2B                 get 2 bytes from PAB into R0
2480  56BC 4834  
2481  56BE 0002         DATA    2                       APEDSK99: error in source listing (was R2)
2482  56C0 C200         MOV     R0,R8                   duplicate it
2483  56C2 0588         INC     R8                      skip first byte
2484  56C4 0982         SRL     R2,8                    filename length (or diskname)
2485  56C6 1316         JEQ     H233                    0: skip filename copying
2486  56C8 04C1         CLR     R1                      
2487  56CA 0429 H234    BLWP    @>005A(R9)              set VDP to read
2487  56CC 005A  
2488  56CE 00A2         DATA    >00A2                   address in R5 (FDR ptr)
2489  56D0 D06F         MOVB    @-1026(R15),R1          get 1 char from filename in FDR
2489  56D2 FBFE  
2490  56D4 0281         CI      R1,>2000                is it a space?
2490  56D6 2000  
2491  56D8 1309         JEQ     H235                    yes: end of name
2492  56DA 0429         BLWP    @>005A(R9)              no: set VDP to write
2492  56DC 005A  
2493  56DE 0103         DATA    >0103                   address in R8 (PAB data buffer ptr)
2494  56E0 DBC1         MOVB    R1,@-2(R15)             copy char in PAB data buffer
2494  56E2 FFFE  
2495  56E4 0585         INC     R5                      increment source ptr
2496  56E6 0588         INC     R8                      increment destination ptr
2497  56E8 0602         DEC     R2                      next char
2498  56EA 16EF         JNE     H234                    
2499  56EC 0502 H235    NEG     R2                      number of trailing spaces
2500  56EE 0222         AI      R2,10                   number of chars in filename
2500  56F0 000A  
2501  56F2 06C2         SWPB    R2                      
2502  56F4 0429 H233    BLWP    @>005A(R9)              set VDP to write
2502  56F6 005A  
2503  56F8 0003         DATA    >0003                   address in R0 (beg of PAB data buffer)
2504  56FA DBC2         MOVB    R2,@-2(R15)             write string length byte
2504  56FC FFFE  
2505            *                                       
2506  56FE 0429         BLWP    @>005A(R9)              set VDP to write
2506  5700 005A  
2507  5702 0103         DATA    >0103                   address in R8
2508  5704 C047         MOV     R7,R1                   file type + protection
2509  5706 06A0         BL      @INT2FP                 make it a float number
2509  5708 57AE  
2510  570A C046         MOV     R6,R1                   file size in sectors, including FDR
2511  570C 06A0         BL      @INT2FP                 make it a float number
2511  570E 57AE  
2512  5710 C043         MOV     R3,R1                   record length
2513  5712 06A0         BL      @INT2FP                 make it a float number
2513  5714 57AE  
2514  5716 C229         MOV     @>0054(R9),R8           get PAB ptr
2514  5718 0054  
2515  571A 0228         AI      R8,5                    point to character count
2515  571C 0005  
2516  571E 0200         LI      R0,>2600                always 38 bytes
2516  5720 2600  
2517  5722 0429         BLWP    @>005A(R9)              set VDP to write
2517  5724 005A  
2518  5726 0103         DATA    >0103                   address in R8
2519  5728 DBC0         MOVB    R0,@-2(R15)             write # of characters in record
2519  572A FFFE  
2520  572C 0460         B       @RTURN1                 return to caller
2520  572E 4340  
2521            *                                       
2522  5730 0228 CFSVIB  AI      R8,46                   count free sectors in VIB bitmap
2522  5732 002E  
2523  5734 0202         LI      R2,200                  bitmap size
2523  5736 00C8  
2524  5738 04C3         CLR     R3                      free sectors counter
2525  573A 0429         BLWP    @>005A(R9)              set VDP to read
2525  573C 005A  
2526  573E 0102         DATA    >0102                   address in R8
2527  5740 D06F H236    MOVB    @-1026(R15),R1          get a byte from bitmap
2527  5742 FBFE  
2528  5744 0221         AI      R1,256                  
2528  5746 0100  
2529  5748 0981         SRL     R1,8                    
2530  574A 130C         JEQ     H237                    was >FF: no free sectors, next byte
2531  574C 0601         DEC     R1                      was it >00?
2532  574E 1603         JNE     H238                    no: count bits
2533  5750 0223         AI      R3,8                    yes: 8 more free sectors
2533  5752 0008  
2534  5754 1007         JMP     H237                    next byte
2535  5756 0200 H238    LI      R0,8                    8 bits per byte
2535  5758 0008  
2536  575A 0911 H239    SRL     R1,1                    test a bit
2537  575C 1801         JOC     H240                    was 1: sector is used
2538  575E 0583         INC     R3                      was 0: one more free sector
2539  5760 0600 H240    DEC     R0                      next bit in byte
2540  5762 16FB         JNE     H239                    more to come
2541  5764 0602 H237    DEC     R2                      next bitmap byte
2542  5766 16EC         JNE     H236                    more to come
2543  5768 045B         B       *R11                    
2544            *                                       
2545  576A C2BB FNDRV   MOV     *R11+,R10               find drive in file control blocks
2546  576C C14B         MOV     R11,R5                  save 2 returns
2547  576E C229         MOV     @>0056(R9),R8           top of mem word in VDP buffers header
2547  5770 0056  
2548  5772 0228         AI      R8,3                    point to max # of files
2548  5774 0003  
2549  5776 0429         BLWP    @>005A(R9)              set VDP to read
2549  5778 005A  
2550  577A 0102         DATA    >0102                   address in R8
2551  577C D0AF         MOVB    @-1026(R15),R2          get # of files
2551  577E FBFE  
2552  5780 0882         SRA     R2,8                    make it a word
2553  5782 0228         AI      R8,6                    point to drive # in file ctrl block
2553  5784 0006  
2554  5786 0203         LI      R3,>0020                filename begin with space (illegal: flag for dir)
2554  5788 0020  
2555  578A D0C6         MOVB    R6,R3                   APEDSK99: error in original disassembly (was R5)
2556  578C 06A0 H241    BL      @VDPR2B                 read 2 bytes from VDP at R8 into R0
2556  578E 4840  
2557  5790 8003         C       R3,R0                   match with that control block?
2558  5792 1309         JEQ     H242                    yes
2559  5794 0240         ANDI    R0,>00FF                keep only first char of filename
2559  5796 00FF  
2560  5798 1601         JNE     H243                    valid filename: a FDR is loaded here
2561  579A C1C8         MOV     R8,R7                   this space is free: save ptr
2562  579C 0228 H243    AI      R8,518                  point to next file control block
2562  579E 0206  
2563  57A0 0602         DEC     R2                      next file
2564  57A2 16F4         JNE     H241                    more to come
2565  57A4 045A         B       *R10                    not found: return to address passed in data word
2566  57A6 0588 H242    INC     R8                      drive matches: point to FDR
2567  57A8 CA48         MOV     R8,@>0056(R9)           save ptr
2567  57AA 0056  
2568  57AC 0455         B       *R5                     return to caller after data word
2569            *
2570            *--------------------------------------
2571            * Floating point format
2572            * ---------------------
2573            * Float numbers are 8 bytes long: EE 12 34 56 78 9A BC
2574            * EE is the exponent in radix 100 (not in radix 10 as usual!). It is biased
2575            * by 64: >40=0, 41=1 (i.e *100), >42=2 (i.e * 10,000) >3F= -1 (i.e /100), etc
2576            *
2577            * 12 ... BC are the mantissa in binary coded decimal: each byte encodes two
2578            * decimal digits from 00 to 99
2579            *
2580            * For negative numbers, the first word is negated
2581            * For zero, the first word is >0000 the others are irrelevant
2582            *
2583            * Examples: 40 08 00 00 00 00 00 00 is 8.0
2584            *           41 02 37 00 00 00 00 00 is 255.0 (>37 hex = 55 decimal)
2585            *           BF F8 00 00 00 00 00 00 is -8.0
2586            *           43 01 02 03 04 05 06 07 is 1020304.050607
2587            *--------------------------------------                                 
2588            *
2589  57AE 0202 INT2FP  LI      R2,>0800                write an integer in floating point format
2589  57B0 0800  
2590  57B2 DBC2         MOVB    R2,@-2(R15)             size=8
2590  57B4 FFFE  
2591  57B6 C141         MOV     R1,R5                   integer is in R1: save it for sign processing
2592  57B8 0241         ANDI    R1,>7FFF                clear sign bit
2592  57BA 7FFF  
2593  57BC 0281         CI      R1,100                  is it less than 100?
2593  57BE 0064  
2594  57C0 1A07         JL      H244                    yes
2595  57C2 04C0         CLR     R0                      100 or over
2596  57C4 0204         LI      R4,100                  
2596  57C6 0064  
2597  57C8 3C04         DIV     R4,R0                   divide by 100
2598  57CA 0260         ORI     R0,>4100                add exponent 2 to hundreths
2598  57CC 4100  
2599  57CE 1005         JMP     H245                    
2600            *                                       
2601  57D0 C001 H244    MOV     R1,R0                   is it 0?
2602  57D2 1302         JEQ     H246                    yes: exponent is 0
2603  57D4 0260         ORI     R0,>4000                no: add exponent 1
2603  57D6 4000  
2604  57D8 04C1 H246    CLR     R1                      next digits will be 0
2605            *                                       
2606  57DA C145 H245    MOV     R5,R5                   test sign bit
2607  57DC 1101         JLT     H247                    negative
2608  57DE 1001         JMP     H248                    positive or zero
2609  57E0 0500 H247    NEG     R0                      negate first word
2610  57E2 DBC0 H248    MOVB    R0,@-2(R15)             write exponent to VDP at preset address
2610  57E4 FFFE  
2611  57E6 06C0         SWPB    R0                      
2612  57E8 DBC0         MOVB    R0,@-2(R15)             write first first 2 digits (or hundreths)
2612  57EA FFFE  
2613  57EC 06C1         SWPB    R1                      
2614  57EE DBC1         MOVB    R1,@-2(R15)             write last 2 digits (if any)
2614  57F0 FFFE  
2615  57F2 0202         LI      R2,5                    the remaining bytes are all 0 with integers
2615  57F4 0005  
2616  57F6 DBC2 H249    MOVB    R2,@-2(R15)             write 0 to VDP
2616  57F8 FFFE  
2617  57FA 0602         DEC     R2                      next byte
2618  57FC 16FC         JNE     H249                    more to do
2619  57FE 045B         B       *R11                    
2620            *
2621            *---------------------------------------
2622            * Subprogram >10: sector R/W
2623            * --------------
2624            * >834A: (n/a)      <--- sector #
2625            * >834C: drive #
2626            * >834D: R/W code (write if >00)
2627            * >834E: VDP buffer
2628            * >8350: sector #   <--- error code
2629            *---------------------------------------                                        
2630            *
2631  5800 C1CB ESUB01  MOV     R11,R7                  
2632  5802 06A0         BL      @PRPFDO                 prepare disk operations
2632  5804 43EE  
2633  5806 CA69         MOV     @>0050(R9),@>004A(R9)   copy sector #
2633  5808 0050  
2633  580A 004A  
2634  580C 0460         B       @SECRW1                 
2634  580E 4178  
2635            *
2636            *---------------------------------------
2637            * Subprogram >11: format disk
2638            * --------------                                        
2639            *
2640  5810 C1CB ESUB02  MOV     R11,R7                  
2641  5812 06A0         BL      @PRPFDO                 prepare disk operations
2641  5814 43EE  
2642  5816 0460         B       @FMTDSK                 
2642  5818 41F6  
2643            *
2644            *---------------------------------------
2645            * Subprogram >12: file (un)protect
2646            * --------------
2647            * >834C: drive #
2648            * >834D: protect code (>00 unprotect)
2649            * >834E: ptr to filename
2650            * >8350: (n/a)      <--- error code
2651            *---------------------------------------                                
2652            *
2653  581A C1CB ESUB03  MOV     R11,R7                  
2654  581C 06A0         BL      @PRPFDO                 prepare disk operations
2654  581E 43EE  
2655  5820 D029         MOVB    @>004D(R9),R0           get protection code
2655  5822 004D  
2656  5824 0240         ANDI    R0,>0800                keep the bit that will be needed
2656  5826 0800  
2657  5828 0429         BLWP    @>005A(R9)              save R0 on stack
2657  582A 005A  
2658  582C 8000         DATA    >8000                   
2659  582E C029         MOV     @>004E(R9),R0           get pointer to filename
2659  5830 004E  
2660  5832 06A0         BL      @CALSUB                 call subroutine
2660  5834 4322  
2661  5836 591C         DATA    RFDRVB                  load FDR in VDP buffer
2662  5838 0429         BLWP    @>005A(R9)              retrieve old R0, in R2
2662  583A 005A  
2663  583C 2001         DATA    >2001                   
2664  583E 06A0         BL      @FDR2B1                 read two bytes in R0 from top of FDR + offset
2664  5840 483A  
2665  5842 000C         DATA    12                      file status byte
2666  5844 0240         ANDI    R0,>F700                clear protection flag
2666  5846 F700  
2667  5848 F002         SOCB    R2,R0                   set it if needed
2668  584A 0429         BLWP    @>005A(R9)              set VDP for write
2668  584C 005A  
2669  584E 0103         DATA    >0103                   address in R8
2670  5850 DBC0         MOVB    R0,@-2(R15)             write back file status to FDR
2670  5852 FFFE  
2671            *                                       
2672  5854 C229 UWFLVB  MOV     @>0056(R9),R8           FDR address in VDP mem
2672  5856 0056  
2673  5858 0429         BLWP    @>005A(R9)              set VDP for read
2673  585A 005A  
2674  585C 0102         DATA    >0102                   address in R8
2675  585E D02F         MOVB    @-1026(R15),R0          get drive # in ctrl block
2675  5860 FBFE  
2676  5862 0260         ORI     R0,>8000                flag it
2676  5864 8000  
2677  5866 0429         BLWP    @>005A(R9)              set VDP for write
2677  5868 005A  
2678  586A 0103         DATA    >0103                   address in R8
2679  586C DBC0         MOVB    R0,@-2(R15)             write it back
2679  586E FFFE  
2680  5870 0460         B       @UPDFDR                 update FDR, load VIB
2680  5872 4540  
2681            *
2682            *---------------------------------
2683            * Subprogram >13: file rename
2684            * --------------
2685            * >834C: drive #
2686            * >834E: ptr to new name
2687            * >8350: ptr to old name <--- error code
2688            *---------------------------------                                      
2689            *
2690  5874 C1CB ESUB04  MOV     R11,R7                  
2691  5876 06A0         BL      @PRPFDO                 prepare disk operations
2691  5878 43EE  
2692  587A C029         MOV     @>004E(R9),R0           get ptr to new filename
2692  587C 004E  
2693  587E 0429         BLWP    @>005A(R9)              save R0 on stack
2693  5880 005A  
2694  5882 8000         DATA    >8000                   
2695  5884 C029         MOV     @>0050(R9),R0           get ptr to old filename
2695  5886 0050  
2696  5888 06A0         BL      @CALSUB                 call subroutine
2696  588A 4322  
2697  588C 591C         DATA    RFDRVB                  put FDR in VDP buffer
2698  588E 06A0         BL      @RMFPTR                 remove FDR ptr from sector 1
2698  5890 47A4  
2699  5892 06A0         BL      @FDR2B1                 get 2 bytes from FDR
2699  5894 483A  
2700  5896 000C         DATA    12                      file status byte
2701  5898 0240         ANDI    R0,>0800                protected?
2701  589A 0800  
2702  589C 1303         JEQ     H250                    no
2703  589E 06A0         BL      @ERROR5                 yes: return with error
2703  58A0 493C  
2704  58A2 2000         DATA    >2000                   write protected
2705  58A4 06A0 H250    BL      @FDR2B1                 get 2 bytes from FDR
2705  58A6 483A  
2706  58A8 FFFC         DATA    -4                      sector # of FDR
2707  58AA C040         MOV     R0,R1                   
2708  58AC 0429         BLWP    @>005A(R9)              retrieve R0 from stack
2708  58AE 005A  
2709  58B0 8001         DATA    >8001                   ptr to new filename
2710  58B2 0429         BLWP    @>005A(R9)              save R1 on stack
2710  58B4 005A  
2711  58B6 4000         DATA    >4000                   sector # of FDR
2712  58B8 06A0         BL      @UFNCB                  write drive # and filename in compare buffer
2712  58BA 5B3E  
2713  58BC 06A0         BL      @CALSUB                 call subroutine
2713  58BE 4322  
2714  58C0 4B02         DATA    FFDRFN                  find FDR from filename
2715  58C2 C104         MOV     R4,R4                   found?
2716  58C4 1338         JEQ     H251                    yes: return with file error (name already exist)
2717  58C6 06A0         BL      @INSFDR                 insert a FDR in sector 1
2717  58C8 47D4  
2718  58CA 0429         BLWP    @>005A(R9)              retrieve sect # of FDR in R4
2718  58CC 005A  
2719  58CE 0801         DATA    >0801                   
2720  58D0 0429         BLWP    @>005A(R9)              set VDP to write
2720  58D2 005A  
2721  58D4 0103         DATA    >0103                   address in R8
2722  58D6 DBC4         MOVB    R4,@-2(R15)             write sector # of FDR
2722  58D8 FFFE  
2723  58DA 06C4         SWPB    R4                      
2724  58DC DBC4         MOVB    R4,@-2(R15)                     
2724  58DE FFFE  
2725  58E0 06C4         SWPB    R4                      sector #
2726  58E2 0702         SETO    R2                      code for read
2727  58E4 04C5         CLR     R5                      buffer offset: VDP at >8356
2728  58E6 06A0         BL      @CALSUB                 call subroutine
2728  58E8 4322  
2729  58EA 4A14         DATA    RDFDR1                  read FDR
2730  58EC C045         MOV     R5,R1                   
2731  58EE C029         MOV     @>0058(R9),R0                   
2731  58F0 0058  
2732  58F2 0220         AI      R0,257                  
2732  58F4 0101  
2733  58F6 0601         DEC     R1                      
2734  58F8 06A0         BL      @CFNFDR                 copy filename in compare buffer to FDR
2734  58FA 5B54  
2735  58FC 04C2         CLR     R2                      code for write
2736  58FE 06A0         BL      @CALSUB                 call subroutine
2736  5900 4322  
2737  5902 4A18         DATA    RWSEC                   write FDR (with new name in it)
2738  5904 06A0         BL      @CALSUB                 call subroutine
2738  5906 4322  
2739  5908 4A00         DATA    WRSEC1                  write sector 1 (with new FDR ptr in it)
2740  590A C069         MOV     @>0056(R9),R1           FDR ptr
2740  590C 0056  
2741  590E 0429         BLWP    @>005A(R9)              prepare VDP to write
2741  5910 005A  
2742  5912 0023         DATA    >0023                   address in R1
2743  5914 DBC4         MOVB    R4,@-2(R15)             clear first char of FDR in buffer
2743  5916 FFFE  
2744  5918 0460         B       @RTURN1                 return to caller
2744  591A 4340  
2745            *                               
2746  591C 04C6 RFDRVB  CLR     R6                      put FDR in VDP buffer
2747  591E D1A9         MOVB    @>004C(R9),R6           get drive #
2747  5920 004C  
2748  5922 06A0         BL      @UFNCB                  update filename compare buffer
2748  5924 5B3E  
2749  5926 06A0         BL      @CALSUB                 call subroutine
2749  5928 4322  
2750  592A 4A8E         DATA    FFDRVB                  look if FDR already in VDP buffer
2751  592C 06A0         BL      @CALSUB                 call subroutine
2751  592E 4322  
2752  5930 4AD2         DATA    FFDROD                  file FDR on disk
2753  5932 C104         MOV     R4,R4                   found?
2754  5934 1303         JEQ     H252                    yes
2755  5936 06A0 H251    BL      @RETERR                 no: return with error code in >8350
2755  5938 4968  
2756  593A E000         DATA    >E000                   file error
2757  593C 0460 H252    B       @RTURN1                 return to caller
2757  593E 4340  
2758            *
2759            *-------------------------------------
2760            * Subprogram >14: file raw read
2761            * --------------
2762            * >834C: drive #                          <--- >00
2763            * >834D: # of sectors (>00=get file info) <--- sectors read
2764            * >834E: ptr to filename
2765            * >8350: file info buffer (>83xx)         <--- error code
2766            *                              |
2767            * >83xx  : VDP buffer       <--'
2768            * >83xx+2: first sector # (total # of sect when get file info)
2769            * >83xx+4: status flag
2770            * >83xx+5: recs/sector
2771            * >83xx+6: eof offset
2772            * >83xx+7: rec size
2773            * >83xx+8: # of recs
2774            *-------------------------------------                                  
2775            *
2776  5940 C1CB ESUB05  MOV     R11,R7                  
2777  5942 06A0         BL      @PRPFDO                 prepare disk operations
2777  5944 43EE  
2778  5946 06A0         BL      @RFNPTR                 load filename and ptrs
2778  5948 5B76  
2779  594A 06A0         BL      @FFFDR                  find file FDR, load some info
2779  594C 5B9C  
2780  594E C082         MOV     R2,R2                   # of sectors to read
2781  5950 131E         JEQ     H253                    >00: get file info
2782  5952 6003         S       R3,R0                   sectors in file - first sector to read
2783  5954 1502         JGT     H254                    in file
2784  5956 04C2         CLR     R2                      past eof
2785  5958 1017         JMP     H255                    
2786  595A 8002 H254    C       R2,R0                   sectors past first one vs sectors to load
2787  595C 1A01         JL      H256                    
2788  595E C080         MOV     R0,R2                   load what's left
2789  5960 0429 H256    BLWP    @>005A(R9)                      
2789  5962 005A  
2790  5964 2000         DATA    >2000                   save R2
2791  5966 0429 H257    BLWP    @>005A(R9)                      
2791  5968 005A  
2792  596A 3100         DATA    >3100                   save R2, R3, R7
2793  596C 06A0         BL      @CALSUB                 call subroutine
2793  596E 4322  
2794  5970 45F4         DATA    RDOFSC                  read sector from offset in file
2795  5972 0429         BLWP    @>005A(R9)                      
2795  5974 005A  
2796  5976 3101         DATA    >3101                   retrieve R2, R3, R7
2797  5978 0583         INC     R3                      next sector
2798  597A 0227         AI      R7,256                  increment VDP buffer ptr by 256 bytes
2798  597C 0100  
2799  597E 0602         DEC     R2                      more to do?
2800  5980 16F2         JNE     H257                    yes
2801  5982 0429 H258    BLWP    @>005A(R9)                      
2801  5984 005A  
2802  5986 2001         DATA    >2001                   retrieve R2 (# of sectors read)
2803  5988 CA42 H255    MOV     R2,@>004C(R9)           update # of sectors in parameters
2803  598A 004C  
2804  598C 100A         JMP     H259                    
2805            *                                       
2806  598E CD00 H253    MOV     R0,*R4+                 get file info: sectors in file
2807  5990 0648         DECT    R8                      
2808  5992 05C2         INCT    R2                      copy 2 bytes (status + recs/sector)
2809  5994 06A0         BL      @VDP2SP                 from VDP at R8 to file info structure
2809  5996 5BD0  
2810  5998 0202         LI      R2,4                    copy 4 bytes
2810  599A 0004  
2811  599C A202         A       R2,R8                   
2812  599E 06A0         BL      @VDP2SP                 eof offset, rec len, # of recs (or # of sect)
2812  59A0 5BD0  
2813  59A2 06A0 H259    BL      @CALSUB                 call subroutine
2813  59A4 4322  
2814  59A6 4540         DATA    UPDFDR                  updata FDR (+ data) if needed, read VIB
2815  59A8 04E9         CLR     @>0050(R9)              clear error flag
2815  59AA 0050  
2816  59AC 0460         B       @RTURN1                 return to caller
2816  59AE 4340  
2817            *
2818            *--------------------------------------
2819            * Subprogram >15: file raw write
2820            * --------------
2821            * >834C: drive #                                  <--- >00
2822            * >834D: # of sectors (>00=create file from info) <--- # of sectors written
2823            * >834E: ptr to filename
2824            * >8350: file info buffer (>83xx)                 <--- error code
2825            *                              |
2826            * >83xx  : VDP buffer       <--'
2827            * >83xx+2: first sector # (total # of sectors when creating file)
2828            * >83xx+4: status flag
2829            * >83xx+5: recs/sector
2830            * >83xx+6: eof offset
2831            * >83xx+7: rec size
2832            * >83xx+8: # of recs
2833            *--------------------------------------                                 
2834            *
2835  59B0 C1CB ESUB06  MOV     R11,R7                  
2836  59B2 06A0         BL      @PRPFDO                 prepare disk operations
2836  59B4 43EE  
2837  59B6 06A0         BL      @RFNPTR                 load drive + filename, + a few info
2837  59B8 5B76  
2838  59BA 1314         JEQ     H260                    sectors to write=0: create file
2839  59BC 06A0         BL      @FFFDR                  find file FDR
2839  59BE 5B9C  
2840  59C0 0429         BLWP    @>005A(R9)                      
2840  59C2 005A  
2841  59C4 2000         DATA    >2000                   save R2 (# of sectors to write)
2842  59C6 0429 H261    BLWP    @>005A(R9)                      
2842  59C8 005A  
2843  59CA 3100         DATA    >3100                   save R2, R3, R7
2844  59CC 06A0         BL      @CALSUB                 call subroutine
2844  59CE 4322  
2845  59D0 4614         DATA    WROFSC                  write sector from offset in file
2846  59D2 0429         BLWP    @>005A(R9)                      
2846  59D4 005A  
2847  59D6 3101         DATA    >3101                   retrieve R2, R3, R7
2848  59D8 0583         INC     R3                      next sector
2849  59DA 0227         AI      R7,256                  increment VDP ptr by 256 bytes
2849  59DC 0100  
2850  59DE 0602         DEC     R2                      more to do?
2851  59E0 16F2         JNE     H261                    yes
2852  59E2 10CF         JMP     H258                    update # of sectors written, in param. Then return
2853            *                               
2854  59E4 06A0 H260    BL      @CALSUB                 create file
2854  59E6 4322  
2855  59E8 4A8E         DATA    FFDRVB                  find file FDR in VDP buffers
2856  59EA 06A0         BL      @CALSUB                 call subroutine
2856  59EC 4322  
2857  59EE 4AD2         DATA    FFDROD                  find file FDR on disk
2858  59F0 06A0         BL      @CALSUB                 call subroutine
2858  59F2 4322  
2859  59F4 4460         DATA    CRFIL2                  create file
2860  59F6 0429         BLWP    @>005A(R9)                      
2860  59F8 005A  
2861  59FA 0801         DATA    >0801                   retrieve R4 (file info ptr)
2862  59FC C229         MOV     @>0056(R9),R8           FDR ptr
2862  59FE 0056  
2863  5A00 05C4         INCT    R4                      skip 2 bytes
2864  5A02 C0F4         MOV     *R4+,R3                 # of sector to create
2865  5A04 0228         AI      R8,10                   skip filename
2865  5A06 000A  
2866  5A08 06A0         BL      @SP2VDP                 write 2 bytes in VDP at R8+2
2866  5A0A 5BE0  
2867  5A0C 0002         DATA    2                       i.e. status + recs/sector
2868  5A0E 06A0         BL      @SP2VDP                 write 4 bytes in VDP at new R8+4
2868  5A10 5BE0  
2869  5A12 0004         DATA    4                       i.e. eof offset, rec len, # of recs (or # of
2870  5A14 0603         DEC     R3                      offset = # of sectors-1 (starts from 0)
2871  5A16 1103         JLT     H262                    create an empty file, FDR only
2872  5A18 06A0         BL      @CALSUB                 
2872  5A1A 4322  
2873  5A1C 462A         DATA    APSCTS                  append enough sectors to reach offset
2874  5A1E 0460 H262    B       @UWFLVB                 modify FDR, write it, load VIB, return
2874  5A20 5854  
2875            *
2876            *---------------------------------------
2877            * Subprogram FILES: number of files
2878            *---------------------------------------                                        
2879  5A22 C1CB ESUB08  MOV     R11,R7                  
2880  5A24 06A0         BL      @PRPFDO                 prepare disk operation
2880  5A26 43EE  
2881  5A28 C229         MOV     @>002C(R9),R8           ptr to next basic token
2881  5A2A 002C  
2882  5A2C 0228         AI      R8,7                    skip FILES
2882  5A2E 0007  
2883  5A30 06A0         BL      @VDPR2B                 get next two bytes in R0
2883  5A32 4840  
2884  5A34 0280         CI      R0,>C801                >C8=unquoted string, size=1 char
2884  5A36 C801  
2885  5A38 161C         JNE     H263                    return (with error) if different
2886  5A3A 05C8         INCT    R8                      increment pointer
2887  5A3C 06A0         BL      @VDPR2B                 get next two bytes
2887  5A3E 4840  
2888  5A40 06C0         SWPB    R0                      
2889  5A42 0220         AI      R0,>49D0                substact >B630: # of files >B6=closed parenthesis
2889  5A44 49D0  
2890  5A46 0280         CI      R0,>0009                only 9 files allowed in Basic !
2890  5A48 0009  
2891  5A4A 1B13         JH      H263                    return with error if more
2892  5A4C 06C0         SWPB    R0                      
2893  5A4E DA40         MOVB    R0,@>004C(R9)           put new # of files in scratch-pad memory
2893  5A50 004C  
2894  5A52 06A0         BL      @CALSUB                 call subroutine
2894  5A54 4322  
2895  5A56 5A7C         DATA    PESB07                  subprogram >16 (private entry point)
2896  5A58 DA69         MOVB    @>0050(R9),@>0050(R9)   test result
2896  5A5A 0050  
2896  5A5C 0050  
2897  5A5E 1609         JNE     H263                    error
2898  5A60 C229         MOV     @>002C(R9),R8           ok: get ptr to Basic token
2898  5A62 002C  
2899  5A64 0228         AI      R8,12                   skip the whole statement
2899  5A66 000C  
2900  5A68 CA48         MOV     R8,@>002C(R9)           update ptr
2900  5A6A 002C  
2901  5A6C 5A69         SZCB    @>0042(R9),@>0042(R9)   clear current token
2901  5A6E 0042  
2901  5A70 0042  
2902  5A72 0460 H263    B       @RTURN1                 return to caller (i.e. Basic)
2902  5A74 4340  
2903            *
2904            *---------------------------------------
2905            * Subprogram >16: number of files
2906            * --------------
2907            * >834C: # of files
2908            * >8350: (n/a)      <--- error code
2909            *---------------------------------------                                        
2910            *
2911  5A76 C1CB ESUB07  MOV     R11,R7                  entry point from assembly
2912  5A78 06A0         BL      @PRPFDO                 prepare disk operations
2912  5A7A 43EE  
2913  5A7C 04C0 PESB07  CLR     R0                      entry point from call files
2914  5A7E D029         MOVB    @>004C(R9),R0           get # of files
2914  5A80 004C  
2915  5A82 1359         JEQ     H264                    return with error
2916  5A84 C229         MOV     @>0056(R9),R8           ptr to end of buffer word
2916  5A86 0056  
2917  5A88 0228         AI      R8,3                    point to # of files byte
2917  5A8A 0003  
2918  5A8C 04C3         CLR     R3                      
2919  5A8E 0429         BLWP    @>005A(R9)              set VDP to read
2919  5A90 005A  
2920  5A92 0102         DATA    >0102                   address in R8
2921  5A94 D0EF         MOVB    @-1026(R15),R3          get current # of files
2921  5A96 FBFE  
2922  5A98 0205         LI      R5,518                  size of 1 file control block
2922  5A9A 0206  
2923  5A9C 90C0         CB      R0,R3                   compare required with current
2924  5A9E 1348         JEQ     H265                    same: return with no error
2925  5AA0 122B         JLE     H266                    less
2926  5AA2 C180         MOV     R0,R6                   more files needed
2927  5AA4 0280         CI      R0,>1000                maximum is 16
2927  5AA6 1000  
2928  5AA8 1B46         JH      H264                    return with error
2929  5AAA 6003         S       R3,R0                   how many to add
2930  5AAC 0980         SRL     R0,8                    make it a word
2931  5AAE 3805         MPY     R5,R0                   # of bytes to add
2932  5AB0 C101         MOV     R1,R4                   result in R0:R1
2933  5AB2 0504         NEG     R4                      
2934  5AB4 C0A9         MOV     @>0070(R9),R2           highest free address in VDP mem
2934  5AB6 0070  
2935  5AB8 C002         MOV     R2,R0                   
2936  5ABA 6001         S       R1,R0                   what it would become
2937  5ABC 0280         CI      R0,>0800                is there room enough for VDP?
2937  5ABE 0800  
2938  5AC0 113A         JLT     H264                    no: return with error
2939  5AC2 C040         MOV     R0,R1                   ok: new base
2940  5AC4 0582 H267    INC     R2                      increment source ptr
2941  5AC6 0580         INC     R0                      increment destination ptr
2942  5AC8 0429         BLWP    @>005A(R9)              set VDP to read
2942  5ACA 005A  
2943  5ACC 0042         DATA    >0042                   address in R2
2944  5ACE D0EF         MOVB    @-1026(R15),R3          get a byte
2944  5AD0 FBFE  
2945  5AD2 0429         BLWP    @>005A(R9)              set VDP to write
2945  5AD4 005A  
2946  5AD6 0003         DATA    >0003                   address in R0
2947  5AD8 DBC3         MOVB    R3,@-2(R15)             copy a byte
2947  5ADA FFFE  
2948  5ADC 8202         C       R2,R8                   did we copy the whole header?
2949  5ADE 16F2         JNE     H267                    not yet
2950  5AE0 0429         BLWP    @>005A(R9)              set VDP to write
2950  5AE2 005A  
2951  5AE4 0003         DATA    >0003                   address in R0
2952  5AE6 DBC6         MOVB    R6,@-2(R15)             new # of files
2952  5AE8 FFFE  
2953  5AEA 04C6         CLR     R6                      
2954  5AEC 6080         S       R0,R2                   
2955  5AEE DBC6 H268    MOVB    R6,@-2(R15)             clear byte
2955  5AF0 FFFE  
2956  5AF2 0602         DEC     R2                      
2957  5AF4 16FC         JNE     H268                    
2958  5AF6 101A         JMP     H269                    
2959            *                                       
2960  5AF8 0429 H266    BLWP    @>005A(R9)              less files needed
2960  5AFA 005A  
2961  5AFC 0103         DATA    >0103                   set VDP to write to address in R8
2962  5AFE DBC0         MOVB    R0,@-2(R15)             new # of files in buffer header
2962  5B00 FFFE  
2963  5B02 60C0         S       R0,R3                   how many to remove
2964  5B04 0983         SRL     R3,8                    make it a word
2965  5B06 38C5         MPY     R5,R3                   # of bytes to remove
2966  5B08 C044         MOV     R4,R1                   result in R3:R4
2967  5B0A A048         A       R8,R1                   new address for buffer header
2968  5B0C C0A9         MOV     @>0070(R9),R2           highest free address in VDP mem
2968  5B0E 0070  
2969  5B10 0429 H270    BLWP    @>005A(R9)              set VDP to read
2969  5B12 005A  
2970  5B14 0102         DATA    >0102                   address in R8
2971  5B16 D02F         MOVB    @-1026(R15),R0          read a byte
2971  5B18 FBFE  
2972  5B1A 0429         BLWP    @>005A(R9)              set VDP to write
2972  5B1C 005A  
2973  5B1E 0023         DATA    >0023                   address in R1
2974  5B20 DBC0         MOVB    R0,@-2(R15)             write byte back
2974  5B22 FFFE  
2975  5B24 0601         DEC     R1                      decrement destination ptr
2976  5B26 0608         DEC     R8                      decrement source ptr
2977  5B28 8088         C       R8,R2                   did we copy the whole header?
2978  5B2A 16F2         JNE     H270                    not yet
2979            *                                       
2980  5B2C CA41 H269    MOV     R1,@>0070(R9)           new first free address                                  
2980  5B2E 0070  
2981  5B30 04E9 H265    CLR     @>0050(R9)              clear error flag
2981  5B32 0050  
2982  5B34 1002         JMP     H272                    
2983  5B36 0729 H264    SETO    @>0050(R9)              set error flag
2983  5B38 0050  
2984  5B3A 0460 H272    B       @RTURN1                 return to caller
2984  5B3C 4340  
2985            *                                       
2986  5B3E 04E9 UFNCB   CLR     @>0054(R9)              write drive # and filename in compare buffer
2986  5B40 0054  
2987  5B42 C069         MOV     @>0058(R9),R1           
2987  5B44 0058  
2988  5B46 0221         AI      R1,256                  ptr to filename compare buffer
2988  5B48 0100  
2989  5B4A 0429         BLWP    @>005A(R9)              set VDP to write
2989  5B4C 005A  
2990  5B4E 0023         DATA    >0023                   address in R1
2991  5B50 DBC6         MOVB    R6,@-2(R15)             write drive #
2991  5B52 FFFE  
2992  5B54 0202 CFNFDR  LI      R2,10                   filename must be exactly 10 chars
2992  5B56 000A  
2993  5B58 0581 H273    INC     R1                      next char in compare buffer
2994  5B5A 0429         BLWP    @>005A(R9)              set VDP to read
2994  5B5C 005A  
2995  5B5E 0002         DATA    >0002                   address in R0
2996  5B60 D0EF         MOVB    @-1026(R15),R3          get 1 char from filename
2996  5B62 FBFE  
2997  5B64 0580         INC     R0                      next char in provided filename
2998  5B66 0429         BLWP    @>005A(R9)              set VDP to write
2998  5B68 005A  
2999  5B6A 0023         DATA    >0023                   address in R1
3000  5B6C DBC3         MOVB    R3,@-2(R15)             write 1 char to compare buffer
3000  5B6E FFFE  
3001  5B70 0602         DEC     R2                      
3002  5B72 16F2         JNE     H273                    next char
3003  5B74 045B         B       *R11                    
3004            *                                       
3005  5B76 C28B RFNPTR  MOV     R11,R10                 load compare buffer and ptrs
3006  5B78 04C6         CLR     R6                      
3007  5B7A D1A9         MOVB    @>004C(R9),R6           drive #
3007  5B7C 004C  
3008  5B7E C029         MOV     @>004E(R9),R0           ptr to filename
3008  5B80 004E  
3009  5B82 06A0         BL      @UFNCB                  write them in compare buffer
3009  5B84 5B3E  
3010  5B86 D129         MOVB    @>0050(R9),R4           file info structure ptr
3010  5B88 0050  
3011  5B8A 0984         SRL     R4,8                    
3012  5B8C A109         A       R9,R4                   make it a PAB address
3013  5B8E D029         MOVB    @>004D(R9),R0           # of sectors (>00=get file info)
3013  5B90 004D  
3014  5B92 0429         BLWP    @>005A(R9)                      
3014  5B94 005A  
3015  5B96 0800         DATA    >0800                   save R4
3016  5B98 0980         SRL     R0,8                    
3017  5B9A 045A         B       *R10                    EQ set for get file info
3018            *                                       
3019  5B9C 0429 FFFDR   BLWP    @>005A(R9)              find file FDR
3019  5B9E 005A  
3020  5BA0 8010         DATA    >8010                   save R0 + R11
3021  5BA2 06A0         BL      @CALSUB                 call subroutine
3021  5BA4 4322  
3022  5BA6 4A8E         DATA    FFDRVB                  find file FDR in VDP buffers
3023  5BA8 06A0         BL      @CALSUB                 call subroutine
3023  5BAA 4322  
3024  5BAC 4AD2         DATA    FFDROD                  find FDR on disk
3025  5BAE C104         MOV     R4,R4                   found ?
3026  5BB0 1303         JEQ     H274                    yes
3027  5BB2 06A0         BL      @ERROR5                 no: return with error
3027  5BB4 493C  
3028  5BB6 E000         DATA    >E000                   file error
3029  5BB8 06A0 H274    BL      @FDR2B1                 get two bytes from FDR into R0
3029  5BBA 483A  
3030  5BBC 000E         DATA    14                      # of sectors in file
3031  5BBE 0429         BLWP    @>005A(R9)                      
3031  5BC0 005A  
3032  5BC2 2011         DATA    >2011                   retrieve R0 in R2 (# of sect to read), and R11
3033  5BC4 0429         BLWP    @>005A(R9)                      
3033  5BC6 005A  
3034  5BC8 0801         DATA    >0801                   retrieve R4 (ptr to file info structure)
3035  5BCA C1F4         MOV     *R4+,R7                 VDP buffer
3036  5BCC C0D4         MOV     *R4,R3                  first sector
3037  5BCE 045B         B       *R11                    
3038            *                                       
3039  5BD0 0429 VDP2SP  BLWP    @>005A(R9)              copy VDP bytes to scratch-pad
3039  5BD2 005A  
3040  5BD4 0102         DATA    >0102                   read from VDP at R8
3041  5BD6 DD2F H275    MOVB    @-1026(R15),*R4+        read bytes into scratch-pad at R4
3041  5BD8 FBFE  
3042  5BDA 0602         DEC     R2                      # of byte in R2
3043  5BDC 16FC         JNE     H275                    next byte
3044  5BDE 045B         B       *R11                    
3045            *                                       
3046  5BE0 C0BB SP2VDP  MOV     *R11+,R2                copy scratch-pad bytes to VDP
3047  5BE2 A202         A       R2,R8                   
3048  5BE4 0429         BLWP    @>005A(R9)              set VDP to write
3048  5BE6 005A  
3049  5BE8 0103         DATA    >0103                   address in R8 + offset in data word
3050  5BEA DBF4 H276    MOVB    *R4+,@-2(R15)           write byte from scratch-pad at R4
3050  5BEC FFFE  
3051  5BEE 0602         DEC     R2                      # of bytes in R2, was in data word
3052  5BF0 16FC         JNE     H276                    next byte
3053  5BF2 045B         B       *R11    
3054            *
3055            *----------------------------------------------------------------------------
3056            * APEDSK99 CALL subprograms
3057            *----------------------------------------------------------------------------
3058            * parameter is single digit -> 0x00
3059  5BF4 0206 PDSK    LI      R6,>0100                Protect ACOMND 
3059  5BF6 0100  
3060  5BF8 1055         JMP     ACLPRP                  generic prep
3061  5BFA 0206 UDSK    LI      R6,>0200                Unprotect ACOMND 
3061  5BFC 0200  
3062  5BFE 1052         JMP     ACLPRP                  generic prep
3063  5C00 0206 LDSK    LI      R6,>0300                Show Files on DSKx ACOMND 
3063  5C02 0300  
3064  5C04 104F         JMP     ACLPRP                  generic prep
3065            * parameters are single digit + character string -> 1x00; ! >1300 IS RESERVED (BL NTPDT+1) ! 
3066  5C06 0206 MDSK    LI      R6,>1000                Change DSK ACOMND
3066  5C08 1000  
3067  5C0A 104C         JMP     ACLPRP                  generic prep
3068  5C0C 0206 NDSK    LI      R6,>1100                create new blank SS/SD DOAD image
3068  5C0E 1100  
3069  5C10 1049         JMP     ACLPRP
3070            * parameter is a charachter string -> 2x00
3071  5C12 0206 RDSK    LI      R6,>2000                Remove DOAD from SD card ACOMND 
3071  5C14 2000  
3072  5C16 1046         JMP     ACLPRP                  generic prep
3073  5C18 0206 FGET    LI      R6,>2100                get DOAD from FTP server ACOMND
3073  5C1A 2100  
3074  5C1C 1043         JMP     ACLPRP                  generic prep
3075  5C1E 0206 FPUT    LI      R6,>2200                save DOAD to FTP server ACOMND 
3075  5C20 2200  
3076  5C22 1040         JMP     ACLPRP                  generic prep
3077  5C24 0206 ADSR    LI      R6,>2300                load DSR and reset ACOMND
3077  5C26 2300  
3078  5C28 103D         JMP     ACLPRP                  generic prep
3079  5C2A 0206 NDIR    LI      R6,>2400                change root folder
3079  5C2C 2400  
3080  5C2E 103A         JMP     ACLPRP                  generic prep
3081            * no parameters ->3x00
3082  5C30 0206 SDSK    LI      R6,>3000                Show DSKx mapping ACOMND
3082  5C32 3000  
3083  5C34 1037         JMP     ACLPRP                  generic prep
3084  5C36 0206 SDIR    LI      R6,>3100                Show SD dir ACOMND
3084  5C38 3100  
3085  5C3A 1034         JMP     ACLPRP                  generic prep
3086  5C3C 0206 AHLP    LI      R6,>3200                display APEDSK99 CALL()'s help screen
3086  5C3E 3200  
3087  5C40 1031         JMP     ACLPRP                  generic prep
3088  5C42 0206 ARST    LI      R6,>3300                reset APEDSK99 ACOMND
3088  5C44 3300  
3089  5C46 102E         JMP     ACLPRP                  generic prep
3090  5C48 0206 TIME    LI      R6,>3400                show NTP time and date
3090  5C4A 3400  
3091  5C4C 102B         JMP     ACLPRP                  generic prep
3092            *
3093            *-----------------------------------------------------------------
3094            * Subprogram PDSK / UDSK
3095            * ----------------------------------------------------------------
3096            *
3097  5C4E D806 PUDSK2  MOVB    R6,@ACOMND              send U/P DSK command to Arduino
3097  5C50 5FE8  
3098            *
3099  5C52 0208         LI      R8,12                   CALL length
3099  5C54 000C  
3100  5C56 1056         JMP     ACLBAS                  return to TI-BASIC              
3101            *                       
3102            *---------------------------------------------------------------------------------------
3103            * Subprogram MDSK / RDSK / FGET / FPUT / ADSR
3104            * --------------------------------------------------------------------------------------
3105            *
3106  5C58 05C8 MNDSK2  INCT    R8                      increment pointer
3107  5C5A 06A0         BL      @VDPR2B                 get next two digits
3107  5C5C 4840  
3108            *
3109  5C5E 0286 QTDSTR  CI      R6,>1000                only RDSK/FGET/FPUT/ADSR?
3109  5C60 1000  
3110  5C62 1A7A         JL      ACLERR                  no -> sneaky PDSK/UDSK don't belong here
3111  5C64 0220         AI      R0,>3900                add 2's complement of >C700 =  only keep # of characters
3111  5C66 3900  
3112  5C68 1377         JEQ     ACLERR                  0 characters / empty string -> * INCORRECT COMMAND
3113  5C6A 0280         CI      R0,8                    max 8 characters?
3113  5C6C 0008  
3114  5C6E 1B74         JH      ACLERR                  no -> * INCORRECT COMMAND
3115            *
3116  5C70 C100         MOV     R0,R4                   save # of characters
3117  5C72 0205         LI      R5,CALLBF+2             pointer to DOAD / DSR name      
3117  5C74 5FCA  
3118  5C76 05C8         INCT    R8                      increment pointer
3119  5C78 C088         MOV     R8,R2                   for VDPRD, address must be in R2
3120  5C7A 06A0         BL      @VDPRD                  set VDP READ address
3120  5C7C 430A  
3121  5C7E DD6F H9900   MOVB    @-1026(R15),*R5+        get character and save in CALL buffer
3121  5C80 FBFE  
3122  5C82 0600         DEC     R0                      one less to go
3123  5C84 16FC         JNE     H9900   
3124            *
3125  5C86 D02F         MOVB    @-1026(R15),R0          get next token
3125  5C88 FBFE  
3126            *
3127  5C8A 0280         CI      R0,>B600                is it a ")" ?
3127  5C8C B600  
3128  5C8E 1664         JNE     ACLERR                  * INCORRECT COMMAND
3129            *
3130  5C90 0208         LI      R8,13                   prep RDSK/FGET/FPUT/ADSR CALL length ( CALL_XXXX("") )
3130  5C92 000D  
3131  5C94 A204         A       R4,R8                   add # of characters in string
3132                    
3133  5C96 0286         CI      R6,>1100                MDSK() and NDSK?
3133  5C98 1100  
3134  5C9A 1B01         JH      H9901                   no; jump and execute RDSK/FGET/FPUT/ADSR
3135  5C9C 05C8         INCT    R8                      adjust MDSK() and NDSK() CALL length
3136            *
3137  5C9E D806 H9901   MOVB    R6,@ACOMND              command to Arduino
3137  5CA0 5FE8  
3138            *
3139  5CA2 1030         JMP     ACLBAS                  return to TI-BASIC
3140            *                       
3141            *----------------------------------------------------------------------------
3142            * Generic prep and return to TI BASIC for APEDSK99 CALL's
3143            *----------------------------------------------------------------------------
3144  5CA4 C1CB ACLPRP  MOV     R11,R7                  save return-to-TI BASIC address
3145  5CA6 06A0         BL      @PRPFDO                 prepare TI Controller DSR operations
3145  5CA8 43EE  
3146  5CAA C229         MOV     @>002C(R9),R8           ptr to next basic token
3146  5CAC 002C  
3147  5CAE 0228         AI      R8,4                    skip length byte and 3 chars of CALL name
3147  5CB0 0004  
3148  5CB2 06A0         BL      @VDPR2B                 get CALL last char and "(" or "0" in R0
3148  5CB4 4840  
3149  5CB6 0A80         SLA     R0,8                    only interested in LSB
3150  5CB8 137E         JEQ     NOPARM                  0 = no parameters? SDSK, SDIR, AHLP, ARST, TIME
3151            *
3152  5CBA 0228         AI      R8,2                    adjust token pointer
3152  5CBC 0002  
3153  5CBE 06A0         BL      @VDPR2B                 get next two bytes in R0
3153  5CC0 4840  
3154  5CC2 0280         CI      R0,>C801                >C8=unquoted string, size=1 char?
3154  5CC4 C801  
3155  5CC6 1304         JEQ     UQTSTR                  yes: PDSK, UDSK, LDSK, MDSK, NDSK
3156            *
3157  5CC8 0280         CI      R0,>C701                >C7=quoted string, minimum 1 character?
3157  5CCA C701  
3158  5CCC 14C8         JHE     QTDSTR                  yes: RDSK, FGET, FPUT, ADSR, NDIR
3159            *
3160  5CCE 1044         JMP     ACLERR                  expect the unexpected                           
3161            *
3162  5CD0 0286 UQTSTR  CI      R6,>2000                only PDSK/UDSK/LDSK/MDSK/NDSK?
3162  5CD2 2000  
3163  5CD4 1441         JHE     ACLERR                  no -> sneaky RDSK etc commands don't belong here
3164  5CD6 05C8         INCT    R8                      continue for PDSK, UDSK, LDSK, MDSK, NDSK; increment pointer
3165  5CD8 06A0         BL      @VDPR2B                 get next two bytes              
3165  5CDA 4840  
3166            *
3167  5CDC 06C0         SWPB    R0
3168  5CDE 0220         AI      R0,>49D0                add 2's complement of >B630: MSB = >B3 / "," or >B6 / ")", LSB= # of files 
3168  5CE0 49D0  
3169  5CE2 1502         JGT     H9902                   >B6
3170  5CE4 0220         AI      R0,768                  >B3, adjust R0 to positive range
3170  5CE6 0300  
3171            *
3172  5CE8 1337 H9902   JEQ     ACLERR                  DSK0 not valid, * INCORRECT COMMAND
3173  5CEA 0280         CI      R0,3                    only 3 DSK's allowed
3173  5CEC 0003  
3174  5CEE 1B34         JH      ACLERR                  if >3 * INCORRECT COMMAND
3175            *
3176  5CF0 06C0         SWPB    R0
3177  5CF2 D800         MOVB    R0,@CALLBF              save DSKx
3177  5CF4 5FC8  
3178            *
3179  5CF6 0286         CI      R6,>0200                PDSK() and UDSK()?
3179  5CF8 0200  
3180  5CFA 12A9         JLE     PUDSK2                  yep
3181  5CFC 0286         CI      R6,>0300                LDSK()?
3181  5CFE 0300  
3182  5D00 132D         JEQ     LDSK2                   yep
3183  5D02 10AA         JMP     MNDSK2                  must be MDSK() or NDSK()        
3184            *
3185  5D04 9820 ACLBAS  CB      @CALLST,@K004           "More" or "AllGood" received from Arduino?      
3185  5D06 5FC6  
3185  5D08 431E  
3186  5D0A 141A         JHE     H9904                   yep
3187            *       
3188  5D0C 0205         LI      R5,GPLINT               no; GPL routine
3188  5D0E 006A  
3189  5D10 06A0         BL      @GPLXML                 
3189  5D12 5E82  
3190  5D14 56CD         DATA    SCROLL                  scroll screen
3191  5D16 0202         LI      R2,738                  screen starting position for (error) message
3191  5D18 02E2  
3192  5D1A 06A0         BL      @VDPWRI                 set VDP address
3192  5D1C 4300  
3193  5D1E 06A0         BL      @DISSTS                 show (error) message
3193  5D20 5DD6  
3194  5D22 0205         LI      R5,GPLINT               GPL routine
3194  5D24 006A  
3195  5D26 06A0         BL      @GPLXML 
3195  5D28 5E82  
3196  5D2A 56CD         DATA    SCROLL                  scroll screen
3197            *
3198  5D2C 9820         CB      @CALLST,@K007           error?
3198  5D2E 5FC6  
3198  5D30 431D  
3199  5D32 1B06         JH      H9904                   no; be silent   
3200            *
3201  5D34 0205 H9903   LI      R5,GPLINT               yes: let's make some noise
3201  5D36 006A  
3202  5D38 06A0         BL      @GPLXML
3202  5D3A 5E82  
3203  5D3C 03D6         DATA    HONK                    GPL routine"bad tone"
3204  5D3E 1005         JMP     H9914
3205            *
3206  5D40 0286 H9904   CI      R6,>3400                TIME() ?
3206  5D42 3400  
3207  5D44 1602         JNE     H9914                   no, end the party
3208  5D46 0460         B       @TIME2                  yes; see if we can assign date/time to NTP$ 
3208  5D48 5E1A  
3209            *
3210  5D4A 04E9 H9914   CLR     @>0050(R9)              clear error flag                
3210  5D4C 0050  
3211  5D4E AA48         A       R8, @>002C(R9)          add call length to token pointer                
3211  5D50 002C  
3212  5D52 5A69         SZCB    @>0042(R9),@>0042(R9)   clear current token
3212  5D54 0042  
3212  5D56 0042  
3213  5D58 0460 ACLERR  B       @RTURN1                 return to caller (i.e. TI-BASIC)
3213  5D5A 4340  
3214            *
3215            *-----------------------------------------------------------------
3216            * Subprogram SDSK / LDSK / SDIR/ AHLP / TIME
3217            * ----------------------------------------------------------------
3218            *
3219  5D5C D806 LDSK2   MOVB    R6,@ACOMND              LDSK/SDSK/SDIR/AHLP command to Arduino
3219  5D5E 5FE8  
3220  5D60 9820         CB      @K002,@CALLST
3220  5D62 431C  
3220  5D64 5FC6  
3221  5D66 132F         JEQ     QTLSSA                  LDSK: >00; no DOAD mapped
3222            *
3223  5D68 04C2 LDNXTS  CLR     R2                      clear screen; position 0
3224  5D6A 06A0         BL      @VDPWRI
3224  5D6C 4300  
3225            *
3226  5D6E 0200         LI      R0,>8000                space + TI BASIC bias
3226  5D70 8000  
3227  5D72 06A0         BL      @VDPRPW
3227  5D74 4248  
3228  5D76 02C0         DATA    704                     704 positions to clear
3229            *
3230  5D78 0202         LI      R2,33                   start 2nd screen line; 1st is lost due to TI BASIC scroll
3230  5D7A 0021  
3231  5D7C 06A0         BL      @VDPWRI                 
3231  5D7E 4300  
3232            *       
3233  5D80 9820 H9905   CB      @K004,@CALLST           check Arduino LDSK/SDSK/SDIR/AHLP return code
3233  5D82 431E  
3233  5D84 5FC6  
3234  5D86 131F         JEQ     QTLSSA                  "More" (>F0); blank "floppy" or done last file / help txt
3235            *
3236  5D88 06A0         BL      @DISSTS                 LDSK/SDSK/SDIR/AHLP output to screen
3236  5D8A 5DD6  
3237            *
3238  5D8C 0222         AI      R2,32                   next screen position
3238  5D8E 0020  
3239  5D90 0282         CI      R2,673                  end of display area?
3239  5D92 02A1  
3240  5D94 1303         JEQ     NXTPRP                  yes; show "more" symbol
3241            *
3242  5D96 C802         MOV     R2,@RDINT               generates interrupt for next file
3242  5D98 5FEA  
3243  5D9A 10F2         JMP     H9905   
3244            *       
3245  5D9C 0202 NXTPRP  LI      R2,703
3245  5D9E 02BF  
3246  5DA0 06A0         BL      @VDPWRI
3246  5DA2 4300  
3247  5DA4 0205         LI      R5,>9E00                ">", more files to display
3247  5DA6 9E00  
3248  5DA8 DBC5         MOVB    R5,@-2(R15)
3248  5DAA FFFE  
3249            *
3250  5DAC 06A0         BL      @CHKKEY
3250  5DAE 5DE8  
3251            *
3252  5DB0 C802         MOV     R2,@RDINT               generates interrupt for next file
3252  5DB2 5FEA  
3253  5DB4 10D9         JMP     LDNXTS
3254            *
3255            *-----------------------------------------------------------------------------------------
3256            * Subprogram ARST / TIME
3257            * ----------------------------------------------------------------------------------------
3258            *
3259  5DB6 0286 NOPARM  CI      R6,>3000                catch PDSK/UDSK/LDSK/MDSK/NDSK/RDSK/FGET/FPUT/ADSR without parameters -> error
3259  5DB8 3000  
3260  5DBA 1ACE         JL      ACLERR
3261  5DBC 0286         CI      R6,>3300                ARST() or TIME() ?      
3261  5DBE 3300  
3262  5DC0 1ACD         JL      LDSK2                   no; SDSK/SDIR/AHLP use LDSK display routine
3263            *
3264  5DC2 D806 ARST2   MOVB    R6,@ACOMND              execute ARST() or TIME()
3264  5DC4 5FE8  
3265            *
3266  5DC6 0208 QTLSSA  LI      R8,9                    current CALL length
3266  5DC8 0009  
3267  5DCA 0286         CI      R6,>0300                LDSK()?
3267  5DCC 0300  
3268  5DCE 1B02         JH      H9906                   nope; exit with CALL lenght 9 for SDSK/SDIR/AHLP
3269  5DD0 0228         AI      R8,3                    yep;  exit with CALL length 12 for LDSK
3269  5DD2 0003  
3270            *
3271  5DD4 1097 H9906   JMP     ACLBAS  
3272            *
3273            * Display data, status messages and errors
3274            *
3275  5DD6 0205 DISSTS  LI      R5,CALLBF               start of file name buffer
3275  5DD8 5FC8  
3276  5DDA 0206         LI      R6,32                   32 bytes / 1 screen row of data to display
3276  5DDC 0020  
3277  5DDE DBF5 H9907   MOVB    *R5+,@-2(R15)           store character in VDP screen memory
3277  5DE0 FFFE  
3278  5DE2 0606         DEC     R6
3279  5DE4 16FC         JNE     H9907
3280  5DE6 045B         B       *R11
3281            *
3282            * Quick key test to display next screen after ">"
3283            * Keyboard column 0 (= space enter <nc> fctn shift ctrl <nc>)
3284            * Code copy from Thierry's TI's Tech Pages site
3285            *
3286  5DE8 C10C CHKKEY  MOV     R12,R4                  save R12
3287  5DEA 04C1         CLR     R1                      test column 0
3288  5DEC 020C         LI      R12,>0024               address for column selection
3288  5DEE 0024  
3289  5DF0 30C1 H9908   LDCR    R1,3                    select column
3290  5DF2 1FF2         TB      -14                     test R12 address >0008
3291  5DF4 1607         JNE     H9909                   <SPACE>
3292  5DF6 1FF3         TB      -13                     test R12 address >000A
3293  5DF8 13FB         JEQ     H9908                   no key; test again
3294            *
3295  5DFA D820         MOVB    @K004,@CALLST           signal ENTER to SDIR() command
3295  5DFC 431E  
3295  5DFE 5FC6  
3296  5E00 020B         LI      R11,QTLSSA              leave without clearing screen
3296  5E02 5DC6  
3297            *
3298  5E04 C304 H9909   MOV     R4,R12                  restore R12
3299  5E06 0A24         SLA     R4,2                    debounce delay
3300  5E08 0604 H9910   DEC     R4                      key debounce
3301  5E0A 16FE         JNE     H9910                   debounce some more
3302            *
3303  5E0C 045B         B       *R11                    we got one; return for next screen
3304            *               
3305            * update FAT time/date for current DOAD after DSR Format / Write / Save
3306            *
3307  5E0E D820 NTPDT   MOVB    @NTPFAT+1,@ACOMND       "DSK NTP date/time update" command to Arduino           
3307  5E10 4027  
3307  5E12 5FE8  
3308  5E14 045B         B       *R11                    return to Format / Close
3309            *       
3310            * prep for calling XML >16 and update BASIC variable NTP$               
3311            *
3312  5E16 4E54 VARINF  TEXT    'NTP$'
3312  5E18 5024  
3313  5E1A 0204 TIME2   LI      R4,VARINF               variable name for XML >16 in FAC
3313  5E1C 5E16  
3314  5E1E C149         MOV     R9,R5                   get scratchpad start address
3315  5E20 D974 H9911   MOVB    *R4+,@>004A(R5)         variable name in FAC
3315  5E22 004A  
3316  5E24 0585         INC     R5
3317  5E26 0284         CI      R4,VARINF+4             done all chars?
3317  5E28 5E1A  
3318  5E2A 16FA         JNE     H9911                   
3319            *
3320  5E2C 0205         LI      R5,>0400                variable length for XML >16 in @>8359
3320  5E2E 0400  
3321  5E30 DA45         MOVB    R5,@>0059(R9)           
3321  5E32 0059  
3322  5E34 04E9         CLR     @>0089(R9)      
3322  5E36 0089  
3323            *
3324  5E38 0205         LI      R5,XML16                ROM routine: find NTP$ in VDP symbol table (returns to GPL interpreter)
3324  5E3A 15D6  
3325  5E3C 06A0         BL      @GPLXML
3325  5E3E 5E82  
3326  5E40 2244         DATA    XMLRTN                  GPL "RTN", escaping GPL interpreter
3327            *
3328  5E42 9A60         CB      @VARINF,@>004A(R9)      found NTP$ in VDP symbol table?
3328  5E44 5E16  
3328  5E46 004A  
3329  5E48 1318         JEQ     H9913                   no symbol table pointer; back to BASIC
3330            *
3331  5E4A 06A0         BL      @XML14                  ROM routine: get NTP$ VDP address and string length (returns through RT)
3331  5E4C 164E  
3332  5E4E 02A9         STWP    R9                      restore scratchpad pointer
3333  5E50 0229         AI      R9,-224
3333  5E52 FF20  
3334            *       
3335  5E54 C169         MOV     @>0050(R9),R5           get string length
3335  5E56 0050  
3336  5E58 0285         CI      R5,16                   16 chars?
3336  5E5A 0010  
3337  5E5C 160E         JNE     H9913                   no NTP$ assignment for you
3338            *
3339  5E5E C0A0         MOV     @>834E,R2               yes
3339  5E60 834E  
3340  5E62 06A0         BL      @VDPWRI                 set VDP write address
3340  5E64 4300  
3341  5E66 0205         LI      R5,CALLBF               CALL TIME data still in buffer
3341  5E68 5FC8  
3342  5E6A D0B5 H9912   MOVB    *R5+,R2                 read character
3343  5E6C 0222         AI      R2,>A000                remove TI BASIC bias
3343  5E6E A000  
3344  5E70 DBC2         MOVB    R2,@-2(R15)             save to NTP$ value space
3344  5E72 FFFE  
3345  5E74 0285         CI      R5,CALLBF+16            done all 16 chars?
3345  5E76 5FD8  
3346  5E78 16F8         JNE     H9912                   no; one more
3347            *
3348  5E7A 0460 H9913   B       @H9914                  yes; back to BASIC
3348  5E7C 5D4A  
3349            *
3350            * execute GROM or XML routine (SCROLL, "bad sound"/ HONK and XML >16)
3351            * DSR and GPL interpreter use same workspace (>83E0) so we need to save a few things
3352            *
3353  5E7E 0000 SAVGRA  BSS     2                       save current GROM address so we can return to BASIC
3354  5E80 0000 SAVR11  BSS     2                       GPL interpreter uses R11
3355            *
3356  5E82 D820 GPLXML  MOVB    @>9802,@SAVGRA          save current GROM address
3356  5E84 9802  
3356  5E86 5E7E  
3357  5E88 1000         NOP
3358  5E8A D820         MOVB    @>9802,@SAVGRA+1
3358  5E8C 9802  
3358  5E8E 5E7F  
3359  5E90 0620         DEC     @SAVGRA                 GRMWA returns address + 1; decrease for correct address
3359  5E92 5E7E  
3360            *
3361  5E94 D83B         MOVB    *R11+,@>9C02            set GPL routine address
3361  5E96 9C02  
3362  5E98 1000         NOP
3363  5E9A D83B         MOVB    *R11+,@>9C02
3363  5E9C 9C02  
3364  5E9E C80B         MOV     R11,@SAVR11             save final DSR return address
3364  5EA0 5E80  
3365            *
3366  5EA2 020B         LI      R11,GXRTN               DSR return address after GPL routine
3366  5EA4 5EBE  
3367  5EA6 C80B         MOV     R11,@RTN5C              @>4028 is where XML >5C returns to
3367  5EA8 4028  
3368            *
3369  5EAA 05E0         INCT    @>8373                  increase stack pointer
3369  5EAC 8373  
3370  5EAE 06C9         SWPB    R9                      
3371  5EB0 D260         MOVB    @>8373,R9
3371  5EB2 8373  
3372  5EB4 06C9         SWPB    R9                      complete stack pointer in R9
3373  5EB6 020B         LI      R11,XML5C               GROM pointer to >0F5C (= XML >5C)
3373  5EB8 105C  
3374  5EBA C64B         MOV     R11,*R9                 save GROM pointer on stack
3375            *
3376  5EBC 0455         B       *R5                     execute GROM/ROM routine, return through GPL interpreter
3377            *
3378  5EBE D820 GXRTN   MOVB    @SAVGRA,@>9C02          and ... we're back; restore saved GROM address
3378  5EC0 5E7E  
3378  5EC2 9C02  
3379  5EC4 1000         NOP
3380  5EC6 D820         MOVB    @SAVGRA+1,@>9C02
3380  5EC8 5E7F  
3380  5ECA 9C02  
3381            *
3382  5ECC 02A9         STWP    R9                      restore scratchpad pointer
3383  5ECE 0229         AI      R9,-224
3383  5ED0 FF20  
3384            *
3385  5ED2 C2E0         MOV     @SAVR11,R11             restore R11
3385  5ED4 5E80  
3386  5ED6 045B         B       *R11                    return to instruction after BL @GPLEXEC DATA statement
3387            *
3388            *----------------------------------------------------------------------------------
3389            * >5EBC - >5FB3: 219 free bytes remaining
3390            * >5FC2 - >5FD3 is DSK1-3 parameters storage
3391            * >5FD4 is the CALL() status byte
3392            * >5FD6 - >5FE7 is buffer storage for APEDSK99 CALL's
3393            * >5FE8 is the Arduino Command Register (TI BASIC CALL support)
3394            * Word >5FEA maps to the read counter (R6, to generate interrupts when reading data) 
3395            * Bytes >5FEE maps to the CRU emulation write register
3396            * Bytes >5FF0 to >5FFE map to the FDC emulation registers
3397            *-----------------------------------------------------------------------------------                                    
3398            *
3399  5ED8 0000         END
3399            


 Assembly Complete - Errors: 0,  Warnings: 0


 ------ Symbol Listing ------

 ACLBAS ABS:5D04 ACLBAS
 ACLERR ABS:5D58 ACLERR
 ACLPRP ABS:5CA4 ACLPRP
 ACOMND ABS:5FE8 ACOMND
 ADDSEC ABS:46CE ADDSEC
 ADSR   ABS:5C24 ADSR
 AFDRPT ABS:5292 AFDRPT
 AFPGPF ABS:51A8 AFPGPF
 AHLP   ABS:5C3C AHLP
 APSCTS ABS:462A APSCTS
 ARST   ABS:5C42 ARST
 ARST2  ABS:5DC2 ARST2
 CALLBF ABS:5FC8 CALLBF
 CALLST ABS:5FC6 CALLST
 CALSUB ABS:4322 CALSUB
 CFNFDR ABS:5B54 CFNFDR
 CFSVIB ABS:5730 CFSVIB
 CHKKEY ABS:5DE8 CHKKEY
 CLOSE  ABS:4F9A CLOSE
 CLRFBT ABS:454C CLRFBT
 CLSDIR ABS:55DA CLSDIR
 CMPFN  ABS:4806 CMPFN
 CPCKFN ABS:48DE CPCKFN
 CRFIL1 ABS:445A CRFIL1
 CRFIL2 ABS:4460 CRFIL2
 CRFIL3 ABS:446C CRFIL3
 CRUWRI ABS:5FEE CRUWRI
 DECDCI ABS:4B80 DECDCI
 DELETE ABS:4738 DELETE
 DISSTS ABS:5DD6 DISSTS
 DSDRVS ABS:4320 DSDRVS
 DSKPRM ABS:5FB4 DSKPRM
 DSR01  ABS:40E2 DSR01
 DSR02  ABS:40EA DSR02
 DSR03  ABS:40F4 DSR03
 DSR04  ABS:40FE DSR04
 ECUSTM ABS:435A ECUSTM
 EDSR01 ABS:4D16 EDSR01
 EDSR02 ABS:4D24 EDSR02
 EDSR03 ABS:4D2A EDSR03
 EDSR04 ABS:4D30 EDSR04
 EPWRUP ABS:4108 EPWRUP
 ERROR1 ABS:42BE ERROR1
 ERROR3 ABS:41F0 ERROR3
 ERROR4 ABS:425C ERROR4
 ERROR5 ABS:493C ERROR5
 ERROR6 ABS:4AF2 ERROR6
 ERROR7 ABS:48E2 ERROR7
 ERROR8 ABS:4D82 ERROR8
 ERROR9 ABS:4D9E ERROR9
 ERRR10 ABS:55B6 ERRR10
 ESUB01 ABS:5800 ESUB01
 ESUB02 ABS:5810 ESUB02
 ESUB03 ABS:581A ESUB03
 ESUB04 ABS:5874 ESUB04
 ESUB05 ABS:5940 ESUB05
 ESUB06 ABS:59B0 ESUB06
 ESUB07 ABS:5A76 ESUB07
 ESUB08 ABS:5A22 ESUB08
 FDR2B1 ABS:483A FDR2B1
 FDR2B2 ABS:483E FDR2B2
 FDSKDR ABS:4854 FDSKDR
 FFDRDK ABS:4AD6 FFDRDK
 FFDRFN ABS:4B02 FFDRFN
 FFDROD ABS:4AD2 FFDROD
 FFDRVB ABS:4A8E FFDRVB
 FFDRVP ABS:5198 FFDRVP
 FFFDR  ABS:5B9C FFFDR
 FFFDRV ABS:4A6E FFFDRV
 FFSBM  ABS:4C86 FFSBM
 FFSBMP ABS:4BC0 FFSBMP
 FFSVIB ABS:45A4 FFSVIB
 FGET   ABS:5C18 FGET
 FMTDSK ABS:41F6 FMTDSK
 FNDFDR ABS:4ACC FNDFDR
 FNDRV  ABS:576A FNDRV
 FPUT   ABS:5C1E FPUT
 FRSCB1 ABS:4C8C FRSCB1
 FSCTOF ABS:4714 FSCTOF
 GPLINT ABS:006A GPLINT
 GPLXML ABS:5E82 GPLXML
 GXRTN  ABS:5EBE GXRTN
 H001   ABS:412E H001
 H005   ABS:4192 H005
 H013   ABS:4196 H013
 H014   ABS:41C4 H014
 H015   ABS:41A4 H015
 H016   ABS:41B2 H016
 H019   ABS:41C0 H019
 H024   ABS:41DA H024
 H027   ABS:41FA H027
 H036   ABS:4212 H036
 H037   ABS:4222 H037
 H038   ABS:4230 H038
 H044   ABS:424A H044
 H055   ABS:426C H055
 H056   ABS:428A H056
 H057   ABS:4282 H057
 H058   ABS:4288 H058
 H061   ABS:42AC H061
 H064   ABS:42D0 H064
 H066   ABS:42D6 H066
 H068   ABS:42FA H068
 H069   ABS:430E H069
 H070   ABS:43A2 H070
 H071   ABS:43D0 H071
 H072   ABS:437E H072
 H073   ABS:43CC H073
 H074   ABS:43A8 H074
 H075   ABS:43E4 H075
 H076   ABS:440E H076
 H077   ABS:44F6 H077
 H078   ABS:4482 H078
 H079   ABS:44DA H079
 H080   ABS:450C H080
 H081   ABS:4536 H081
 H082   ABS:4516 H082
 H083   ABS:4528 H083
 H084   ABS:453C H084
 H085   ABS:4574 H085
 H086   ABS:45A0 H086
 H087   ABS:45C2 H087
 H088   ABS:45F0 H088
 H089   ABS:45CC H089
 H090   ABS:4604 H090
 H091   ABS:460E H091
 H092   ABS:46C2 H092
 H093   ABS:463A H093
 H094   ABS:4660 H094
 H095   ABS:464E H095
 H096   ABS:4696 H096
 H097   ABS:46A4 H097
 H098   ABS:46A2 H098
 H099   ABS:469A H099
 H100   ABS:46B2 H100
 H101   ABS:46CA H101
 H102   ABS:4712 H102
 H103   ABS:4728 H103
 H104   ABS:4734 H104
 H105   ABS:471E H105
 H106   ABS:4750 H106
 H107   ABS:4772 H107
 H108   ABS:4766 H108
 H109   ABS:47B6 H109
 H110   ABS:47E6 H110
 H111   ABS:480E H111
 H112   ABS:4832 H112
 H113   ABS:486C H113
 H114   ABS:4876 H114
 H115   ABS:48D4 H115
 H116   ABS:487E H116
 H118   ABS:48CC H118
 H119   ABS:48E8 H119
 H120   ABS:48F6 H120
 H121   ABS:4932 H121
 H122   ABS:4902 H122
 H123   ABS:4966 H123
 H124   ABS:4988 H124
 H125   ABS:498C H125
 H126   ABS:49F2 H126
 H127   ABS:49C4 H127
 H128   ABS:49D8 H128
 H129   ABS:49E8 H129
 H130   ABS:4A66 H130
 H131   ABS:4A48 H131
 H132   ABS:4A5E H132
 H133   ABS:4A58 H133
 H134   ABS:4AA8 H134
 H135   ABS:4AC8 H135
 H136   ABS:4A8A H136
 H137   ABS:4AF8 H137
 H138   ABS:4ADE H138
 H139   ABS:4B0E H139
 H140   ABS:4B74 H140
 H141   ABS:4B70 H141
 H142   ABS:4B7A H142
 H143   ABS:4BD4 H143
 H144   ABS:4BE6 H144
 H145   ABS:4BF6 H145
 H146   ABS:4C02 H146
 H147   ABS:4C32 H147
 H148   ABS:4C28 H148
 H149   ABS:4C7C H149
 H150   ABS:4C3A H150
 H151   ABS:4C60 H151
 H152   ABS:4CB8 H152
 H153   ABS:4CCC H153
 H154   ABS:4CC6 H154
 H155   ABS:4CC8 H155
 H156   ABS:4CCE H156
 H157   ABS:4CF6 H157
 H158   ABS:4CFE H158
 H159   ABS:4D3A H159
 H160   ABS:4D34 H160
 H161   ABS:4D60 H161
 H162   ABS:4DA4 H162
 H163   ABS:4DBA H163
 H164   ABS:4E6E H164
 H165   ABS:4DC6 H165
 H166   ABS:4DF8 H166
 H167   ABS:4E10 H167
 H168   ABS:4E14 H168
 H169   ABS:4E6A H169
 H170   ABS:4E96 H170
 H171   ABS:4E92 H171
 H172   ABS:4EBA H172
 H173   ABS:4EE8 H173
 H174   ABS:4F40 H174
 H175   ABS:4F66 H175
 H176   ABS:4F6A H176
 H177   ABS:4FB4 H177
 H178   ABS:4FCE H178
 H179   ABS:4FB0 H179
 H180   ABS:4FC6 H180
 H181   ABS:4FC0 H181
 H182   ABS:4FF0 H182
 H183   ABS:5026 H183
 H184   ABS:500A H184
 H185   ABS:5034 H185
 H186   ABS:5058 H186
 H187   ABS:5060 H187
 H188   ABS:5084 H188
 H189   ABS:50CA H189
 H190   ABS:50C2 H190
 H191   ABS:5170 H191
 H192   ABS:50D4 H192
 H193   ABS:50EA H193
 H194   ABS:5100 H194
 H195   ABS:51E4 H195
 H196   ABS:5204 H196
 H197   ABS:520A H197
 H198   ABS:5266 H198
 H199   ABS:5276 H199
 H200   ABS:535E H200
 H201   ABS:5392 H201
 H202   ABS:53A0 H202
 H203   ABS:53A6 H203
 H204   ABS:53E4 H204
 H205   ABS:5406 H205
 H206   ABS:53E8 H206
 H207   ABS:5412 H207
 H208   ABS:5434 H208
 H209   ABS:5444 H209
 H210   ABS:54BA H210
 H211   ABS:54E6 H211
 H212   ABS:5566 H212
 H213   ABS:5552 H213
 H214   ABS:54F4 H214
 H215   ABS:5500 H215
 H216   ABS:5522 H216
 H217   ABS:550C H217
 H218   ABS:554E H218
 H219   ABS:5534 H219
 H220   ABS:5562 H220
 H221   ABS:5590 H221
 H222   ABS:55A0 H222
 H223   ABS:558A H223
 H224   ABS:55BC H224
 H225   ABS:55C6 H225
 H226   ABS:5620 H226
 H227   ABS:569C H227
 H228   ABS:5692 H228
 H229   ABS:5682 H229
 H230   ABS:568C H230
 H231   ABS:569A H231
 H232   ABS:56BA H232
 H233   ABS:56F4 H233
 H234   ABS:56CA H234
 H235   ABS:56EC H235
 H236   ABS:5740 H236
 H237   ABS:5764 H237
 H238   ABS:5756 H238
 H239   ABS:575A H239
 H240   ABS:5760 H240
 H241   ABS:578C H241
 H242   ABS:57A6 H242
 H243   ABS:579C H243
 H244   ABS:57D0 H244
 H245   ABS:57DA H245
 H246   ABS:57D8 H246
 H247   ABS:57E0 H247
 H248   ABS:57E2 H248
 H249   ABS:57F6 H249
 H250   ABS:58A4 H250
 H251   ABS:5936 H251
 H252   ABS:593C H252
 H253   ABS:598E H253
 H254   ABS:595A H254
 H255   ABS:5988 H255
 H256   ABS:5960 H256
 H257   ABS:5966 H257
 H258   ABS:5982 H258
 H259   ABS:59A2 H259
 H260   ABS:59E4 H260
 H261   ABS:59C6 H261
 H262   ABS:5A1E H262
 H263   ABS:5A72 H263
 H264   ABS:5B36 H264
 H265   ABS:5B30 H265
 H266   ABS:5AF8 H266
 H267   ABS:5AC4 H267
 H268   ABS:5AEE H268
 H269   ABS:5B2C H269
 H270   ABS:5B10 H270
 H272   ABS:5B3A H272
 H273   ABS:5B58 H273
 H274   ABS:5BB8 H274
 H275   ABS:5BD6 H275
 H276   ABS:5BEA H276
 H9900  ABS:5C7E H9900
 H9901  ABS:5C9E H9901
 H9902  ABS:5CE8 H9902
 H9903  ABS:5D34 H9903
 H9904  ABS:5D40 H9904
 H9905  ABS:5D80 H9905
 H9906  ABS:5DD4 H9906
 H9907  ABS:5DDE H9907
 H9908  ABS:5DF0 H9908
 H9909  ABS:5E04 H9909
 H9910  ABS:5E08 H9910
 H9911  ABS:5E20 H9911
 H9912  ABS:5E6A H9912
 H9913  ABS:5E7A H9913
 H9914  ABS:5D4A H9914
 HONK   ABS:03D6 HONK
 INSFDR ABS:47D4 INSFDR
 INT2FP ABS:57AE INT2FP
 K001   ABS:4176 K001
 K002   ABS:431C K002
 K004   ABS:431E K004
 K005   ABS:431F K005
 K007   ABS:431D K007
 K013   ABS:42CE K013
 K014   ABS:493A K014
 LASTRK ABS:42DC LASTRK
 LDNXTS ABS:5D68 LDNXTS
 LDSK   ABS:5C00 LDSK
 LDSK2  ABS:5D5C LDSK2
 LOAD   ABS:5396 LOAD
 MDSK   ABS:5C06 MDSK
 MNDSK2 ABS:5C58 MNDSK2
 NDIR   ABS:5C2A NDIR
 NDSK   ABS:5C0C NDSK
 NOCRU  ABS:4174 NOCRU
 NOPARM ABS:5DB6 NOPARM
 NTPDT  ABS:5E0E NTPDT
 NTPFAT ABS:4026 NTPFAT
 NXTPRP ABS:5D9C NXTPRP
 OPCVEC ABS:4D68 OPCVEC
 OPEN   ABS:4D88 OPEN
 OPNDIR ABS:557C OPNDIR
 PABR2B ABS:4834 PABR2B
 PDSK   ABS:5BF4 PDSK
 PESB07 ABS:5A7C PESB07
 PRFDRS ABS:4F48 PRFDRS
 PRPFDO ABS:43EE PRPFDO
 PRPRTN ABS:43F0 PRPRTN
 PUDSK2 ABS:5C4E PUDSK2
 PWRUP  ABS:40DC PWRUP
 QTDSTR ABS:5C5E QTDSTR
 QTLSSA ABS:5DC6 QTLSSA
 R0     ABS:0000 R0
 R1     ABS:0001 R1
 R10    ABS:000A R10
 R11    ABS:000B R11
 R12    ABS:000C R12
 R13    ABS:000D R13
 R14    ABS:000E R14
 R15    ABS:000F R15
 R2     ABS:0002 R2
 R3     ABS:0003 R3
 R4     ABS:0004 R4
 R5     ABS:0005 R5
 R6     ABS:0006 R6
 R7     ABS:0007 R7
 R8     ABS:0008 R8
 R9     ABS:0009 R9
 RBANB  ABS:5488 RBANB
 RCOFCB ABS:5318 RCOFCB
 RDATA  ABS:5FF6 RDATA
 RDDIR  ABS:55F0 RDDIR
 RDFDR1 ABS:4A14 RDFDR1
 RDFDR2 ABS:4A10 RDFDR2
 RDINT  ABS:5FEA RDINT
 RDOFSC ABS:45F4 RDOFSC
 RDSEC1 ABS:49FE RDSEC1
 RDSK   ABS:5C12 RDSK
 READ   ABS:4FA4 READ
 RETERR ABS:4968 RETERR
 RFDRST ABS:51C4 RFDRST
 RFDRVB ABS:591C RFDRVB
 RFNPTR ABS:5B76 RFNPTR
 RMFPTR ABS:47A4 RMFPTR
 RNFISE ABS:5222 RNFISE
 RRFDR  ABS:523E RRFDR
 RRNPAB ABS:51D8 RRNPAB
 RRSEC  ABS:502A RRSEC
 RSTAT  ABS:5FF0 RSTAT
 RSTDRV ABS:4290 RSTDRV
 RTN5C  ABS:4028 RTN5C
 RTURN1 ABS:4340 RTURN1
 RVRVDP ABS:43A6 RVRVDP
 RWIND1 ABS:5342 RWIND1
 RWIND2 ABS:5370 RWIND2
 RWSEC  ABS:4A18 RWSEC
 RWSECA ABS:4A1A RWSECA
 RWSECB ABS:4A1C RWSECB
 RWVIB  ABS:499C RWVIB
 SAVE   ABS:5438 SAVE
 SAVGRA ABS:5E7E SAVGRA
 SAVR11 ABS:5E80 SAVR11
 SCROLL ABS:56CD SCROLL
 SDIR   ABS:5C36 SDIR
 SDSK   ABS:5C30 SDSK
 SECRW1 ABS:4178 SECRW1
 SELDRV ABS:4262 SELDRV
 SNDCMD ABS:42D4 SNDCMD
 SP2VDP ABS:5BE0 SP2VDP
 STATUS ABS:54BC STATUS
 SUB01  ABS:4010 SUB01
 SUB02  ABS:4016 SUB02
 SUB03  ABS:401C SUB03
 SUB04  ABS:4022 SUB04
 SUB05  ABS:402A SUB05
 SUB06  ABS:4030 SUB06
 SUB07  ABS:4036 SUB07
 SUB08  ABS:403C SUB08
 SUB09  ABS:4046 SUB09
 SUB10  ABS:4050 SUB10
 SUB11  ABS:405A SUB11
 SUB12  ABS:4064 SUB12
 SUB13  ABS:406E SUB13
 SUB14  ABS:4078 SUB14
 SUB15  ABS:4082 SUB15
 SUB16  ABS:408C SUB16
 SUB17  ABS:4096 SUB17
 SUB18  ABS:40A0 SUB18
 SUB19  ABS:40AA SUB19
 SUB20  ABS:40B4 SUB20
 SUB21  ABS:40BE SUB21
 SUB22  ABS:40C8 SUB22
 SUB23  ABS:40D2 SUB23
 SVDPRD ABS:43DC SVDPRD
 SVDPWR ABS:43D2 SVDPWR
 SVRVDP ABS:437A SVRVDP
 TIME   ABS:5C48 TIME
 TIME2  ABS:5E1A TIME2
 UCOFCB ABS:52B6 UCOFCB
 UDSK   ABS:5BFA UDSK
 UFNCB  ABS:5B3E UFNCB
 UPDBF  ABS:4560 UPDBF
 UPDCLI ABS:4B9C UPDCLI
 UPDFCB ABS:4F72 UPDFCB
 UPDFDR ABS:4540 UPDFDR
 UQTSTR ABS:5CD0 UQTSTR
 URFFDR ABS:52E2 URFFDR
 UWFLVB ABS:5854 UWFLVB
 VARINF ABS:5E16 VARINF
 VDP2SP ABS:5BD0 VDP2SP
 VDPR2B ABS:4840 VDPR2B
 VDPRD  ABS:430A VDPRD
 VDPRPW ABS:4248 VDPRPW
 VDPWRI ABS:4300 VDPWRI
 VECRTN ABS:4372 VECRTN
 WCOMND ABS:5FF8 WCOMND
 WDATA  ABS:5FFE WDATA
 WFDRPB ABS:5006 WFDRPB
 WRFDR  ABS:4A0A WRFDR
 WRITE  ABS:508E WRITE
 WROFSC ABS:4614 WROFSC
 WRSEC1 ABS:4A00 WRSEC1
 WSECTR ABS:5FFC WSECTR
 WTCPT1 ABS:4254 WTCPT1
 XML14  ABS:164E XML14
 XML16  ABS:15D6 XML16
 XML5C  ABS:105C XML5C
 XMLRTN ABS:2244 XMLRTN
