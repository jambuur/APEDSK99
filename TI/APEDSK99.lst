Asm994a TMS99000 Assembler - v3.010

                * Asm994a Generated Register Equates
                *
      0000 0000 R0      EQU     0 
      0000 0001 R1      EQU     1 
      0000 0002 R2      EQU     2 
      0000 0003 R3      EQU     3 
      0000 0004 R4      EQU     4 
      0000 0005 R5      EQU     5 
      0000 0006 R6      EQU     6 
      0000 0007 R7      EQU     7 
      0000 0008 R8      EQU     8 
      0000 0009 R9      EQU     9 
      0000 000A R10     EQU     10
      0000 000B R11     EQU     11
      0000 000C R12     EQU     12
      0000 000D R13     EQU     13
      0000 000E R14     EQU     14
      0000 000F R15     EQU     15
                *
   1            *===============================================================================================================
   2            * TI DISK CONTROLLER ROM   >4000-5FFF
   3            * 
   4            * initial commented disassembly by Thierry Nouspikel
   5            * (see http://www.unige.ch/medecine/nouspikel/ti99/titechpages.htm)
   6            *
   7            * and
   8            * 
   9            * Monty Schmidt's book: TI Technical Drive
  10            *
  11            * adapted for APEDSK99 by Jochen Buur
  12            * github.com/jambuur/APEDSK99
  13            *
  14            * v12r: support for Double Density / 80 tracks (max 1440 AU's)
  15            *================================================================================================================
  16  0000 5FB4 DSKPRM  EQU     >5FB4                   per DSKx: Mbyte #sectors, Lbyte #sectors, #sectors/track, #tracks, #sides
  17  0000 5FC6 CALLST  EQU     >5FC6                   CALL() execution status: finished, still active, error
  18  0000 5FC7 LSTDRV  EQU     >5FC7                   remember last drive accessed for LDSK without argument
  19  0000 5FC8 CALLBF  EQU     >5FC8                   2-way buffer for TI BASIC CALL's (1 screen line, 32 characters)
  20  0000 5FE8 ACOMND  EQU     >5FE8                   APEDSK99-specific Command register
  21  0000 5FE9 ASUBCM  EQU     >5FE9                   APEDSK99-specific SubCommand register
  22  0000 5FEA RDINT   EQU     >5FEA                   issue read interrupt
  23  0000 5FEE CRUWRI  EQU     >5FEE                   emulated 8 CRU output bits
  24  0000 5FF0 RSTAT   EQU     >5FF0                   read FD1771 Status register
  25  0000 5FF6 RDATA   EQU     >5FF6                   read FD1771 Data register
  26  0000 5FF8 WCOMND  EQU     >5FF8                   write FD1771 Command register
  27  0000 5FFC WSECTR  EQU     >5FFC                   write FD1771 Sector register
  28  0000 5FFE WDATA   EQU     >5FFE                   write FD1771 Data register
  29            *
  30  0000 164E XML14   EQU     >164E                   ROM address for XML >14
  31  0000 15D6 XML16   EQU     >15D6                   ROM address for XML >16
  32            *
  33  0000 4409 XMLBC   EQU     >4409                   GROM address for XML >BC 
  34  0000 A018 RTNBC   EQU     >A018                   return address for XML >BC in high memory expansion
  35            *
  36  0000 006A GPLINT  EQU     >006A                   jump to GROM interpreter for SCROLL / HONK
  37  0000 2244 XMLRTN  EQU     >2244                   jump to GROM interpreter for RTN (after executing XML >14 / >16 routine)
  38  0000 56CD SCROLL  EQU     >56CD                   GROM address for scroll routine
  39  0000 0036 HONK    EQU     >0036                   GROM address for bad sound / HONK routine
  40            *
  41                    AORG    >4000                   DSR memory block
  42            *
  43  4000 AA           BYTE    >AA                     standard header mark
  44  4001 02           BYTE    >02                     version 2
  45  4002 0000         DATA    >0000                   no programs
  46  4004 40FE         DATA    PWRUP                   power-up chain ptr
  47  4006 0000         DATA    >0000                   programs chain ptr (none)
  48  4008 4104         DATA    DSR01                   DSR chain ptr
  49  400A 4010         DATA    SUB01                   subprograms chain ptr
  50  400C 0000         DATA    >0000                   ISR chain ptr (none)
  51  400E 0000         DATA    >0000                   
  52            *
  53  4010 4016 SUB01   DATA    SUB02                   link to next subprogram
  54  4012 582A         DATA    ESUB01                  address of that one
  55  4014 0110         DATA    >0110                   subprogram name: >10 (sector R/W)
  56  4016 401C SUB02   DATA    SUB03                   
  57  4018 583A         DATA    ESUB02                  
  58  401A 0111         DATA    >0111                   subprogram >11 (format disk)
  59  401C 4022 SUB03   DATA    SUB04                   
  60  401E 5844         DATA    ESUB03                  
  61  4020 0112         DATA    >0112                   subprogram >12 (file un/protect)
  62  4022 4028 SUB04   DATA    SUB05                   
  63  4024 589E         DATA    ESUB04                  
  64  4026 0113 NTPFAT  DATA    >0113                   subprogram >13 (file rename); doubles as FAT update flag
  65            *
  66  4028 402E SUB05   DATA    SUB06                   
  67  402A 596A         DATA    ESUB05                  
  68  402C 0114         DATA    >0114                   subprogram >14 (file direct input)              
  69  402E 4034 SUB06   DATA    SUB07                   
  70  4030 59DA         DATA    ESUB06                  
  71  4032 0115         DATA    >0115                   subprogram >15 (file direct output)
  72  4034 403A SUB07   DATA    SUB08                   
  73  4036 5AA0         DATA    ESUB07                  
  74  4038 0116         DATA    >0116                   subprogram >16 (number of files)
  75  403A 4054 SUB08   DATA    SUB09                   
  76  403C 5A4C         DATA    ESUB08                  
  77  403E 05           BYTE    >05                     
  78  403F 4649         TEXT    'FILES'                 same as >16, called from Basic
  78  4041 4C45  
  78  4043 53    
  79            *
  80  4044 0400 PATTBL  DATA    >0400                   TI BASIC VDP RAM address for Pattern Table
  81  4046 7631 AVERSN  TEXT    'v12r'                  APEDSK99 version string (ARST)
  81  4048 3272  
  82            *
  83  404A 0000 XBASRT  DATA    >0000                   CALL LINK return address (Extended Basic)
  84  404C 4418 XBPFDO  DATA    PRPFDO                  CALL LINK jump table (Extended Basic only): 
  85  404E 5D44 XBJUMP  DATA    XBUSTR                    PDSK / UDSK/ LDSK entry point
  86  4050 5DF8         DATA    A9909                     MDSK / NDSK / RDSK / FGET / FPUT / ADSR / CDIR entry point
  87  4052 5CCC         DATA    NOPRM2                    SMAP / LDIR / AHLP / ACHR / ARST / TIME / ACFG entry point
  88            *
  89  4054 405E SUB09   DATA    SUB10
  90  4056 5C1E         DATA    PDSK
  91  4058 04           BYTE    >04
  92  4059 5044         TEXT    'PDSK'                  Protect DSKx (apply adhesive tab)
  92  405B 534B  
  93  405D 0000         EVEN
  94  405E 4068 SUB10   DATA    SUB11                   
  95  4060 5C24         DATA    UDSK
  96  4062 04           BYTE    >04
  97  4063 5544         TEXT    'UDSK'                  Un-protect DSKx (remove adhesive tab)
  97  4065 534B  
  98  4067 0000         EVEN
  99  4068 4072 SUB11   DATA    SUB12
 100  406A 5C2A         DATA    LDSK
 101  406C 04           BYTE    >04
 102  406D 4C44         TEXT    'LDSK'                  List files on DSKx
 102  406F 534B  
 103  4071 0000         EVEN
 104  4072 407C SUB12   DATA    SUB13
 105  4074 5C30         DATA    MDSK
 106  4076 04           BYTE    >04
 107  4077 4D44         TEXT    'MDSK'                  Map DOAD to DSKx
 107  4079 534B  
 108  407B 0000         EVEN
 109  407C 4086 SUB13   DATA    SUB14
 110  407E 5C36         DATA    NDSK
 111  4080 04           BYTE    >04
 112  4081 4E44         TEXT    'NDSK'                  reName mapped DSKx
 112  4083 534B  
 113  4085 0000         EVEN
 114  4086 4090 SUB14   DATA    SUB15
 115  4088 5C3C         DATA    RDSK
 116  408A 04           BYTE    >04
 117  408B 5244         TEXT    'RDSK'                  Remove DOAD from SD card
 117  408D 534B  
 118  408F 0000         EVEN
 119  4090 409A SUB15   DATA    SUB16
 120  4092 5C42         DATA    FGET
 121  4094 04           BYTE    >04
 122  4095 4647         TEXT    'FGET'                  Load DOAD from FTP server
 122  4097 4554  
 123  4099 0000         EVEN
 124  409A 40A4 SUB16   DATA    SUB17
 125  409C 5C48         DATA    FPUT
 126  409E 04           BYTE    >04
 127  409F 4650         TEXT    'FPUT'                  Save DOAD to FTP server
 127  40A1 5554  
 128  40A3 0000         EVEN
 129  40A4 40AE SUB17   DATA    SUB18
 130  40A6 5C4E         DATA    ADSR
 131  40A8 04           BYTE    >04
 132  40A9 4144         TEXT    'ADSR'                  APEDSK99 DSR load / initialise / set default
 132  40AB 5352  
 133  40AD 0000         EVEN
 134  40AE 40B8 SUB18   DATA    SUB19
 135  40B0 5C54         DATA    CDIR
 136  40B2 04           BYTE    >04
 137  40B3 4344         TEXT    'CDIR'                  Change working /Folder
 137  40B5 4952  
 138  40B7 0000         EVEN
 139  40B8 40C2 SUB19   DATA    SUB20
 140  40BA 5C5A         DATA    SMAP
 141  40BC 04           BYTE    >04
 142  40BD 534D         TEXT    'SMAP'                  Show DOAD mappings for DSK[1-3] + available working /Folders
 142  40BF 4150  
 143  40C1 0000         EVEN
 144  40C2 40CC SUB20   DATA    SUB21
 145  40C4 5C60         DATA    LDIR
 146  40C6 04           BYTE    >04
 147  40C7 4C44         TEXT    'LDIR'                  List DOAD files on SD card
 147  40C9 4952  
 148  40CB 0000         EVEN
 149  40CC 40D6 SUB21   DATA    SUB22
 150  40CE 5C66         DATA    AHLP
 151  40D0 04           BYTE    >04
 152  40D1 4148         TEXT    'AHLP'                  APEDSK99 CALL help screen
 152  40D3 4C50  
 153  40D5 0000         EVEN
 154  40D6 40E0 SUB22   DATA    SUB23
 155  40D8 5C6C         DATA    ACHR
 156  40DA 04           BYTE    >04
 157  40DB 4143         TEXT    'ACHR'                  Load real lower case characters
 157  40DD 4852  
 158  40DF 0000         EVEN
 159  40E0 40EA SUB23   DATA    SUB24
 160  40E2 5C72         DATA    ARST
 161  40E4 04           BYTE    >04
 162  40E5 4152         TEXT    'ARST'                  APEDSK99 Reset
 162  40E7 5354  
 163  40E9 0000         EVEN
 164  40EA 40F4 SUB24   DATA    SUB25
 165  40EC 5C78         DATA    TIME
 166  40EE 04           BYTE    >04
 167  40EF 5449         TEXT    'TIME'                  NTP date/time display / assign to NTP$
 167  40F1 4D45  
 168  40F3 0000         EVEN
 169  40F4 0000 SUB25   DATA    >0000                   APEDSK99 configuration (IP address etc)
 170  40F6 5C7E         DATA    ACFG
 171  40F8 04           BYTE    >04
 172  40F9 4143         TEXT    'ACFG'
 172  40FB 4647  
 173  40FD 0000         EVEN
 174            *
 175  40FE 0000 PWRUP   DATA    >0000                   power-up chain (no more)
 176  4100 412A         DATA    EPWRUP                  address of power-up routine
 177  4102 0000         DATA    >0000                   no name
 178            *                                       
 179  4104 410C DSR01   DATA    DSR02                   DSR chain
 180  4106 4D40         DATA    EDSR01                  address of DSR
 181  4108 03           BYTE    >03                     name size
 182  4109 4453         TEXT    'DSK'                   DSR name
 182  410B 4B    
 183  410C 4116 DSR02   DATA    DSR03                   
 184  410E 4D4E         DATA    EDSR02                  
 185  4110 04           BYTE    >04                     
 186  4111 4453         TEXT    'DSK1'                  
 186  4113 4B31  
 187  4115 0000         EVEN                            
 188  4116 4120 DSR03   DATA    DSR04                   
 189  4118 4D54         DATA    EDSR03                  
 190  411A 04           BYTE    >04                     
 191  411B 4453         TEXT    'DSK2'                  
 191  411D 4B32  
 192  411F 0000         EVEN                            
 193  4120 0000 DSR04   DATA    >0000                   no more
 194  4122 4D5A         DATA    EDSR04                  
 195  4124 04           BYTE    >04                     
 196  4125 4453         TEXT    'DSK3'                  
 196  4127 4B33  
 197  4129 0000         EVEN            
 198            *
 199            *=====================================
 200            * Power-up routine
 201            *=====================================                                          
 202            *
 203  412A 028C EPWRUP  CI      R12,>1000               Dhr. F.G. Kaal check: are we powering up 1st CRU (>1000) peripheral?
 203  412C 1000  
 204  412E 1633         JNE     NOCRU                   nope; return
 205            *
 206  4130 C1CB         MOV     R11,R7                  yes; save return address
 207  4132 02A9         STWP    R9                      get workspace (should be >83E0)
 208  4134 0229         AI      R9,-224                 point to top of scratch-pad mem (>8300)
 208  4136 FF20  
 209  4138 C0A9         MOV     @>0070(R9),R2           highest free address in vdp mem (>8370)
 209  413A 0070  
 210  413C C002         MOV     R2,R0                   save it
 211  413E 0222         AI      R2,-2088                we'll need >828 bytes
 211  4140 F7D8  
 212  4142 CA42         MOV     R2,@>0070(R9)           update address
 212  4144 0070  
 213  4146 0582         INC     R2
 214  4148 06A0         BL      @VDPWRI                 set VDP address
 214  414A 4322  
 215  414C 0201         LI      R1,2088                 
 215  414E 0828  
 216  4150 04EF H001    CLR     @-2(R15)                clear these >828 bytes
 216  4152 FFFE  
 217  4154 0601         DEC     R1                      
 218  4156 16FC         JNE     H001                    
 219  4158 06A0         BL      @VDPWRI                 set VDP address (same)
 219  415A 4322  
 220  415C 0203         LI      R3,>AA03                        
 220  415E AA03  
 221  4160 DBC3         MOVB    R3,@-2(R15)             write buffer ID mark
 221  4162 FFFE  
 222  4164 1000         NOP                             
 223  4166 DBC0         MOVB    R0,@-2(R15)             write old highest free address
 223  4168 FFFE  
 224  416A 06C0         SWPB    R0
 225  416C DBC0         MOVB    R0,@-2(R15)
 225  416E FFFE  
 226  4170 1000         NOP                             
 227  4172 DBCC         MOVB    R12,@-2(R15)            write CRU address (>1000 for APEDSK99)
 227  4174 FFFE  
 228  4176 06C3         SWPB    R3                      
 229  4178 DBC3         MOVB    R3,@-2(R15)             write number of files (3)
 229  417A FFFE  
 230  417C 06A0         BL      @PRPRTN                 preparation routine
 230  417E 441A  
 231  4180 06A0         BL      @CALSUB                 call subroutine
 231  4182 4344  
 232  4184 42B2         DATA    RSTDRV                  reset all drives
 233  4186 04E9         CLR     @>0054(R9)              name length = 0 for power-up
 233  4188 0054  
 234  418A 0429         BLWP    @>005A(R9)              retrieve R7 (saved by PRPRTN)
 234  418C 005A  
 235  418E 0011         DATA    >0011                   put it into R11
 236  4190 CA60         MOV     @K001,@>006C(R9)        ???
 236  4192 4198  
 236  4194 006C  
 237  4196 045B NOCRU   B       *R11                    return
 238            *                               
 239  4198 0404 K001    DATA    >0404                   
 240            *
 241            *---------------------------------------
 242            * Sector read/write
 243            *---------------------------------------                                        
 244            *
 245  419A DA60 SECRW1  MOVB    @K002,@>0050(R9)        APEDSK99: no error
 245  419C 433E  
 245  419E 0050  
 246  41A0 06A0         BL      @SELDRV                 select drive
 246  41A2 4284  
 247            *
 248  41A4 C069         MOV     @>004A(R9),R1           sector #
 248  41A6 004A  
 249  41A8 0281         CI      R1,>05A0                APEDSK99: max 1440 (DS/DD/40T or DS/SD/80T)?
 249  41AA 05A0  
 250  41AC 1A03         JL      H002                    APEDSK99: yes; sector# within range
 251  41AE 06A0         BL      @ERROR1                 APEDSK99: no -> "device error"
 251  41B0 42E0  
 252  41B2 0600         DATA    >0600   
 253            
 254  41B4 C801 H002    MOV     R1,@WSECTR              APEDSK99: sector# to FD1771 write sector register (16bits)
 254  41B6 5FFC  
 255            *
 256  41B8 C0A9         MOV     @>004E(R9),R2           data buffer address
 256  41BA 004E  
 257  41BC D029         MOVB    @>004D(R9),R0           read or write ?
 257  41BE 004D  
 258  41C0 1312         JEQ     H005                    write
 259  41C2 06A0         BL      @VDPWRI                 read FD = write to VDP buffer
 259  41C4 4322  
 260  41C6 0206         LI      R6,256                  
 260  41C8 0100  
 261  41CA C806         MOV     R6,@RDINT               APEDSK99: interrupt Arduino for read operation 
 261  41CC 5FEA  
 262  41CE 06A0         BL      @SNDCMD                 send command
 262  41D0 42F6  
 263  41D2 8800         DATA    >8800                   APEDSK99: read sector
 264            *
 265  41D4 D020 H003    MOVB    @RDATA,R0               get 1 byte from FDC
 265  41D6 5FF6  
 266  41D8 DBC0         MOVB    R0,@-2(R15)             save it to VDP
 266  41DA FFFE  
 267  41DC 0620         DEC     @RDINT                  APEDSK99: interrupt Arduino for read operation
 267  41DE 5FEA  
 268  41E0 16F9         JNE     H003                    next byte
 269            *
 270  41E2 0460 H004    B       @RTURN1                 return
 270  41E4 4362  
 271            
 272            *       
 273  41E6 06A0 H005    BL      @VDPRD                  write to FD = read from VDP buffer
 273  41E8 432C  
 274  41EA 0206         LI      R6,256                  256 bytes to write
 274  41EC 0100  
 275            *
 276            * APEDSK99: the first byte to be written needs to be in the data register before the write command is given
 277            *
 278  41EE D02F         MOVB    @-1026(R15),R0          APEDSK99: get a byte from data buffer
 278  41F0 FBFE  
 279  41F2 D800         MOVB    R0,@WDATA               APEDSK99: write first byte to data register
 279  41F4 5FFE  
 280  41F6 06A0         BL      @SNDCMD                 send command
 280  41F8 42F6  
 281  41FA A800         DATA    >A800                   APEDSK99: write sector
 282            *
 283  41FC D02F H006    MOVB    @-1026(R15),R0          get a byte from data buffer
 283  41FE FBFE  
 284  4200 D800         MOVB    R0,@WDATA               pass it to data register
 284  4202 5FFE  
 285  4204 0606         DEC     R6                      
 286  4206 16FA         JNE     H006                    next byte
 287            *
 288  4208 06A0         BL      @WTCPT1                 APEDSK99: check for Write Protect
 288  420A 4276  
 289  420C 0A20         SLA     R0,2                    APEDSK99: WP bit in Carry
 290  420E 1801         JOC     ERROR3                  write protect: error 34
 291  4210 10E8         JMP     H004                    APEDSK99: no need to verify             
 292            *                                       
 293  4212 06A0 ERROR3  BL      @ERROR1                 error 34 (Write Protect)
 293  4214 42E0  
 294  4216 3400         DATA    >3400                   
 295            *
 296            *--------------------------------------------------------------------
 297            * Format disk - APEDSK99: we don't do any physical formatting anymore
 298            *--------------------------------------------------------------------
 299            *
 300  4218 04E9 FMTDSK  CLR     @>004A(R9)              called by subprogram >11
 300  421A 004A  
 301            *                                       
 302  421C 5A60         SZCB    @K004,@>004C(R9)        clear DSR version flags
 302  421E 4340  
 302  4220 004C  
 303            *
 304  4222 06A0         BL      @SELDRV                 select drive
 304  4224 4284  
 305            *
 306  4226 D029         MOVB    @>004D(R9),R0           APEDSK99: get # of tracks
 306  4228 004D  
 307  422A 9829         CB      @>0051(R9),@K005        APEDSK99: double sided?
 307  422C 0051  
 307  422E 4341  
 308  4230 1601         JNE     H007                    APEDSK99: single-side
 309            *
 310  4232 0A10         SLA     R0,1                    times two (since 2 sides)
 311            *
 312  4234 0980 H007    SRL     R0,8                    APEDSK99: make it a byte
 313  4236 0206         LI      R6,9                    APEDSK99: start with single density
 313  4238 0009  
 314  423A 9829         CB      @>0050(R9),@K005        APEDSK99: double density required?
 314  423C 0050  
 314  423E 4341  
 315  4240 1601         JNE     H008                    APEDSK99: no, leave R6 alone
 316  4242 0A16         SLA     R6,1                    APEDSK99: yes, R6*2
 317            *               
 318  4244 3806 H008    MPY     R6,R0                   APEDSK99: #sectors/track * #tracks
 319  4246 0281         CI      R1,>05A0                APEDSK99: >1440 sectors?
 319  4248 05A0  
 320  424A 1203         JLE     H009                    APEDSK99: nope; continue
 321  424C 06A0         BL      @ERROR1                 APEDSK99: yes; "device error"
 321  424E 42E0  
 322  4250 0600         DATA    >0600   
 323            *
 324  4252 CA41 H009    MOV     R1,@>004A(R9)           pass total # of sectors per disk
 324  4254 004A  
 325  4256 06C6         SWPB    R6
 326  4258 DA46         MOVB    R6,@>004D(R9)           APEDSK99: pass # of sectors per track
 326  425A 004D  
 327  425C DA60         MOVB    @K002,@>0050(R9)        no error
 327  425E 433E  
 327  4260 0050  
 328            *
 329  4262 06A0         BL      @NTPDT                  APEDSK99: update DOAD FAT time/date
 329  4264 5F60  
 330            *
 331  4266 0460         B       @RTURN1                 return
 331  4268 4362  
 332            *                                       
 333                                                    
 334  426A C1BB VDPRPW  MOV     *R11+,R6                VDP repeated write
 335  426C DBC0 H010    MOVB    R0,@-2(R15)
 335  426E FFFE  
 336  4270 0606         DEC     R6                      byte in R0
 337  4272 16FC         JNE     H010                    number of repeats in data word
 338  4274 045B         B       *R11                    
 339            *
 340  4276 D020 WTCPT1  MOVB    @RSTAT,R0               get status. APEDSK99: Not Ready >80 / Write Protect >40
 340  4278 5FF0  
 341  427A 1101         JLT     ERROR4                  drive not ready. APEDSK99: Not Ready set when DOAD file is unavailable
 342  427C 045B         B       *R11                    
 343            *
 344  427E 06A0 ERROR4  BL      @ERROR1                 exit with error code 6, reseting all drives
 344  4280 42E0  
 345  4282 0600         DATA    >0600                   
 346            *                                       
 347  4284 C1CB SELDRV  MOV     R11,R7                  select a drive
 348  4286 C0A9         MOV     @>0058(R9),R2
 348  4288 0058  
 349  428A 0222         AI      R2,-10                  point to drive info
 349  428C FFF6  
 350  428E 04C0         CLR     R0                      
 351  4290 D029         MOVB    @>004C(R9),R0           get drive #
 351  4292 004C  
 352  4294 130B         JEQ     H011                    can't be >00: error #7
 353  4296 0280         CI      R0,>0300                        
 353  4298 0300  
 354  429A 1B08         JH      H011                    drive number can't be higher than 3: error #7
 355  429C 06A0         BL      @VDPWRI                 set VDP to write, address in R2
 355  429E 4322  
 356  42A0 DBC0         MOVB    R0,@-2(R15)             modify last drive accessed              
 356  42A2 FFFE  
 357            *
 358  42A4 0A10         SLA     R0,1                    APEDSK99: bit 0 is side select, 1-3 is drive #
 359  42A6 D800         MOVB    R0,@CRUWRI              APEDSK99: select drive
 359  42A8 5FEE  
 360  42AA 0457         B       *R7                     
 361            *                                       
 362  42AC 06A0 H011    BL      @ERROR1                 exit with error #7
 362  42AE 42E0  
 363  42B0 0700         DATA    >0700                   
 364            *                                       
 365  42B2 5820 RSTDRV  SZCB    @DSDRVS,@CRUWRI         APEDSK99: reset all drives including side
 365  42B4 4342  
 365  42B6 5FEE  
 366  42B8 D820         MOVB    @K013,@WCOMND           send Force Interrupt with no interrupt flag set
 366  42BA 42F0  
 366  42BC 5FF8  
 367  42BE C0A9         MOV     @>0058(R9),R2           ptr to VIB buffer
 367  42C0 0058  
 368  42C2 0222         AI      R2,-10                  now points to drive info buffer
 368  42C4 FFF6  
 369  42C6 06A0         BL      @VDPWRI                 set VDP to write to address in R2
 369  42C8 4322  
 370  42CA 0200         LI      R0,4                    
 370  42CC 0004  
 371  42CE DBC0 H012    MOVB    R0,@-2(R15)             write four >00 (i.e. clear drive info)
 371  42D0 FFFE  
 372  42D2 0600         DEC     R0                      
 373  42D4 16FC         JNE     H012                    
 374  42D6 DA60         MOVB    @K002,@>0050(R9)        no error
 374  42D8 433E  
 374  42DA 0050  
 375  42DC 0460         B       @RTURN1                 get return address from stack
 375  42DE 4362  
 376            *                                       
 377  42E0 C01B ERROR1  MOV     *R11,R0                 exit with error
 378  42E2 DA40         MOVB    R0,@>0050(R9)           place err code in >8350
 378  42E4 0050  
 379  42E6 0280         CI      R0,>0600                check if device error
 379  42E8 0600  
 380  42EA 1603         JNE     H013                    no: exit
 381  42EC 06A0         BL      @SNDCMD                 yes: reset drives
 381  42EE 42F6  
 382            *
 383  42F0 0000 K013    DATA    >0000                   APEDSK99: send Restore command
 384            *
 385  42F2 0460 H013    B       @RTURN1                 return to caller (address from stack)
 385  42F4 4362  
 386            *                               
 387  42F6 C03B SNDCMD  MOV     *R11+,R0                send command to FDC from data word
 388  42F8 D800         MOVB    R0,@WCOMND              send command
 388  42FA 5FF8  
 389  42FC 045B         B       *R11                    
 390            *                                       
 391  42FE 04C0 LASTRK  CLR     R0                      get last track # for this drive
 392  4300 D029         MOVB    @>004C(R9),R0           get drive #
 392  4302 004C  
 393  4304 130B         JEQ     H014                    can't be 0
 394  4306 06C0         SWPB    R0                      
 395  4308 0280         CI      R0,3                    
 395  430A 0003  
 396  430C 1B07         JH      H014                    can't be higher than 3
 397  430E C0A9         MOV     @>0058(R9),R2                   
 397  4310 0058  
 398  4312 0222         AI      R2,-10                  point to last drive accessed
 398  4314 FFF6  
 399  4316 A080         A       R0,R2                   point to last track for this drive
 400  4318 0460         B       @VDPRD                  prepare VDP to read from address in R2
 400  431A 432C  
 401            *                                       
 402  431C 06A0 H014    BL      @ERROR1                 exit with error code 7
 402  431E 42E0  
 403  4320 0700         DATA    >0700                   
 404            *                                       
 405  4322 0262 VDPWRI  ORI     R2,>4000                set VDP address to write
 405  4324 4000  
 406  4326 0242         ANDI    R2,>7FFF                not to a register
 406  4328 7FFF  
 407  432A 1002         JMP     H015                    
 408  432C 0242 VDPRD   ANDI    R2,>3FFF                set VDP address to read
 408  432E 3FFF  
 409  4330 06C2 H015    SWPB    R2                      
 410  4332 D7C2         MOVB    R2,*R15                 write address
 411  4334 06C2         SWPB    R2                      
 412  4336 D7C2         MOVB    R2,*R15                 
 413  4338 0242         ANDI    R2,>3FFF                        
 413  433A 3FFF  
 414  433C 045B         B       *R11                    
 415            *                                       
 416  433E 00   K002    BYTE    >00                     
 417  433F 09   K007    BYTE    >09                                             
 418  4340 F0   K004    BYTE    >F0                     
 419  4341 02   K005    BYTE    2
 420  4342 0F   DSDRVS  BYTE    >0F                     APEDSK99: deselect all drives + side (reset CRUWRI bits 7,6,5 and 4)                    
 421            *
 422  4343 0000         EVEN
 423            *                               
 424  4344 0669 CALSUB  DECT    @>0066(R9)              call subroutine, return address in stack
 424  4346 0066  
 425  4348 C2A9         MOV     @>0066(R9),R10
 425  434A 0066  
 426  434C 0429         BLWP    @>005A(R9)              set VDP to write to address in R10
 426  434E 005A  
 427  4350 0143         DATA    >0143                   
 428  4352 C2BB         MOV     *R11+,R10               get next data word
 429  4354 06CB         SWPB    R11                     write return address to VDP
 430  4356 DBCB         MOVB    R11,@-2(R15)                    
 430  4358 FFFE  
 431  435A 06CB         SWPB    R11                     
 432  435C DBCB         MOVB    R11,@-2(R15)                    
 432  435E FFFE  
 433  4360 045A         B       *R10                    branch to address in data word
 434            *                               
 435  4362 C2E0 RTURN1  MOV     @XBASRT,R11             APEDSK99: CALL LINK from Extended Basic?
 435  4364 404A  
 436  4366 1301         JEQ     H015A                   nope
 437  4368 045B         B       *R11                    yes; return to ExBas program
 438            *
 439  436A C2E9 H015A   MOV     @>0066(R9),R11          get return address from VDP stack
 439  436C 0066  
 440  436E 0429         BLWP    @>005A(R9)              
 440  4370 005A  
 441  4372 0162         DATA    >0162                   set VDP to read from address in R11
 442  4374 D2EF         MOVB    @-1026(R15),R11                 
 442  4376 FBFE  
 443  4378 06CB         SWPB    R11                     
 444  437A D2EF         MOVB    @-1026(R15),R11                 
 444  437C FBFE  
 445  437E 05E9         INCT    @>0066(R9)                      
 445  4380 0066  
 446  4382 045B         B       *R11                    
 447            *
 448            *---------------------------------------
 449            * Custom routines, dealing with VDP memory
 450            * Format is >pppr where r is routine number (0-3)
 451            * and ppp contains parameters
 452            * The workspace it >8300. Called by BLWP @>005A(9).
 453            *---------------------------------------                                        
 454            *
 455  4384 C28D ECUSTM  MOV     R13,R10                 save wregs ptr
 456  4386 C23E         MOV     *R14+,R8                get next data word
 457  4388 C248         MOV     R8,R9                   save it
 458  438A 0949         SRL     R9,4                    keep parameter
 459  438C 0248         ANDI    R8,3                    four possible operations
 459  438E 0003  
 460  4390 A208         A       R8,R8                   make it a word ptr
 461  4392 C2ED         MOV     @>001E(R13),R11         get old R15, i.e. VDP port (>8C02)
 461  4394 001E  
 462  4396 C228         MOV     @VECRTN(R8),R8          get vector for operation
 462  4398 439C  
 463  439A 0458         B       *R8                     branch to it
 464            *                                       
 465  439C 43A4 VECRTN  DATA    SVRVDP                  save registers to VDP stack
 466  439E 43D0         DATA    RVRVDP                  retrieve registers
 467  43A0 4406         DATA    SVDPRD                  set VDP address to read
 468  43A2 43FC         DATA    SVDPWR                  set VDP address to write
 469            *                                       
 470  43A4 022A SVRVDP  AI      R10,22                  0: save registers in VDP mem
 470  43A6 0016  
 471  43A8 0919 H016    SRL     R9,1                    start with R12
 472  43AA 1710         JNC     H017                    bits in >ppp tell which register to save (R0-R11)
 473  43AC 064C         DECT    R12                     previous address in VDP stack (grows down)
 474  43AE C21A         MOV     *R10,R8                 get register contents
 475  43B0 06CC         SWPB    R12                     set VDP address to write
 476  43B2 D6CC         MOVB    R12,*R11                R12 is >8366: VDP stack ptr
 477  43B4 06CC         SWPB    R12                     
 478  43B6 026C         ORI     R12,>4000                       
 478  43B8 4000  
 479  43BA D6CC         MOVB    R12,*R11                        
 480  43BC 06C8         SWPB    R8                      save register to VDP mem
 481  43BE DAC8         MOVB    R8,@-2(R11)                     
 481  43C0 FFFE  
 482  43C2 06C8         SWPB    R8                      
 483  43C4 DAC8         MOVB    R8,@-2(R11)                     
 483  43C6 FFFE  
 484  43C8 C249         MOV     R9,R9                   more to come?
 485  43CA 1317         JEQ     H020                    no:return
 486  43CC 064A H017    DECT    R10                     point to previous register
 487  43CE 10EC         JMP     H016                    
 488            *                               
 489  43D0 0A49 RVRVDP  SLA     R9,4                    1: retrieve registers from VDP mem
 490  43D2 0A19 H018    SLA     R9,1                    each bit tells whether to load
 491  43D4 1710         JNC     H019                    don't retrieve that one
 492  43D6 06CC         SWPB    R12                     set VDP address to read
 493  43D8 D6CC         MOVB    R12,*R11                R12 is >8366: VDP stack ptr
 494  43DA 06CC         SWPB    R12                     
 495  43DC 024C         ANDI    R12,>3FFF                       
 495  43DE 3FFF  
 496  43E0 D6CC         MOVB    R12,*R11                        
 497  43E2 1000         NOP                             
 498  43E4 D22B         MOVB    @-1026(R11),R8          get a 2-byte value from VDP
 498  43E6 FBFE  
 499  43E8 06C8         SWPB    R8                      
 500  43EA D22B         MOVB    @-1026(R11),R8                  
 500  43EC FBFE  
 501  43EE C688         MOV     R8,*R10                 save it to register
 502  43F0 05CC         INCT    R12                     increment ptr (stack grows downwards)
 503  43F2 C249         MOV     R9,R9                   more to come?
 504  43F4 1302         JEQ     H020                    no: return
 505  43F6 05CA H019    INCT    R10                     next register
 506  43F8 10EC         JMP     H018                    
 507  43FA 0380 H020    RTWP                            
 508            *                                       
 509  43FC A24D SVDPWR  A       R13,R9                  2: set VDP for a write
 510  43FE C219         MOV     *R9,R8                  
 511  4400 0268         ORI     R8,>4000                get address from reg in >..p2 (*2)
 511  4402 4000  
 512  4404 1004         JMP     H021                    
 513            *                                       
 514  4406 A24D SVDPRD  A       R13,R9                  3: set VDP for a read
 515  4408 C219         MOV     *R9,R8
 516  440A 0248         ANDI    R8,>3FFF                get register from reg in >..p3 (*2)
 516  440C 3FFF  
 517  440E 06C8 H021    SWPB    R8                      set VDP address
 518  4410 D6C8         MOVB    R8,*R11                 
 519  4412 06C8         SWPB    R8                      
 520  4414 D6C8         MOVB    R8,*R11                 
 521  4416 0380         RTWP                            
 522            *
 523            *---------------------------------------
 524            * Preparation subroutine
 525            * Sets up the 4 custom subroutines
 526            * Gets a few pointers to VDP buffers
 527            *  >8358: copy of VIB  >8366: VDP stack ptr (grows down from drive info)
 528            *  >8354: PAB          >8356: ptr to end-of-buffer
 529            *---------------------------------------                                        
 530            *
 531  4418 05C7 PRPFDO  INCT    R7                      stop scanning upon return
 532  441A C28B PRPRTN  MOV     R11,R10                 save return address
 533  441C 02A9         STWP    R9                      get workspace (should be >83E0)
 534  441E 0229         AI      R9,-224                 top of scratch/pad mem (>8300)
 534  4420 FF20  
 535  4422 0200         LI      R0,ECUSTM               entry to 4 custom routines
 535  4424 4384  
 536  4426 CA40         MOV     R0,@>005C(R9)           put it in >835C
 536  4428 005C  
 537  442A C009         MOV     R9,R0                   
 538  442C 0220         AI      R0,>004E                workspace for these four (>834E)
 538  442E 004E  
 539  4430 CA40         MOV     R0,@>005A(R9)           put it in >835A
 539  4432 005A  
 540            *                                       
 541  4434 C229         MOV     @>0070(R9),R8           highest free address in VDP mem
 541  4436 0070  
 542  4438 05C8         INCT    R8                      point to end-of-buffer word
 543  443A 06A0         BL      @VDPR2B                 read 2 bytes from VDP address R8, into R0
 543  443C 486A  
 544  443E C088         MOV     R8,R2                   save current R8
 545  4440 C200         MOV     R0,R8                   get end-of-buffer word
 546  4442 0228         AI      R8,-266                 yes: point to volume information block
 546  4444 FEF6  
 547  4446 CA48         MOV     R8,@>0058(R9)           save it in >8358
 547  4448 0058  
 548  444A 0228         AI      R8,-10                  point to disk drive info (drive #, last tracks)
 548  444C FFF6  
 549  444E CA48         MOV     R8,@>0066(R9)           save in >8366: VDP stack ptr (DECT before writing)
 549  4450 0066  
 550  4452 0429         BLWP    @>005A(R9)              save R7 (return address)
 550  4454 005A  
 551  4456 0100         DATA    >0100                   
 552  4458 C1E9         MOV     @>0056(R9),R7           ptr to PAB: end of DSR name
 552  445A 0056  
 553  445C C0C7         MOV     R7,R3                   save it
 554  445E 61E9         S       @>0054(R9),R7           start of DSR name
 554  4460 0054  
 555  4462 CA42         MOV     R2,@>0056(R9)           >8356: ptr to end-of-buffer word in VDP mem
 555  4464 0056  
 556  4466 0607         DEC     R7                      point to name length byte
 557  4468 04C2         CLR     R2                      
 558  446A 0429         BLWP    @>005A(R9)              set VDP to read from address in R2
 558  446C 005A  
 559  446E 00E2         DATA    >00E2                   
 560  4470 D0AF         MOVB    @-1026(R15),R2          get name length byte
 560  4472 FBFE  
 561  4474 06C2         SWPB    R2                      make it a word
 562  4476 60A9         S       @>0054(R9),R2           minus DSR name size: lenght of .parameters
 562  4478 0054  
 563  447A 0227         AI      R7,-9                   point to top of PAB
 563  447C FFF7  
 564  447E CA47         MOV     R7,@>0054(R9)           save it in >8354
 564  4480 0054  
 565  4482 045A         B       *R10                    
 566            *                               
 567  4484 06A0 CRFIL1  BL      @CALSUB                 create file
 567  4486 4344  
 568  4488 4AF6         DATA    FNDFDR                  find a FDR in disk
 569  448A C104 CRFIL2  MOV     R4,R4                   found?
 570  448C 1604         JNE     CRFIL3                  no
 571  448E 06A0         BL      @CALSUB                 yes: delete old file
 571  4490 4344  
 572  4492 45CE         DATA    FFSVIB                  free file sector in VIB bitmap
 573  4494 1045         JMP     H024                    clear its FDR
 574            *                               
 575  4496 06A0 CRFIL3  BL      @INSFDR                 new file: insert a FDR in sector 1
 575  4498 47FE  
 576  449A 0701         SETO    R1                      
 577  449C 06A0         BL      @CALSUB                 call subroutine
 577  449E 4344  
 578  44A0 4BEA         DATA    FFSBMP                  find a free sector in VIB bitmap
 579  44A2 C000         MOV     R0,R0                   found?
 580  44A4 1603         JNE     H022                    yes: # in R0
 581  44A6 06A0         BL      @ERROR5                 no: update data, then return with error
 581  44A8 4966  
 582  44AA 8000         DATA    >8000                   memory full (APEDSK99: doubles as subcommand flag)
 583            *                               
 584  44AC 0429 H022    BLWP    @>005A(R9)              set VDP to write
 584  44AE 005A  
 585  44B0 0103         DATA    >0103                   address in R8
 586  44B2 DBC0         MOVB    R0,@-2(R15)             write sector # for FDR in sector 1
 586  44B4 FFFE  
 587  44B6 06C0         SWPB    R0                      
 588  44B8 DBC0         MOVB    R0,@-2(R15)                     
 588  44BA FFFE  
 589  44BC 06C0         SWPB    R0                      
 590  44BE C069         MOV     @>0056(R9),R1           ptr to FDR in VDP buffers
 590  44C0 0056  
 591  44C2 0221         AI      R1,-4                   ptr to sector # for FDR
 591  44C4 FFFC  
 592  44C6 0429         BLWP    @>005A(R9)              set VDP to write
 592  44C8 005A  
 593  44CA 0023         DATA    >0023                   address in R1
 594  44CC DBC0         MOVB    R0,@-2(R15)             write sector # for FDR in VDP buffer
 594  44CE FFFE  
 595  44D0 06C0         SWPB    R0                      
 596  44D2 DBC0         MOVB    R0,@-2(R15)                     
 596  44D4 FFFE  
 597  44D6 0221         AI      R1,3                    ptr to drive #
 597  44D8 0003  
 598  44DA 0429         BLWP    @>005A(R9)              set VDP to write
 598  44DC 005A  
 599  44DE 0023         DATA    >0023                   address in R1
 600  44E0 DBC6         MOVB    R6,@-2(R15)             write drive # before FDR in VDP buffer
 600  44E2 FFFE  
 601  44E4 04C2         CLR     R2                      code for write
 602  44E6 0581         INC     R1                      
 603  44E8 06A0         BL      @CALSUB                 call subroutine
 603  44EA 4344  
 604  44EC 4A2A         DATA    WRSEC1                  write sector 1
 605  44EE C169         MOV     @>0058(R9),R5           ptr to VIB in VDP buffers
 605  44F0 0058  
 606  44F2 04C4         CLR     R4                      sector 0
 607  44F4 06A0         BL      @CALSUB                 call subroutine
 607  44F6 4344  
 608  44F8 4A42         DATA    RWSEC                   write VIB to sector 0
 609  44FA C0C5         MOV     R5,R3                   copy filename from compare buffer to FDR
 610  44FC 0223         AI      R3,257                  ptr to file compare buffer
 610  44FE 0101  
 611  4500 0202         LI      R2,10                   10 chars per filename
 611  4502 000A  
 612  4504 0429 H023    BLWP    @>005A(R9)              set VDP to read
 612  4506 005A  
 613  4508 0062         DATA    >0062                   address in R3
 614  450A D02F         MOVB    @-1026(R15),R0          get 1 char
 614  450C FBFE  
 615  450E 0583         INC     R3                      increment source ptr
 616  4510 0429         BLWP    @>005A(R9)              set VDP to write
 616  4512 005A  
 617  4514 0023         DATA    >0023                   address in R1
 618  4516 DBC0         MOVB    R0,@-2(R15)             copy 1 char
 618  4518 FFFE  
 619  451A 0581         INC     R1                      increment destination ptr
 620  451C 0602         DEC     R2                      # of chars in R2
 621  451E 16F2         JNE     H023                    next
 622            *
 623  4520 06A0 H024    BL      @NTPDT                  APEDSK99: update DOAD FAT time/date
 623  4522 5F60  
 624            *
 625  4524 C069         MOV     @>0056(R9),R1           FDR ptr
 625  4526 0056  
 626  4528 0221         AI      R1,10                   skip filename
 626  452A 000A  
 627  452C 0202         LI      R2,246                  remaining bytes in FDR
 627  452E 00F6  
 628  4530 0429         BLWP    @>005A(R9)              set VDP to write
 628  4532 005A  
 629  4534 0023         DATA    >0023                   address in R1
 630  4536 DBC2 H025    MOVB    R2,@-2(R15)             write >00
 630  4538 FFFE  
 631  453A 0602         DEC     R2                      clear remainder of new FDR
 632  453C 16FC         JNE     H025                    next byte
 633  453E 1010         JMP     H028                    write FDR to disk return to caller
 634            *                                       
 635  4540 C169 H026    MOV     @>0056(R9),R5           check if FDR must be updated
 635  4542 0056  
 636  4544 0429         BLWP    @>005A(R9)              set VDP to read
 636  4546 005A  
 637  4548 00A2         DATA    >00A2                   address in R5
 638  454A D12F         MOVB    @-1026(R15),R4          get filename in file ctrl block
 638  454C FBFE  
 639  454E 1101         JLT     H027                    flag: FDR was modified, update it
 640  4550 100A         JMP     H029                    
 641  4552 0244 H027    ANDI    R4,>7F00                clear flag bit
 641  4554 7F00  
 642  4556 0429         BLWP    @>005A(R9)              st VDP to write
 642  4558 005A  
 643  455A 00A3         DATA    >00A3                   address in R5
 644  455C DBC4         MOVB    R4,@-2(R15)             write back filename without flag bit
 644  455E FFFE  
 645  4560 04C2 H028    CLR     R2                      code for write
 646  4562 0460         B       @WRFDR                  write FDR to disk
 646  4564 4A34  
 647  4566 0460 H029    B       @RTURN1                 return to caller
 647  4568 4362  
 648            *                               
 649  456A 06A0 UPDFDR  BL      @CALSUB                 update FDR + data
 649  456C 4344  
 650  456E 458A         DATA    UPDBF                   update data buffer if necessary
 651  4570 06A0         BL      @CALSUB                 call subroutine
 651  4572 4344  
 652  4574 4540         DATA    H026                    update FDR if necessary
 653  4576 C169 CLRFBT  MOV     @>0056(R9),R5                   
 653  4578 0056  
 654  457A 04C6         CLR     R6                      
 655  457C 0429         BLWP    @>005A(R9)              set VDP to write
 655  457E 005A  
 656  4580 00A3         DATA    >00A3                   address in R5
 657  4582 DBC6         MOVB    R6,@-2(R15)             clr first byte of filename in FDR
 657  4584 FFFE  
 658  4586 0460         B       @RWVIB                  
 658  4588 49C6  
 659            *                                       
 660  458A C129 UPDBF   MOV     @>0056(R9),R4           check if data buffer must be updated
 660  458C 0056  
 661  458E 0604         DEC     R4                      
 662  4590 0429         BLWP    @>005A(R9)              set VDP to read
 662  4592 005A  
 663  4594 0082         DATA    >0082                   address in R4
 664  4596 D06F         MOVB    @-1026(R15),R1          get drive #
 664  4598 FBFE  
 665  459A 1101         JLT     H030                    flag: must be updated
 666  459C 1016         JMP     H031                    no need to update: return
 667  459E 0241 H030    ANDI    R1,>7F00                erase flag
 667  45A0 7F00  
 668  45A2 0429         BLWP    @>005A(R9)              set VDP to write
 668  45A4 005A  
 669  45A6 0083         DATA    >0083                   address in R4
 670  45A8 DBC1         MOVB    R1,@-2(R15)             write back drive # without flag
 670  45AA FFFE  
 671  45AC 0224         AI      R4,-5                   point to current logical record offset
 671  45AE FFFB  
 672  45B0 0429         BLWP    @>005A(R9)              set VDP to read
 672  45B2 005A  
 673  45B4 0082         DATA    >0082                   address in R4
 674  45B6 D0EF         MOVB    @-1026(R15),R3          get current logical record offset
 674  45B8 FBFE  
 675  45BA 06C3         SWPB    R3                      
 676  45BC D0EF         MOVB    @-1026(R15),R3                  
 676  45BE FBFE  
 677  45C0 06C3         SWPB    R3                      
 678  45C2 C1C4         MOV     R4,R7                   
 679  45C4 0227         AI      R7,262                  point to data buffer area
 679  45C6 0106  
 680  45C8 103A         JMP     WROFSC                  
 681  45CA 0460 H031    B       @RTURN1                 return to caller
 681  45CC 4362  
 682            *                               
 683  45CE C0A9 FFSVIB  MOV     @>0056(R9),R2           free file sectors in VIB bitmap
 683  45D0 0056  
 684  45D2 0222         AI      R2,12                   
 684  45D4 000C  
 685  45D6 0429         BLWP    @>005A(R9)              set VDP to read
 685  45D8 005A  
 686  45DA 0042         DATA    >0042                   address in R2
 687  45DC D02F         MOVB    @-1026(R15),R0          get file status byte from FDR
 687  45DE FBFE  
 688  45E0 0240         ANDI    R0,>0800                write protected?
 688  45E2 0800  
 689  45E4 1303         JEQ     H032                    no
 690  45E6 06A0         BL      @ERROR5                 update data if needed, the return with error
 690  45E8 4966  
 691  45EA 2000         DATA    >2000                   write protected
 692            *                                       
 693  45EC C229 H032    MOV     @>0056(R9),R8           get ptr to FDR
 693  45EE 0056  
 694  45F0 0228         AI      R8,28                   point to clusters list
 694  45F2 001C  
 695  45F4 0704         SETO    R4                      previous offset
 696  45F6 06A0 H033    BL      @DECDCI                 decode cluster info: sector in R1, offset in R2
 696  45F8 4BAA  
 697  45FA 0228         AI      R8,3                    next cluster ptr
 697  45FC 0003  
 698  45FE C041         MOV     R1,R1                   
 699  4600 130C         JEQ     H034                    sector 0 = no more clusters
 700  4602 C002         MOV     R2,R0                   total offset
 701  4604 6084         S       R4,R2                   minus previous cluster offset = cluster size
 702  4606 C100         MOV     R0,R4                   new previous cluster offset
 703  4608 06A0         BL      @CALSUB                 call subroutine
 703  460A 4344  
 704  460C 4CB6         DATA    FRSCB1                  free sectors in bitmap (from R1, # in R2)
 705  460E C048         MOV     R8,R1                   
 706  4610 6069         S       @>0056(R9),R1                   
 706  4612 0056  
 707  4614 0281         CI      R1,>0100                end of FDR reached?
 707  4616 0100  
 708  4618 16EE         JNE     H033                    not yet
 709  461A 0460 H034    B       @RTURN1                 return to caller
 709  461C 4362  
 710            *                                       
 711  461E 06A0 RDOFSC  BL      @FDR2B1                 read a sector from offset in file
 711  4620 4864  
 712  4622 000E         DATA    14                      get # of sectors
 713  4624 80C0         C       R0,R3                   is desired sector in file?
 714  4626 1B03         JH      H035                    yes
 715  4628 06A0         BL      @ERROR5                 no: update data, then return with error
 715  462A 4966  
 716  462C A000         DATA    >A000                   past end-of-file
 717  462E 06A0 H035    BL      @CALSUB                 call subroutine
 717  4630 4344  
 718  4632 473E         DATA    FSCTOF                  find sector from cluster list
 719  4634 A101         A       R1,R4                   put sector in R4
 720  4636 0702         SETO    R2                      code for read
 721  4638 C147 H036    MOV     R7,R5                   buffer ptr
 722  463A 0460         B       @RWSEC                  read/write sector
 722  463C 4A42  
 723            *                                       
 724  463E 0429 WROFSC  BLWP    @>005A(R9)              write sector to offset in file offset in R3
 724  4640 005A  
 725  4642 8100         DATA    >8100                   save R0 and R7
 726  4644 06A0         BL      @CALSUB                 call subroutine
 726  4646 4344  
 727  4648 4654         DATA    APSCTS                  append enough sectors to reach that offset
 728  464A 0429         BLWP    @>005A(R9)              retrieve R0 and R7
 728  464C 005A  
 729  464E 8101         DATA    >8101                   
 730  4650 04C2         CLR     R2                      code for write
 731  4652 10F2         JMP     H036                    write sector
 732            *                               
 733  4654 06A0 APSCTS  BL      @FDR2B1                 append sector(s) to a file to get offset in R3
 733  4656 4864  
 734  4658 000E         DATA    14                      get # of sect from FDR
 735            *                                       
 736  465A 80C0         C       R0,R3                   is desired sector in file?
 737  465C 1B47         JH      H045                    yes: find it and return
 738  465E C000         MOV     R0,R0                   
 739  4660 1301         JEQ     H037                    empty file
 740  4662 0600         DEC     R0                      last sector #
 741  4664 C143 H037    MOV     R3,R5                   save desired sector offset
 742  4666 C0C0         MOV     R0,R3                   last sector in file
 743  4668 06A0         BL      @CALSUB                 call subroutine
 743  466A 4344  
 744  466C 473E         DATA    FSCTOF                  find sector # from offset in file
 745  466E 0429         BLWP    @>005A(R9)              save R1 (sector #)
 745  4670 005A  
 746  4672 4000         DATA    >4000                   
 747  4674 A044         A       R4,R1                   # of last sector in cluster
 748  4676 C105         MOV     R5,R4                   offset of desired sector
 749  4678 06A0 H038    BL      @CALSUB                 call subroutine
 749  467A 4344  
 750  467C 4BEA         DATA    FFSBMP                  find free sector in bitmap, starting from R1
 751  467E C000         MOV     R0,R0                   found?
 752  4680 1604         JNE     H039                    yes: # in R0
 753  4682 C142         MOV     R2,R5                   no: save # of sectors
 754  4684 06A0         BL      @ADDSEC                 update FDR
 754  4686 46F8  
 755  4688 101B         JMP     H040                    return with memory full
 756            *                                       
 757  468A C041 H039    MOV     R1,R1                   
 758  468C 1320         JEQ     H043                    empty cluster
 759  468E 0581         INC     R1                      one more sector in cluster
 760  4690 8040         C       R0,R1                   same as the one found in bitmap?
 761  4692 131C         JEQ     H042                    yes: just increase cluster size
 762  4694 0429         BLWP    @>005A(R9)              no: retrieve R1 (sector #)
 762  4696 005A  
 763  4698 4001         DATA    >4001                   
 764  469A 0429         BLWP    @>005A(R9)              save R0 + R2
 764  469C 005A  
 765  469E A000         DATA    >A000                   
 766  46A0 06A0         BL      @UPDCLI                 update current cluster info
 766  46A2 4BC6  
 767  46A4 0429         BLWP    @>005A(R9)              retrieve R0 + R2
 767  46A6 005A  
 768  46A8 A001         DATA    >A001                   
 769  46AA 0228         AI      R8,3                    ptr to next cluster info
 769  46AC 0003  
 770  46AE C048         MOV     R8,R1                   
 771  46B0 6069         S       @>0056(R9),R1           current FDR size
 771  46B2 0056  
 772  46B4 0281         CI      R1,>0100                room enough?
 772  46B6 0100  
 773  46B8 1605         JNE     H041                    yes
 774  46BA 06A0         BL      @CALSUB                 no: call subroutine
 774  46BC 4344  
 775  46BE 4CB0         DATA    FFSBM                   free sector in bitmap
 776  46C0 0460 H040    B       @ERROR6                 return with memory full
 776  46C2 4B1C  
 777            *                                       
 778  46C4 C040 H041    MOV     R0,R1                   new sector #
 779  46C6 0429         BLWP    @>005A(R9)              save R1
 779  46C8 005A  
 780  46CA 4000         DATA    >4000                   
 781  46CC 1007 H042    JMP     H044                    make a new cluster
 782            *                                       
 783  46CE 0429 H043    BLWP    @>005A(R9)              retrieve R1
 783  46D0 005A  
 784  46D2 4001         DATA    >4001                   
 785  46D4 0429         BLWP    @>005A(R9)              save R0
 785  46D6 005A  
 786  46D8 8000         DATA    >8000                   
 787  46DA 0702         SETO    R2                      empty file: start from offset 0
 788  46DC C040 H044    MOV     R0,R1                   sector #
 789  46DE 0582         INC     R2                      increment cluster size
 790  46E0 8102         C       R2,R4                   enough?
 791  46E2 16CA         JNE     H038                    no: get one more sector
 792  46E4 C144         MOV     R4,R5                   
 793  46E6 06A0         BL      @ADDSEC                 add sector to FDR
 793  46E8 46F8  
 794  46EA 1004         JMP     H046                    done
 795            *                               
 796  46EC 06A0 H045    BL      @CALSUB                 call subroutine
 796  46EE 4344  
 797  46F0 473E         DATA    FSCTOF                  find a sector from offset in file
 798  46F2 A101         A       R1,R4                   last sector in cluster
 799  46F4 0460 H046    B       @RTURN1                 return to caller
 799  46F6 4362  
 800            *                                       
 801  46F8 C28B ADDSEC  MOV     R11,R10                 add sector to FDR
 802  46FA C101         MOV     R1,R4                   
 803  46FC 0429         BLWP    @>005A(R9)              retrieve R1
 803  46FE 005A  
 804  4700 4001         DATA    >4001                   
 805  4702 C041         MOV     R1,R1                   sector #
 806  4704 131B         JEQ     H047                    none: return
 807  4706 06A0         BL      @UPDCLI                 write info for R1 cluster
 807  4708 4BC6  
 808  470A C0A9         MOV     @>0056(R9),R2           pointer to FDR
 808  470C 0056  
 809  470E 0429         BLWP    @>005A(R9)              set VDP to read
 809  4710 005A  
 810  4712 0042         DATA    >0042                   address in R2
 811  4714 D06F         MOVB    @-1026(R15),R1          first char of filename
 811  4716 FBFE  
 812  4718 0261         ORI     R1,>8000                flag
 812  471A 8000  
 813  471C 0429         BLWP    @>005A(R9)              set VDP to write
 813  471E 005A  
 814  4720 0043         DATA    >0043                   address in R2
 815  4722 DBC1         MOVB    R1,@-2(R15)                     
 815  4724 FFFE  
 816  4726 0222         AI      R2,14                   ptr to # of sectors
 816  4728 000E  
 817  472A 0585         INC     R5                      new # of sectors
 818  472C 0429         BLWP    @>005A(R9)              set VDP to write
 818  472E 005A  
 819  4730 0043         DATA    >0043                   address in R2
 820  4732 DBC5         MOVB    R5,@-2(R15)             update # of sectors
 820  4734 FFFE  
 821  4736 06C5         SWPB    R5                      
 822  4738 DBC5         MOVB    R5,@-2(R15)                     
 822  473A FFFE  
 823  473C 045A H047    B       *R10                    
 824            *                                       
 825  473E C229 FSCTOF  MOV     @>0056(R9),R8           find sector from offset in file
 825  4740 0056  
 826  4742 0228         AI      R8,28                   cluster list
 826  4744 001C  
 827  4746 C103         MOV     R3,R4                   desired sector offset is in R3
 828  4748 06A0 H048    BL      @DECDCI                 decode info: sector in R1, offset in R2
 828  474A 4BAA  
 829  474C 80C2         C       R2,R3                   reached yet?
 830  474E 1101         JLT     H049                    no
 831  4750 1006         JMP     H050                    yes: return
 832  4752 0228 H049    AI      R8,3                    point to next cluster info
 832  4754 0003  
 833  4756 C103         MOV     R3,R4                   
 834  4758 6102         S       R2,R4                   
 835  475A 0604         DEC     R4                      size of the desired cluster (if it's the next)
 836  475C 10F5         JMP     H048                    keep trying
 837  475E 0460 H050    B       @RTURN1                 return to caller
 837  4760 4362  
 838            *
 839            *---------------------------------
 840            * Opcode 7: Delete
 841            * ----------------
 842            * PAB 0: >07
 843            *     1:            <--- error code
 844            *   2-3:
 845            *     4:
 846            *     5:
 847            *   6-7:
 848            *     8:
 849            *---------------------------------                                      
 850            *
 851  4762 06A0 DELETE  BL      @CALSUB                 delete file
 851  4764 4344  
 852  4766 4A98         DATA    FFFDRV                  find file FDR in VDP buffers
 853  4768 C104         MOV     R4,R4                   found?
 854  476A 1307         JEQ     H051                    yes
 855  476C 06A0         BL      @CALSUB                 no: call subroutine
 855  476E 4344  
 856  4770 4B00         DATA    FFDRDK                  find FDR on disk
 857  4772 C104         MOV     R4,R4                   found?
 858  4774 1313         JEQ     H053                    yes
 859  4776 0460         B       @RTURN1                 no: return to caller
 859  4778 4362  
 860            *                                       
 861  477A 0581 H051    INC     R1                      FDR found, point to it
 862  477C CA41         MOV     R1,@>0056(R9)           save it for other routines
 862  477E 0056  
 863  4780 06A0         BL      @CALSUB                 call subroutine
 863  4782 4344  
 864  4784 4A28         DATA    RDSEC1                  read sector 1
 865  4786 06A0         BL      @FDR2B1                 read 2 bytes from VDP at >8356+offset
 865  4788 4864  
 866  478A FFFC         DATA    -4                      i.e. get sector # of FRD in R0
 867  478C C0C0         MOV     R0,R3                   save it for later
 868  478E C205         MOV     R5,R8                   ptr to top of sector 1
 869  4790 06A0 H052    BL      @VDPR2B                 read 2 bytes from VDP at R8 into R0
 869  4792 486A  
 870  4794 05C8         INCT    R8                      next FDR ptr in sector 1
 871  4796 80C0         C       R0,R3                   is this the one we want?
 872  4798 16FB         JNE     H052                    not yet
 873  479A 0648         DECT    R8                      yes: point back to it
 874            *
 875  479C 06A0 H053    BL      @NTPDT                  APEDSK99: update DOAD FAT time/date
 875  479E 5F60  
 876            *
 877  47A0 0429         BLWP    @>005A(R9)              save R8
 877  47A2 005A  
 878  47A4 0080         DATA    >0080                   
 879  47A6 06A0         BL      @CALSUB                 call subroutine
 879  47A8 4344  
 880  47AA 45CE         DATA    FFSVIB                  free file sectors in VIB bitmap
 881  47AC 0429         BLWP    @>005A(R9)              retrieve R8
 881  47AE 005A  
 882  47B0 0081         DATA    >0081                   
 883  47B2 06A0         BL      @RMFPTR                 remove FDR ptr from sector 1
 883  47B4 47CE  
 884  47B6 04C2         CLR     R2                      code for write
 885  47B8 06A0         BL      @CALSUB                 call subroutine
 885  47BA 4344  
 886  47BC 4A2A         DATA    WRSEC1                  write sector 1
 887  47BE 06A0         BL      @FDR2B1                 get 2 bytes from VDP at >8356+offset in R0
 887  47C0 4864  
 888  47C2 FFFC         DATA    -4                      i.e. sector # of FDR
 889  47C4 06A0         BL      @CALSUB                 call subroutine
 889  47C6 4344  
 890  47C8 4CB0         DATA    FFSBM                   free sector in R0 in VIB bitmap
 891  47CA 0460         B       @CLRFBT                 clear 1rst byte of filename in VDP
 891  47CC 4576  
 892            *
 893            * Sector 1 contains an alphabetically sorted list of FDR pointers
 894            * Each pointer is 2 bytes long and contains the sector # of this FDR
 895            * The list must end with a >0000 mark. Thus there can be 127 files at most
 896            *
 897  47CE C169 RMFPTR  MOV     @>0056(R9),R5           remove FDR ptr from sector 1
 897  47D0 0056  
 898  47D2 0225         AI      R5,256                  
 898  47D4 0100  
 899  47D6 C0C5         MOV     R5,R3                   pointer to data buffer
 900  47D8 0223         AI      R3,256                  point to next ctrl block
 900  47DA 0100  
 901  47DC C088         MOV     R8,R2                   shift up FDR list, erasing FDR pointed by R8
 902  47DE 05C2         INCT    R2                      point to next FDR ptr in sector 1
 903  47E0 0429 H054    BLWP    @>005A(R9)              set VDP to read
 903  47E2 005A  
 904  47E4 0042         DATA    >0042                   address in R2
 905  47E6 D02F         MOVB    @-1026(R15),R0          get 1 byte
 905  47E8 FBFE  
 906  47EA 0582         INC     R2                      inc source ptr
 907  47EC 0429         BLWP    @>005A(R9)              set VDP to write
 907  47EE 005A  
 908  47F0 0103         DATA    >0103                   address in R8
 909  47F2 DBC0         MOVB    R0,@-2(R15)             copy 1 byte
 909  47F4 FFFE  
 910  47F6 0588         INC     R8                      inc dest pointer
 911  47F8 80C2         C       R2,R3                   done?
 912  47FA 16F2         JNE     H054                    not yet
 913  47FC 045B         B       *R11                    
 914            *                                       
 915  47FE C28B INSFDR  MOV     R11,R10                 insert a FDR in sector 1
 916  4800 C048         MOV     R8,R1                   
 917  4802 06A0         BL      @FDR2B1                 get 2 bytes from VDP at >8356+offset
 917  4804 4864  
 918  4806 01FC         DATA    508                     i.e. last FDR slot in sector 1 (list ends with 0)
 919  4808 C000         MOV     R0,R0                   
 920  480A 1302         JEQ     H055                    
 921  480C 0460         B       @ERROR6                 memory full error
 921  480E 4B1C  
 922  4810 0608 H055    DEC     R8                      previous byte
 923  4812 0429         BLWP    @>005A(R9)              set VDP to read
 923  4814 005A  
 924  4816 0102         DATA    >0102                   address in R8
 925  4818 D02F         MOVB    @-1026(R15),R0          get 1 byte
 925  481A FBFE  
 926  481C 05C8         INCT    R8                      
 927  481E 0429         BLWP    @>005A(R9)              set VDP to write
 927  4820 005A  
 928  4822 0103         DATA    >0103                   address in R8
 929  4824 DBC0         MOVB    R0,@-2(R15)             copy byte two bytes further down
 929  4826 FFFE  
 930  4828 0648         DECT    R8                      
 931  482A 8048         C       R8,R1                   done ?
 932  482C 16F1         JNE     H055                    not yet
 933  482E 045A         B       *R10                    
 934            *                               
 935  4830 C0A9 CMPFN   MOV     @>0058(R9),R2           compare filenames
 935  4832 0058  
 936  4834 0222         AI      R2,256                  
 936  4836 0100  
 937  4838 0429 H056    BLWP    @>005A(R9)              set VDP to read
 937  483A 005A  
 938  483C 0022         DATA    >0022                   address in R1 (ptr to filename)
 939  483E D02F         MOVB    @-1026(R15),R0          get 1 char
 939  4840 FBFE  
 940  4842 0240         ANDI    R0,>7FFF                clear flag (on drive #)
 940  4844 7FFF  
 941  4846 0429         BLWP    @>005A(R9)              set VDP to read
 941  4848 005A  
 942  484A 0042         DATA    >0042                   address in R2 (filename compare buffer)
 943  484C D0EF         MOVB    @-1026(R15),R3          get 1 char
 943  484E FBFE  
 944  4850 90C0         CB      R0,R3                   compare chars
 945  4852 1604         JNE     H057                    mismatch
 946  4854 0581         INC     R1                      match: increment pointers
 947  4856 0582         INC     R2                      
 948  4858 0604         DEC     R4                      
 949  485A 16EE         JNE     H056                    next char
 950  485C 045B H057    B       *R11                    if complete match: ret with EQ set
 951            *                                       
 952  485E C229 PABR2B  MOV     @>0054(R9),R8           get two bytes from PAB
 952  4860 0054  
 953  4862 1002         JMP     FDR2B2                  
 954            *                                       
 955  4864 C229 FDR2B1  MOV     @>0056(R9),R8           get two bytes from FDR
 955  4866 0056  
 956  4868 A23B FDR2B2  A       *R11+,R8                offset in data word
 957            *                                       
 958  486A 0429 VDPR2B  BLWP    @>005A(R9)              get two byte from VDP at R8
 958  486C 005A  
 959  486E 0102         DATA    >0102                   set VDP to read at R8
 960  4870 D02F         MOVB    @-1026(R15),R0          get two bytes of data
 960  4872 FBFE  
 961  4874 06C0         SWPB    R0                      
 962  4876 D02F         MOVB    @-1026(R15),R0                  
 962  4878 FBFE  
 963  487A 0B80         SRC     R0,8                    why not swpb ?
 964  487C 045B         B       *R11                    
 965            *                       
 966  487E C069 FDSKDR  MOV     @>0058(R9),R1           find disk from name (ptr in R3)
 966  4880 0058  
 967  4882 0221         AI      R1,256                  
 967  4884 0100  
 968  4886 06A0         BL      @CPCKFN                 copy filename from VDP at R3 to compare buffer
 968  4888 4908  
 969  488A 0429         BLWP    @>005A(R9)              save R2 + R3
 969  488C 005A  
 970  488E 3000         DATA    >3000                   
 971  4890 C000         MOV     R0,R0                   last char copied
 972  4892 1101         JLT     H058                    flagged
 973  4894 1005         JMP     H059                    
 974  4896 C180 H058    MOV     R0,R6                   
 975  4898 0246         ANDI    R6,>0300                        
 975  489A 0300  
 976  489C 1337         JEQ     ERROR7                  return with file error
 977  489E 102F         JMP     H062                    return to caller
 978  48A0 04C6 H059    CLR     R6                      don't read any drive
 979  48A2 06A0         BL      @CALSUB                 call subroutine
 979  48A4 4344  
 980  48A6 49C6         DATA    RWVIB                   save current VIB
 981  48A8 0226 H060    AI      R6,>0100                next drive
 981  48AA 0100  
 982  48AC 0707         SETO    R7                      error flags
 983  48AE 0702         SETO    R2                      code for read
 984  48B0 04C4         CLR     R4                      sector 0
 985  48B2 06A0         BL      @CALSUB                 call subroutine
 985  48B4 4344  
 986  48B6 4A44         DATA    RWSECA                  read sector 0
 987  48B8 C1C7         MOV     R7,R7                   ok?
 988  48BA 161D         JNE     H061                    no: try next drive
 989  48BC 0204         LI      R4,10                   yes: diskname size
 989  48BE 000A  
 990  48C0 C069         MOV     @>0058(R9),R1           VIB ptr
 990  48C2 0058  
 991  48C4 0429         BLWP    @>005A(R9)              save R1-R3
 991  48C6 005A  
 992  48C8 7000         DATA    >7000                   
 993  48CA 06A0         BL      @CMPFN                  compare names (ptr in R1 + compare buffer)
 993  48CC 4830  
 994  48CE 0429         BLWP    @>005A(R9)                      
 994  48D0 005A  
 995  48D2 7001         DATA    >7001                   retrieve R1-R3
 996  48D4 C104         MOV     R4,R4                   name matched?
 997  48D6 160F         JNE     H061                    no: try next drive
 998  48D8 C006         MOV     R6,R0                   drive #
 999  48DA 0260         ORI     R0,>8000                add update flag
 999  48DC 8000  
1000  48DE 0429         BLWP    @>005A(R9)              set VDP to write
1000  48E0 005A  
1001  48E2 0063         DATA    >0063                   address in R3
1002  48E4 DBC0         MOVB    R0,@-2(R15)             copy drive+flag before diskname in source
1002  48E6 FFFE  
1003  48E8 0605         DEC     R5                      before sector 0 copy
1004  48EA 0429         BLWP    @>005A(R9)              set VDP to write
1004  48EC 005A  
1005  48EE 00A3         DATA    >00A3                   address in R5
1006  48F0 DBC6         MOVB    R6,@-2(R15)             copy drive # before VIB
1006  48F2 FFFE  
1007  48F4 1004         JMP     H062                    done
1008            *                               
1009  48F6 0286 H061    CI      R6,>0300                did we do all drives?
1009  48F8 0300  
1010  48FA 16D6         JNE     H060                    no: try next on
1011  48FC 1007         JMP     ERROR7                  return with file error
1012            *                                       
1013  48FE 0429 H062    BLWP    @>005A(R9)              retrieve R2 + R3
1013  4900 005A  
1014  4902 3001         DATA    >3001                   
1015  4904 0460         B       @RTURN1                 return to caller
1015  4906 4362  
1016            *                               
1017  4908 0602 CPCKFN  DEC     R2                      
1018  490A 1B03         JH      H063                    
1019  490C 06A0 ERROR7  BL      @RETERR                 return with error
1019  490E 4992  
1020  4910 E000         DATA    >E000                   file error
1021            *                                       
1022  4912 0200 H063    LI      R0,>2000                copy (+check) filename in VDP from R3 to R1 (space)
1022  4914 2000  
1023  4916 0429         BLWP    @>005A(R9)              set VDP to write
1023  4918 005A  
1024  491A 0023         DATA    >0023                   address in R1
1025  491C 0208         LI      R8,10                   10 chars per filename
1025  491E 000A  
1026  4920 DBC0 H064    MOVB    R0,@-2(R15)             fill filename with spaces
1026  4922 FFFE  
1027  4924 0608         DEC     R8                      
1028  4926 16FC         JNE     H064                    
1029  4928 0208         LI      R8,11                   11 chars countring drive #
1029  492A 000B  
1030  492C 0583 H065    INC     R3                      increment source ptr
1031  492E 0429         BLWP    @>005A(R9)              set VDP to read
1031  4930 005A  
1032  4932 0062         DATA    >0062                   address in R3
1033  4934 D02F         MOVB    @-1026(R15),R0          get a char
1033  4936 FBFE  
1034  4938 13E9         JEQ     ERROR7                  >00: return with file error
1035  493A 1110         JLT     H066                    flag bit set
1036  493C 0280         CI      R0,>2E00                        
1036  493E 2E00  
1037  4940 130D         JEQ     H066                    '.'
1038  4942 0608         DEC     R8                      
1039  4944 13E3         JEQ     ERROR7                  name to long: return with file error
1040  4946 0280         CI      R0,>2000                        
1040  4948 2000  
1041  494A 13E0         JEQ     ERROR7                  name can't contain spaces: file error again
1042  494C 0429         BLWP    @>005A(R9)              set VDP to write
1042  494E 005A  
1043  4950 0023         DATA    >0023                   address in R1
1044  4952 DBC0         MOVB    R0,@-2(R15)             copy 1 char
1044  4954 FFFE  
1045  4956 0581         INC     R1                      increment destination pointer
1046  4958 0602         DEC     R2                      more?
1047  495A 16E8         JNE     H065                    yes
1048  495C 0288 H066    CI      R8,>000B                name can't be 0 chars long
1048  495E 000B  
1049  4960 13D5         JEQ     ERROR7                  else return with file error
1050  4962 045B         B       *R11                    
1051            *                                       
1052  4964 AA00 K014    DATA    >AA00                   
1053            *                               
1054  4966 C00B ERROR5  MOV     R11,R0                  update data, then error
1055  4968 C0E9         MOV     @>0056(R9),R3           
1055  496A 0056  
1056  496C 0603         DEC     R3                      see what >8356 is pointing at
1057  496E 0429         BLWP    @>005A(R9)              set VDP to read
1057  4970 005A  
1058  4972 0062         DATA    >0062                   address in R3
1059  4974 D0AF         MOVB    @-1026(R15),R2          get 1 byte
1059  4976 FBFE  
1060  4978 9802         CB      R2,@K014                is it >AA (disk buffer area mark)
1060  497A 4964  
1061  497C 1309         JEQ     H067                    yes: announce error (code in data word)
1062  497E 0429         BLWP    @>005A(R9)              no: >8356 points to a FDR. Save R0
1062  4980 005A  
1063  4982 8000         DATA    >8000                   
1064  4984 06A0         BL      @CALSUB                 call subroutine
1064  4986 4344  
1065  4988 456A         DATA    UPDFDR                  update FRD and data buffer if needed
1066  498A 0429         BLWP    @>005A(R9)              retrieve R0
1066  498C 005A  
1067  498E 8001         DATA    >8001                   
1068  4990 C2C0 H067    MOV     R0,R11                  
1069            *                               
1070  4992 C069 RETERR  MOV     @>0054(R9),R1           annouce error
1070  4994 0054  
1071  4996 130D         JEQ     H068                    no PAB
1072  4998 0581         INC     R1                      for DSRs: ptr to status byte
1073  499A 0429         BLWP    @>005A(R9)              set VDP to read
1073  499C 005A  
1074  499E 0022         DATA    >0022                   address in R2
1075  49A0 D0AF         MOVB    @-1026(R15),R2          get file status byte
1075  49A2 FBFE  
1076  49A4 E0BB         SOC     *R11+,R2                add error code
1077  49A6 0429         BLWP    @>005A(R9)              set VDP to write
1077  49A8 005A  
1078  49AA 0023         DATA    >0023                   address in R2
1079  49AC DBC2         MOVB    R2,@-2(R15)             write back status byte
1079  49AE FFFE  
1080  49B0 1002         JMP     H069                    
1081  49B2 CA7B H068    MOV     *R11+,@>0050(R9)        for subs: error code in >8350
1081  49B4 0050  
1082  49B6 C229 H069    MOV     @>0058(R9),R8           get stack ptr
1082  49B8 0058  
1083  49BA 0228         AI      R8,-12                  point back to initial caller
1083  49BC FFF4  
1084  49BE CA48         MOV     R8,@>0066(R9)           update pointer
1084  49C0 0066  
1085  49C2 0460         B       @RTURN1                 return to caller
1085  49C4 4362  
1086            *                               
1087  49C6 0429 RWVIB   BLWP    @>005A(R9)              read VIB (drive # in R6)
1087  49C8 005A  
1088  49CA 3000         DATA    >3000                   save R2 + R3
1089  49CC C169         MOV     @>0058(R9),R5           pointer to VIB in ctrl block
1089  49CE 0058  
1090  49D0 0605         DEC     R5                      ptr to drive #
1091  49D2 0429         BLWP    @>005A(R9)              set VDP for read
1091  49D4 005A  
1092  49D6 00A2         DATA    >00A2                   address in R5
1093  49D8 D0AF         MOVB    @-1026(R15),R2          get drive #
1093  49DA FBFE  
1094  49DC C0C2         MOV     R2,R3                   
1095  49DE 04C4         CLR     R4                      sector 0 for VIB
1096  49E0 0242         ANDI    R2,>0300                clear flag (>80 = update data)
1096  49E2 0300  
1097  49E4 9182         CB      R2,R6                   wanted drive?
1098  49E6 131A         JEQ     H073                    yes: return
1099  49E8 C0C3         MOV     R3,R3                   no: shall we update VIB?
1100  49EA 1101         JLT     H070                    yes
1101  49EC 100A         JMP     H071                    no
1102  49EE 0429 H070    BLWP    @>005A(R9)              set VDP to write
1102  49F0 005A  
1103  49F2 00A3         DATA    >00A3                   address in R5
1104  49F4 DBC4         MOVB    R4,@-2(R15)             clr drive #
1104  49F6 FFFE  
1105  49F8 0585         INC     R5                      point back to VIB buffer
1106  49FA 06A0         BL      @CALSUB                 call subroutine
1106  49FC 4344  
1107  49FE 4A46         DATA    RWSECB                  write sector 0 to old drive (in R2)
1108  4A00 0605         DEC     R5                      point to drive #
1109  4A02 0702 H071    SETO    R2                      flag for read
1110  4A04 D086         MOVB    R6,R2                   APEDSK99: error in original disassembly (was R5)
1111  4A06 1305         JEQ     H072                    none
1112  4A08 0585         INC     R5                      point at VIB buffer
1113  4A0A 06A0         BL      @CALSUB                 call subroutine
1113  4A0C 4344  
1114  4A0E 4A44         DATA    RWSECA                  read sector (in R4) to buffer (in R5)
1115  4A10 0605         DEC     R5                      point at drive #
1116  4A12 0429 H072    BLWP    @>005A(R9)              set VDP to write
1116  4A14 005A  
1117  4A16 00A3         DATA    >00A3                   address in R5
1118  4A18 DBC6         MOVB    R6,@-2(R15)             write drive # in control block, before FDR
1118  4A1A FFFE  
1119  4A1C 0585 H073    INC     R5                      point back to FDR
1120  4A1E 0429         BLWP    @>005A(R9)                      
1120  4A20 005A  
1121  4A22 3001         DATA    >3001                   retrieve R2 + R3 from stack
1122  4A24 0460         B       @RTURN1                 branch to address on stack
1122  4A26 4362  
1123            *                               
1124  4A28 0702 RDSEC1  SETO    R2                      read sector 1
1125  4A2A 0204 WRSEC1  LI      R4,1
1125  4A2C 0001  
1126  4A2E 0205         LI      R5,>0100                into data buffer area of current ctrl block
1126  4A30 0100  
1127  4A32 1005         JMP     RDFDR1                  
1128            *                               
1129  4A34 06A0 WRFDR   BL      @FDR2B1                 read FDR
1129  4A36 4864  
1130  4A38 FFFC         DATA    -4                      get sector # of FDR from control block
1131            *                               
1132  4A3A C100 RDFDR2  MOV     R0,R4                   sector read/write
1133  4A3C 04C5         CLR     R5
1134  4A3E A169 RDFDR1  A       @>0056(R9),R5           point to FDR or data buffer
1134  4A40 0056  
1135  4A42 04C7 RWSEC   CLR     R7                      
1136  4A44 D086 RWSECA  MOVB    R6,R2                   add drive # for r/w flag
1137  4A46 0429 RWSECB  BLWP    @>005A(R9)              save R0-R8
1137  4A48 005A  
1138  4A4A FF80         DATA    >FF80                   
1139  4A4C CA44         MOV     R4,@>004A(R9)           sector #
1139  4A4E 004A  
1140  4A50 CA42         MOV     R2,@>004C(R9)           drive | r/w flag
1140  4A52 004C  
1141  4A54 CA45         MOV     R5,@>004E(R9)           buffer ptr
1141  4A56 004E  
1142  4A58 06A0         BL      @CALSUB                 call subroutine
1142  4A5A 4344  
1143  4A5C 419A         DATA    SECRW1                  sector read/write
1144  4A5E 0429         BLWP    @>005A(R9)              retrieve R0-R8
1144  4A60 005A  
1145  4A62 FF81         DATA    >FF81                   
1146  4A64 D1E9         MOVB    @>0050(R9),R7           get error code | flags
1146  4A66 0050  
1147  4A68 06C7         SWPB    R7                      
1148  4A6A 1312         JEQ     H077                    
1149  4A6C C1C7         MOV     R7,R7                   
1150  4A6E 1501         JGT     H074                    
1151  4A70 100B         JMP     H076                    
1152  4A72 0247 H074    ANDI    R7,>00FF                        
1152  4A74 00FF  
1153  4A76 0287         CI      R7,>0034                        
1153  4A78 0034  
1154  4A7A 1603         JNE     H075                    
1155  4A7C 06A0         BL      @ERROR5                 
1155  4A7E 4966  
1156  4A80 2000         DATA    >2000                   write protected
1157  4A82 06A0 H075    BL      @ERROR5                 
1157  4A84 4966  
1158  4A86 C000         DATA    >C000                   device error
1159  4A88 DA69 H076    MOVB    @>004D(R9),@>004D(R9)   read or write?
1159  4A8A 004D  
1159  4A8C 004D  
1160  4A8E 13F1         JEQ     H074                    write
1161  4A90 0247 H077    ANDI    R7,>00FF                        
1161  4A92 00FF  
1162  4A94 0460         B       @RTURN1                 return to caller
1162  4A96 4362  
1163            *                               
1164  4A98 C069 FFFDRV  MOV     @>0058(R9),R1           save filename in compare buffer and find its FDR
1164  4A9A 0058  
1165  4A9C 0221         AI      R1,256                  
1165  4A9E 0100  
1166  4AA0 0429         BLWP    @>005A(R9)              set VDP to write
1166  4AA2 005A  
1167  4AA4 0023         DATA    >0023                   address in R1: filename compare buffer
1168  4AA6 DBC6         MOVB    R6,@-2(R15)             write drive #
1168  4AA8 FFFE  
1169  4AAA 0581         INC     R1                      
1170  4AAC 06A0         BL      @CPCKFN                 copy (+ check) filename from R3 to R1
1170  4AAE 4908  
1171  4AB0 C082         MOV     R2,R2                   all chars copied (or was there a . or a >00
1172  4AB2 1302         JEQ     FFDRVB                  
1173  4AB4 0460 H078    B       @ERROR7                 return with file error
1173  4AB6 490C  
1174            *                                       
1175  4AB8 C069 FFDRVB  MOV     @>0056(R9),R1           find filename in buffered FDRs
1175  4ABA 0056  
1176  4ABC 0221         AI      R1,3                    
1176  4ABE 0003  
1177  4AC0 0429         BLWP    @>005A(R9)              set VDP to read
1177  4AC2 005A  
1178  4AC4 0022         DATA    >0022                   address in R1
1179  4AC6 D0AF         MOVB    @-1026(R15),R2          get # of files
1179  4AC8 FBFE  
1180  4ACA 0982         SRL     R2,8                    make it a word
1181  4ACC C0C2         MOV     R2,R3                   save it
1182  4ACE 0221         AI      R1,6                    ptr to drive #
1182  4AD0 0006  
1183  4AD2 0204 H079    LI      R4,11                   compare 11 bytes (drive + filename)
1183  4AD4 000B  
1184  4AD6 0429         BLWP    @>005A(R9)              save R1-R3
1184  4AD8 005A  
1185  4ADA 7000         DATA    >7000                   
1186  4ADC 06A0         BL      @CMPFN                  compare with name in compare buffer
1186  4ADE 4830  
1187  4AE0 0429         BLWP    @>005A(R9)              retrieve R1-R3
1187  4AE2 005A  
1188  4AE4 7001         DATA    >7001                   
1189  4AE6 C104         MOV     R4,R4                   fully compared?
1190  4AE8 1304         JEQ     H080                    yes: done
1191  4AEA 0221         AI      R1,518                  move to next FDR in VDP mem
1191  4AEC 0206  
1192  4AEE 0602         DEC     R2                      
1193  4AF0 16F0         JNE     H079                    next file
1194  4AF2 0460 H080    B       @RTURN1                 return to caller (R4=0 if successfull)
1194  4AF4 4362  
1195            *                               
1196  4AF6 06A0 FNDFDR  BL      @CALSUB                 
1196  4AF8 4344  
1197  4AFA 4A98         DATA    FFFDRV                  save name in comp buffer, find FDR in VDP buffers
1198            *                                       
1199  4AFC C104 FFDROD  MOV     R4,R4                   find FDR on disk (from filename)
1200  4AFE 13DA         JEQ     H078                    file error
1201  4B00 C169 FFDRDK  MOV     @>0056(R9),R5           ptr to top of disk buffer in VDP mem
1201  4B02 0056  
1202  4B04 0225         AI      R5,10                   ptr to drive # in first file control block
1202  4B06 000A  
1203  4B08 0429 H081    BLWP    @>005A(R9)              set VDP to read
1203  4B0A 005A  
1204  4B0C 00A2         DATA    >00A2                   address in R5
1205  4B0E D0AF         MOVB    @-1026(R15),R2          get drive #
1205  4B10 FBFE  
1206  4B12 1307         JEQ     H082                    free control block found
1207  4B14 0225         AI      R5,518                  ptr to file control block
1207  4B16 0206  
1208  4B18 0603         DEC     R3                      
1209  4B1A 16F6         JNE     H081                    more files ?
1210  4B1C 06A0 ERROR6  BL      @ERROR5                 no:
1210  4B1E 4966  
1211  4B20 8000         DATA    >8000                   memory full
1212            *                               
1213  4B22 CA45 H082    MOV     R5,@>0056(R9)           save ptr to free ctrl block (drive #)
1213  4B24 0056  
1214  4B26 06A0         BL      @CALSUB                 call subroutine
1214  4B28 4344  
1215  4B2A 4A28         DATA    RDSEC1                  read sector 1
1216  4B2C C229 FFDRFN  MOV     @>0056(R9),R8           entry point if sector 1 already read
1216  4B2E 0056  
1217  4B30 0228         AI      R8,382                  point to middle of sector 1
1217  4B32 017E  
1218  4B34 0202         LI      R2,64                   distance: start with 1/4 sector
1218  4B36 0040  
1219  4B38 0704 H083    SETO    R4                      
1220  4B3A 06A0         BL      @VDPR2B                 read 2 bytes in R0 from VDP address in R8
1220  4B3C 486A  
1221  4B3E C000         MOV     R0,R0                   
1222  4B40 132E         JEQ     H085                    no file here: move up
1223  4B42 0429         BLWP    @>005A(R9)              save R2
1223  4B44 005A  
1224  4B46 2000         DATA    >2000                   
1225  4B48 0702         SETO    R2                      code for read
1226  4B4A 06A0         BL      @CALSUB                 call subroutine
1226  4B4C 4344  
1227  4B4E 4A3A         DATA    RDFDR2                  read FDR, sector # in R0
1228  4B50 C045         MOV     R5,R1                   RDFDR2 sets R5 as FDR ptr
1229  4B52 0225         AI      R5,-4                   point to sector # of FDR in ctrl block
1229  4B54 FFFC  
1230  4B56 0429         BLWP    @>005A(R9)              set VDP to write
1230  4B58 005A  
1231  4B5A 00A3         DATA    >00A3                   address in R5
1232  4B5C DBC4         MOVB    R4,@-2(R15)             RDFDR2 puts sector # in R4
1232  4B5E FFFE  
1233  4B60 06C4         SWPB    R4                      copy it to ctrl block
1234  4B62 DBC4         MOVB    R4,@-2(R15)                     
1234  4B64 FFFE  
1235  4B66 C141         MOV     R1,R5                   FDR ptr
1236  4B68 0601         DEC     R1                      now point to drive #
1237  4B6A 0429         BLWP    @>005A(R9)              set VDP to write
1237  4B6C 005A  
1238  4B6E 0023         DATA    >0023                   address in R1
1239  4B70 DBC6         MOVB    R6,@-2(R15)             save drive #
1239  4B72 FFFE  
1240  4B74 0204         LI      R4,11                   size to compare (drive # + filename)
1240  4B76 000B  
1241  4B78 06A0         BL      @CMPFN                  compare filenames
1241  4B7A 4830  
1242  4B7C 0429         BLWP    @>005A(R9)              retrieve R2
1242  4B7E 005A  
1243  4B80 2001         DATA    >2001                   
1244  4B82 130B         JEQ     H084                    compared ok: return
1245  4B84 0429         BLWP    @>005A(R9)              set VDP to write
1245  4B86 005A  
1246  4B88 00A3         DATA    >00A3                   address in R5
1247  4B8A DBC4         MOVB    R4,@-2(R15)             remaining chars to compare
1247  4B8C FFFE  
1248  4B8E 80C0         C       R0,R3                   what kind of mismatch occured?
1249  4B90 1B06         JH      H085                    too far down the alphabet
1250  4B92 A202         A       R2,R8                   too far up: move half-way down
1251  4B94 C082         MOV     R2,R2                   
1252  4B96 1606         JNE     H086                    then divide distance by 2
1253  4B98 05C8         INCT    R8                      already checked: reset EQ
1254  4B9A 0460 H084    B       @RTURN1                 return (from stack)
1254  4B9C 4362  
1255            *                               
1256  4B9E 6202 H085    S       R2,R8                   move half-way up
1257  4BA0 C082         MOV     R2,R2                   
1258  4BA2 13FB         JEQ     H084                    can't: already checked
1259  4BA4 0922 H086    SRL     R2,2                    divide distance by 2
1260  4BA6 A082         A       R2,R2                   but keep it even
1261  4BA8 10C7         JMP     H083                    
1262            *
1263            * The cluster info list is located in the FDR, bytes >1C to >FF
1264            * A cluster info consists in 3 bytes, i.e 6 nibbles
1265            * 3 nibbles specify the beginning sector for that cluster, and
1266            * 3 nibbles specify the total file offset in sectors, including this cluster.
1267            * The nibbles are arranged as EG SB OF, to be combined as BEG OFS
1268            *
1269  4BAA C28B DECDCI  MOV     R11,R10                 decode cluster info
1270  4BAC 06A0         BL      @VDPR2B                 read 2 bytes VDP at R8 in R0
1270  4BAE 486A  
1271  4BB0 06C0         SWPB    R0                      
1272  4BB2 D0AF         MOVB    @-1026(R15),R2          get third byte from cluster list
1272  4BB4 FBFE  
1273  4BB6 C040         MOV     R0,R1                   
1274  4BB8 0241         ANDI    R1,>0FFF                start sector in R1
1274  4BBA 0FFF  
1275  4BBC 4001         SZC     R1,R0                   remove it from R0
1276  4BBE 0982         SRL     R2,8                    
1277  4BC0 E080         SOC     R0,R2                   combine offset nibbles
1278  4BC2 0BC2         SRC     R2,12                   offset in R2
1279  4BC4 045A         B       *R10                    
1280            *                               
1281  4BC6 0B42 UPDCLI  SRC     R2,4                    write info for 1 cluster
1282  4BC8 C002         MOV     R2,R0                   
1283  4BCA 0240         ANDI    R0,>F000                sector in R1, offset in R2
1283  4BCC F000  
1284  4BCE E040         SOC     R0,R1                   copy nibble 3 of offset before nibble 1 of sector
1285  4BD0 0429         BLWP    @>005A(R9)              set VDP to write
1285  4BD2 005A  
1286  4BD4 0103         DATA    >0103                   address in R8
1287  4BD6 06C1         SWPB    R1                      write cluster info
1288  4BD8 DBC1         MOVB    R1,@-2(R15)             as 3 bytes
1288  4BDA FFFE  
1289  4BDC 06C1         SWPB    R1                      
1290  4BDE DBC1         MOVB    R1,@-2(R15)                     
1290  4BE0 FFFE  
1291  4BE2 06C2         SWPB    R2                      
1292  4BE4 DBC2         MOVB    R2,@-2(R15)                     
1292  4BE6 FFFE  
1293  4BE8 045B         B       *R11                    
1294            *
1295            * The sector bitmap is located in the VIB (i.e. sector 0) at bytes >38 to >FF
1296            * In each byte a bit defines a sector, from right to left: "0"=free, "1"=used                                   
1297            *
1298  4BEA 0429 FFSBMP  BLWP    @>005A(R9)              find a free sector in bitmap
1298  4BEC 005A  
1299  4BEE 7800         DATA    >7800                   
1300  4BF0 06A0         BL      @CALSUB                 call subroutine
1300  4BF2 4344  
1301  4BF4 49C6         DATA    RWVIB                   load VIB for drive in R6
1302  4BF6 C041         MOV     R1,R1                   first sector specified in R1 ?
1303  4BF8 1602         JNE     H087                    yes
1304  4BFA 0201         LI      R1,33                   no: start with sector 34
1304  4BFC 0021  
1305  4BFE 0581 H087    INC     R1                      
1306  4C00 C001         MOV     R1,R0                   
1307  4C02 0931         SRL     R1,3                    div by 8 since 8 sect/byte in bitmap
1308  4C04 0202         LI      R2,>00FF                        
1308  4C06 00FF  
1309  4C08 0240         ANDI    R0,>0007                bit number in bitmap byte
1309  4C0A 0007  
1310  4C0C 1301         JEQ     H088                    
1311  4C0E 0A02         SLA     R2,0                    get that bit
1312  4C10 C0C1 H088    MOV     R1,R3                   byte #
1313  4C12 A0C5         A       R5,R3                   add VIB ptr
1314  4C14 0223         AI      R3,56                   ptr to sector in bitmap
1314  4C16 0038  
1315  4C18 0281         CI      R1,>00C8                end of VIB?
1315  4C1A 00C8  
1316  4C1C 1101         JLT     H089                    no
1317  4C1E 04C1         CLR     R1                      yes: top of bitmap
1318  4C20 A045 H089    A       R5,R1                   
1319  4C22 0221         AI      R1,56                   make another bitmap ptr
1319  4C24 0038  
1320  4C26 0429         BLWP    @>005A(R9)              set VDP to read
1320  4C28 005A  
1321  4C2A 0022         DATA    >0022                   address in R1
1322  4C2C 0700 H090    SETO    R0                      
1323  4C2E D02F         MOVB    @-1026(R15),R0          get bitmap byte
1323  4C30 FBFE  
1324  4C32 C100         MOV     R0,R4                   save it
1325  4C34 E002         SOC     R2,R0                   mask previous sectors
1326  4C36 04C2         CLR     R2                      
1327  4C38 0580         INC     R0                      get 1 more sector
1328  4C3A 1610         JNE     H092                    ok
1329  4C3C 0581         INC     R1                      byte full: try next
1330  4C3E C001         MOV     R1,R0                   
1331  4C40 0220         AI      R0,-256                 won't change if byte # became >100
1331  4C42 FF00  
1332  4C44 8140         C       R0,R5                   still in VIB?
1333  4C46 1605         JNE     H091                    yes
1334  4C48 0221         AI      R1,-200                 no: to top of bitmap
1334  4C4A FF38  
1335  4C4C 0429         BLWP    @>005A(R9)              set VDP to read
1335  4C4E 005A  
1336  4C50 0022         DATA    >0022                   address in R1
1337  4C52 80C1 H091    C       R1,R3                   are we back to where we started?
1338  4C54 16EB         JNE     H090                    no: seach that byte for a free sector
1339  4C56 C004         MOV     R4,R0                   get original byte
1340  4C58 0580         INC     R0                      try sectors just before ours (no mask this time)
1341  4C5A 1325         JEQ     H095                    full: return with EQ
1342  4C5C 0600 H092    DEC     R0                      restore original byte
1343  4C5E C080         MOV     R0,R2                   
1344  4C60 04C0         CLR     R0                      bit counter
1345  4C62 06C2         SWPB    R2                      
1346  4C64 0580 H093    INC     R0                      increment bit count
1347  4C66 0B12         SRC     R2,1                    find first 0 bit from the right
1348  4C68 18FD         JOC     H093                    not yet
1349  4C6A 0202         LI      R2,>0080                        
1349  4C6C 0080  
1350  4C6E 0A02         SLA     R2,0                    make a mask for that bit
1351  4C70 0600         DEC     R0                      bit # (0-7)
1352  4C72 E102         SOC     R2,R4                   mark sector as used in bitmap byte
1353  4C74 0429         BLWP    @>005A(R9)              set VDP to write
1353  4C76 005A  
1354  4C78 0023         DATA    >0023                   address in R1
1355  4C7A DBC4         MOVB    R4,@-2(R15)             update bitmap
1355  4C7C FFFE  
1356  4C7E 0221         AI      R1,-56                  
1356  4C80 FFC8  
1357  4C82 6045         S       R5,R1                   byte # in bitmap
1358  4C84 0A31         SLA     R1,3                    times 8 (8 sect per byte)
1359  4C86 E040         SOC     R0,R1                   add bit #: = sector #
1360  4C88 C001         MOV     R1,R0                   save it
1361            *                               
1362  4C8A 0605 H094    DEC     R5                      point to drive #
1363  4C8C 0429         BLWP    @>005A(R9)              set VDP to read
1363  4C8E 005A  
1364  4C90 00A2         DATA    >00A2                   address in R5
1365  4C92 D06F         MOVB    @-1026(R15),R1          get drive #
1365  4C94 FBFE  
1366  4C96 0261         ORI     R1,>8000                add flag: update VIB
1366  4C98 8000  
1367  4C9A 0429         BLWP    @>005A(R9)              set VDP to write
1367  4C9C 005A  
1368  4C9E 00A3         DATA    >00A3                   address in R5
1369  4CA0 DBC1         MOVB    R1,@-2(R15)             write back flagged drive #
1369  4CA2 FFFE  
1370  4CA4 0585         INC     R5                      point to VIB (& return with NEQ)
1371  4CA6 0429 H095    BLWP    @>005A(R9)              retrieve R1-R4
1371  4CA8 005A  
1372  4CAA 7801         DATA    >7801                   
1373  4CAC 0460         B       @RTURN1                 return to caller
1373  4CAE 4362  
1374            *                               
1375  4CB0 C040 FFSBM   MOV     R0,R1                   free sector(s) in bitmap
1376  4CB2 0202         LI      R2,1                    1 sector only
1376  4CB4 0001  
1377  4CB6 0429 FRSCB1  BLWP    @>005A(R9)              entry point if more than 1 sector
1377  4CB8 005A  
1378  4CBA 7800         DATA    >7800                   save R1-R4
1379  4CBC 06A0         BL      @CALSUB                 call subroutine
1379  4CBE 4344  
1380  4CC0 49C6         DATA    RWVIB                   load VIB for drive in R6
1381  4CC2 C001         MOV     R1,R0                   sector #
1382  4CC4 0240         ANDI    R0,>0007                bit in bitmap byte (8 per byte)
1382  4CC6 0007  
1383  4CC8 0931         SRL     R1,3                    byte in bitmap
1384  4CCA A045         A       R5,R1                   add VIB buffer
1385  4CCC 0221         AI      R1,56                   add bitmap offset in VIB
1385  4CCE 0038  
1386  4CD0 C0C0         MOV     R0,R3                   
1387  4CD2 0500         NEG     R0                      
1388  4CD4 0220         AI      R0,8                    change 0-7 into 8-1
1388  4CD6 0008  
1389  4CD8 0204         LI      R4,>00FF                mask to erase
1389  4CDA 00FF  
1390  4CDC 8002         C       R2,R0                   how many to erase?
1391  4CDE 1101         JLT     H096                    less than in that byte
1392  4CE0 100A         JMP     H099                    
1393            *                               
1394  4CE2 0200 H096    LI      R0,8                    free sectors in first byte
1394  4CE4 0008  
1395  4CE6 6002         S       R2,R0                   
1396  4CE8 0B04         SRC     R4,0                    adjust mask
1397  4CEA C003         MOV     R3,R0                   original bit # of starting sector
1398  4CEC 1301         JEQ     H097                    
1399  4CEE 0A04         SLA     R4,0                    don't erase before starting sector
1400  4CF0 1000 H097    JMP     H098                    
1401            *                               
1402  4CF2 06C4 H098    SWPB    R4                      
1403  4CF4 1019         JMP     H102                    goto erase last byte
1404            *                                       
1405  4CF6 0B04 H099    SRC     R4,0                    adjust mask
1406  4CF8 6080 H100    S       R0,R2                   that many will be freed
1407  4CFA 0429         BLWP    @>005A(R9)              set VDP to read
1407  4CFC 005A  
1408  4CFE 0022         DATA    >0022                   address in R1
1409  4D00 D02F         MOVB    @-1026(R15),R0          get bitmap byte
1409  4D02 FBFE  
1410  4D04 4004         SZC     R4,R0                   mark sectors as free
1411  4D06 0429         BLWP    @>005A(R9)              set VDP to write
1411  4D08 005A  
1412  4D0A 0023         DATA    >0023                   address in R1
1413  4D0C DBC0         MOVB    R0,@-2(R15)             write it back
1413  4D0E FFFE  
1414  4D10 0204         LI      R4,>FF00                clear full byte
1414  4D12 FF00  
1415  4D14 0581         INC     R1                      next byte
1416  4D16 0200         LI      R0,8                    i.e. 8 sectors
1416  4D18 0008  
1417  4D1A 8002         C       R2,R0                   how many more sectors?
1418  4D1C 1101         JLT     H101                    less than 8
1419  4D1E 10EC         JMP     H100                    8 or more: next byte
1420            *                                       
1421  4D20 C002 H101    MOV     R2,R0                   remaining sectors
1422  4D22 0204         LI      R4,>00FF                        
1422  4D24 00FF  
1423  4D26 0A04         SLA     R4,0                    coin mask
1424  4D28 0429 H102    BLWP    @>005A(R9)              set VDP to read
1424  4D2A 005A  
1425  4D2C 0022         DATA    >0022                   address in R1
1426  4D2E D02F         MOVB    @-1026(R15),R0          get bitmap byte
1426  4D30 FBFE  
1427  4D32 4004         SZC     R4,R0                   mark sectors as free
1428  4D34 0429         BLWP    @>005A(R9)              set VDP to write
1428  4D36 005A  
1429  4D38 0023         DATA    >0023                   address in R1
1430  4D3A DBC0         MOVB    R0,@-2(R15)             write it back
1430  4D3C FFFE  
1431  4D3E 10A5         JMP     H094                    done: flag drive # and return
1432            *
1433            *===================================
1434            * DSR entry points
1435            *===================================                                    
1436            *
1437  4D40 C1CB EDSR01  MOV     R11,R7                  DSK
1438  4D42 06A0         BL      @PRPFDO                 --- prepare file operations
1438  4D44 4418  
1439  4D46 06A0         BL      @CALSUB                 call subroutine
1439  4D48 4344  
1440  4D4A 487E         DATA    FDSKDR                  find disk in drive (name ptr in R3)
1441  4D4C 100B         JMP     H104                    
1442            *                                       
1443  4D4E 0206 EDSR02  LI      R6,>0100                DSK1
1443  4D50 0100  
1444  4D52 1005         JMP     H103                    ----
1445            *                                       
1446  4D54 0206 EDSR03  LI      R6,>0200                DSK2
1446  4D56 0200  
1447  4D58 1002         JMP     H103                    ----
1448            *                                       
1449  4D5A 0206 EDSR04  LI      R6,>0300                DSK3
1449  4D5C 0300  
1450            *                                       
1451  4D5E C1CB H103    MOV     R11,R7                  save return address
1452  4D60 06A0         BL      @PRPFDO                 prepare file operations
1452  4D62 4418  
1453  4D64 C029 H104    MOV     @>0054(R9),R0           PAB ptr
1453  4D66 0054  
1454  4D68 0429         BLWP    @>005A(R9)              set VDP to read
1454  4D6A 005A  
1455  4D6C 0002         DATA    >0002                   address in R0
1456  4D6E D06F         MOVB    @-1026(R15),R1          get opcode
1456  4D70 FBFE  
1457  4D72 0981         SRL     R1,8                    
1458  4D74 0281         CI      R1,>0009                check range
1458  4D76 0009  
1459  4D78 1B19         JH      ERROR8                  illegal opcode
1460  4D7A 0282         CI      R2,>0001                filename lenght (including . )
1460  4D7C 0001  
1461  4D7E 1605         JNE     H105                    no filename: dir
1462  4D80 0221         AI      R1,10                   only allow open, close and read
1462  4D82 000A  
1463  4D84 0281         CI      R1,>000C                        
1463  4D86 000C  
1464  4D88 1B11         JH      ERROR8                  others are illegal
1465  4D8A A041 H105    A       R1,R1                   make it a word ptr
1466  4D8C C061         MOV     @OPCVEC(R1),R1          get vector
1466  4D8E 4D92  
1467  4D90 0451         B       *R1                     branch to it
1468            *                                       
1469  4D92 4DB2 OPCVEC  DATA    OPEN                    open
1470  4D94 4FC4         DATA    CLOSE                   close
1471  4D96 4FCE         DATA    READ                    read
1472  4D98 50B8         DATA    WRITE                   write
1473  4D9A 536C         DATA    RWIND1                  rewind
1474  4D9C 53C0         DATA    LOAD                    load
1475  4D9E 5462         DATA    SAVE                    save
1476  4DA0 4762         DATA    DELETE                  delete
1477  4DA2 4992         DATA    RETERR                  scratch record: return with bad attribute error
1478  4DA4 54E6         DATA    STATUS                  status
1479            *                                       
1480  4DA6 55A6         DATA    OPNDIR                  open directory
1481  4DA8 5604         DATA    CLSDIR                  close directory
1482  4DAA 561A         DATA    RDDIR                   read directory
1483            *                                       
1484  4DAC 06A0 ERROR8  BL      @ERROR5                 return with error
1484  4DAE 4966  
1485  4DB0 6000         DATA    >6000                   illegal opcode
1486            *
1487            *---------------------------------
1488            * Opcode 0: Open
1489            * --------------
1490            * PAB 0: >00
1491            *     1: file type  <--- error code
1492            *   2-3:
1493            *     4: record length
1494            *     5:
1495            *   6-7: # of records (if output)
1496            *     8:
1497            *---------------------------------                                      
1498            *
1499  4DB2 04C0 OPEN    CLR     R0                      
1500  4DB4 D02F         MOVB    @-1026(R15),R0          get file attributes
1500  4DB6 FBFE  
1501  4DB8 0429         BLWP    @>005A(R9)                      
1501  4DBA 005A  
1502  4DBC 8000         DATA    >8000                   save R0
1503  4DBE 0240         ANDI    R0,>1600                keep fix/var and access mode
1503  4DC0 1600  
1504  4DC2 0280         CI      R0,>0600                        
1504  4DC4 0600  
1505  4DC6 1603         JNE     H106                    
1506  4DC8 06A0 ERROR9  BL      @ERROR5                 dis/fix, open as append: return with error
1506  4DCA 4966  
1507  4DCC 4000         DATA    >4000                   bad attribute
1508            *                                       
1509  4DCE 120A H106    JLE     H107                    
1510  4DD0 C040         MOV     R0,R1                   var
1511  4DD2 06A0         BL      @PABR2B                 get 2 bytes from PAB into R0
1511  4DD4 485E  
1512  4DD6 0004         DATA    4                       rec len and char count
1513  4DD8 0280         CI      R0,>FF00                is rec len 255?
1513  4DDA FF00  
1514  4DDC 14F5         JHE     ERROR9                  yes: bad attribute
1515  4DDE C001         MOV     R1,R0                   retrieve attributes
1516  4DE0 0240         ANDI    R0,>0600                keep only access mode
1516  4DE2 0600  
1517            *                                       
1518  4DE4 0280 H107    CI      R0,>0200                is it output?
1518  4DE6 0200  
1519  4DE8 1657         JNE     H113                    no
1520  4DEA 06A0         BL      @CALSUB                 call subroutine
1520  4DEC 4344  
1521  4DEE 4484         DATA    CRFIL1                  create file
1522  4DF0 06A0 H108    BL      @PRFDRS                 coin status byte in FDR style
1522  4DF2 4F72  
1523  4DF4 0429         BLWP    @>005A(R9)              set VDP to write
1523  4DF6 005A  
1524  4DF8 0083         DATA    >0083                   address in R4: status byte in FDR buffer
1525  4DFA DBC2         MOVB    R2,@-2(R15)             write file status in FDR
1525  4DFC FFFE  
1526  4DFE C0E9         MOV     @>0054(R9),R3           PAB ptr
1526  4E00 0054  
1527  4E02 0223         AI      R3,4                    ptr to rec len
1527  4E04 0004  
1528  4E06 04C5         CLR     R5                      
1529  4E08 0429         BLWP    @>005A(R9)              set VDP to read
1529  4E0A 005A  
1530  4E0C 0062         DATA    >0062                   address in R3
1531  4E0E D16F         MOVB    @-1026(R15),R5          get record length
1531  4E10 FBFE  
1532  4E12 1607         JNE     H109                    
1533  4E14 0205         LI      R5,>5000                >00: default it 80
1533  4E16 5000  
1534  4E18 0429         BLWP    @>005A(R9)              set VDP to write
1534  4E1A 005A  
1535  4E1C 0063         DATA    >0063                   address in R3
1536  4E1E DBC5         MOVB    R5,@-2(R15)             write default rec len
1536  4E20 FFFE  
1537  4E22 0224 H109    AI      R4,5                    point to rec len byte in FDR
1537  4E24 0005  
1538  4E26 0429         BLWP    @>005A(R9)              set VDP to write
1538  4E28 005A  
1539  4E2A 0083         DATA    >0083                   address in R4
1540  4E2C DBC5         MOVB    R5,@-2(R15)             write rec len in FDR buffer
1540  4E2E FFFE  
1541  4E30 0201         LI      R1,256                  256 bytes/sector
1541  4E32 0100  
1542  4E34 C082         MOV     R2,R2                   var or dis?
1543  4E36 1101         JLT     H110                    var
1544  4E38 1002         JMP     H111                    dis
1545  4E3A A141 H110    A       R1,R5                   var: rec len +1
1546  4E3C 0601         DEC     R1                      254 bytes only (needs size byte)
1547  4E3E 06C5 H111    SWPB    R5                      make it a word
1548  4E40 04C0         CLR     R0                      
1549  4E42 3C05         DIV     R5,R0                   how many times in 254/255 bytes?
1550  4E44 0224         AI      R4,-4                   point to # of rec/sect in FDR
1550  4E46 FFFC  
1551  4E48 C040         MOV     R0,R1                   save result for later
1552  4E4A 06C0         SWPB    R0                      
1553  4E4C 0429         BLWP    @>005A(R9)              set VDP to write
1553  4E4E 005A  
1554  4E50 0083         DATA    >0083                   address in R4
1555  4E52 DBC0         MOVB    R0,@-2(R15)             write # of rec/sect in FDR
1555  4E54 FFFE  
1556  4E56 C229         MOV     @>0056(R9),R8           point to filename in FDR
1556  4E58 0056  
1557  4E5A 0429         BLWP    @>005A(R9)              set VDP to read
1557  4E5C 005A  
1558  4E5E 0102         DATA    >0102                   address in R8
1559  4E60 D02F         MOVB    @-1026(R15),R0          get first char
1559  4E62 FBFE  
1560  4E64 0260         ORI     R0,>8000                flag it: update FDR before leaving
1560  4E66 8000  
1561  4E68 0429         BLWP    @>005A(R9)              set VDP to write
1561  4E6A 005A  
1562  4E6C 0103         DATA    >0103                   address in R8
1563  4E6E DBC0         MOVB    R0,@-2(R15)             write it back
1563  4E70 FFFE  
1564  4E72 0429         BLWP    @>005A(R9)                      
1564  4E74 005A  
1565  4E76 8001         DATA    >8001                   retrieve R0 (access mode)
1566  4E78 06A0         BL      @PABR2B                 get 2 bytes from PAB into R0
1566  4E7A 485E  
1567  4E7C 0006         DATA    6                       required size in records
1568  4E7E C100         MOV     R0,R4                   
1569  4E80 1309         JEQ     H112                    no size specified
1570  4E82 11A2         JLT     ERROR9                  return with bad attribute error
1571  4E84 A101         A       R1,R4                   round up to record size
1572  4E86 0604         DEC     R4                      
1573  4E88 04C3         CLR     R3                      
1574  4E8A 3CC1         DIV     R1,R3                   how many sectors will this be?
1575  4E8C 0603         DEC     R3                      offset start from 0
1576  4E8E 06A0         BL      @CALSUB                 call subroutine
1576  4E90 4344  
1577  4E92 4654         DATA    APSCTS                  add sectors to FDR to match offset in R3
1578  4E94 0460 H112    B       @RWIND2                 initialise file control block and return to caller
1578  4E96 539A  
1579            *                                       
1580  4E98 0429 H113    BLWP    @>005A(R9)              not output
1580  4E9A 005A  
1581  4E9C 8000         DATA    >8000                   save R0
1582  4E9E 06A0         BL      @CALSUB                 call subroutine
1582  4EA0 4344  
1583  4EA2 4AF6         DATA    FNDFDR                  find FDR on disk
1584  4EA4 0429         BLWP    @>005A(R9)                      
1584  4EA6 005A  
1585  4EA8 8001         DATA    >8001                   retrieve R0 (access mode)
1586  4EAA C104         MOV     R4,R4                   found FDR?
1587  4EAC 1309         JEQ     H115                    yes
1588  4EAE 0280         CI      R0,>0400                no: is file open as input?
1588  4EB0 0400  
1589  4EB2 1304         JEQ     H114                    yes: must exist
1590  4EB4 06A0         BL      @CALSUB                 no: call subroutine
1590  4EB6 4344  
1591  4EB8 4496         DATA    CRFIL3                  create file
1592  4EBA 109A         JMP     H108                    
1593            *                                       
1594  4EBC 0460 H114    B       @ERROR9                 return with bad attribute error
1594  4EBE 4DC8  
1595            *                                       
1596  4EC0 C1C0 H115    MOV     R0,R7                   save access mode
1597  4EC2 06A0         BL      @PRFDRS                 prepare status byte for FDR
1597  4EC4 4F72  
1598  4EC6 0429         BLWP    @>005A(R9)              set VDP to read
1598  4EC8 005A  
1599  4ECA 0082         DATA    >0082                   address in R4 (status byte in FDR)
1600  4ECC D02F         MOVB    @-1026(R15),R0          get current file status
1600  4ECE FBFE  
1601  4ED0 C0C0         MOV     R0,R3                   save it
1602  4ED2 0243         ANDI    R3,>0800                is file write protected?
1602  4ED4 0800  
1603  4ED6 1306         JEQ     H116                    no
1604  4ED8 0287         CI      R7,>0400                yes: is it open as input?
1604  4EDA 0400  
1605  4EDC 1303         JEQ     H116                    no
1606  4EDE 06A0         BL      @ERROR5                 yes: return with error
1606  4EE0 4966  
1607  4EE2 2000         DATA    >2000                   write protected
1608            *                                       
1609  4EE4 0240 H116    ANDI    R0,>8300                keep only file type bits (V/F, D/I, Prg/Data)
1609  4EE6 8300  
1610  4EE8 2802         XOR     R2,R0                   compare with new (coined by PRFDRS)
1611  4EEA 16E8         JNE     H114                    different: bad attribute
1612  4EEC C0E9         MOV     @>0054(R9),R3           PAB ptr
1612  4EEE 0054  
1613  4EF0 0223         AI      R3,4                    ptr to rec len in PAB
1613  4EF2 0004  
1614  4EF4 0224         AI      R4,5                    ptr to rec len in FDR
1614  4EF6 0005  
1615  4EF8 0429         BLWP    @>005A(R9)              set VDP to read
1615  4EFA 005A  
1616  4EFC 0082         DATA    >0082                   address in R4
1617  4EFE D02F         MOVB    @-1026(R15),R0          get rec len from FDR
1617  4F00 FBFE  
1618  4F02 0429         BLWP    @>005A(R9)              set VDP to read
1618  4F04 005A  
1619  4F06 0062         DATA    >0062                   address in R3
1620  4F08 D0AF         MOVB    @-1026(R15),R2          get rec len from PAB
1620  4F0A FBFE  
1621  4F0C 1302         JEQ     H117                    0 = keep current one
1622  4F0E 9080         CB      R0,R2                   are they identical?
1623  4F10 16D5         JNE     H114                    no: bad attribute
1624  4F12 0429 H117    BLWP    @>005A(R9)              set VDP to write
1624  4F14 005A  
1625  4F16 0063         DATA    >0063                   address in R3
1626  4F18 DBC0         MOVB    R0,@-2(R15)             update rec len in PAB (in case it was 0)
1626  4F1A FFFE  
1627  4F1C 0429         BLWP    @>005A(R9)              retrieve R0 (open mode)
1627  4F1E 005A  
1628  4F20 8001         DATA    >8001                   
1629  4F22 0240         ANDI    R0,>0600                keep only access mode
1629  4F24 0600  
1630  4F26 04C2         CLR     R2                      
1631  4F28 0703         SETO    R3                      
1632  4F2A 0280         CI      R0,>0600                is it append
1632  4F2C 0600  
1633  4F2E 161D         JNE     H118                    no
1634  4F30 C129         MOV     @>0056(R9),R4           yes: get FDR ptr
1634  4F32 0056  
1635  4F34 C1C4         MOV     R4,R7                   save it
1636  4F36 0224         AI      R4,14                   ptr to # of sectors
1636  4F38 000E  
1637  4F3A 0429         BLWP    @>005A(R9)              set VDP to read
1637  4F3C 005A  
1638  4F3E 0082         DATA    >0082                   address in R4
1639  4F40 D0EF         MOVB    @-1026(R15),R3          get # of sectors in file
1639  4F42 FBFE  
1640  4F44 06C3         SWPB    R3                      
1641  4F46 D0EF         MOVB    @-1026(R15),R3                  
1641  4F48 FBFE  
1642  4F4A 06C3         SWPB    R3                      
1643  4F4C D0AF         MOVB    @-1026(R15),R2          get eof offset
1643  4F4E FBFE  
1644  4F50 0603         DEC     R3                      offset starts from 0
1645  4F52 110B         JLT     H118                    file is empty (0 sectors)
1646  4F54 0429         BLWP    @>005A(R9)                      
1646  4F56 005A  
1647  4F58 3000         DATA    >3000                   save R2 + R3
1648  4F5A 0227         AI      R7,256                  ptr to data buffer area for this file
1648  4F5C 0100  
1649  4F5E 06A0         BL      @CALSUB                 call subroutine
1649  4F60 4344  
1650  4F62 461E         DATA    RDOFSC                  read a sector, from offset in R3
1651  4F64 0429         BLWP    @>005A(R9)                      
1651  4F66 005A  
1652  4F68 3001         DATA    >3001                   retrieve R2 + R3
1653  4F6A 06A0 H118    BL      @UPDFCB                 update current record offset in file ctrl block
1653  4F6C 4F9C  
1654  4F6E 0460         B       @RTURN1                 return to caller
1654  4F70 4362  
1655            *                                       
1656  4F72 0429 PRFDRS  BLWP    @>005A(R9)              prepare file status byte for FDR
1656  4F74 005A  
1657  4F76 8001         DATA    >8001                   access mode in R0
1658  4F78 0429         BLWP    @>005A(R9)                      
1658  4F7A 005A  
1659  4F7C 8000         DATA    >8000                   save it back
1660  4F7E 0202         LI      R2,2                    int in FDR status byte
1660  4F80 0002  
1661  4F82 C129         MOV     @>0056(R9),R4           FDR pointer
1661  4F84 0056  
1662  4F86 0A40         SLA     R0,4                    fix or var?
1663  4F88 1703         JNC     H119                    fix
1664  4F8A 0202         LI      R2,>0082                int var in FDR
1664  4F8C 0082  
1665  4F8E C000         MOV     R0,R0                   dis or int?
1666  4F90 1101 H119    JLT     H120                    int
1667  4F92 0642         DECT    R2                      dis: remove the int from FDR status
1668  4F94 0224 H120    AI      R4,12                   point at file status byte in FDR
1668  4F96 000C  
1669  4F98 06C2         SWPB    R2                      
1670  4F9A 045B         B       *R11                    
1671            *                                       
1672  4F9C C129 UPDFCB  MOV     @>0056(R9),R4           update sect + rec offsets in file control block
1672  4F9E 0056  
1673  4FA0 0224         AI      R4,-6                   
1673  4FA2 FFFA  
1674  4FA4 0429         BLWP    @>005A(R9)              set VDP to write
1674  4FA6 005A  
1675  4FA8 0083         DATA    >0083                   address in R4
1676  4FAA DBC3         MOVB    R3,@-2(R15)             write current sect offset
1676  4FAC FFFE  
1677  4FAE 06C3         SWPB    R3                      
1678  4FB0 DBC3         MOVB    R3,@-2(R15)                     
1678  4FB2 FFFE  
1679  4FB4 0224         AI      R4,4                    point to logical rec offset (for var files)
1679  4FB6 0004  
1680  4FB8 0429         BLWP    @>005A(R9)              set VDP to write
1680  4FBA 005A  
1681  4FBC 0083         DATA    >0083                   address in R4
1682  4FBE DBC2         MOVB    R2,@-2(R15)             write record offset
1682  4FC0 FFFE  
1683  4FC2 045B         B       *R11                    
1684            *
1685            *----------------------------------
1686            * Opcode 1: Close
1687            * --------------
1688            * PAB 0: >01
1689            *     1:           <--- error code
1690            *   2-3:
1691            *     4:
1692            *     5:
1693            *   6-7:
1694            *     8:
1695            *----------------------------------                                     
1696            *
1697  4FC4 06A0 CLOSE   BL      @CALSUB                 call subroutine
1697  4FC6 4344  
1698  4FC8 51C2         DATA    FFDRVP                  find file FDR
1699  4FCA 0460         B       @UPDFDR                 update FDR + data area, get VIB, return to caller
1699  4FCC 456A  
1700            *
1701            *----------------------------------
1702            * Opcode 2: Read
1703            * --------------
1704            * PAB 0: >02
1705            *     1: file type <--- error code
1706            *   2-3: data buffer address in VDP mem
1707            *     4:
1708            *     5: bytes read
1709            *   6-7: record #
1710            *     8:
1711            *
1712            * Logical records organisation whithin sectors
1713            *
1714            * Fixed records (e.g. rec length = 6)
1715            * 11 11 11 11 11 11 22 22 22 22 22 22 33 33 33 33 33 33 xx xx xx
1716            * Where 11=data for record 1, 22=record 2, 33=record 3, xx=junk bytes
1717            *
1718            * Variable records:
1719            * sz 11 11 11 11 11 11 11 sz 22 22 22 22 22 sz 33 33 FF xx xx xx
1720            * Where sz=record size, 11,22,33=record data, FF=end-of-sector mark, xx=junk
1721            *----------------------------------                                     
1722            *
1723  4FCE 06A0 READ    BL      @CALSUB                 call subroutine
1723  4FD0 4344  
1724  4FD2 51C2         DATA    FFDRVP                  find FDR in VDP buffers, get status from PAB
1725  4FD4 0240         ANDI    R0,>0200                what type of access?
1725  4FD6 0200  
1726  4FD8 1302         JEQ     H122                    update or input: ok
1727  4FDA 0460 H121    B       @ERROR8                 append or output: error illegal opcode
1727  4FDC 4DAC  
1728  4FDE 06A0 H122    BL      @RFDRST                 get status byte in R0, from FDR
1728  4FE0 51EE  
1729  4FE2 110A         JLT     H125                    var
1730  4FE4 06A0         BL      @RRNPAB                 fix: get rec # compare to # of recs/file
1730  4FE6 5202  
1731  4FE8 1A03         JL      H124                    ok: in file
1732  4FEA 06A0 H123    BL      @ERROR5                 update data and return with error
1732  4FEC 4966  
1733  4FEE A000         DATA    >A000                   eof reached
1734  4FF0 06A0 H124    BL      @CALSUB                 call subroutine
1734  4FF2 4344  
1735  4FF4 5268         DATA    RRFDR                   load record from disk into FDR data buffer area
1736  4FF6 1011         JMP     H126                    
1737            *                                       
1738  4FF8 06A0 H125    BL      @CALSUB                 var: call subroutine
1738  4FFA 4344  
1739  4FFC 5054         DATA    RRSEC                   load proper sector, point to rec in it
1740  4FFE 10F5         JMP     H123                    skipped if ok: return with eof reached
1741            *                                       
1742  5000 0582         INC     R2                      next byte in data buffer
1743  5002 A004         A       R4,R0                   add rec size to offset
1744  5004 0580         INC     R0                      room for end-of-sector mark
1745  5006 C169         MOV     @>0056(R9),R5           FDR ptr
1745  5008 0056  
1746  500A 0645         DECT    R5                      point to var record offset in sector
1747  500C 06C0         SWPB    R0                      
1748  500E 0429         BLWP    @>005A(R9)              set VDP to write
1748  5010 005A  
1749  5012 00A3         DATA    >00A3                   address in R5
1750  5014 DBC0         MOVB    R0,@-2(R15)             update var record offset in sector
1750  5016 FFFE  
1751  5018 C004         MOV     R4,R0                   save # of bytes to be read
1752  501A C129 H126    MOV     @>0054(R9),R4           PAB ptr
1752  501C 0054  
1753  501E 0224         AI      R4,5                    point to char count
1753  5020 0005  
1754  5022 06C0         SWPB    R0                      
1755  5024 0429         BLWP    @>005A(R9)              set VDP to write
1755  5026 005A  
1756  5028 0083         DATA    >0083                   address in R4
1757  502A DBC0         MOVB    R0,@-2(R15)             write # of char to be read
1757  502C FFFE  
1758  502E 06C0         SWPB    R0                      make it a word
1759            *                                       
1760  5030 C000 WFDRPB  MOV     R0,R0                   check it
1761  5032 130E         JEQ     H128                    none: return
1762  5034 0429 H127    BLWP    @>005A(R9)              set VDP to read
1762  5036 005A  
1763  5038 0042         DATA    >0042                   address in R2
1764  503A D0EF         MOVB    @-1026(R15),R3          read 1 byte from FDR data buffer area
1764  503C FBFE  
1765  503E 0582         INC     R2                      increment source ptr
1766  5040 0429         BLWP    @>005A(R9)              set VDP to write
1766  5042 005A  
1767  5044 0023         DATA    >0023                   address in R1
1768  5046 DBC3         MOVB    R3,@-2(R15)             write the byte in PAB data buffer
1768  5048 FFFE  
1769  504A 0581         INC     R1                      increment destination ptr
1770  504C 0600         DEC     R0                      more to read?
1771  504E 16F2         JNE     H127                    yes
1772  5050 0460 H128    B       @RTURN1                 return to caller
1772  5052 4362  
1773            *                                       
1774  5054 06A0 RRSEC   BL      @RCOFCB                 load sector, point to record in it
1774  5056 5342  
1775  5058 C0C3         MOV     R3,R3                   sector offset
1776  505A 1101         JLT     H129                    -1: top of file
1777  505C 1012         JMP     H130                    in file
1778  505E C003 H129    MOV     R3,R0                   
1779  5060 0580         INC     R0                      next sector
1780  5062 8080         C       R0,R2                   compare to # of sect/file
1781  5064 13F5         JEQ     H128                    end-of-file reached: return to caller (JMP to err)
1782  5066 06A0         BL      @CALSUB                 call subroutine
1782  5068 4344  
1783  506A 458A         DATA    UPDBF                   update data buffer, if needed
1784  506C C0C0         MOV     R0,R3                   desired offset
1785  506E 04C5         CLR     R5                      
1786  5070 06A0         BL      @UCOFCB                 update sect + rec offsets in control block
1786  5072 52E0  
1787  5074 0227         AI      R7,256                  point to data buffer area (R7 set by UCOFCB)
1787  5076 0100  
1788  5078 06A0         BL      @CALSUB                 call subroutine
1788  507A 4344  
1789  507C 461E         DATA    RDOFSC                  read a sector, from offset in file (in R3)
1790  507E 04C0         CLR     R0                      
1791  5080 1004         JMP     H131                    
1792            *                                       
1793  5082 C000 H130    MOV     R0,R0                   in file: test var rec offset (from RCOFCB)
1794  5084 1602         JNE     H131                    inside sector
1795  5086 8080         C       R0,R2                   at beg of sector
1796  5088 13E3         JEQ     H128                    file is empty: return
1797  508A C080 H131    MOV     R0,R2                   FDR data buffer will be added to R2 by AFDRPT
1798  508C 06A0         BL      @CALSUB                 call subroutine
1798  508E 4344  
1799  5090 52BC         DATA    AFDRPT                  R2=byte in FDR data buf, R1=top of PAB data buf
1800  5092 0429         BLWP    @>005A(R9)              set VDP to read
1800  5094 005A  
1801  5096 0042         DATA    >0042                   address in R2
1802  5098 D12F         MOVB    @-1026(R15),R4          get first byte (rec length)
1802  509A FBFE  
1803  509C 0984         SRL     R4,8                    make it a word
1804  509E C000         MOV     R0,R0                   var rec offset
1805  50A0 1306         JEQ     H132                    
1806  50A2 0284         CI      R4,>00FF                is it >FF (end of sector mark) ?
1806  50A4 00FF  
1807  50A6 1603         JNE     H132                    no
1808  50A8 06A0         BL      @RCOFCB                 yes: get sect + rec offsets from control block
1808  50AA 5342  
1809  50AC 10D8         JMP     H129                    try again with next sector
1810            *                                       
1811  50AE 0429 H132    BLWP    @>005A(R9)                      
1811  50B0 005A  
1812  50B2 0011         DATA    >0011                   retrieve return address from stack in R11
1813  50B4 05CB         INCT    R11                     skip the JMP to eof reached error
1814  50B6 045B         B       *R11                    
1815            *
1816            *------------------------------------
1817            * Opcode 3: Write
1818            * --------------
1819            * PAB 0: >03
1820            *     1: file type <--- error code
1821            *   2-3: data buffer address in VDP mem
1822            *     4:
1823            *     5: bytes to write
1824            *   6-7: record #
1825            *     8:
1826            *------------------------------------                                   
1827            *
1828  50B8 06A0 WRITE   BL      @CALSUB                 call subroutine
1828  50BA 4344  
1829  50BC 51C2         DATA    FFDRVP                  find FDR in VDP buffers
1830  50BE 0240         ANDI    R0,>0600                keep only access mode
1830  50C0 0600  
1831  50C2 0280         CI      R0,>0400                is it input
1831  50C4 0400  
1832  50C6 1389         JEQ     H121                    yes: return with error illegal opcode
1833  50C8 06A0         BL      @RFDRST                 get file status byte from FDR
1833  50CA 51EE  
1834  50CC 1113         JLT     H134                    var                     
1835  50CE 06A0         BL      @RRNPAB                 fix: get rec # from PAB, sect # in R0
1835  50D0 5202  
1836  50D2 1A0C         JL      H133                    less that total rec/file
1837  50D4 0429         BLWP    @>005A(R9)              past eof: expand file
1837  50D6 005A  
1838  50D8 D800         DATA    >D800                   save R0, R1, R3, R4
1839  50DA C0C0         MOV     R0,R3                   desired sector offset
1840  50DC 06A0         BL      @CALSUB                 call subroutine
1840  50DE 4344  
1841  50E0 4654         DATA    APSCTS                  append enough sectors to reach offset in R3
1842  50E2 0429         BLWP    @>005A(R9)                      
1842  50E4 005A  
1843  50E6 D801         DATA    >D801                   restore R0, R1, R3, R4
1844  50E8 06A0         BL      @URFFDR                 update # of rec/file in FDR
1844  50EA 530C  
1845            *                                       
1846  50EC 06A0 H133    BL      @CALSUB                 in file: call subroutine
1846  50EE 4344  
1847  50F0 5268         DATA    RRFDR                   fetch rec from disk into FDR data buffer area
1848  50F2 1053         JMP     H138                    set update data flag, write data, return
1849            *                                       
1850  50F4 06A0 H134    BL      @RCOFCB                 var: R2=sect/file R3=sect offset R0=rec offset
1850  50F6 5342  
1851  50F8 C0C3         MOV     R3,R3                   sector offset in file
1852  50FA 1101         JLT     H135                    -1: top of file
1853  50FC 100B         JMP     H136                    in file
1854  50FE 0429 H135    BLWP    @>005A(R9)              next sector loop
1854  5100 005A  
1855  5102 3000         DATA    >3000                   save R2 + R3
1856  5104 06A0         BL      @CALSUB                 call subroutine
1856  5106 4344  
1857  5108 458A         DATA    UPDBF                   update data buffer if needed
1858  510A 0429         BLWP    @>005A(R9)                      
1858  510C 005A  
1859  510E 3001         DATA    >3001                   retrieve R2 + R3
1860  5110 0583         INC     R3                      next sector
1861  5112 04C0         CLR     R0                      init char offset in sector
1862            *                                       
1863  5114 8083 H136    C       R3,R2                   did we reach last sector?
1864  5116 1609         JNE     H137                    no
1865  5118 0429         BLWP    @>005A(R9)              yes: expand file
1865  511A 005A  
1866  511C 9000         DATA    >9000                   save R0 + R4
1867  511E 06A0         BL      @CALSUB                 call subroutine
1867  5120 4344  
1868  5122 4654         DATA    APSCTS                  get last sector then append sectors to reach R3
1869  5124 0429         BLWP    @>005A(R9)                      
1869  5126 005A  
1870  5128 9001         DATA    >9001                   retrieve R0 + R4
1871            *                                       
1872  512A C169 H137    MOV     @>0054(R9),R5           PAB ptr
1872  512C 0054  
1873  512E 0225         AI      R5,5                    point to char count
1873  5130 0005  
1874  5132 0429         BLWP    @>005A(R9)              set VDP to read
1874  5134 005A  
1875  5136 00A2         DATA    >00A2                   address in R5
1876  5138 D12F         MOVB    @-1026(R15),R4          get # of chars to write
1876  513A FBFE  
1877  513C 0984         SRL     R4,8                    make it a word
1878  513E C144         MOV     R4,R5                   
1879  5140 A140         A       R0,R5                   add current char offset in sector
1880  5142 0585         INC     R5                      make room for size byte
1881  5144 0285         CI      R5,>00FF                past end of sector?
1881  5146 00FF  
1882  5148 1BDA         JH      H135                    yes: not enough room, try next sector
1883  514A 0702         SETO    R2                      ok: rec will fit in sector
1884  514C C069         MOV     @>0056(R9),R1           FDR ptr
1884  514E 0056  
1885  5150 A045         A       R5,R1                   past-last-byte offset
1886  5152 0221         AI      R1,256                  ptr to data buffer area
1886  5154 0100  
1887  5156 0429         BLWP    @>005A(R9)              set VDP to write
1887  5158 005A  
1888  515A 0023         DATA    >0023                   address in R1
1889  515C DBC2         MOVB    R2,@-2(R15)             write end-of-sect mark to FDR data buffer area
1889  515E FFFE  
1890  5160 0429         BLWP    @>005A(R9)                      
1890  5162 005A  
1891  5164 8000         DATA    >8000                   save R0 (current byte offset in sector)
1892  5166 C003         MOV     R3,R0                   
1893  5168 06A0         BL      @UCOFCB                 update sect + rec offsets in control block
1893  516A 52E0  
1894  516C 0221         AI      R1,18                   point to eof offset in FDR (R1 modified by UCOFCB)
1894  516E 0012  
1895  5170 0429         BLWP    @>005A(R9)              set VDP to write
1895  5172 005A  
1896  5174 0023         DATA    >0023                   address in R1
1897  5176 DBC5         MOVB    R5,@-2(R15)             update eof offset in last sector, in FDR
1897  5178 FFFE  
1898  517A 06A0         BL      @URFFDR                 update # of rec/file in FDR
1898  517C 530C  
1899  517E 0429         BLWP    @>005A(R9)                      
1899  5180 005A  
1900  5182 2001         DATA    >2001                   retrieve old R0 in R2 (current byte offset)
1901  5184 C004         MOV     R4,R0                   record size
1902  5186 06A0         BL      @CALSUB                 call subroutine
1902  5188 4344  
1903  518A 52BC         DATA    AFDRPT                  get FDR data buffer in R2, PAB data buffer in R1
1904  518C 06C4         SWPB    R4                      
1905  518E 0429         BLWP    @>005A(R9)              set VDP to write
1905  5190 005A  
1906  5192 0043         DATA    >0043                   address in R2
1907  5194 DBC4         MOVB    R4,@-2(R15)             write size byte to FDR data buffer
1907  5196 FFFE  
1908  5198 0582         INC     R2                      increment dest pointer
1909            *                                       
1910  519A C0C2 H138    MOV     R2,R3                   invert source and dest
1911  519C C081         MOV     R1,R2                   so we can use the same read-write loop
1912  519E C043         MOV     R3,R1                   than the read opcode
1913  51A0 C129         MOV     @>0056(R9),R4           FDR ptr
1913  51A2 0056  
1914  51A4 0604         DEC     R4                      pointer to drive # for that file
1915  51A6 0429         BLWP    @>005A(R9)              set VDP to read
1915  51A8 005A  
1916  51AA 0082         DATA    >0082                   address in R4
1917  51AC D16F         MOVB    @-1026(R15),R5          get drive #
1917  51AE FBFE  
1918  51B0 0265         ORI     R5,>8000                add update data area flag
1918  51B2 8000  
1919  51B4 0429         BLWP    @>005A(R9)              set VDP to write
1919  51B6 005A  
1920  51B8 0083         DATA    >0083                   address in R4
1921  51BA DBC5         MOVB    R5,@-2(R15)             write back flagged byte
1921  51BC FFFE  
1922  51BE 0460         B       @WFDRPB                 to read-write loop
1922  51C0 5030  
1923            *                                       
1924  51C2 06A0 FFDRVP  BL      @CALSUB                 find FDR in VDP buffer
1924  51C4 4344  
1925  51C6 4A98         DATA    FFFDRV                  find file FDR
1926  51C8 C104         MOV     R4,R4                   found?
1927  51CA 1303         JEQ     AFPGPF                  yes
1928  51CC 06A0         BL      @ERROR5                 no: return with error
1928  51CE 4966  
1929  51D0 E000         DATA    >E000                   file error
1930  51D2 0581 AFPGPF  INC     R1                      point to filename in FDR
1931  51D4 CA41         MOV     R1,@>0056(R9)           new FDR ptr
1931  51D6 0056  
1932  51D8 C129         MOV     @>0054(R9),R4           get PAB ptr
1932  51DA 0054  
1933  51DC 0584         INC     R4                      point to status byte
1934  51DE 04C0         CLR     R0                      
1935  51E0 0429         BLWP    @>005A(R9)              set VDP to read
1935  51E2 005A  
1936  51E4 0082         DATA    >0082                   address in R4
1937  51E6 D02F         MOVB    @-1026(R15),R0          get file status
1937  51E8 FBFE  
1938  51EA 0460         B       @RTURN1                 return to caller
1938  51EC 4362  
1939            *                                       
1940  51EE C129 RFDRST  MOV     @>0056(R9),R4           get status byte from FDR
1940  51F0 0056  
1941  51F2 0224         AI      R4,12                   point to status byte
1941  51F4 000C  
1942  51F6 0429         BLWP    @>005A(R9)              set VDP to read
1942  51F8 005A  
1943  51FA 0082         DATA    >0082                   address in R4
1944  51FC D02F         MOVB    @-1026(R15),R0          read status byte
1944  51FE FBFE  
1945  5200 045B         B       *R11                    
1946            *                                       
1947  5202 D16F RRNPAB  MOVB    @-1026(R15),R5          get record # from PAB, check if valid
1947  5204 FBFE  
1948  5206 0985         SRL     R5,8                    
1949  5208 1602         JNE     H139                    get # of rec/sector from FDR
1950  520A 0205         LI      R5,256                  0: default to 256
1950  520C 0100  
1951  520E C0E9 H139    MOV     @>0054(R9),R3           PAB ptr
1951  5210 0054  
1952  5212 0223         AI      R3,6                    point to rec #
1952  5214 0006  
1953  5216 0429         BLWP    @>005A(R9)              set VDP to read
1953  5218 005A  
1954  521A 0062         DATA    >0062                   address in R3
1955  521C D06F         MOVB    @-1026(R15),R1          get record # from PAB
1955  521E FBFE  
1956  5220 06C1         SWPB    R1                      
1957  5222 D06F         MOVB    @-1026(R15),R1                  
1957  5224 FBFE  
1958  5226 06C1         SWPB    R1                      
1959  5228 C001         MOV     R1,R0                   save it
1960  522A 1101         JLT     H140                    too big
1961  522C 1003         JMP     H141                    ok
1962  522E 06A0 H140    BL      @ERROR5                 update data then return with error
1962  5230 4966  
1963  5232 8000         DATA    >8000                   memory full
1964  5234 0580 H141    INC     R0                      next record
1965  5236 0429         BLWP    @>005A(R9)              set VDP to write
1965  5238 005A  
1966  523A 0063         DATA    >0063                   address in R3
1967  523C DBC0         MOVB    R0,@-2(R15)             write back # of future record
1967  523E FFFE  
1968  5240 06C0         SWPB    R0                      
1969  5242 DBC0         MOVB    R0,@-2(R15)                     
1969  5244 FFFE  
1970  5246 04C0         CLR     R0                      
1971  5248 C0C1         MOV     R1,R3                   save # of desired rec
1972  524A 3C05         DIV     R5,R0                   divide by # of rec/sector = sect # in R0
1973  524C C0A9 RNFISE  MOV     @>0056(R9),R2           FDR ptr
1973  524E 0056  
1974  5250 0222         AI      R2,18                   point to total # of rec (# of sectors for var)
1974  5252 0012  
1975  5254 0429         BLWP    @>005A(R9)              set VDP to read
1975  5256 005A  
1976  5258 0042         DATA    >0042                   address in R2
1977  525A D0AF         MOVB    @-1026(R15),R2          get total # of recs/file (sect/file for var)
1977  525C FBFE  
1978  525E 06C2         SWPB    R2                      
1979  5260 D0AF         MOVB    @-1026(R15),R2          remember: bytes are swapped
1979  5262 FBFE  
1980  5264 8083         C       R3,R2                   compare with desired record (ignored by var)
1981  5266 045B         B       *R11                    
1982            *                                       
1983  5268 0429 RRFDR   BLWP    @>005A(R9)              fetch record into FDR data buffer area
1983  526A 005A  
1984  526C 4000         DATA    >4000                   save R1
1985  526E 0224         AI      R4,-18                  ptr to top of control block
1985  5270 FFEE  
1986  5272 0429         BLWP    @>005A(R9)              set VDP to read
1986  5274 005A  
1987  5276 0082         DATA    >0082                   address in R4
1988  5278 D16F         MOVB    @-1026(R15),R5          get current sector offset in file
1988  527A FBFE  
1989  527C 06C5         SWPB    R5                      
1990  527E D16F         MOVB    @-1026(R15),R5                  
1990  5280 FBFE  
1991  5282 0B85         SRC     R5,8                    
1992  5284 1105         JLT     H142                    -1: top of file
1993  5286 8005         C       R5,R0                   compare with desired offset (from RRNPAB)
1994  5288 130B         JEQ     H143                    same
1995  528A 06A0         BL      @CALSUB                 call subroutine
1995  528C 4344  
1996  528E 458A         DATA    UPDBF                   update data buffer if needed
1997  5290 C0C0 H142    MOV     R0,R3                   desired sector offset in file
1998  5292 06A0         BL      @UCOFCB                 update sect + rec offsets in control block
1998  5294 52E0  
1999  5296 0227         AI      R7,256                  point to data buffer area (R7 set by UCOFCB)
1999  5298 0100  
2000  529A 06A0         BL      @CALSUB                 call subroutine
2000  529C 4344  
2001  529E 461E         DATA    RDOFSC                  read a sector from offset in file (in R3)
2002  52A0 0429 H143    BLWP    @>005A(R9)                      
2002  52A2 005A  
2003  52A4 4001         DATA    >4001                   retrieve R1
2004  52A6 C0E9         MOV     @>0056(R9),R3           FDR ptr
2004  52A8 0056  
2005  52AA 0223         AI      R3,17                   point to record length
2005  52AC 0011  
2006  52AE 0429         BLWP    @>005A(R9)              set VDP to read
2006  52B0 005A  
2007  52B2 0062         DATA    >0062                   address in R3
2008  52B4 D02F         MOVB    @-1026(R15),R0          get rec length in bytes
2008  52B6 FBFE  
2009  52B8 0980         SRL     R0,8                    make it a word
2010  52BA 3840         MPY     R0,R1                   calc file offset in bytes
2011  52BC A0A9 AFDRPT  A       @>0056(R9),R2           add FDR ptr
2011  52BE 0056  
2012  52C0 0222         AI      R2,256                  point inside data buffer area
2012  52C2 0100  
2013  52C4 C0E9         MOV     @>0054(R9),R3           PAB ptr
2013  52C6 0054  
2014  52C8 05C3         INCT    R3                      point to data buffer address
2015  52CA 0429         BLWP    @>005A(R9)              set VDP to read
2015  52CC 005A  
2016  52CE 0062         DATA    >0062                   address in R3
2017  52D0 D06F         MOVB    @-1026(R15),R1          get PAB data buffer address
2017  52D2 FBFE  
2018  52D4 06C1         SWPB    R1                      
2019  52D6 D06F         MOVB    @-1026(R15),R1                  
2019  52D8 FBFE  
2020  52DA 06C1         SWPB    R1                      
2021  52DC 0460         B       @RTURN1                 return
2021  52DE 4362  
2022            *                               
2023  52E0 C1E9 UCOFCB  MOV     @>0056(R9),R7           update sect + rec offsets in control block
2023  52E2 0056  
2024  52E4 C047         MOV     R7,R1                   FDR ptr
2025  52E6 0221         AI      R1,-6                   top of file control block
2025  52E8 FFFA  
2026  52EA 0429         BLWP    @>005A(R9)              set VDP to write
2026  52EC 005A  
2027  52EE 0023         DATA    >0023                   address in R1
2028  52F0 DBC0         MOVB    R0,@-2(R15)             current sector offset in file
2028  52F2 FFFE  
2029  52F4 06C0         SWPB    R0                      
2030  52F6 DBC0         MOVB    R0,@-2(R15)                     
2030  52F8 FFFE  
2031  52FA 0221         AI      R1,4                    point to var rec offset in sector
2031  52FC 0004  
2032  52FE 06C5         SWPB    R5                      
2033  5300 0429         BLWP    @>005A(R9)              set VDP to write
2033  5302 005A  
2034  5304 0023         DATA    >0023                   address in R1
2035  5306 DBC5         MOVB    R5,@-2(R15)             first free byte in current sector
2035  5308 FFFE  
2036  530A 045B         B       *R11                    
2037            *                                       
2038  530C C0A9 URFFDR  MOV     @>0056(R9),R2           update # of rec/file in FDR
2038  530E 0056  
2039  5310 0429         BLWP    @>005A(R9)              set VDP to read
2039  5312 005A  
2040  5314 0042         DATA    >0042                   address in R2 (FDR ptr)
2041  5316 D2AF         MOVB    @-1026(R15),R10         get first char of filename
2041  5318 FBFE  
2042  531A 026A         ORI     R10,>8000               set was modified flag
2042  531C 8000  
2043  531E 0429         BLWP    @>005A(R9)              set VDP to write
2043  5320 005A  
2044  5322 0043         DATA    >0043                   address in R2
2045  5324 DBCA         MOVB    R10,@-2(R15)            write flagged char back
2045  5326 FFFE  
2046  5328 0222         AI      R2,18                   point to # of recs/file in FDR
2046  532A 0012  
2047  532C 0583         INC     R3                      one more
2048  532E 0429         BLWP    @>005A(R9)              set VDP to write
2048  5330 005A  
2049  5332 0043         DATA    >0043                   address in R2
2050  5334 06C3         SWPB    R3                      update # of recs/file
2051  5336 DBC3         MOVB    R3,@-2(R15)                     
2051  5338 FFFE  
2052  533A 06C3         SWPB    R3                      
2053  533C DBC3         MOVB    R3,@-2(R15)                     
2053  533E FFFE  
2054  5340 045B         B       *R11                    
2055            *                                       
2056  5342 C229 RCOFCB  MOV     @>0056(R9),R8           get rec offset, compare sect with total
2056  5344 0056  
2057  5346 C108         MOV     R8,R4                   FDR ptr
2058  5348 0224         AI      R4,256                  point to data buffer area
2058  534A 0100  
2059  534C 0648         DECT    R8                      point to var record offset
2060  534E 0429         BLWP    @>005A(R9)              set VDP to read
2060  5350 005A  
2061  5352 0102         DATA    >0102                   address in R8
2062  5354 D0AF         MOVB    @-1026(R15),R2          get var rec offset in current sector
2062  5356 FBFE  
2063  5358 0982         SRL     R2,8                    make it a word
2064  535A C28B         MOV     R11,R10                 save return point
2065  535C 06A0         BL      @FDR2B2                 get 2 bytes from FDR (at R8-4) into R0
2065  535E 4868  
2066  5360 FFFC         DATA    -4                      current sector offset in file
2067  5362 C0C0         MOV     R0,R3                   save it
2068  5364 C2CA         MOV     R10,R11                 restore return point
2069  5366 C002         MOV     R2,R0                   var record offset
2070  5368 0460         B       @RNFISE                 get # of sect/file from FDR, return
2070  536A 524C  
2071            *
2072            *------------------------------------
2073            * Opcode 4: Rewind
2074            * --------------
2075            * PAB 0: >04
2076            *     1: file type <--- error code
2077            *   2-3:
2078            *     4:
2079            *     5:
2080            *   6-7: record #  <--- >0000 if sequential
2081            *     8:
2082            *------------------------------------                                   
2083            *
2084  536C 06A0 RWIND1  BL      @CALSUB                 call subroutine
2084  536E 4344  
2085  5370 51C2         DATA    FFDRVP                  find FDR in VDP buffers, read status from PAB
2086  5372 0429         BLWP    @>005A(R9)                      
2086  5374 005A  
2087  5376 8000         DATA    >8000                   save R0 (status from PAB)
2088  5378 0240         ANDI    R0,>0600                keep only access mode
2088  537A 0600  
2089  537C 1305         JEQ     H144                    update is ok
2090  537E 0280         CI      R0,>0400                is it input?
2090  5380 0400  
2091  5382 1302         JEQ     H144                    yes: ok
2092  5384 0460         B       @ERROR8                 output or append: return with illegal opcode
2092  5386 4DAC  
2093  5388 06A0 H144    BL      @CALSUB                 call subroutine
2093  538A 4344  
2094  538C 458A         DATA    UPDBF                   update data buffer if needed
2095  538E 0429         BLWP    @>005A(R9)                      
2095  5390 005A  
2096  5392 8001         DATA    >8001                   retrieve R0 (status from PAB)
2097  5394 0240         ANDI    R0,>0100                sequential or reloc?
2097  5396 0100  
2098  5398 1611         JNE     H145                    reloc: don't do anything, return
2099            *                                       
2100  539A 04C2 RWIND2  CLR     R2                      rewind file: record offset = 0
2101  539C 0703         SETO    R3                      current record = -1 (none)
2102  539E 06A0         BL      @UPDFCB                 update file control block
2102  53A0 4F9C  
2103  53A2 04C0         CLR     R0                      record 0
2104  53A4 C229         MOV     @>0054(R9),R8           get PAB ptr
2104  53A6 0054  
2105  53A8 0228         AI      R8,6                    point to record #
2105  53AA 0006  
2106  53AC 0429         BLWP    @>005A(R9)              set VDP to write
2106  53AE 005A  
2107  53B0 0103         DATA    >0103                   address in R8
2108  53B2 DBC0         MOVB    R0,@-2(R15)             write record #
2108  53B4 FFFE  
2109  53B6 1000         NOP                             
2110  53B8 DBC0         MOVB    R0,@-2(R15)                     
2110  53BA FFFE  
2111  53BC 0460 H145    B       @RTURN1                 return to caller
2111  53BE 4362  
2112            *
2113            *------------------------------------
2114            * Opcode 5: Load
2115            * --------------
2116            * PAB 0: >05
2117            *     1: file type  <--- error code
2118            *   2-3: data buffer address in VDP mem
2119            *     4:
2120            *     5:
2121            *   6-7: maximum # of bytes (size of buffer)
2122            *     8:
2123            *------------------------------------                                   
2124            *
2125  53C0 06A0 LOAD    BL      @CALSUB                 call subroutine
2125  53C2 4344  
2126  53C4 4AF6         DATA    FNDFDR                  find FDR on disk
2127  53C6 C104         MOV     R4,R4                   found?
2128  53C8 1303         JEQ     H147                    yes
2129  53CA 06A0 H146    BL      @ERROR5                 no: return with error
2129  53CC 4966  
2130  53CE E000         DATA    >E000                   file error
2131  53D0 06A0 H147    BL      @FDR2B1                 get 2 bytes from FDR into R0
2131  53D2 4864  
2132  53D4 000C         DATA    12                      file status byte
2133  53D6 0240         ANDI    R0,>0100                is it program?
2133  53D8 0100  
2134  53DA 13F7         JEQ     H146                    no: file error
2135  53DC 05C8         INCT    R8                      point to # of sect/file in FDR
2136  53DE 0429         BLWP    @>005A(R9)              set VDP to read
2136  53E0 005A  
2137  53E2 0102         DATA    >0102                   address in R8
2138  53E4 D06F         MOVB    @-1026(R15),R1          get # of sectors in file
2138  53E6 FBFE  
2139  53E8 06C1         SWPB    R1                      
2140  53EA D06F         MOVB    @-1026(R15),R1                  
2140  53EC FBFE  
2141  53EE 0B81         SRC     R1,8                    
2142  53F0 13EC         JEQ     H146                    0=empty file: return with file error
2143  53F2 06A0         BL      @RBANB                  get data buffer address in R7, # of sectors in R2
2143  53F4 54B2  
2144  53F6 05C8         INCT    R8                      point to eof offset in FDR
2145  53F8 04C4         CLR     R4                      
2146  53FA 0429         BLWP    @>005A(R9)              set VDP to read
2146  53FC 005A  
2147  53FE 0102         DATA    >0102                   address in R8
2148  5400 D12F         MOVB    @-1026(R15),R4          get # of bytes in last sector
2148  5402 FBFE  
2149  5404 8081         C       R1,R2                   compare # of sect with max in PAB
2150  5406 1BE1         JH      H146                    file is too big: return with file error
2151  5408 1602         JNE     H148                    file is smaller
2152  540A 8100         C       R0,R4                   same # of sect: check bytes in last sector
2153  540C 1ADE         JL      H146                    file is too big: file error
2154  540E 04C3 H148    CLR     R3                      sector offset in file
2155  5410 06C4         SWPB    R4                      
2156  5412 0601 H149    DEC     R1                      next sector
2157  5414 130D         JEQ     H150                    done
2158  5416 0429         BLWP    @>005A(R9)                      
2158  5418 005A  
2159  541A D900         DATA    >D900                   save R0, R1, R3, R4, R7
2160  541C 06A0         BL      @CALSUB                 call subroutine
2160  541E 4344  
2161  5420 461E         DATA    RDOFSC                  read a sector from offset in R3
2162  5422 0429         BLWP    @>005A(R9)              restore R0, R1, R3, R4, R7
2162  5424 005A  
2163  5426 D901         DATA    >D901                   
2164  5428 0583         INC     R3                      next sector
2165  542A 0227         AI      R7,256                  256 bytes further in PAB buffer
2165  542C 0100  
2166  542E 10F1         JMP     H149                    keep going
2167            *                                       
2168  5430 C104 H150    MOV     R4,R4                   
2169  5432 1604         JNE     H151                    
2170  5434 06A0         BL      @CALSUB                 call subroutine
2170  5436 4344  
2171  5438 461E         DATA    RDOFSC                  read a sector from offset in R3
2172  543A 1011         JMP     H152                    done
2173            *                                       
2174  543C C147 H151    MOV     R7,R5                   save PAB data buffer ptr
2175  543E C1E9         MOV     @>0056(R9),R7           FDR ptr
2175  5440 0056  
2176  5442 0227         AI      R7,256                  point to FDR data area
2176  5444 0100  
2177  5446 0429         BLWP    @>005A(R9)                      
2177  5448 005A  
2178  544A 0D00         DATA    >0D00                   save R4, R5, R7
2179  544C 06A0         BL      @CALSUB                 call subroutine
2179  544E 4344  
2180  5450 461E         DATA    RDOFSC                  read a sector from offset in R3
2181  5452 0429         BLWP    @>005A(R9)              restore R4 in R0, R5 in R1, R7 in R2
2181  5454 005A  
2182  5456 E001         DATA    >E001                   
2183  5458 06A0         BL      @CALSUB                 call subroutine
2183  545A 4344  
2184  545C 5030         DATA    WFDRPB                  write bytes from FDR data buffer to PAB data buf
2185  545E 0460 H152    B       @UPDFDR                 update FDR, data buffer, VIB and return to caller
2185  5460 456A  
2186            *
2187            *------------------------------------
2188            * Opcode 6: Save
2189            * --------------
2190            * PAB 0: >06
2191            *     1: file type  <--- error code
2192            *   2-3: data buffer address in VDP mem
2193            *     4:
2194            *     5:
2195            *   6-7: # of bytes to save
2196            *     8:
2197            *------------------------------------                                   
2198            *
2199  5462 06A0 SAVE    BL      @CALSUB                 call subroutine
2199  5464 4344  
2200  5466 4484         DATA    CRFIL1                  create file
2201  5468 06A0         BL      @RBANB                  get PAB buffer ptr + # of bytes
2201  546A 54B2  
2202  546C 04C3         CLR     R3                      sector offset 0
2203  546E 0429 H153    BLWP    @>005A(R9)                      
2203  5470 005A  
2204  5472 B100         DATA    >B100                   save R0, R2, R3, R7
2205  5474 06A0         BL      @CALSUB                 call subroutine
2205  5476 4344  
2206  5478 463E         DATA    WROFSC                  write sector to offset in R3
2207  547A 0429         BLWP    @>005A(R9)                      
2207  547C 005A  
2208  547E B101         DATA    >B101                   retrieve R0, R2, R3, R7
2209  5480 0583         INC     R3                      next sector
2210  5482 0227         AI      R7,256                  256 bytes further in PAB data buffer
2210  5484 0100  
2211  5486 0602         DEC     R2                      next sector
2212  5488 16F2         JNE     H153                    more to do
2213            *                                       
2214  548A C069         MOV     @>0056(R9),R1           FDR ptr
2214  548C 0056  
2215  548E 0221         AI      R1,12                   point to file status byte
2215  5490 000C  
2216  5492 0202         LI      R2,>0100                value for program file
2216  5494 0100  
2217  5496 0429         BLWP    @>005A(R9)              set VDP to write
2217  5498 005A  
2218  549A 0023         DATA    >0023                   address in R1
2219  549C DBC2         MOVB    R2,@-2(R15)             write file status byte in FDR
2219  549E FFFE  
2220  54A0 0221         AI      R1,4                    point to eof offset byte in FDR
2220  54A2 0004  
2221  54A4 0429         BLWP    @>005A(R9)              set VDP to write
2221  54A6 005A  
2222  54A8 0023         DATA    >0023                   address in R1
2223  54AA DBC0         MOVB    R0,@-2(R15)             # of bytes in last sector
2223  54AC FFFE  
2224  54AE 0460         B       @UPDFDR                 update FDR, data buffer, VIB then return to caller
2224  54B0 456A  
2225            *                                       
2226  54B2 C029 RBANB   MOV     @>0054(R9),R0           get buffer address + # of bytes
2226  54B4 0054  
2227  54B6 05C0         INCT    R0                      data buffer in PAB
2228  54B8 0429         BLWP    @>005A(R9)              set VDP to read
2228  54BA 005A  
2229  54BC 0002         DATA    >0002                   address in R0
2230  54BE D1EF         MOVB    @-1026(R15),R7          get data buffer address
2230  54C0 FBFE  
2231  54C2 06C7         SWPB    R7                      
2232  54C4 D1EF         MOVB    @-1026(R15),R7                  
2232  54C6 FBFE  
2233  54C8 06C7         SWPB    R7                      
2234  54CA 0220         AI      R0,4                    point to # of bytes to transfer
2234  54CC 0004  
2235  54CE 0429         BLWP    @>005A(R9)              set VDP to read
2235  54D0 005A  
2236  54D2 0002         DATA    >0002                   address in R0
2237  54D4 D0AF         MOVB    @-1026(R15),R2          get # of bytes to be transfered
2237  54D6 FBFE  
2238  54D8 0982         SRL     R2,8                    make it # of sectors (256 bytes each)
2239  54DA 04C0         CLR     R0                      
2240  54DC D02F         MOVB    @-1026(R15),R0          see if one more is needed
2240  54DE FBFE  
2241  54E0 1301         JEQ     H154                    no
2242  54E2 0582         INC     R2                      yes: one more sector
2243  54E4 045B H154    B       *R11                    
2244            *
2245            *-------------------------------------
2246            * Opcode 9: Status
2247            * --------------
2248            * PAB 0: >09
2249            *     1:
2250            *   2-3:
2251            *     4:
2252            *     5:
2253            *   6-7: record #
2254            *     8:           <--- file status
2255            *
2256            * Status bits, returned in PAB byte 8:
2257            * >80: file not found
2258            * >40: file is protected
2259            * >20:
2260            * >10: internal (else display or program)
2261            * >08: program file
2262            * >04: variable (else fixed or program)
2263            * >02: memory full
2264            * >01: end-of-file reached
2265            *-------------------------------------                                  
2266            *
2267  54E6 06A0 STATUS  BL      @CALSUB                 call subroutine
2267  54E8 4344  
2268  54EA 4A98         DATA    FFFDRV                  save filename in comp buf, then find FDR in VDP
2269  54EC C104         MOV     R4,R4                   found?
2270  54EE 1310         JEQ     H155                    yes
2271            *                                       
2272  54F0 06A0         BL      @CALSUB                 no: call subroutine
2272  54F2 4344  
2273  54F4 4B00         DATA    FFDRDK                  find FDR on disk
2274  54F6 0200         LI      R0,>8000                value for file not found
2274  54F8 8000  
2275  54FA C104         MOV     R4,R4                   found?
2276  54FC 1649         JNE     H164                    no: return with that value
2277  54FE C069         MOV     @>0056(R9),R1           yes: ptr to FDR
2277  5500 0056  
2278  5502 04C2         CLR     R2                      
2279  5504 0429         BLWP    @>005A(R9)              set VDP to write
2279  5506 005A  
2280  5508 0023         DATA    >0023                   address in R1
2281  550A DBC2         MOVB    R2,@-2(R15)             invalidate that FDR (file not open)
2281  550C FFFE  
2282  550E 1036         JMP     H162                    transfer FDR status to PAB status byte
2283            *                                       
2284  5510 06A0 H155    BL      @CALSUB                 file is open: call subroutine
2284  5512 4344  
2285  5514 51D2         DATA    AFPGPF                  adjust FDR ptr, get PAB file type into R4
2286  5516 06A0         BL      @RFDRST                 get status byte from FDR
2286  5518 51EE  
2287  551A 1101         JLT     H156                    var
2288  551C 1006         JMP     H157                    fix
2289            *                                       
2290  551E 06A0 H156    BL      @CALSUB                 var: call subroutine
2290  5520 4344  
2291  5522 5054         DATA    RRSEC                   load wanted sector, point to wanted rec in buffer
2292  5524 1013         JMP     H159                    out of range
2293  5526 04C2         CLR     R2                      ok: clear flag
2294  5528 1029         JMP     H162                    copy status byte from FDR into PAB, return
2295            *                                       
2296  552A D16F H157    MOVB    @-1026(R15),R5          fix: get rec/sect byte
2296  552C FBFE  
2297  552E 0985         SRL     R5,8                    make it a word
2298  5530 1602         JNE     H158                    
2299  5532 0205         LI      R5,>0100                00 (program files) means 256
2299  5534 0100  
2300  5536 06A0 H158    BL      @PABR2B                 get 2 bytes from PAB into R0
2300  5538 485E  
2301  553A 0006         DATA    6                       # of wanted record
2302  553C C0C0         MOV     R0,R3                   save it
2303  553E 111C         JLT     H161                    too big: set memory full bit in PAB status byte
2304  5540 06A0         BL      @RNFISE                 get # recs/file into R2, comp with R3
2304  5542 524C  
2305  5544 04C2         CLR     R2                      
2306  5546 1A1A         JL      H162                    in file: copy file type bits, return
2307  5548 3C85         DIV     R5,R2                   how many sectors do we need?
2308  554A C0C2         MOV     R2,R3                   save result
2309            *                                       
2310  554C 06A0 H159    BL      @FDR2B1                 get 2 bytes from FDR into R0
2310  554E 4864  
2311  5550 000E         DATA    14                      # of sectors/file
2312  5552 0583         INC     R3                      plus 1 sector for FDR
2313  5554 0202         LI      R2,>0100                value for eof reached in PAB status
2313  5556 0100  
2314  5558 60C0         S       R0,R3                   are there enough sectors in file for these recs?
2315  555A 1501         JGT     H160                    
2316  555C 100F         JMP     H162                    yes: we reached the eof
2317  555E 06A0 H160    BL      @CALSUB                 call subroutine
2317  5560 4344  
2318  5562 49C6         DATA    RWVIB                   load VIB (sector 0)
2319  5564 C103         MOV     R3,R4                   number of sectors that will be needed
2320  5566 C205         MOV     R5,R8                   VIB ptr
2321  5568 0228         AI      R8,10                   skip 10 bytes (required by CFSVIB)
2321  556A 000A  
2322  556C 06A0         BL      @CFSVIB                 count free sectors in bitmap, into R3
2322  556E 575A  
2323  5570 0202         LI      R2,>0100                value for eof reached
2323  5572 0100  
2324  5574 8103         C       R3,R4                   are there that many free sectors?
2325  5576 1402         JHE     H162                    yes
2326  5578 0202 H161    LI      R2,>0200                value for memory full
2326  557A 0200  
2327            *                                       
2328  557C 06A0 H162    BL      @FDR2B1                 get 2 bytes from FDR into R0
2328  557E 4864  
2329  5580 000C         DATA    12                      file status byte
2330  5582 0240         ANDI    R0,>8F00                mask irrelevant bits
2330  5584 8F00  
2331  5586 1502         JGT     H163                    
2332  5588 0260         ORI     R0,>0080                var: put var bit in PAB status style
2332  558A 0080  
2333  558C 0A30 H163    SLA     R0,3                    get rid of var bit in FDR style
2334  558E F002         SOCB    R2,R0                   add eof and mem full bits
2335            *                                       
2336  5590 C069 H164    MOV     @>0054(R9),R1           PAB ptr
2336  5592 0054  
2337  5594 0221         AI      R1,8                    point to bias/status return byte
2337  5596 0008  
2338  5598 0429         BLWP    @>005A(R9)              set VDP to write
2338  559A 005A  
2339  559C 0023         DATA    >0023                   address in R1
2340  559E DBC0         MOVB    R0,@-2(R15)             write file status to PAB
2340  55A0 FFFE  
2341  55A2 0460         B       @RTURN1                 return to caller
2341  55A4 4362  
2342            *
2343            *---------------------------------
2344            * Disk directory access
2345            * ---------------------
2346            * The directory is accessed by omiting the filename in the DSR name: "DSK1."
2347            * It must be opened for input only, as an Int/Fix 38 file.
2348            * It consists in upto 128 records, the first one contains the disk informations,
2349            * the others the informations for upto 127 files (in alphabetical order).
2350            * Each record consists in an ascii string and three floating point numbers.
2351            *
2352            * Record 0 contains:
2353            * - Diskname (an ascii string of upto 10 chars).
2354            * - The number zero.
2355            * - The number of sectors on disk.
2356            * - The number of free sectors on disk.
2357            *
2358            * Other records contain:
2359            * - Filename (an ascii string of upto 10 chars).
2360            * - Filetype: 1=D/F, 2=D/V, 3=I/F, 4=I/V, 5=Prog, 0=end of directory.
2361            *   If the file is protected, this number is negative (-1=D/F, etc).
2362            * - File size in sectors (including the FDR itself).
2363            * - File record length (0 for programs).
2364            *---------------------------------
2365             
2366            *---------------------------------
2367            * Open disk directory pseudo-file
2368            *---------------------------------                                      
2369            *
2370  55A6 D02F OPNDIR  MOVB    @-1026(R15),R0          get file type from PAB
2370  55A8 FBFE  
2371  55AA 0240         ANDI    R0,>1E00                mask irrelavant bits (rel/seq)
2371  55AC 1E00  
2372  55AE 0280         CI      R0,>0C00                is it int/fix in output mode?
2372  55B0 0C00  
2373  55B2 1303         JEQ     H166                    yes
2374  55B4 06A0 H165    BL      @RETERR                 return with error
2374  55B6 4992  
2375  55B8 4000         DATA    >4000                   bad attributes
2376  55BA 06A0 H166    BL      @PABR2B                 get 2 bytes from PAB into R0
2376  55BC 485E  
2377  55BE 0004         DATA    4                       rec length
2378  55C0 0980         SRL     R0,8                    make it a word
2379  55C2 1303         JEQ     H167                    >00= default: set it to 38
2380  55C4 0280         CI      R0,>0026                is it 38?
2380  55C6 0026  
2381  55C8 16F5         JNE     H165                    no: return with bad attributes error
2382  55CA 0200 H167    LI      R0,>2600                set rec len to 38
2382  55CC 2600  
2383  55CE 0429         BLWP    @>005A(R9)              set VDP to write
2383  55D0 005A  
2384  55D2 0103         DATA    >0103                   address in R8 (from PABR2B)
2385  55D4 DBC0         MOVB    R0,@-2(R15)             write rec len to PAB
2385  55D6 FFFE  
2386            *                                       
2387  55D8 04C7         CLR     R7                      
2388  55DA 06A0         BL      @FNDRV                  find matching drive in file control blocks
2388  55DC 5794  
2389  55DE 55E6         DATA    H168                    go there if not found
2390  55E0 06A0 ERRR10  BL      @ERROR5                 update data then return with error
2390  55E2 4966  
2391  55E4 E000         DATA    >E000                   file error
2392  55E6 C1C7 H168    MOV     R7,R7                   did we find a free slot?
2393  55E8 1603         JNE     H169                    yes
2394  55EA 06A0         BL      @RETERR                 no: return with error
2394  55EC 4992  
2395  55EE 8000         DATA    >8000                   memory full
2396  55F0 0429 H169    BLWP    @>005A(R9)              set VDP to write
2396  55F2 005A  
2397  55F4 00E3         DATA    >00E3                   address in R7
2398  55F6 DBC3         MOVB    R3,@-2(R15)             write drive #
2398  55F8 FFFE  
2399  55FA 06C3         SWPB    R3                      
2400  55FC DBC3         MOVB    R3,@-2(R15)             and a space as filename (illegal, indicates dir)
2400  55FE FFFE  
2401  5600 0460         B       @RTURN1                 return to caller
2401  5602 4362  
2402            *
2403            *---------------------------------
2404            * Close disk directory
2405            *---------------------------------                                      
2406  5604 06A0 CLSDIR  BL      @FNDRV                  find matching drive in file control blocks
2406  5606 5794  
2407  5608 55E0         DATA    ERRR10                  go there if not found: return with file error
2408  560A 04C0         CLR     R0                      
2409  560C 0429         BLWP    @>005A(R9)              set VDP to write
2409  560E 005A  
2410  5610 0103         DATA    >0103                   address in R8
2411  5612 DBC0         MOVB    R0,@-2(R15)             clear drive #
2411  5614 FFFE  
2412  5616 0460         B       @RTURN1                 return to caller
2412  5618 4362  
2413            *
2414            *---------------------------------
2415            * Read a record from disk directory
2416            *---------------------------------                                      
2417            *
2418  561A 06A0 RDDIR   BL      @FNDRV                  find matching drive in file control blocks
2418  561C 5794  
2419  561E 55E0         DATA    ERRR10                  go ther it not found: return with file error
2420  5620 0588         INC     R8                      
2421  5622 C148         MOV     R8,R5                   save ptr to FDR
2422  5624 06A0         BL      @PABR2B                 get 2 bytes from PAB into R0
2422  5626 485E  
2423  5628 0006         DATA    6                       record #
2424  562A C080         MOV     R0,R2                   save it
2425  562C 0582         INC     R2                      
2426  562E 0429         BLWP    @>005A(R9)              set VDP to write
2426  5630 005A  
2427  5632 0103         DATA    >0103                   address in R8
2428  5634 DBC2         MOVB    R2,@-2(R15)             write record number in FDR
2428  5636 FFFE  
2429  5638 06C2         SWPB    R2                      after first char of filename!
2430  563A DBC2         MOVB    R2,@-2(R15)                     
2430  563C FFFE  
2431  563E 0A10         SLA     R0,1                    since two byte per file ptr
2432  5640 D000         MOVB    R0,R0                   is rec # greater than 128?
2433  5642 1303         JEQ     H170                    no
2434  5644 06A0         BL      @ERROR5                 yes: update data then return with error
2434  5646 4966  
2435  5648 A000         DATA    >A000                   past eof
2436  564A 0702 H170    SETO    R2                      code for read
2437  564C C100         MOV     R0,R4                   record #
2438  564E 133B         JEQ     H175                    0=disk parameters
2439  5650 0204         LI      R4,1                    sector #1
2439  5652 0001  
2440  5654 06A0         BL      @CALSUB                 call subroutine
2440  5656 4344  
2441  5658 4A42         DATA    RWSEC                   read sector into buffer in R5
2442  565A C205         MOV     R5,R8                   buffer ptr
2443  565C 0225         AI      R5,255                  point to data buffer area in this ctrl block
2443  565E 00FF  
2444  5660 0640         DECT    R0                      don't count record 0
2445  5662 A200         A       R0,R8                   point to desired file ptr
2446  5664 06A0         BL      @VDPR2B                 get two byte from VDP at R8 into R0
2446  5666 486A  
2447  5668 C100         MOV     R0,R4                   sector where that FDR is to be found
2448  566A 1328         JEQ     H173                    no more
2449  566C 06A0         BL      @CALSUB                 call subroutine
2449  566E 4344  
2450  5670 4A42         DATA    RWSEC                   read FDR sector into data buffer area
2451  5672 06A0         BL      @FDR2B1                 get 2 bytes from FDR into R0
2451  5674 4864  
2452  5676 010E         DATA    270                     # of sect/file
2453  5678 C180         MOV     R0,R6                   save it to output file size
2454  567A 0586         INC     R6                      include the FDR itself
2455  567C D0EF         MOVB    @-1026(R15),R3          ignore eof offset
2455  567E FBFE  
2456  5680 0202         LI      R2,>0A00                10 chars per filename
2456  5682 0A00  
2457  5684 D0EF         MOVB    @-1026(R15),R3          get rec length
2457  5686 FBFE  
2458  5688 0983         SRL     R3,8                    make it a word
2459  568A 0648         DECT    R8                      point to status byte in FDR
2460  568C 0429         BLWP    @>005A(R9)              set VDP to read
2460  568E 005A  
2461  5690 0102         DATA    >0102                   address in R8
2462  5692 D02F         MOVB    @-1026(R15),R0          get file status byte
2462  5694 FBFE  
2463  5696 C1C0         MOV     R0,R7                   
2464  5698 0240         ANDI    R0,>0800                keep only write protected bit
2464  569A 0800  
2465  569C 51C0         SZCB    R0,R7                   clear write protected bit (if it was set)
2466  569E 0987         SRL     R7,8                    make it a word
2467  56A0 0587         INC     R7                      types are numbered from 1
2468  56A2 0287         CI      R7,>0002                is it a program file?
2468  56A4 0002  
2469  56A6 1602         JNE     H171                    no
2470  56A8 0227         AI      R7,3                    yes: make it type 5
2470  56AA 0003  
2471  56AC 0287 H171    CI      R7,>0008                is it var?
2471  56AE 0008  
2472  56B0 1A02         JL      H172                    no
2473  56B2 0227         AI      R7,-127                 yes: add 1 and clear var bit
2473  56B4 FF81  
2474  56B6 0A40 H172    SLA     R0,4                    write protect bit will be >80
2475  56B8 E1C0         SOC     R0,R7                   add it to file type
2476  56BA 1004         JMP     H174                    
2477            *                                       
2478  56BC 04C2 H173    CLR     R2                      no more files: filename size = 0
2479  56BE 04C6         CLR     R6                      file size = 0
2480  56C0 04C3         CLR     R3                      rec length = 0
2481  56C2 04C7         CLR     R7                      type = 0
2482  56C4 100F H174    JMP     H176                    output that
2483            *                                       
2484  56C6 0225 H175    AI      R5,255                  disk info: point to data buffer area in ctrl block
2484  56C8 00FF  
2485  56CA 06A0         BL      @CALSUB                 call subroutine
2485  56CC 4344  
2486  56CE 4A42         DATA    RWSEC                   read sector 0
2487  56D0 06A0         BL      @FDR2B1                 get 2 bytes from FDR into R0
2487  56D2 4864  
2488  56D4 010A         DATA    266                     # of sectors on disk
2489  56D6 C180         MOV     R0,R6                   duplicate it
2490  56D8 0646         DECT    R6                      minus directory itself (sect 0 + 1)
2491  56DA 06A0         BL      @CFSVIB                 count free sectors in bitmap, result in R3
2491  56DC 575A  
2492  56DE 04C7         CLR     R7                      filetype is not used
2493  56E0 0202         LI      R2,>0A00                diskname is 10 chars
2493  56E2 0A00  
2494            *                                       
2495  56E4 06A0 H176    BL      @PABR2B                 get 2 bytes from PAB into R0
2495  56E6 485E  
2496  56E8 0002         DATA    2                       APEDSK99: error in source listing (was R2)
2497  56EA C200         MOV     R0,R8                   duplicate it
2498  56EC 0588         INC     R8                      skip first byte
2499  56EE 0982         SRL     R2,8                    filename length (or diskname)
2500  56F0 1316         JEQ     H179                    0: skip filename copying
2501  56F2 04C1         CLR     R1                      
2502  56F4 0429 H177    BLWP    @>005A(R9)              set VDP to read
2502  56F6 005A  
2503  56F8 00A2         DATA    >00A2                   address in R5 (FDR ptr)
2504  56FA D06F         MOVB    @-1026(R15),R1          get 1 char from filename in FDR
2504  56FC FBFE  
2505  56FE 0281         CI      R1,>2000                is it a space?
2505  5700 2000  
2506  5702 1309         JEQ     H178                    yes: end of name
2507  5704 0429         BLWP    @>005A(R9)              no: set VDP to write
2507  5706 005A  
2508  5708 0103         DATA    >0103                   address in R8 (PAB data buffer ptr)
2509  570A DBC1         MOVB    R1,@-2(R15)             copy char in PAB data buffer
2509  570C FFFE  
2510  570E 0585         INC     R5                      increment source ptr
2511  5710 0588         INC     R8                      increment destination ptr
2512  5712 0602         DEC     R2                      next char
2513  5714 16EF         JNE     H177                    
2514  5716 0502 H178    NEG     R2                      number of trailing spaces
2515  5718 0222         AI      R2,10                   number of chars in filename
2515  571A 000A  
2516  571C 06C2         SWPB    R2                      
2517  571E 0429 H179    BLWP    @>005A(R9)              set VDP to write
2517  5720 005A  
2518  5722 0003         DATA    >0003                   address in R0 (beg of PAB data buffer)
2519  5724 DBC2         MOVB    R2,@-2(R15)             write string length byte
2519  5726 FFFE  
2520            *                                       
2521  5728 0429         BLWP    @>005A(R9)              set VDP to write
2521  572A 005A  
2522  572C 0103         DATA    >0103                   address in R8
2523  572E C047         MOV     R7,R1                   file type + protection
2524  5730 06A0         BL      @INT2FP                 make it a float number
2524  5732 57D8  
2525  5734 C046         MOV     R6,R1                   file size in sectors, including FDR
2526  5736 06A0         BL      @INT2FP                 make it a float number
2526  5738 57D8  
2527  573A C043         MOV     R3,R1                   record length
2528  573C 06A0         BL      @INT2FP                 make it a float number
2528  573E 57D8  
2529  5740 C229         MOV     @>0054(R9),R8           get PAB ptr
2529  5742 0054  
2530  5744 0228         AI      R8,5                    point to character count
2530  5746 0005  
2531  5748 0200         LI      R0,>2600                always 38 bytes
2531  574A 2600  
2532  574C 0429         BLWP    @>005A(R9)              set VDP to write
2532  574E 005A  
2533  5750 0103         DATA    >0103                   address in R8
2534  5752 DBC0         MOVB    R0,@-2(R15)             write # of characters in record
2534  5754 FFFE  
2535  5756 0460         B       @RTURN1                 return to caller
2535  5758 4362  
2536            *                                       
2537  575A 0228 CFSVIB  AI      R8,46                   count free sectors in VIB bitmap
2537  575C 002E  
2538  575E 0202         LI      R2,200                  bitmap size
2538  5760 00C8  
2539  5762 04C3         CLR     R3                      free sectors counter
2540  5764 0429         BLWP    @>005A(R9)              set VDP to read
2540  5766 005A  
2541  5768 0102         DATA    >0102                   address in R8
2542  576A D06F H180    MOVB    @-1026(R15),R1          get a byte from bitmap
2542  576C FBFE  
2543  576E 0221         AI      R1,256                  
2543  5770 0100  
2544  5772 0981         SRL     R1,8                    
2545  5774 130C         JEQ     H184                    was >FF: no free sectors, next byte
2546  5776 0601         DEC     R1                      was it >00?
2547  5778 1603         JNE     H181                    no: count bits
2548  577A 0223         AI      R3,8                    yes: 8 more free sectors
2548  577C 0008  
2549  577E 1007         JMP     H184                    next byte
2550  5780 0200 H181    LI      R0,8                    8 bits per byte
2550  5782 0008  
2551  5784 0911 H182    SRL     R1,1                    test a bit
2552  5786 1801         JOC     H183                    was 1: sector is used
2553  5788 0583         INC     R3                      was 0: one more free sector
2554  578A 0600 H183    DEC     R0                      next bit in byte
2555  578C 16FB         JNE     H182                    more to come
2556  578E 0602 H184    DEC     R2                      next bitmap byte
2557  5790 16EC         JNE     H180                    more to come
2558  5792 045B         B       *R11                    
2559            *                                       
2560  5794 C2BB FNDRV   MOV     *R11+,R10               find drive in file control blocks
2561  5796 C14B         MOV     R11,R5                  save 2 returns
2562  5798 C229         MOV     @>0056(R9),R8           top of mem word in VDP buffers header
2562  579A 0056  
2563  579C 0228         AI      R8,3                    point to max # of files
2563  579E 0003  
2564  57A0 0429         BLWP    @>005A(R9)              set VDP to read
2564  57A2 005A  
2565  57A4 0102         DATA    >0102                   address in R8
2566  57A6 D0AF         MOVB    @-1026(R15),R2          get # of files
2566  57A8 FBFE  
2567  57AA 0882         SRA     R2,8                    make it a word
2568  57AC 0228         AI      R8,6                    point to drive # in file ctrl block
2568  57AE 0006  
2569  57B0 0203         LI      R3,>0020                filename begin with space (illegal: flag for dir)
2569  57B2 0020  
2570  57B4 D0C6         MOVB    R6,R3                   APEDSK99: error in original disassembly (was R5)
2571  57B6 06A0 H185    BL      @VDPR2B                 read 2 bytes from VDP at R8 into R0
2571  57B8 486A  
2572  57BA 8003         C       R3,R0                   match with that control block?
2573  57BC 1309         JEQ     H187                    yes
2574  57BE 0240         ANDI    R0,>00FF                keep only first char of filename
2574  57C0 00FF  
2575  57C2 1601         JNE     H186                    valid filename: a FDR is loaded here
2576  57C4 C1C8         MOV     R8,R7                   this space is free: save ptr
2577  57C6 0228 H186    AI      R8,518                  point to next file control block
2577  57C8 0206  
2578  57CA 0602         DEC     R2                      next file
2579  57CC 16F4         JNE     H185                    more to come
2580  57CE 045A         B       *R10                    not found: return to address passed in data word
2581  57D0 0588 H187    INC     R8                      drive matches: point to FDR
2582  57D2 CA48         MOV     R8,@>0056(R9)           save ptr
2582  57D4 0056  
2583  57D6 0455         B       *R5                     return to caller after data word
2584            *
2585            *--------------------------------------
2586            * Floating point format
2587            * ---------------------
2588            * Float numbers are 8 bytes long: EE 12 34 56 78 9A BC
2589            * EE is the exponent in radix 100 (not in radix 10 as usual!). It is biased
2590            * by 64: >40=0, 41=1 (i.e *100), >42=2 (i.e * 10,000) >3F= -1 (i.e /100), etc
2591            *
2592            * 12 ... BC are the mantissa in binary coded decimal: each byte encodes two
2593            * decimal digits from 00 to 99
2594            *
2595            * For negative numbers, the first word is negated
2596            * For zero, the first word is >0000 the others are irrelevant
2597            *
2598            * Examples: 40 08 00 00 00 00 00 00 is 8.0
2599            *           41 02 37 00 00 00 00 00 is 255.0 (>37 hex = 55 decimal)
2600            *           BF F8 00 00 00 00 00 00 is -8.0
2601            *           43 01 02 03 04 05 06 07 is 1020304.050607
2602            *--------------------------------------                                 
2603            *
2604  57D8 0202 INT2FP  LI      R2,>0800                write an integer in floating point format
2604  57DA 0800  
2605  57DC DBC2         MOVB    R2,@-2(R15)             size=8
2605  57DE FFFE  
2606  57E0 C141         MOV     R1,R5                   integer is in R1: save it for sign processing
2607  57E2 0241         ANDI    R1,>7FFF                clear sign bit
2607  57E4 7FFF  
2608  57E6 0281         CI      R1,100                  is it less than 100?
2608  57E8 0064  
2609  57EA 1A07         JL      H188                    yes
2610  57EC 04C0         CLR     R0                      100 or over
2611  57EE 0204         LI      R4,100                  
2611  57F0 0064  
2612  57F2 3C04         DIV     R4,R0                   divide by 100
2613  57F4 0260         ORI     R0,>4100                add exponent 2 to hundreths
2613  57F6 4100  
2614  57F8 1005         JMP     H190                    
2615            *                                       
2616  57FA C001 H188    MOV     R1,R0                   is it 0?
2617  57FC 1302         JEQ     H189                    yes: exponent is 0
2618  57FE 0260         ORI     R0,>4000                no: add exponent 1
2618  5800 4000  
2619  5802 04C1 H189    CLR     R1                      next digits will be 0
2620            *                                       
2621  5804 C145 H190    MOV     R5,R5                   test sign bit
2622  5806 1101         JLT     H191                    negative
2623  5808 1001         JMP     H192                    positive or zero
2624  580A 0500 H191    NEG     R0                      negate first word
2625  580C DBC0 H192    MOVB    R0,@-2(R15)             write exponent to VDP at preset address
2625  580E FFFE  
2626  5810 06C0         SWPB    R0                      
2627  5812 DBC0         MOVB    R0,@-2(R15)             write first first 2 digits (or hundreths)
2627  5814 FFFE  
2628  5816 06C1         SWPB    R1                      
2629  5818 DBC1         MOVB    R1,@-2(R15)             write last 2 digits (if any)
2629  581A FFFE  
2630  581C 0202         LI      R2,5                    the remaining bytes are all 0 with integers
2630  581E 0005  
2631  5820 DBC2 H193    MOVB    R2,@-2(R15)             write 0 to VDP
2631  5822 FFFE  
2632  5824 0602         DEC     R2                      next byte
2633  5826 16FC         JNE     H193                    more to do
2634  5828 045B         B       *R11                    
2635            *
2636            *---------------------------------------
2637            * Subprogram >10: sector R/W
2638            * --------------
2639            * >834A: (n/a)      <--- sector #
2640            * >834C: drive #
2641            * >834D: R/W code (write if >00)
2642            * >834E: VDP buffer
2643            * >8350: sector #   <--- error code
2644            *---------------------------------------                                        
2645            *
2646  582A C1CB ESUB01  MOV     R11,R7                  
2647  582C 06A0         BL      @PRPFDO                 prepare disk operations
2647  582E 4418  
2648  5830 CA69         MOV     @>0050(R9),@>004A(R9)   copy sector #
2648  5832 0050  
2648  5834 004A  
2649  5836 0460         B       @SECRW1                 
2649  5838 419A  
2650            *
2651            *---------------------------------------
2652            * Subprogram >11: format disk
2653            * --------------                                        
2654            *
2655  583A C1CB ESUB02  MOV     R11,R7                  
2656  583C 06A0         BL      @PRPFDO                 prepare disk operations
2656  583E 4418  
2657  5840 0460         B       @FMTDSK                 
2657  5842 4218  
2658            *
2659            *---------------------------------------
2660            * Subprogram >12: file (un)protect
2661            * --------------
2662            * >834C: drive #
2663            * >834D: protect code (>00 unprotect)
2664            * >834E: ptr to filename
2665            * >8350: (n/a)      <--- error code
2666            *---------------------------------------                                
2667            *
2668  5844 C1CB ESUB03  MOV     R11,R7                  
2669  5846 06A0         BL      @PRPFDO                 prepare disk operations
2669  5848 4418  
2670  584A D029         MOVB    @>004D(R9),R0           get protection code
2670  584C 004D  
2671  584E 0240         ANDI    R0,>0800                keep the bit that will be needed
2671  5850 0800  
2672  5852 0429         BLWP    @>005A(R9)              save R0 on stack
2672  5854 005A  
2673  5856 8000         DATA    >8000                   
2674  5858 C029         MOV     @>004E(R9),R0           get pointer to filename
2674  585A 004E  
2675  585C 06A0         BL      @CALSUB                 call subroutine
2675  585E 4344  
2676  5860 5946         DATA    RFDRVB                  load FDR in VDP buffer
2677  5862 0429         BLWP    @>005A(R9)              retrieve old R0, in R2
2677  5864 005A  
2678  5866 2001         DATA    >2001                   
2679  5868 06A0         BL      @FDR2B1                 read two bytes in R0 from top of FDR + offset
2679  586A 4864  
2680  586C 000C         DATA    12                      file status byte
2681  586E 0240         ANDI    R0,>F700                clear protection flag
2681  5870 F700  
2682  5872 F002         SOCB    R2,R0                   set it if needed
2683  5874 0429         BLWP    @>005A(R9)              set VDP for write
2683  5876 005A  
2684  5878 0103         DATA    >0103                   address in R8
2685  587A DBC0         MOVB    R0,@-2(R15)             write back file status to FDR
2685  587C FFFE  
2686            *                                       
2687  587E C229 UWFLVB  MOV     @>0056(R9),R8           FDR address in VDP mem
2687  5880 0056  
2688  5882 0429         BLWP    @>005A(R9)              set VDP for read
2688  5884 005A  
2689  5886 0102         DATA    >0102                   address in R8
2690  5888 D02F         MOVB    @-1026(R15),R0          get drive # in ctrl block
2690  588A FBFE  
2691  588C 0260         ORI     R0,>8000                flag it
2691  588E 8000  
2692  5890 0429         BLWP    @>005A(R9)              set VDP for write
2692  5892 005A  
2693  5894 0103         DATA    >0103                   address in R8
2694  5896 DBC0         MOVB    R0,@-2(R15)             write it back
2694  5898 FFFE  
2695  589A 0460         B       @UPDFDR                 update FDR, load VIB
2695  589C 456A  
2696            *
2697            *---------------------------------
2698            * Subprogram >13: file rename
2699            * --------------
2700            * >834C: drive #
2701            * >834E: ptr to new name
2702            * >8350: ptr to old name <--- error code
2703            *---------------------------------                                      
2704            *
2705  589E C1CB ESUB04  MOV     R11,R7                  
2706  58A0 06A0         BL      @PRPFDO                 prepare disk operations
2706  58A2 4418  
2707  58A4 C029         MOV     @>004E(R9),R0           get ptr to new filename
2707  58A6 004E  
2708  58A8 0429         BLWP    @>005A(R9)              save R0 on stack
2708  58AA 005A  
2709  58AC 8000         DATA    >8000                   
2710  58AE C029         MOV     @>0050(R9),R0           get ptr to old filename
2710  58B0 0050  
2711  58B2 06A0         BL      @CALSUB                 call subroutine
2711  58B4 4344  
2712  58B6 5946         DATA    RFDRVB                  put FDR in VDP buffer
2713  58B8 06A0         BL      @RMFPTR                 remove FDR ptr from sector 1
2713  58BA 47CE  
2714  58BC 06A0         BL      @FDR2B1                 get 2 bytes from FDR
2714  58BE 4864  
2715  58C0 000C         DATA    12                      file status byte
2716  58C2 0240         ANDI    R0,>0800                protected?
2716  58C4 0800  
2717  58C6 1303         JEQ     H194                    no
2718  58C8 06A0         BL      @ERROR5                 yes: return with error
2718  58CA 4966  
2719  58CC 2000         DATA    >2000                   write protected
2720  58CE 06A0 H194    BL      @FDR2B1                 get 2 bytes from FDR
2720  58D0 4864  
2721  58D2 FFFC         DATA    -4                      sector # of FDR
2722  58D4 C040         MOV     R0,R1                   
2723  58D6 0429         BLWP    @>005A(R9)              retrieve R0 from stack
2723  58D8 005A  
2724  58DA 8001         DATA    >8001                   ptr to new filename
2725  58DC 0429         BLWP    @>005A(R9)              save R1 on stack
2725  58DE 005A  
2726  58E0 4000         DATA    >4000                   sector # of FDR
2727  58E2 06A0         BL      @UFNCB                  write drive # and filename in compare buffer
2727  58E4 5B68  
2728  58E6 06A0         BL      @CALSUB                 call subroutine
2728  58E8 4344  
2729  58EA 4B2C         DATA    FFDRFN                  find FDR from filename
2730  58EC C104         MOV     R4,R4                   found?
2731  58EE 1338         JEQ     H195                    yes: return with file error (name already exist)
2732  58F0 06A0         BL      @INSFDR                 insert a FDR in sector 1
2732  58F2 47FE  
2733  58F4 0429         BLWP    @>005A(R9)              retrieve sect # of FDR in R4
2733  58F6 005A  
2734  58F8 0801         DATA    >0801                   
2735  58FA 0429         BLWP    @>005A(R9)              set VDP to write
2735  58FC 005A  
2736  58FE 0103         DATA    >0103                   address in R8
2737  5900 DBC4         MOVB    R4,@-2(R15)             write sector # of FDR
2737  5902 FFFE  
2738  5904 06C4         SWPB    R4                      
2739  5906 DBC4         MOVB    R4,@-2(R15)                     
2739  5908 FFFE  
2740  590A 06C4         SWPB    R4                      sector #
2741  590C 0702         SETO    R2                      code for read
2742  590E 04C5         CLR     R5                      buffer offset: VDP at >8356
2743  5910 06A0         BL      @CALSUB                 call subroutine
2743  5912 4344  
2744  5914 4A3E         DATA    RDFDR1                  read FDR
2745  5916 C045         MOV     R5,R1                   
2746  5918 C029         MOV     @>0058(R9),R0                   
2746  591A 0058  
2747  591C 0220         AI      R0,257                  
2747  591E 0101  
2748  5920 0601         DEC     R1                      
2749  5922 06A0         BL      @CFNFDR                 copy filename in compare buffer to FDR
2749  5924 5B7E  
2750  5926 04C2         CLR     R2                      code for write
2751  5928 06A0         BL      @CALSUB                 call subroutine
2751  592A 4344  
2752  592C 4A42         DATA    RWSEC                   write FDR (with new name in it)
2753  592E 06A0         BL      @CALSUB                 call subroutine
2753  5930 4344  
2754  5932 4A2A         DATA    WRSEC1                  write sector 1 (with new FDR ptr in it)
2755  5934 C069         MOV     @>0056(R9),R1           FDR ptr
2755  5936 0056  
2756  5938 0429         BLWP    @>005A(R9)              prepare VDP to write
2756  593A 005A  
2757  593C 0023         DATA    >0023                   address in R1
2758  593E DBC4         MOVB    R4,@-2(R15)             clear first char of FDR in buffer
2758  5940 FFFE  
2759  5942 0460         B       @RTURN1                 return to caller
2759  5944 4362  
2760            *                               
2761  5946 04C6 RFDRVB  CLR     R6                      put FDR in VDP buffer
2762  5948 D1A9         MOVB    @>004C(R9),R6           get drive #
2762  594A 004C  
2763  594C 06A0         BL      @UFNCB                  update filename compare buffer
2763  594E 5B68  
2764  5950 06A0         BL      @CALSUB                 call subroutine
2764  5952 4344  
2765  5954 4AB8         DATA    FFDRVB                  look if FDR already in VDP buffer
2766  5956 06A0         BL      @CALSUB                 call subroutine
2766  5958 4344  
2767  595A 4AFC         DATA    FFDROD                  file FDR on disk
2768  595C C104         MOV     R4,R4                   found?
2769  595E 1303         JEQ     H196                    yes
2770  5960 06A0 H195    BL      @RETERR                 no: return with error code in >8350
2770  5962 4992  
2771  5964 E000         DATA    >E000                   file error
2772  5966 0460 H196    B       @RTURN1                 return to caller
2772  5968 4362  
2773            *
2774            *-------------------------------------
2775            * Subprogram >14: file raw read
2776            * --------------
2777            * >834C: drive #                          <--- >00
2778            * >834D: # of sectors (>00=get file info) <--- sectors read
2779            * >834E: ptr to filename
2780            * >8350: file info buffer (>83xx)         <--- error code
2781            *                              |
2782            * >83xx  : VDP buffer       <--'
2783            * >83xx+2: first sector # (total # of sect when get file info)
2784            * >83xx+4: status flag
2785            * >83xx+5: recs/sector
2786            * >83xx+6: eof offset
2787            * >83xx+7: rec size
2788            * >83xx+8: # of recs
2789            *-------------------------------------                                  
2790            *
2791  596A C1CB ESUB05  MOV     R11,R7                  
2792  596C 06A0         BL      @PRPFDO                 prepare disk operations
2792  596E 4418  
2793  5970 06A0         BL      @RFNPTR                 load filename and ptrs
2793  5972 5BA0  
2794  5974 06A0         BL      @FFFDR                  find file FDR, load some info
2794  5976 5BC6  
2795  5978 C082         MOV     R2,R2                   # of sectors to read
2796  597A 131E         JEQ     H202                    >00: get file info
2797  597C 6003         S       R3,R0                   sectors in file - first sector to read
2798  597E 1502         JGT     H197                    in file
2799  5980 04C2         CLR     R2                      past eof
2800  5982 1017         JMP     H201                    
2801  5984 8002 H197    C       R2,R0                   sectors past first one vs sectors to load
2802  5986 1A01         JL      H198                    
2803  5988 C080         MOV     R0,R2                   load what's left
2804  598A 0429 H198    BLWP    @>005A(R9)                      
2804  598C 005A  
2805  598E 2000         DATA    >2000                   save R2
2806  5990 0429 H199    BLWP    @>005A(R9)                      
2806  5992 005A  
2807  5994 3100         DATA    >3100                   save R2, R3, R7
2808  5996 06A0         BL      @CALSUB                 call subroutine
2808  5998 4344  
2809  599A 461E         DATA    RDOFSC                  read sector from offset in file
2810  599C 0429         BLWP    @>005A(R9)                      
2810  599E 005A  
2811  59A0 3101         DATA    >3101                   retrieve R2, R3, R7
2812  59A2 0583         INC     R3                      next sector
2813  59A4 0227         AI      R7,256                  increment VDP buffer ptr by 256 bytes
2813  59A6 0100  
2814  59A8 0602         DEC     R2                      more to do?
2815  59AA 16F2         JNE     H199                    yes
2816  59AC 0429 H200    BLWP    @>005A(R9)                      
2816  59AE 005A  
2817  59B0 2001         DATA    >2001                   retrieve R2 (# of sectors read)
2818  59B2 CA42 H201    MOV     R2,@>004C(R9)           update # of sectors in parameters
2818  59B4 004C  
2819  59B6 100A         JMP     H203                    
2820            *                                       
2821  59B8 CD00 H202    MOV     R0,*R4+                 get file info: sectors in file
2822  59BA 0648         DECT    R8                      
2823  59BC 05C2         INCT    R2                      copy 2 bytes (status + recs/sector)
2824  59BE 06A0         BL      @VDP2SP                 from VDP at R8 to file info structure
2824  59C0 5BFA  
2825  59C2 0202         LI      R2,4                    copy 4 bytes
2825  59C4 0004  
2826  59C6 A202         A       R2,R8                   
2827  59C8 06A0         BL      @VDP2SP                 eof offset, rec len, # of recs (or # of sect)
2827  59CA 5BFA  
2828  59CC 06A0 H203    BL      @CALSUB                 call subroutine
2828  59CE 4344  
2829  59D0 456A         DATA    UPDFDR                  updata FDR (+ data) if needed, read VIB
2830  59D2 04E9         CLR     @>0050(R9)              clear error flag
2830  59D4 0050  
2831  59D6 0460         B       @RTURN1                 return to caller
2831  59D8 4362  
2832            *
2833            *--------------------------------------
2834            * Subprogram >15: file raw write
2835            * --------------
2836            * >834C: drive #                                  <--- >00
2837            * >834D: # of sectors (>00=create file from info) <--- # of sectors written
2838            * >834E: ptr to filename
2839            * >8350: file info buffer (>83xx)                 <--- error code
2840            *                              |
2841            * >83xx  : VDP buffer       <--'
2842            * >83xx+2: first sector # (total # of sectors when creating file)
2843            * >83xx+4: status flag
2844            * >83xx+5: recs/sector
2845            * >83xx+6: eof offset
2846            * >83xx+7: rec size
2847            * >83xx+8: # of recs
2848            *--------------------------------------                                 
2849            *
2850  59DA C1CB ESUB06  MOV     R11,R7                  
2851  59DC 06A0         BL      @PRPFDO                 prepare disk operations
2851  59DE 4418  
2852  59E0 06A0         BL      @RFNPTR                 load drive + filename, + a few info
2852  59E2 5BA0  
2853  59E4 1314         JEQ     H205                    sectors to write=0: create file
2854  59E6 06A0         BL      @FFFDR                  find file FDR
2854  59E8 5BC6  
2855  59EA 0429         BLWP    @>005A(R9)                      
2855  59EC 005A  
2856  59EE 2000         DATA    >2000                   save R2 (# of sectors to write)
2857  59F0 0429 H204    BLWP    @>005A(R9)                      
2857  59F2 005A  
2858  59F4 3100         DATA    >3100                   save R2, R3, R7
2859  59F6 06A0         BL      @CALSUB                 call subroutine
2859  59F8 4344  
2860  59FA 463E         DATA    WROFSC                  write sector from offset in file
2861  59FC 0429         BLWP    @>005A(R9)                      
2861  59FE 005A  
2862  5A00 3101         DATA    >3101                   retrieve R2, R3, R7
2863  5A02 0583         INC     R3                      next sector
2864  5A04 0227         AI      R7,256                  increment VDP ptr by 256 bytes
2864  5A06 0100  
2865  5A08 0602         DEC     R2                      more to do?
2866  5A0A 16F2         JNE     H204                    yes
2867  5A0C 10CF         JMP     H200                    update # of sectors written, in param. Then return
2868            *                               
2869  5A0E 06A0 H205    BL      @CALSUB                 create file
2869  5A10 4344  
2870  5A12 4AB8         DATA    FFDRVB                  find file FDR in VDP buffers
2871  5A14 06A0         BL      @CALSUB                 call subroutine
2871  5A16 4344  
2872  5A18 4AFC         DATA    FFDROD                  find file FDR on disk
2873  5A1A 06A0         BL      @CALSUB                 call subroutine
2873  5A1C 4344  
2874  5A1E 448A         DATA    CRFIL2                  create file
2875  5A20 0429         BLWP    @>005A(R9)                      
2875  5A22 005A  
2876  5A24 0801         DATA    >0801                   retrieve R4 (file info ptr)
2877  5A26 C229         MOV     @>0056(R9),R8           FDR ptr
2877  5A28 0056  
2878  5A2A 05C4         INCT    R4                      skip 2 bytes
2879  5A2C C0F4         MOV     *R4+,R3                 # of sector to create
2880  5A2E 0228         AI      R8,10                   skip filename
2880  5A30 000A  
2881  5A32 06A0         BL      @SP2VDP                 write 2 bytes in VDP at R8+2
2881  5A34 5C0A  
2882  5A36 0002         DATA    2                       i.e. status + recs/sector
2883  5A38 06A0         BL      @SP2VDP                 write 4 bytes in VDP at new R8+4
2883  5A3A 5C0A  
2884  5A3C 0004         DATA    4                       i.e. eof offset, rec len, # of recs (or # of
2885  5A3E 0603         DEC     R3                      offset = # of sectors-1 (starts from 0)
2886  5A40 1103         JLT     H206                    create an empty file, FDR only
2887  5A42 06A0         BL      @CALSUB                 
2887  5A44 4344  
2888  5A46 4654         DATA    APSCTS                  append enough sectors to reach offset
2889  5A48 0460 H206    B       @UWFLVB                 modify FDR, write it, load VIB, return
2889  5A4A 587E  
2890            *
2891            *---------------------------------------
2892            * Subprogram FILES: number of files
2893            *---------------------------------------                                        
2894  5A4C C1CB ESUB08  MOV     R11,R7                  
2895  5A4E 06A0         BL      @PRPFDO                 prepare disk operation
2895  5A50 4418  
2896  5A52 C229         MOV     @>002C(R9),R8           ptr to next basic token
2896  5A54 002C  
2897  5A56 0228         AI      R8,7                    skip FILES
2897  5A58 0007  
2898  5A5A 06A0         BL      @VDPR2B                 get next two bytes in R0
2898  5A5C 486A  
2899  5A5E 0280         CI      R0,>C801                >C8=unquoted string, size=1 char
2899  5A60 C801  
2900  5A62 161C         JNE     H207                    return (with error) if different
2901  5A64 05C8         INCT    R8                      increment pointer
2902  5A66 06A0         BL      @VDPR2B                 get next two bytes
2902  5A68 486A  
2903  5A6A 06C0         SWPB    R0                      
2904  5A6C 0220         AI      R0,>49D0                substact >B630: # of files >B6=closed parenthesis
2904  5A6E 49D0  
2905  5A70 0280         CI      R0,>0009                only 9 files allowed in Basic !
2905  5A72 0009  
2906  5A74 1B13         JH      H207                    return with error if more
2907  5A76 06C0         SWPB    R0                      
2908  5A78 DA40         MOVB    R0,@>004C(R9)           put new # of files in scratch-pad memory
2908  5A7A 004C  
2909  5A7C 06A0         BL      @CALSUB                 call subroutine
2909  5A7E 4344  
2910  5A80 5AA6         DATA    PESB07                  subprogram >16 (private entry point)
2911  5A82 DA69         MOVB    @>0050(R9),@>0050(R9)   test result
2911  5A84 0050  
2911  5A86 0050  
2912  5A88 1609         JNE     H207                    error
2913  5A8A C229         MOV     @>002C(R9),R8           ok: get ptr to Basic token
2913  5A8C 002C  
2914  5A8E 0228         AI      R8,12                   skip the whole statement
2914  5A90 000C  
2915  5A92 CA48         MOV     R8,@>002C(R9)           update ptr
2915  5A94 002C  
2916  5A96 5A69         SZCB    @>0042(R9),@>0042(R9)   clear current token
2916  5A98 0042  
2916  5A9A 0042  
2917  5A9C 0460 H207    B       @RTURN1                 return to caller (i.e. Basic)
2917  5A9E 4362  
2918            *
2919            *---------------------------------------
2920            * Subprogram >16: number of files
2921            * --------------
2922            * >834C: # of files
2923            * >8350: (n/a)      <--- error code
2924            *---------------------------------------                                        
2925            *
2926  5AA0 C1CB ESUB07  MOV     R11,R7                  entry point from assembly
2927  5AA2 06A0         BL      @PRPFDO                 prepare disk operations
2927  5AA4 4418  
2928  5AA6 04C0 PESB07  CLR     R0                      entry point from call files
2929  5AA8 D029         MOVB    @>004C(R9),R0           get # of files
2929  5AAA 004C  
2930  5AAC 1359         JEQ     H214                    return with error
2931  5AAE C229         MOV     @>0056(R9),R8           ptr to end of buffer word
2931  5AB0 0056  
2932  5AB2 0228         AI      R8,3                    point to # of files byte
2932  5AB4 0003  
2933  5AB6 04C3         CLR     R3                      
2934  5AB8 0429         BLWP    @>005A(R9)              set VDP to read
2934  5ABA 005A  
2935  5ABC 0102         DATA    >0102                   address in R8
2936  5ABE D0EF         MOVB    @-1026(R15),R3          get current # of files
2936  5AC0 FBFE  
2937  5AC2 0205         LI      R5,518                  size of 1 file control block
2937  5AC4 0206  
2938  5AC6 90C0         CB      R0,R3                   compare required with current
2939  5AC8 1348         JEQ     H213                    same: return with no error
2940  5ACA 122B         JLE     H210                    less
2941  5ACC C180         MOV     R0,R6                   more files needed
2942  5ACE 0280         CI      R0,>1000                maximum is 16
2942  5AD0 1000  
2943  5AD2 1B46         JH      H214                    return with error
2944  5AD4 6003         S       R3,R0                   how many to add
2945  5AD6 0980         SRL     R0,8                    make it a word
2946  5AD8 3805         MPY     R5,R0                   # of bytes to add
2947  5ADA C101         MOV     R1,R4                   result in R0:R1
2948  5ADC 0504         NEG     R4                      
2949  5ADE C0A9         MOV     @>0070(R9),R2           highest free address in VDP mem
2949  5AE0 0070  
2950  5AE2 C002         MOV     R2,R0                   
2951  5AE4 6001         S       R1,R0                   what it would become
2952  5AE6 0280         CI      R0,>0800                is there room enough for VDP?
2952  5AE8 0800  
2953  5AEA 113A         JLT     H214                    no: return with error
2954  5AEC C040         MOV     R0,R1                   ok: new base
2955  5AEE 0582 H208    INC     R2                      increment source ptr
2956  5AF0 0580         INC     R0                      increment destination ptr
2957  5AF2 0429         BLWP    @>005A(R9)              set VDP to read
2957  5AF4 005A  
2958  5AF6 0042         DATA    >0042                   address in R2
2959  5AF8 D0EF         MOVB    @-1026(R15),R3          get a byte
2959  5AFA FBFE  
2960  5AFC 0429         BLWP    @>005A(R9)              set VDP to write
2960  5AFE 005A  
2961  5B00 0003         DATA    >0003                   address in R0
2962  5B02 DBC3         MOVB    R3,@-2(R15)             copy a byte
2962  5B04 FFFE  
2963  5B06 8202         C       R2,R8                   did we copy the whole header?
2964  5B08 16F2         JNE     H208                    not yet
2965  5B0A 0429         BLWP    @>005A(R9)              set VDP to write
2965  5B0C 005A  
2966  5B0E 0003         DATA    >0003                   address in R0
2967  5B10 DBC6         MOVB    R6,@-2(R15)             new # of files
2967  5B12 FFFE  
2968  5B14 04C6         CLR     R6                      
2969  5B16 6080         S       R0,R2                   
2970  5B18 DBC6 H209    MOVB    R6,@-2(R15)             clear byte
2970  5B1A FFFE  
2971  5B1C 0602         DEC     R2                      
2972  5B1E 16FC         JNE     H209                    
2973  5B20 101A         JMP     H212                    
2974            *                                       
2975  5B22 0429 H210    BLWP    @>005A(R9)              less files needed
2975  5B24 005A  
2976  5B26 0103         DATA    >0103                   set VDP to write to address in R8
2977  5B28 DBC0         MOVB    R0,@-2(R15)             new # of files in buffer header
2977  5B2A FFFE  
2978  5B2C 60C0         S       R0,R3                   how many to remove
2979  5B2E 0983         SRL     R3,8                    make it a word
2980  5B30 38C5         MPY     R5,R3                   # of bytes to remove
2981  5B32 C044         MOV     R4,R1                   result in R3:R4
2982  5B34 A048         A       R8,R1                   new address for buffer header
2983  5B36 C0A9         MOV     @>0070(R9),R2           highest free address in VDP mem
2983  5B38 0070  
2984  5B3A 0429 H211    BLWP    @>005A(R9)              set VDP to read
2984  5B3C 005A  
2985  5B3E 0102         DATA    >0102                   address in R8
2986  5B40 D02F         MOVB    @-1026(R15),R0          read a byte
2986  5B42 FBFE  
2987  5B44 0429         BLWP    @>005A(R9)              set VDP to write
2987  5B46 005A  
2988  5B48 0023         DATA    >0023                   address in R1
2989  5B4A DBC0         MOVB    R0,@-2(R15)             write byte back
2989  5B4C FFFE  
2990  5B4E 0601         DEC     R1                      decrement destination ptr
2991  5B50 0608         DEC     R8                      decrement source ptr
2992  5B52 8088         C       R8,R2                   did we copy the whole header?
2993  5B54 16F2         JNE     H211                    not yet
2994            *                                       
2995  5B56 CA41 H212    MOV     R1,@>0070(R9)           new first free address                                  
2995  5B58 0070  
2996  5B5A 04E9 H213    CLR     @>0050(R9)              clear error flag
2996  5B5C 0050  
2997  5B5E 1002         JMP     H215                    
2998  5B60 0729 H214    SETO    @>0050(R9)              set error flag
2998  5B62 0050  
2999  5B64 0460 H215    B       @RTURN1                 return to caller
2999  5B66 4362  
3000            *                                       
3001  5B68 04E9 UFNCB   CLR     @>0054(R9)              write drive # and filename in compare buffer
3001  5B6A 0054  
3002  5B6C C069         MOV     @>0058(R9),R1           
3002  5B6E 0058  
3003  5B70 0221         AI      R1,256                  ptr to filename compare buffer
3003  5B72 0100  
3004  5B74 0429         BLWP    @>005A(R9)              set VDP to write
3004  5B76 005A  
3005  5B78 0023         DATA    >0023                   address in R1
3006  5B7A DBC6         MOVB    R6,@-2(R15)             write drive #
3006  5B7C FFFE  
3007  5B7E 0202 CFNFDR  LI      R2,10                   filename must be exactly 10 chars
3007  5B80 000A  
3008  5B82 0581 H216    INC     R1                      next char in compare buffer
3009  5B84 0429         BLWP    @>005A(R9)              set VDP to read
3009  5B86 005A  
3010  5B88 0002         DATA    >0002                   address in R0
3011  5B8A D0EF         MOVB    @-1026(R15),R3          get 1 char from filename
3011  5B8C FBFE  
3012  5B8E 0580         INC     R0                      next char in provided filename
3013  5B90 0429         BLWP    @>005A(R9)              set VDP to write
3013  5B92 005A  
3014  5B94 0023         DATA    >0023                   address in R1
3015  5B96 DBC3         MOVB    R3,@-2(R15)             write 1 char to compare buffer
3015  5B98 FFFE  
3016  5B9A 0602         DEC     R2                      
3017  5B9C 16F2         JNE     H216                    next char
3018  5B9E 045B         B       *R11                    
3019            *                                       
3020  5BA0 C28B RFNPTR  MOV     R11,R10                 load compare buffer and ptrs
3021  5BA2 04C6         CLR     R6                      
3022  5BA4 D1A9         MOVB    @>004C(R9),R6           drive #
3022  5BA6 004C  
3023  5BA8 C029         MOV     @>004E(R9),R0           ptr to filename
3023  5BAA 004E  
3024  5BAC 06A0         BL      @UFNCB                  write them in compare buffer
3024  5BAE 5B68  
3025  5BB0 D129         MOVB    @>0050(R9),R4           file info structure ptr
3025  5BB2 0050  
3026  5BB4 0984         SRL     R4,8                    
3027  5BB6 A109         A       R9,R4                   make it a PAB address
3028  5BB8 D029         MOVB    @>004D(R9),R0           # of sectors (>00=get file info)
3028  5BBA 004D  
3029  5BBC 0429         BLWP    @>005A(R9)                      
3029  5BBE 005A  
3030  5BC0 0800         DATA    >0800                   save R4
3031  5BC2 0980         SRL     R0,8                    
3032  5BC4 045A         B       *R10                    EQ set for get file info
3033            *                                       
3034  5BC6 0429 FFFDR   BLWP    @>005A(R9)              find file FDR
3034  5BC8 005A  
3035  5BCA 8010         DATA    >8010                   save R0 + R11
3036  5BCC 06A0         BL      @CALSUB                 call subroutine
3036  5BCE 4344  
3037  5BD0 4AB8         DATA    FFDRVB                  find file FDR in VDP buffers
3038  5BD2 06A0         BL      @CALSUB                 call subroutine
3038  5BD4 4344  
3039  5BD6 4AFC         DATA    FFDROD                  find FDR on disk
3040  5BD8 C104         MOV     R4,R4                   found ?
3041  5BDA 1303         JEQ     H217                    yes
3042  5BDC 06A0         BL      @ERROR5                 no: return with error
3042  5BDE 4966  
3043  5BE0 E000         DATA    >E000                   file error
3044  5BE2 06A0 H217    BL      @FDR2B1                 get two bytes from FDR into R0
3044  5BE4 4864  
3045  5BE6 000E         DATA    14                      # of sectors in file
3046  5BE8 0429         BLWP    @>005A(R9)                      
3046  5BEA 005A  
3047  5BEC 2011         DATA    >2011                   retrieve R0 in R2 (# of sect to read), and R11
3048  5BEE 0429         BLWP    @>005A(R9)                      
3048  5BF0 005A  
3049  5BF2 0801         DATA    >0801                   retrieve R4 (ptr to file info structure)
3050  5BF4 C1F4         MOV     *R4+,R7                 VDP buffer
3051  5BF6 C0D4         MOV     *R4,R3                  first sector
3052  5BF8 045B         B       *R11                    
3053            *                                       
3054  5BFA 0429 VDP2SP  BLWP    @>005A(R9)              copy VDP bytes to scratch-pad
3054  5BFC 005A  
3055  5BFE 0102         DATA    >0102                   read from VDP at R8
3056  5C00 DD2F H218    MOVB    @-1026(R15),*R4+        read bytes into scratch-pad at R4
3056  5C02 FBFE  
3057  5C04 0602         DEC     R2                      # of byte in R2
3058  5C06 16FC         JNE     H218                    next byte
3059  5C08 045B         B       *R11                    
3060            *                                       
3061  5C0A C0BB SP2VDP  MOV     *R11+,R2                copy scratch-pad bytes to VDP
3062  5C0C A202         A       R2,R8                   
3063  5C0E 0429         BLWP    @>005A(R9)              set VDP to write
3063  5C10 005A  
3064  5C12 0103         DATA    >0103                   address in R8 + offset in data word
3065  5C14 DBF4 H219    MOVB    *R4+,@-2(R15)           write byte from scratch-pad at R4
3065  5C16 FFFE  
3066  5C18 0602         DEC     R2                      # of bytes in R2, was in data word
3067  5C1A 16FC         JNE     H219                    next byte
3068  5C1C 045B         B       *R11    
3069            *
3070            * APEDSK99 CALL subprograms
3071            *
3072            * parameter is single digit -> 0x00
3073  5C1E 0206 PDSK    LI      R6,>0100                Protect ACOMND 
3073  5C20 0100  
3074  5C22 102F         JMP     ACLPRP                  generic prep
3075  5C24 0206 UDSK    LI      R6,>0200                Unprotect ACOMND 
3075  5C26 0200  
3076  5C28 102C         JMP     ACLPRP                  generic prep
3077  5C2A 0206 LDSK    LI      R6,>0300                List Files on DSKx ACOMND 
3077  5C2C 0300  
3078  5C2E 1029         JMP     ACLPRP                  generic prep
3079            * parameters are single digit + character string -> 1x00; ! >1300 IS RESERVED (BL NTPDT+1) ! 
3080  5C30 0206 MDSK    LI      R6,>1000                Change DSK ACOMND
3080  5C32 1000  
3081  5C34 1026         JMP     ACLPRP                  generic prep
3082  5C36 0206 NDSK    LI      R6,>1100                create new blank SS/SD DOAD image
3082  5C38 1100  
3083  5C3A 1023         JMP     ACLPRP
3084            * parameter is a charachter string -> 2x00
3085  5C3C 0206 RDSK    LI      R6,>2000                Remove DOAD from SD card ACOMND 
3085  5C3E 2000  
3086  5C40 1020         JMP     ACLPRP                  generic prep
3087  5C42 0206 FGET    LI      R6,>2100                get DOAD from FTP server ACOMND
3087  5C44 2100  
3088  5C46 101D         JMP     ACLPRP                  generic prep
3089  5C48 0206 FPUT    LI      R6,>2200                save DOAD to FTP server ACOMND 
3089  5C4A 2200  
3090  5C4C 101A         JMP     ACLPRP                  generic prep
3091  5C4E 0206 ADSR    LI      R6,>2300                load DSR and reset ACOMND
3091  5C50 2300  
3092  5C52 1017         JMP     ACLPRP                  generic prep
3093  5C54 0206 CDIR    LI      R6,>2400                change root folder
3093  5C56 2400  
3094  5C58 1014         JMP     ACLPRP                  generic prep
3095            * no parameters ->3x00
3096  5C5A 0206 SMAP    LI      R6,>3000                Show DSKx mapping ACOMND
3096  5C5C 3000  
3097  5C5E 1011         JMP     ACLPRP                  generic prep
3098  5C60 0206 LDIR    LI      R6,>3100                List SD dir ACOMND
3098  5C62 3100  
3099  5C64 100E         JMP     ACLPRP                  generic prep
3100  5C66 0206 AHLP    LI      R6,>3200                display APEDSK99 CALL()'s help screen
3100  5C68 3200  
3101  5C6A 100B         JMP     ACLPRP                  generic prep
3102  5C6C 0206 ACHR    LI      R6,>3300                load proper lowercase character set
3102  5C6E 3300  
3103  5C70 1008         JMP     ACLPRP                  generic prep
3104  5C72 0206 ARST    LI      R6,>3468                APEDSK99 reset ACOMND
3104  5C74 3468  
3105  5C76 1005         JMP     ACLPRP                  generic prep
3106  5C78 0206 TIME    LI      R6,>3500                show NTP time and date
3106  5C7A 3500  
3107  5C7C 1002         JMP     ACLPRP                  generic prep
3108  5C7E 0206 ACFG    LI      R6,>3600                APEDSK99 configuration
3108  5C80 3600  
3109            *
3110            * Generic prep and return to TI BASIC for APEDSK99 CALL's
3111            *
3112  5C82 04E0 ACLPRP  CLR     @XBASRT                 return to TI BASIC, not EXBAS
3112  5C84 404A  
3113  5C86 06C6         SWPB    R6                      get optional subcommand in MSB
3114  5C88 D806         MOVB    R6,@ASUBCM              save
3114  5C8A 5FE9  
3115  5C8C 06C6         SWPB    R6                      back to primary command
3116            *
3117  5C8E C1CB         MOV     R11,R7                  save return-to-TI BASIC address
3118  5C90 06A0         BL      @PRPFDO                 prepare TI Controller DSR operations
3118  5C92 4418  
3119            *
3120  5C94 C229         MOV     @>002C(R9),R8           ptr to next basic token
3120  5C96 002C  
3121  5C98 0228         AI      R8,4                    skip length byte and 3 chars of CALL name
3121  5C9A 0004  
3122  5C9C 06A0         BL      @VDPR2B                 get CALL last char and "(" or "0" in R0
3122  5C9E 486A  
3123  5CA0 0A80         SLA     R0,8                    only interested in LSB
3124  5CA2 130E         JEQ     NOPARM                  0 = no parameters? SMAP / LDIR / AHLP / ACHR / ARST / TIME / ACFG (and special guest LDSK)
3125            *
3126  5CA4 0228         AI      R8,2                    adjust token pointer
3126  5CA6 0002  
3127  5CA8 06A0         BL      @VDPR2B                 get next two bytes in R0
3127  5CAA 486A  
3128  5CAC 0280         CI      R0,>C801                >C8=unquoted string, size=1 char?
3128  5CAE C801  
3129  5CB0 1331         JEQ     USTRNG                  yes: PDSK / UDSK / LDSK / MDSK / NDSK
3130            *
3131  5CB2 0280         CI      R0,>C701                >C7=quoted string, minimum 1 character?
3131  5CB4 C701  
3132  5CB6 1A02         JL      ACLERR
3133  5CB8 0460         B       @QSTRNG                 yes: RDSK / FGET / FPUT / ADSR / CDIR
3133  5CBA 5DB0  
3134            *
3135  5CBC 0460 ACLERR  B       @RTURN1                 expect the unexpected                           
3135  5CBE 4362  
3136            *
3137            * SMAP / LDIR / AHLP / ACHR / ARST / TIME / ACFG (and special guest LDSK)
3138            *
3139  5CC0 0286 NOPARM  CI      R6,>0300                LDSK without parameters is handy (re-use last used DSK#)
3139  5CC2 0300  
3140  5CC4 1303         JEQ     NOPRM2
3141  5CC6 0286         CI      R6,>3000                catch other CALL's without parameters -> error
3141  5CC8 3000  
3142  5CCA 1AF8         JL      ACLERR
3143            *
3144  5CCC D820 NOPRM2  MOVB    @LSTDRV,@CALLBF         get last drive accessed (LDSK without parameters)
3144  5CCE 5FC7  
3144  5CD0 5FC8  
3145  5CD2 D806         MOVB    R6,@ACOMND              execute LDSK / ACHR / ARST / TIME / ACFG
3145  5CD4 5FE8  
3146  5CD6 0286         CI      R6,>3300                ACHR / ARST / TIME / ACFG?      
3146  5CD8 3300  
3147  5CDA 1A3C         JL      LDSK2                   no; SMAP / LDIR / AHLP use LDSK display routine
3148            *
3149  5CDC 0208 QNOPRM  LI      R8,9                    current CALL length
3149  5CDE 0009  
3150  5CE0 0286         CI      R6,>3300                ACHR?
3150  5CE2 3300  
3151  5CE4 1306         JEQ     ACHR2                   yes; get some real characters
3152  5CE6 0286         CI      R6,>0300                LDSK()?
3152  5CE8 0300  
3153  5CEA 1602         JNE     A9901                   nope; exit with CALL lenght 9 for SMAP / LDIR / AHLP / ARST / TIME / ACFG
3154  5CEC 0228         AI      R8,3                    yep;  exit with CALL length 12 for LDSK
3154  5CEE 0003  
3155            *
3156  5CF0 1030 A9901   JMP     A9904
3157            *
3158  5CF2 9820 ACHR2   CB      @INT2FP+2,@CALLST
3158  5CF4 57DA  
3158  5CF6 5FC6  
3159  5CF8 132C         JEQ     A9904                   >08; no char definition file found
3160            *
3161  5CFA C0A0         MOV     @PATTBL,R2              get start of <SPACE> pattern table entry (default >0400 for TI BASIC)
3161  5CFC 4044  
3162  5CFE 06A0         BL      @VDPWRI                 set VPD address
3162  5D00 4322  
3163            *                       
3164  5D02 06A0 A9902   BL      @DISSTS                 use existing display routine to write 4 definitions at a time
3164  5D04 5E5A  
3165  5D06 9820         CB      @K004,@CALLST           check Arduino ACHR return code
3165  5D08 4340  
3165  5D0A 5FC6  
3166  5D0C 1322         JEQ     A9904                   we're done
3167  5D0E 05A0         INC     @RDINT                  generates interrupt for next lot
3167  5D10 5FEA  
3168  5D12 10F7         JMP     A9902                   again
3169            *
3170            * PDSK / UDSK / LDSK / MDSK / NDSK
3171            *
3172  5D14 0286 USTRNG  CI      R6,>2000                only PDSK / UDSK / LDSK / MDSK / NDSK?
3172  5D16 2000  
3173  5D18 14D1         JHE     ACLERR                  no -> sneaky other commands don't belong here
3174  5D1A 05C8         INCT    R8                      increment pointer
3175  5D1C 06A0         BL      @VDPR2B                 get next two bytes              
3175  5D1E 486A  
3176            *
3177  5D20 06C0         SWPB    R0
3178  5D22 0220         AI      R0,>49D0                add 2's complement of >B630: MSB = >B3 / "," or >B6 / ")", LSB= # of files 
3178  5D24 49D0  
3179  5D26 1502         JGT     A9903                   >B6
3180  5D28 0220         AI      R0,768                  >B3, adjust R0 to positive range
3180  5D2A 0300  
3181            *
3182  5D2C 13C7 A9903   JEQ     ACLERR                  DSK0 not valid, * INCORRECT COMMAND
3183  5D2E 0280         CI      R0,3                    only 3 DSK's allowed
3183  5D30 0003  
3184  5D32 1BC4         JH      ACLERR                  DSK4+, * INCORRECT COMMAND
3185            *
3186  5D34 06C0         SWPB    R0
3187  5D36 D800         MOVB    R0,@CALLBF              save DSKx
3187  5D38 5FC8  
3188  5D3A D800         MOVB    R0,@LSTDRV              remember last drive accessed for LDSK without parameter
3188  5D3C 5FC7  
3189            *
3190  5D3E 0286         CI      R6,>1000                MDSK or NDSK?
3190  5D40 1000  
3191  5D42 1433         JHE     MNDSK2                  yep
3192            *
3193  5D44 D806 XBUSTR  MOVB    R6,@ACOMND              send PDSK / UDSK / LDSK command to Arduino
3193  5D46 5FE8  
3194            
3195  5D48 0286         CI      R6,>0300                LDSK?
3195  5D4A 0300  
3196  5D4C 1303         JEQ     LDSK2                   yep
3197            *
3198  5D4E 0208 PUDSK2  LI      R8,12                   CALL length
3198  5D50 000C  
3199  5D52 1054 A9904   JMP     ACLBAS                  return to BASIC         
3200            *                       
3201  5D54 9820 LDSK2   CB      @K002,@CALLST
3201  5D56 433E  
3201  5D58 5FC6  
3202  5D5A 13C0         JEQ     QNOPRM                  LDSK: >00; no DOAD mapped
3203            *
3204  5D5C 04C2 NXTSCR  CLR     R2                      clear screen; position 0
3205  5D5E 06A0         BL      @VDPWRI
3205  5D60 4322  
3206            *
3207  5D62 0200         LI      R0,>8000                space + TI BASIC bias
3207  5D64 8000  
3208  5D66 06A0         BL      @VDPRPW
3208  5D68 426A  
3209  5D6A 02C0         DATA    704                     704 positions to clear
3210            *
3211  5D6C 0202         LI      R2,32                   start 2nd screen line; 1st is lost due to BASIC scroll
3211  5D6E 0020  
3212  5D70 06A0 A9905   BL      @VDPWRI                 
3212  5D72 4322  
3213            *       
3214  5D74 9820         CB      @K004,@CALLST           check Arduino LDSK / SDSK / LDIR / AHLP return code
3214  5D76 4340  
3214  5D78 5FC6  
3215  5D7A 13B0         JEQ     QNOPRM                  "More" (>F0); blank DSK or done last file / help txt
3216            *
3217  5D7C 06A0         BL      @DISSTS                 LDSK / SDSK / LDIR / AHLP output to screen
3217  5D7E 5E5A  
3218            *
3219  5D80 0222         AI      R2,32                   next screen position
3219  5D82 0020  
3220  5D84 0282         CI      R2,640                  end of display area?
3220  5D86 0280  
3221  5D88 1303         JEQ     NXTPRP                  yes; show "more" symbol
3222            *
3223  5D8A 05A0         INC     @RDINT                  generates interrupt for next file / help txt
3223  5D8C 5FEA  
3224  5D8E 10F0         JMP     A9905   
3225            *       
3226  5D90 0202 NXTPRP  LI      R2,702
3226  5D92 02BE  
3227  5D94 06A0         BL      @VDPWRI
3227  5D96 4322  
3228  5D98 0205         LI      R5,>9E00                show ">", more file / help txt to display
3228  5D9A 9E00  
3229  5D9C DBC5         MOVB    R5,@-2(R15)
3229  5D9E FFFE  
3230            *
3231  5DA0 06A0         BL      @CHKKEY
3231  5DA2 5E6C  
3232            *
3233  5DA4 05A0         INC     @RDINT                  generates interrupt for next file / help txt
3233  5DA6 5FEA  
3234  5DA8 10D9         JMP     NXTSCR
3235            *
3236            * MDSK / NDSK / RDSK / FGET / FPUT / ADSR / CDIR
3237            *
3238  5DAA 05C8 MNDSK2  INCT    R8                      increment pointer
3239  5DAC 06A0         BL      @VDPR2B                 get next two digits
3239  5DAE 486A  
3240            *
3241  5DB0 0286 QSTRNG  CI      R6,>1000                further check on RDSK / FGET / FPUT / ADSR / CDIR
3241  5DB2 1000  
3242  5DB4 1A18         JL      A9907                   no -> sneaky PDSK / UDSK don't belong here      
3243  5DB6 0220         AI      R0,>3900                add 2's complement of >C700 =  only keep # of characters
3243  5DB8 3900  
3244  5DBA 1315         JEQ     A9907                   0 characters / empty string -> * INCORRECT COMMAND
3245  5DBC 0280         CI      R0,8                    max 8 characters?
3245  5DBE 0008  
3246  5DC0 1B12         JH      A9907                   no -> * INCORRECT COMMAND
3247            *
3248  5DC2 C100         MOV     R0,R4                   save #characters
3249  5DC4 0205         LI      R5,CALLBF+2             buffer pointer to DOAD / DSR name       
3249  5DC6 5FCA  
3250  5DC8 05C8         INCT    R8                      increment pointer
3251  5DCA C088         MOV     R8,R2                   for VDPRD, address must be in R2
3252  5DCC 06A0         BL      @VDPRD                  set VDP READ address
3252  5DCE 432C  
3253  5DD0 DD6F A9906   MOVB    @-1026(R15),*R5+        get character and save in CALL buffer
3253  5DD2 FBFE  
3254  5DD4 0600         DEC     R0                      one less to go
3255  5DD6 16FC         JNE     A9906   
3256  5DD8 D560         MOVB    @K002,*R5               mark end of string with >00 (Arduino check for end of string)
3256  5DDA 433E  
3257            *
3258  5DDC D02F         MOVB    @-1026(R15),R0          get next token
3258  5DDE FBFE  
3259  5DE0 0280         CI      R0,>B600                is it a ")" ?
3259  5DE2 B600  
3260  5DE4 1302         JEQ     A9908
3261  5DE6 0460 A9907   B       @ACLERR                 * INCORRECT COMMAND
3261  5DE8 5CBC  
3262            *
3263  5DEA 0208 A9908   LI      R8,13                   prep RDSK / FGET / FPUT / ADSR / CDIR CALL length ( CALL_XXXX("") )
3263  5DEC 000D  
3264  5DEE A204         A       R4,R8                   add # of characters in string
3265                    
3266  5DF0 0286         CI      R6,>1100                MDSK or NDSK?
3266  5DF2 1100  
3267  5DF4 1B01         JH      A9909                   no; jump and execute RDSK / FGET / FPUT / ADSR / CDIR
3268  5DF6 05C8         INCT    R8                      adjust MDSK and NDSK CALL length
3269            *
3270  5DF8 D806 A9909   MOVB    R6,@ACOMND              command to Arduino
3270  5DFA 5FE8  
3271            *
3272  5DFC 9820 ACLBAS  CB      @CALLST,@K004           "More" or "AllGood" received from Arduino?      
3272  5DFE 5FC6  
3272  5E00 4340  
3273  5E02 1419         JHE     A9910                   yep
3274            *       
3275  5E04 0205         LI      R5,GPLINT               no; GPL routine
3275  5E06 006A  
3276  5E08 06A0         BL      @GPLXML                 
3276  5E0A 5EFE  
3277  5E0C 56CD         DATA    SCROLL                  scroll screen
3278  5E0E 0202         LI      R2,736                  screen starting position for (error) message
3278  5E10 02E0  
3279  5E12 06A0         BL      @VDPWRI                 set VDP address
3279  5E14 4322  
3280  5E16 06A0         BL      @DISSTS                 show (error) message
3280  5E18 5E5A  
3281  5E1A 0205         LI      R5,GPLINT               GPL routine
3281  5E1C 006A  
3282  5E1E 06A0         BL      @GPLXML 
3282  5E20 5EFE  
3283  5E22 56CD         DATA    SCROLL                  scroll screen
3284            *
3285  5E24 9820         CB      @CALLST,@K007           error (status code 0 - 9)?
3285  5E26 5FC6  
3285  5E28 433F  
3286  5E2A 1405         JHE     A9910                   no, informational; be silent    
3287            *
3288  5E2C 0205         LI      R5,GPLINT               yes: let's make some noise
3288  5E2E 006A  
3289  5E30 06A0         BL      @GPLXML
3289  5E32 5EFE  
3290  5E34 0036         DATA    HONK                    GPL routine"bad tone"
3291            *
3292  5E36 0286 A9910   CI      R6,>3500                TIME() ?
3292  5E38 3500  
3293  5E3A 132D         JEQ     TIME2                   yes; see if we can assign date/time to NTP$
3294            *
3295  5E3C 04C6 A9911   CLR     R6
3296  5E3E D1A0         MOVB    @ASUBCM,R6              any subcommand to execute?
3296  5E40 5FE9  
3297  5E42 1302         JEQ     A9912                   no
3298  5E44 D806         MOVB    R6,@ACOMND              yes; execute (currently only ARST)
3298  5E46 5FE8  
3299            *
3300  5E48 04E9 A9912   CLR     @>0050(R9)              clear error flag                
3300  5E4A 0050  
3301  5E4C AA48         A       R8, @>002C(R9)          add call length to token pointer                
3301  5E4E 002C  
3302  5E50 5A69         SZCB    @>0042(R9),@>0042(R9)   clear current token
3302  5E52 0042  
3302  5E54 0042  
3303  5E56 0460         B       @RTURN1                 return to caller (i.e. TI-BASIC)
3303  5E58 4362  
3304            *       
3305            * Display data, status messages and errors
3306            *
3307  5E5A 0205 DISSTS  LI      R5,CALLBF               start of file name buffer
3307  5E5C 5FC8  
3308  5E5E 0206         LI      R6,32                   32 bytes / 1 screen row of data to display
3308  5E60 0020  
3309  5E62 DBF5 A9913   MOVB    *R5+,@-2(R15)           store character in VDP screen memory
3309  5E64 FFFE  
3310  5E66 0606         DEC     R6
3311  5E68 16FC         JNE     A9913
3312  5E6A 045B         B       *R11
3313            *
3314            * Quick key test to display next screen after ">"
3315            * Keyboard column 0 (= space enter <nc> fctn shift ctrl <nc>)
3316            * Code copy from Thierry's TI's Tech Pages site
3317            *
3318  5E6C C10C CHKKEY  MOV     R12,R4                  save R12
3319  5E6E 04C1         CLR     R1                      test column 0
3320  5E70 020C         LI      R12,>0024               address for column selection
3320  5E72 0024  
3321  5E74 30C1 A9914   LDCR    R1,3                    select column
3322  5E76 1FF2         TB      -14                     test R12 address >0008
3323  5E78 1607         JNE     A9915                   <SPACE>
3324  5E7A 1FF3         TB      -13                     test R12 address >000A
3325  5E7C 13FB         JEQ     A9914                   no key; test again
3326            *
3327  5E7E D820         MOVB    @K004,@CALLST           signal ENTER to LDIR() command
3327  5E80 4340  
3327  5E82 5FC6  
3328  5E84 020B         LI      R11,QNOPRM              leave without clearing screen
3328  5E86 5CDC  
3329            *
3330  5E88 C304 A9915   MOV     R4,R12                  restore R12
3331  5E8A 0A24         SLA     R4,2                    debounce delay
3332  5E8C 0604 A9916   DEC     R4                      key debounce
3333  5E8E 16FE         JNE     A9916                   debounce some more
3334            *
3335  5E90 045B         B       *R11                    we got one; return for next screen
3336            *
3337            * prep for calling XML >16 and update BASIC variable NTP$               
3338            *
3339  5E92 4E54 VARINF  TEXT    'NTP$'
3339  5E94 5024  
3340  5E96 0204 TIME2   LI      R4,VARINF               variable name for XML >16 in FAC
3340  5E98 5E92  
3341  5E9A C149         MOV     R9,R5                   get scratchpad start address
3342  5E9C D974 A9917   MOVB    *R4+,@>004A(R5)         variable name in FAC
3342  5E9E 004A  
3343  5EA0 0585         INC     R5
3344  5EA2 0284         CI      R4,VARINF+4             done all chars?
3344  5EA4 5E96  
3345  5EA6 16FA         JNE     A9917                   
3346            *
3347  5EA8 0205         LI      R5,>0400                variable length for XML >16 in @>8359
3347  5EAA 0400  
3348  5EAC DA45         MOVB    R5,@>0059(R9)           
3348  5EAE 0059  
3349  5EB0 04E9         CLR     @>0089(R9)      
3349  5EB2 0089  
3350            *
3351  5EB4 0205         LI      R5,XML16                ROM routine: find NTP$ in VDP symbol table (returns to GPL interpreter)
3351  5EB6 15D6  
3352  5EB8 06A0         BL      @GPLXML
3352  5EBA 5EFE  
3353  5EBC 2244         DATA    XMLRTN                  GPL "RTN", escaping GPL interpreter
3354            *
3355  5EBE 9A60         CB      @VARINF,@>004A(R9)      found NTP$ in VDP symbol table?
3355  5EC0 5E92  
3355  5EC2 004A  
3356  5EC4 1318         JEQ     A9919                   no symbol table pointer; back to BASIC
3357            *
3358  5EC6 06A0         BL      @XML14                  ROM routine: get NTP$ VDP address and string length (returns through RT)
3358  5EC8 164E  
3359  5ECA 02A9         STWP    R9                      restore scratchpad pointer
3360  5ECC 0229         AI      R9,-224
3360  5ECE FF20  
3361            *       
3362  5ED0 C169         MOV     @>0050(R9),R5           get string length
3362  5ED2 0050  
3363  5ED4 0285         CI      R5,16                   16 chars?
3363  5ED6 0010  
3364  5ED8 160E         JNE     A9919                   no NTP$ assignment for you
3365            *
3366  5EDA C0A0         MOV     @>834E,R2               yes
3366  5EDC 834E  
3367  5EDE 06A0         BL      @VDPWRI                 set VDP write address
3367  5EE0 4322  
3368  5EE2 0205         LI      R5,CALLBF               CALL TIME data still in buffer
3368  5EE4 5FC8  
3369  5EE6 D0B5 A9918   MOVB    *R5+,R2                 read character
3370  5EE8 0222         AI      R2,>A000                remove TI BASIC bias
3370  5EEA A000  
3371  5EEC DBC2         MOVB    R2,@-2(R15)             save to NTP$ value space
3371  5EEE FFFE  
3372  5EF0 0285         CI      R5,CALLBF+16            done all 16 chars?
3372  5EF2 5FD8  
3373  5EF4 16F8         JNE     A9918                   no; one more
3374            *
3375  5EF6 10A2 A9919   JMP     A9911                   yes; back to BASIC
3376            *
3377            * execute GROM or XML routine (SCROLL, "bad sound" / HONK and XML >16)
3378            * DSR and GPL interpreter use same workspace (>83E0) so we need to save a few things
3379            *
3380  5EF8 0000 SAVGRA  BSS     2                       save current GROM address so we can return to BASIC
3381  5EFA 0000 SAVR11  BSS     2                       GPL interpreter uses R11
3382  5EFC 0000 SAVMEX  BSS     2                       save current >A018 value
3383            *
3384  5EFE D820 GPLXML  MOVB    @>9802,@SAVGRA          save current GROM address
3384  5F00 9802  
3384  5F02 5EF8  
3385  5F04 1000         NOP
3386  5F06 D820         MOVB    @>9802,@SAVGRA+1
3386  5F08 9802  
3386  5F0A 5EF9  
3387  5F0C 0620         DEC     @SAVGRA                 GRMWA returns address + 1; decrease for correct address
3387  5F0E 5EF8  
3388            *
3389  5F10 D83B         MOVB    *R11+,@>9C02            set GPL routine address
3389  5F12 9C02  
3390  5F14 1000         NOP
3391  5F16 D83B         MOVB    *R11+,@>9C02
3391  5F18 9C02  
3392  5F1A C80B         MOV     R11,@SAVR11             save final DSR return address
3392  5F1C 5EFA  
3393            *
3394  5F1E C820         MOV     @RTNBC,@SAVMEX          save >A018
3394  5F20 A018  
3394  5F22 5EFC  
3395  5F24 020B         LI      R11,GXRTN               DSR return address after GPL routine
3395  5F26 5F40  
3396  5F28 C80B         MOV     R11,@RTNBC              @>A018 is where XML >BC returns to
3396  5F2A A018  
3397            *
3398  5F2C 05E0         INCT    @>8373                  increase stack pointer
3398  5F2E 8373  
3399  5F30 06C9         SWPB    R9                      
3400  5F32 D260         MOVB    @>8373,R9
3400  5F34 8373  
3401  5F36 06C9         SWPB    R9                      complete stack pointer in R9
3402  5F38 020B         LI      R11,XMLBC               GROM pointer to >0FBC (= XML >BC)
3402  5F3A 4409  
3403  5F3C C64B         MOV     R11,*R9                 save GROM pointer on stack
3404            *
3405  5F3E 0455         B       *R5                     execute GROM/ROM routine, return through GPL interpreter
3406            *
3407  5F40 D820 GXRTN   MOVB    @SAVGRA,@>9C02          and ... we're back; restore saved GROM address
3407  5F42 5EF8  
3407  5F44 9C02  
3408  5F46 1000         NOP
3409  5F48 D820         MOVB    @SAVGRA+1,@>9C02
3409  5F4A 5EF9  
3409  5F4C 9C02  
3410            *
3411  5F4E C820         MOV     @SAVMEX,@RTNBC          restore original >A018 value
3411  5F50 5EFC  
3411  5F52 A018  
3412            *
3413  5F54 02A9         STWP    R9                      restore scratchpad pointer
3414  5F56 0229         AI      R9,-224
3414  5F58 FF20  
3415            *
3416  5F5A C2E0         MOV     @SAVR11,R11             restore R11
3416  5F5C 5EFA  
3417  5F5E 045B         B       *R11                    return to instruction after BL @GPLEXEC DATA statement
3418            *               
3419            * update FAT time/date for current DOAD after DSR Write / Format / Save
3420            *
3421  5F60 D820 NTPDT   MOVB    @NTPFAT+1,@ACOMND       "DSK NTP date/time update" command to Arduino           
3421  5F62 4027  
3421  5F64 5FE8  
3422  5F66 045B         B       *R11                    return to Format / Close
3423            *
3424            *----------------------------------------------------------------------------------
3425            * >5F68 - >5FB3: 46 free bytes remaining
3426            * >5FC2 - >5FD3 is DSK1-3 parameters storage
3427            * >5FD4 is the CALL() status byte
3428            * >5FD6 - >5FE7 is buffer storage for APEDSK99 CALL's
3429            * >5FE8 is the Arduino Command Register (TI BASIC CALL support)
3430            * Word >5FEA maps to the read counter (R6, to generate interrupts when reading data) 
3431            * Bytes >5FEE maps to the CRU emulation write register
3432            * Bytes >5FF0 to >5FFE map to the FDC emulation registers
3433            *-----------------------------------------------------------------------------------                                    
3434            *
3435  5F68 0000         END
3435            


 Assembly Complete - Errors: 0,  Warnings: 0


 ------ Symbol Listing ------

 A9901  ABS:5CF0 A9901
 A9902  ABS:5D02 A9902
 A9903  ABS:5D2C A9903
 A9904  ABS:5D52 A9904
 A9905  ABS:5D70 A9905
 A9906  ABS:5DD0 A9906
 A9907  ABS:5DE6 A9907
 A9908  ABS:5DEA A9908
 A9909  ABS:5DF8 A9909
 A9910  ABS:5E36 A9910
 A9911  ABS:5E3C A9911
 A9912  ABS:5E48 A9912
 A9913  ABS:5E62 A9913
 A9914  ABS:5E74 A9914
 A9915  ABS:5E88 A9915
 A9916  ABS:5E8C A9916
 A9917  ABS:5E9C A9917
 A9918  ABS:5EE6 A9918
 A9919  ABS:5EF6 A9919
 ACFG   ABS:5C7E ACFG
 ACHR   ABS:5C6C ACHR
 ACHR2  ABS:5CF2 ACHR2
 ACLBAS ABS:5DFC ACLBAS
 ACLERR ABS:5CBC ACLERR
 ACLPRP ABS:5C82 ACLPRP
 ACOMND ABS:5FE8 ACOMND
 ADDSEC ABS:46F8 ADDSEC
 ADSR   ABS:5C4E ADSR
 AFDRPT ABS:52BC AFDRPT
 AFPGPF ABS:51D2 AFPGPF
 AHLP   ABS:5C66 AHLP
 APSCTS ABS:4654 APSCTS
 ARST   ABS:5C72 ARST
 ASUBCM ABS:5FE9 ASUBCM
 AVERSN ABS:4046 AVERSN
 CALLBF ABS:5FC8 CALLBF
 CALLST ABS:5FC6 CALLST
 CALSUB ABS:4344 CALSUB
 CDIR   ABS:5C54 CDIR
 CFNFDR ABS:5B7E CFNFDR
 CFSVIB ABS:575A CFSVIB
 CHKKEY ABS:5E6C CHKKEY
 CLOSE  ABS:4FC4 CLOSE
 CLRFBT ABS:4576 CLRFBT
 CLSDIR ABS:5604 CLSDIR
 CMPFN  ABS:4830 CMPFN
 CPCKFN ABS:4908 CPCKFN
 CRFIL1 ABS:4484 CRFIL1
 CRFIL2 ABS:448A CRFIL2
 CRFIL3 ABS:4496 CRFIL3
 CRUWRI ABS:5FEE CRUWRI
 DECDCI ABS:4BAA DECDCI
 DELETE ABS:4762 DELETE
 DISSTS ABS:5E5A DISSTS
 DSDRVS ABS:4342 DSDRVS
 DSKPRM ABS:5FB4 DSKPRM
 DSR01  ABS:4104 DSR01
 DSR02  ABS:410C DSR02
 DSR03  ABS:4116 DSR03
 DSR04  ABS:4120 DSR04
 ECUSTM ABS:4384 ECUSTM
 EDSR01 ABS:4D40 EDSR01
 EDSR02 ABS:4D4E EDSR02
 EDSR03 ABS:4D54 EDSR03
 EDSR04 ABS:4D5A EDSR04
 EPWRUP ABS:412A EPWRUP
 ERROR1 ABS:42E0 ERROR1
 ERROR3 ABS:4212 ERROR3
 ERROR4 ABS:427E ERROR4
 ERROR5 ABS:4966 ERROR5
 ERROR6 ABS:4B1C ERROR6
 ERROR7 ABS:490C ERROR7
 ERROR8 ABS:4DAC ERROR8
 ERROR9 ABS:4DC8 ERROR9
 ERRR10 ABS:55E0 ERRR10
 ESUB01 ABS:582A ESUB01
 ESUB02 ABS:583A ESUB02
 ESUB03 ABS:5844 ESUB03
 ESUB04 ABS:589E ESUB04
 ESUB05 ABS:596A ESUB05
 ESUB06 ABS:59DA ESUB06
 ESUB07 ABS:5AA0 ESUB07
 ESUB08 ABS:5A4C ESUB08
 FDR2B1 ABS:4864 FDR2B1
 FDR2B2 ABS:4868 FDR2B2
 FDSKDR ABS:487E FDSKDR
 FFDRDK ABS:4B00 FFDRDK
 FFDRFN ABS:4B2C FFDRFN
 FFDROD ABS:4AFC FFDROD
 FFDRVB ABS:4AB8 FFDRVB
 FFDRVP ABS:51C2 FFDRVP
 FFFDR  ABS:5BC6 FFFDR
 FFFDRV ABS:4A98 FFFDRV
 FFSBM  ABS:4CB0 FFSBM
 FFSBMP ABS:4BEA FFSBMP
 FFSVIB ABS:45CE FFSVIB
 FGET   ABS:5C42 FGET
 FMTDSK ABS:4218 FMTDSK
 FNDFDR ABS:4AF6 FNDFDR
 FNDRV  ABS:5794 FNDRV
 FPUT   ABS:5C48 FPUT
 FRSCB1 ABS:4CB6 FRSCB1
 FSCTOF ABS:473E FSCTOF
 GPLINT ABS:006A GPLINT
 GPLXML ABS:5EFE GPLXML
 GXRTN  ABS:5F40 GXRTN
 H001   ABS:4150 H001
 H002   ABS:41B4 H002
 H003   ABS:41D4 H003
 H004   ABS:41E2 H004
 H005   ABS:41E6 H005
 H006   ABS:41FC H006
 H007   ABS:4234 H007
 H008   ABS:4244 H008
 H009   ABS:4252 H009
 H010   ABS:426C H010
 H011   ABS:42AC H011
 H012   ABS:42CE H012
 H013   ABS:42F2 H013
 H014   ABS:431C H014
 H015   ABS:4330 H015
 H015A  ABS:436A H015A
 H016   ABS:43A8 H016
 H017   ABS:43CC H017
 H018   ABS:43D2 H018
 H019   ABS:43F6 H019
 H020   ABS:43FA H020
 H021   ABS:440E H021
 H022   ABS:44AC H022
 H023   ABS:4504 H023
 H024   ABS:4520 H024
 H025   ABS:4536 H025
 H026   ABS:4540 H026
 H027   ABS:4552 H027
 H028   ABS:4560 H028
 H029   ABS:4566 H029
 H030   ABS:459E H030
 H031   ABS:45CA H031
 H032   ABS:45EC H032
 H033   ABS:45F6 H033
 H034   ABS:461A H034
 H035   ABS:462E H035
 H036   ABS:4638 H036
 H037   ABS:4664 H037
 H038   ABS:4678 H038
 H039   ABS:468A H039
 H040   ABS:46C0 H040
 H041   ABS:46C4 H041
 H042   ABS:46CC H042
 H043   ABS:46CE H043
 H044   ABS:46DC H044
 H045   ABS:46EC H045
 H046   ABS:46F4 H046
 H047   ABS:473C H047
 H048   ABS:4748 H048
 H049   ABS:4752 H049
 H050   ABS:475E H050
 H051   ABS:477A H051
 H052   ABS:4790 H052
 H053   ABS:479C H053
 H054   ABS:47E0 H054
 H055   ABS:4810 H055
 H056   ABS:4838 H056
 H057   ABS:485C H057
 H058   ABS:4896 H058
 H059   ABS:48A0 H059
 H060   ABS:48A8 H060
 H061   ABS:48F6 H061
 H062   ABS:48FE H062
 H063   ABS:4912 H063
 H064   ABS:4920 H064
 H065   ABS:492C H065
 H066   ABS:495C H066
 H067   ABS:4990 H067
 H068   ABS:49B2 H068
 H069   ABS:49B6 H069
 H070   ABS:49EE H070
 H071   ABS:4A02 H071
 H072   ABS:4A12 H072
 H073   ABS:4A1C H073
 H074   ABS:4A72 H074
 H075   ABS:4A82 H075
 H076   ABS:4A88 H076
 H077   ABS:4A90 H077
 H078   ABS:4AB4 H078
 H079   ABS:4AD2 H079
 H080   ABS:4AF2 H080
 H081   ABS:4B08 H081
 H082   ABS:4B22 H082
 H083   ABS:4B38 H083
 H084   ABS:4B9A H084
 H085   ABS:4B9E H085
 H086   ABS:4BA4 H086
 H087   ABS:4BFE H087
 H088   ABS:4C10 H088
 H089   ABS:4C20 H089
 H090   ABS:4C2C H090
 H091   ABS:4C52 H091
 H092   ABS:4C5C H092
 H093   ABS:4C64 H093
 H094   ABS:4C8A H094
 H095   ABS:4CA6 H095
 H096   ABS:4CE2 H096
 H097   ABS:4CF0 H097
 H098   ABS:4CF2 H098
 H099   ABS:4CF6 H099
 H100   ABS:4CF8 H100
 H101   ABS:4D20 H101
 H102   ABS:4D28 H102
 H103   ABS:4D5E H103
 H104   ABS:4D64 H104
 H105   ABS:4D8A H105
 H106   ABS:4DCE H106
 H107   ABS:4DE4 H107
 H108   ABS:4DF0 H108
 H109   ABS:4E22 H109
 H110   ABS:4E3A H110
 H111   ABS:4E3E H111
 H112   ABS:4E94 H112
 H113   ABS:4E98 H113
 H114   ABS:4EBC H114
 H115   ABS:4EC0 H115
 H116   ABS:4EE4 H116
 H117   ABS:4F12 H117
 H118   ABS:4F6A H118
 H119   ABS:4F90 H119
 H120   ABS:4F94 H120
 H121   ABS:4FDA H121
 H122   ABS:4FDE H122
 H123   ABS:4FEA H123
 H124   ABS:4FF0 H124
 H125   ABS:4FF8 H125
 H126   ABS:501A H126
 H127   ABS:5034 H127
 H128   ABS:5050 H128
 H129   ABS:505E H129
 H130   ABS:5082 H130
 H131   ABS:508A H131
 H132   ABS:50AE H132
 H133   ABS:50EC H133
 H134   ABS:50F4 H134
 H135   ABS:50FE H135
 H136   ABS:5114 H136
 H137   ABS:512A H137
 H138   ABS:519A H138
 H139   ABS:520E H139
 H140   ABS:522E H140
 H141   ABS:5234 H141
 H142   ABS:5290 H142
 H143   ABS:52A0 H143
 H144   ABS:5388 H144
 H145   ABS:53BC H145
 H146   ABS:53CA H146
 H147   ABS:53D0 H147
 H148   ABS:540E H148
 H149   ABS:5412 H149
 H150   ABS:5430 H150
 H151   ABS:543C H151
 H152   ABS:545E H152
 H153   ABS:546E H153
 H154   ABS:54E4 H154
 H155   ABS:5510 H155
 H156   ABS:551E H156
 H157   ABS:552A H157
 H158   ABS:5536 H158
 H159   ABS:554C H159
 H160   ABS:555E H160
 H161   ABS:5578 H161
 H162   ABS:557C H162
 H163   ABS:558C H163
 H164   ABS:5590 H164
 H165   ABS:55B4 H165
 H166   ABS:55BA H166
 H167   ABS:55CA H167
 H168   ABS:55E6 H168
 H169   ABS:55F0 H169
 H170   ABS:564A H170
 H171   ABS:56AC H171
 H172   ABS:56B6 H172
 H173   ABS:56BC H173
 H174   ABS:56C4 H174
 H175   ABS:56C6 H175
 H176   ABS:56E4 H176
 H177   ABS:56F4 H177
 H178   ABS:5716 H178
 H179   ABS:571E H179
 H180   ABS:576A H180
 H181   ABS:5780 H181
 H182   ABS:5784 H182
 H183   ABS:578A H183
 H184   ABS:578E H184
 H185   ABS:57B6 H185
 H186   ABS:57C6 H186
 H187   ABS:57D0 H187
 H188   ABS:57FA H188
 H189   ABS:5802 H189
 H190   ABS:5804 H190
 H191   ABS:580A H191
 H192   ABS:580C H192
 H193   ABS:5820 H193
 H194   ABS:58CE H194
 H195   ABS:5960 H195
 H196   ABS:5966 H196
 H197   ABS:5984 H197
 H198   ABS:598A H198
 H199   ABS:5990 H199
 H200   ABS:59AC H200
 H201   ABS:59B2 H201
 H202   ABS:59B8 H202
 H203   ABS:59CC H203
 H204   ABS:59F0 H204
 H205   ABS:5A0E H205
 H206   ABS:5A48 H206
 H207   ABS:5A9C H207
 H208   ABS:5AEE H208
 H209   ABS:5B18 H209
 H210   ABS:5B22 H210
 H211   ABS:5B3A H211
 H212   ABS:5B56 H212
 H213   ABS:5B5A H213
 H214   ABS:5B60 H214
 H215   ABS:5B64 H215
 H216   ABS:5B82 H216
 H217   ABS:5BE2 H217
 H218   ABS:5C00 H218
 H219   ABS:5C14 H219
 HONK   ABS:0036 HONK
 INSFDR ABS:47FE INSFDR
 INT2FP ABS:57D8 INT2FP
 K001   ABS:4198 K001
 K002   ABS:433E K002
 K004   ABS:4340 K004
 K005   ABS:4341 K005
 K007   ABS:433F K007
 K013   ABS:42F0 K013
 K014   ABS:4964 K014
 LASTRK ABS:42FE LASTRK
 LDIR   ABS:5C60 LDIR
 LDSK   ABS:5C2A LDSK
 LDSK2  ABS:5D54 LDSK2
 LOAD   ABS:53C0 LOAD
 LSTDRV ABS:5FC7 LSTDRV
 MDSK   ABS:5C30 MDSK
 MNDSK2 ABS:5DAA MNDSK2
 NDSK   ABS:5C36 NDSK
 NOCRU  ABS:4196 NOCRU
 NOPARM ABS:5CC0 NOPARM
 NOPRM2 ABS:5CCC NOPRM2
 NTPDT  ABS:5F60 NTPDT
 NTPFAT ABS:4026 NTPFAT
 NXTPRP ABS:5D90 NXTPRP
 NXTSCR ABS:5D5C NXTSCR
 OPCVEC ABS:4D92 OPCVEC
 OPEN   ABS:4DB2 OPEN
 OPNDIR ABS:55A6 OPNDIR
 PABR2B ABS:485E PABR2B
 PATTBL ABS:4044 PATTBL
 PDSK   ABS:5C1E PDSK
 PESB07 ABS:5AA6 PESB07
 PRFDRS ABS:4F72 PRFDRS
 PRPFDO ABS:4418 PRPFDO
 PRPRTN ABS:441A PRPRTN
 PUDSK2 ABS:5D4E PUDSK2
 PWRUP  ABS:40FE PWRUP
 QNOPRM ABS:5CDC QNOPRM
 QSTRNG ABS:5DB0 QSTRNG
 R0     ABS:0000 R0
 R1     ABS:0001 R1
 R10    ABS:000A R10
 R11    ABS:000B R11
 R12    ABS:000C R12
 R13    ABS:000D R13
 R14    ABS:000E R14
 R15    ABS:000F R15
 R2     ABS:0002 R2
 R3     ABS:0003 R3
 R4     ABS:0004 R4
 R5     ABS:0005 R5
 R6     ABS:0006 R6
 R7     ABS:0007 R7
 R8     ABS:0008 R8
 R9     ABS:0009 R9
 RBANB  ABS:54B2 RBANB
 RCOFCB ABS:5342 RCOFCB
 RDATA  ABS:5FF6 RDATA
 RDDIR  ABS:561A RDDIR
 RDFDR1 ABS:4A3E RDFDR1
 RDFDR2 ABS:4A3A RDFDR2
 RDINT  ABS:5FEA RDINT
 RDOFSC ABS:461E RDOFSC
 RDSEC1 ABS:4A28 RDSEC1
 RDSK   ABS:5C3C RDSK
 READ   ABS:4FCE READ
 RETERR ABS:4992 RETERR
 RFDRST ABS:51EE RFDRST
 RFDRVB ABS:5946 RFDRVB
 RFNPTR ABS:5BA0 RFNPTR
 RMFPTR ABS:47CE RMFPTR
 RNFISE ABS:524C RNFISE
 RRFDR  ABS:5268 RRFDR
 RRNPAB ABS:5202 RRNPAB
 RRSEC  ABS:5054 RRSEC
 RSTAT  ABS:5FF0 RSTAT
 RSTDRV ABS:42B2 RSTDRV
 RTNBC  ABS:A018 RTNBC
 RTURN1 ABS:4362 RTURN1
 RVRVDP ABS:43D0 RVRVDP
 RWIND1 ABS:536C RWIND1
 RWIND2 ABS:539A RWIND2
 RWSEC  ABS:4A42 RWSEC
 RWSECA ABS:4A44 RWSECA
 RWSECB ABS:4A46 RWSECB
 RWVIB  ABS:49C6 RWVIB
 SAVE   ABS:5462 SAVE
 SAVGRA ABS:5EF8 SAVGRA
 SAVMEX ABS:5EFC SAVMEX
 SAVR11 ABS:5EFA SAVR11
 SCROLL ABS:56CD SCROLL
 SECRW1 ABS:419A SECRW1
 SELDRV ABS:4284 SELDRV
 SMAP   ABS:5C5A SMAP
 SNDCMD ABS:42F6 SNDCMD
 SP2VDP ABS:5C0A SP2VDP
 STATUS ABS:54E6 STATUS
 SUB01  ABS:4010 SUB01
 SUB02  ABS:4016 SUB02
 SUB03  ABS:401C SUB03
 SUB04  ABS:4022 SUB04
 SUB05  ABS:4028 SUB05
 SUB06  ABS:402E SUB06
 SUB07  ABS:4034 SUB07
 SUB08  ABS:403A SUB08
 SUB09  ABS:4054 SUB09
 SUB10  ABS:405E SUB10
 SUB11  ABS:4068 SUB11
 SUB12  ABS:4072 SUB12
 SUB13  ABS:407C SUB13
 SUB14  ABS:4086 SUB14
 SUB15  ABS:4090 SUB15
 SUB16  ABS:409A SUB16
 SUB17  ABS:40A4 SUB17
 SUB18  ABS:40AE SUB18
 SUB19  ABS:40B8 SUB19
 SUB20  ABS:40C2 SUB20
 SUB21  ABS:40CC SUB21
 SUB22  ABS:40D6 SUB22
 SUB23  ABS:40E0 SUB23
 SUB24  ABS:40EA SUB24
 SUB25  ABS:40F4 SUB25
 SVDPRD ABS:4406 SVDPRD
 SVDPWR ABS:43FC SVDPWR
 SVRVDP ABS:43A4 SVRVDP
 TIME   ABS:5C78 TIME
 TIME2  ABS:5E96 TIME2
 UCOFCB ABS:52E0 UCOFCB
 UDSK   ABS:5C24 UDSK
 UFNCB  ABS:5B68 UFNCB
 UPDBF  ABS:458A UPDBF
 UPDCLI ABS:4BC6 UPDCLI
 UPDFCB ABS:4F9C UPDFCB
 UPDFDR ABS:456A UPDFDR
 URFFDR ABS:530C URFFDR
 USTRNG ABS:5D14 USTRNG
 UWFLVB ABS:587E UWFLVB
 VARINF ABS:5E92 VARINF
 VDP2SP ABS:5BFA VDP2SP
 VDPR2B ABS:486A VDPR2B
 VDPRD  ABS:432C VDPRD
 VDPRPW ABS:426A VDPRPW
 VDPWRI ABS:4322 VDPWRI
 VECRTN ABS:439C VECRTN
 WCOMND ABS:5FF8 WCOMND
 WDATA  ABS:5FFE WDATA
 WFDRPB ABS:5030 WFDRPB
 WRFDR  ABS:4A34 WRFDR
 WRITE  ABS:50B8 WRITE
 WROFSC ABS:463E WROFSC
 WRSEC1 ABS:4A2A WRSEC1
 WSECTR ABS:5FFC WSECTR
 WTCPT1 ABS:4276 WTCPT1
 XBASRT ABS:404A XBASRT
 XBJUMP ABS:404E XBJUMP
 XBPFDO ABS:404C XBPFDO
 XBUSTR ABS:5D44 XBUSTR
 XML14  ABS:164E XML14
 XML16  ABS:15D6 XML16
 XMLBC  ABS:4409 XMLBC
 XMLRTN ABS:2244 XMLRTN
