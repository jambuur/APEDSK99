Asm994a TMS99000 Assembler - v3.010

                * Asm994a Generated Register Equates
                *
      0000 0000 R0      EQU     0 
      0000 0001 R1      EQU     1 
      0000 0002 R2      EQU     2 
      0000 0003 R3      EQU     3 
      0000 0004 R4      EQU     4 
      0000 0005 R5      EQU     5 
      0000 0006 R6      EQU     6 
      0000 0007 R7      EQU     7 
      0000 0008 R8      EQU     8 
      0000 0009 R9      EQU     9 
      0000 000A R10     EQU     10
      0000 000B R11     EQU     11
      0000 000C R12     EQU     12
      0000 000D R13     EQU     13
      0000 000E R14     EQU     14
      0000 000F R15     EQU     15
                *
   1            *===============================================================================================================
   2            * TI DISK CONTROLLER ROM   >4000-5FFF
   3            * 
   4            * initial commented disassembly by Thierry Nouspikel
   5            * (see http://www.unige.ch/medecine/nouspikel/ti99/titechpages.htm)
   6            *
   7            * and
   8            * 
   9            * Monty Schmidt's book: TI Technical Drive
  10            *
  11            * adapted for APEDSK99 by Jochen Buur
  12            * github.com/jambuur/APEDSK99
  13            *
  14            * v12s: support for Double Density / 80 tracks (max 1440 AU's); CALL LINK for XB, E/A and MM
  15            *================================================================================================================
  16  0000 5FB4 DSKPRM  EQU     >5FB4                   per DSKx: Mbyte #sectors, Lbyte #sectors, #sectors/track, #tracks, #sides
  17  0000 5FC6 CALLST  EQU     >5FC6                   CALL() execution status: finished, still active, error
  18  0000 5FC7 LSTDRV  EQU     >5FC7                   remember last drive accessed for LDSK without argument
  19  0000 5FC8 CALLBF  EQU     >5FC8                   2-way buffer for TI BASIC CALL's (1 screen line, 32 characters)
  20  0000 5FE8 ACOMND  EQU     >5FE8                   APEDSK99-specific Command register
  21  0000 5FE9 ASUBCM  EQU     >5FE9                   APEDSK99-specific SubCommand register
  22  0000 5FEA RDINT   EQU     >5FEA                   issue read interrupt
  23  0000 5FEE CRUWRI  EQU     >5FEE                   emulated 8 CRU output bits
  24  0000 5FF0 RSTAT   EQU     >5FF0                   read FD1771 Status register
  25  0000 5FF6 RDATA   EQU     >5FF6                   read FD1771 Data register
  26  0000 5FF8 WCOMND  EQU     >5FF8                   write FD1771 Command register
  27  0000 5FFC WSECTR  EQU     >5FFC                   write FD1771 Sector register
  28  0000 5FFE WDATA   EQU     >5FFE                   write FD1771 Data register
  29            *
  30  0000 164E XML14   EQU     >164E                   ROM address for XML >14
  31  0000 15D6 XML16   EQU     >15D6                   ROM address for XML >16
  32            *
  33  0000 4409 XMLBC   EQU     >4409                   GROM address for XML >BC 
  34  0000 A018 RTNBC   EQU     >A018                   return address for XML >BC in high memory expansion
  35            *
  36  0000 006A GPLINT  EQU     >006A                   jump to GROM interpreter for SCROLL / HONK
  37  0000 2244 XMLRTN  EQU     >2244                   jump to GROM interpreter for RTN (after executing XML >14 / >16 routine)
  38  0000 56CD SCROLL  EQU     >56CD                   GROM address for scroll routine
  39  0000 0036 HONK    EQU     >0036                   GROM address for bad sound / HONK routine
  40            *
  41                    AORG    >4000                   DSR memory block
  42            *
  43  4000 AA           BYTE    >AA                     standard header mark
  44  4001 02           BYTE    >02                     version 2
  45  4002 0000         DATA    >0000                   no programs
  46  4004 40FE         DATA    PWRUP                   power-up chain ptr
  47  4006 0000         DATA    >0000                   programs chain ptr (none)
  48  4008 4104         DATA    DSR01                   DSR chain ptr
  49  400A 4010         DATA    SUB01                   subprograms chain ptr
  50  400C 0000         DATA    >0000                   ISR chain ptr (none)
  51  400E 0000         DATA    >0000                   
  52            *
  53  4010 4016 SUB01   DATA    SUB02                   link to next subprogram
  54  4012 5822         DATA    ESUB01                  address of that one
  55  4014 0110         DATA    >0110                   subprogram name: >10 (sector R/W)
  56  4016 401C SUB02   DATA    SUB03                   
  57  4018 5832         DATA    ESUB02                  
  58  401A 0111         DATA    >0111                   subprogram >11 (format disk)
  59  401C 4022 SUB03   DATA    SUB04                   
  60  401E 583C         DATA    ESUB03                  
  61  4020 0112         DATA    >0112                   subprogram >12 (file un/protect)
  62  4022 4028 SUB04   DATA    SUB05                   
  63  4024 5896         DATA    ESUB04                  
  64  4026 0113 NTPFAT  DATA    >0113                   subprogram >13 (file rename); doubles as FAT update flag
  65            *
  66  4028 402E SUB05   DATA    SUB06                   
  67  402A 5962         DATA    ESUB05                  
  68  402C 0114         DATA    >0114                   subprogram >14 (file direct input)              
  69  402E 4034 SUB06   DATA    SUB07                   
  70  4030 59D2         DATA    ESUB06                  
  71  4032 0115         DATA    >0115                   subprogram >15 (file direct output)
  72  4034 403A SUB07   DATA    SUB08                   
  73  4036 5A98         DATA    ESUB07                  
  74  4038 0116         DATA    >0116                   subprogram >16 (number of files)
  75  403A 4054 SUB08   DATA    SUB09                   
  76  403C 5A44         DATA    ESUB08                  
  77  403E 05           BYTE    >05                     
  78  403F 4649         TEXT    'FILES'                 same as >16, called from Basic
  78  4041 4C45  
  78  4043 53    
  79            *
  80  4044 0400 PATTBL  DATA    >0400                   TI BASIC VDP RAM address for Pattern Table
  81  4046 7631 AVERSN  TEXT    'v12s'                  APEDSK99 version string (ARST)
  81  4048 3273  
  82            *
  83  404A 0000 XEMRET  DATA    >0000                   CALL LINK return address
  84  404C 5D3C XEMJMP  DATA    XEMUST                  XBAS, E/A, MM: PDSK / UDSK/ LDSK
  85  404E 5DF0         DATA    A9909                   XBAS, E/A, MM: MDSK / NDSK              
  86  4050 5DF0         DATA    A9909                   XBAS, E/A, MM: RDSK / FGET / FPUT / ADSR / CDIR
  87  4052 5CC4         DATA    NOPRM2                  XBAS, E/A, MM: SMAP / LDIR / AHLP / ACHR / ARST / TIME / ACFG
  88            *
  89  4054 405E SUB09   DATA    SUB10
  90  4056 5C16         DATA    PDSK
  91  4058 04           BYTE    >04
  92  4059 5044         TEXT    'PDSK'                  Protect DSKx (apply adhesive tab)
  92  405B 534B  
  93  405D 0000         EVEN
  94  405E 4068 SUB10   DATA    SUB11                   
  95  4060 5C1C         DATA    UDSK
  96  4062 04           BYTE    >04
  97  4063 5544         TEXT    'UDSK'                  Un-protect DSKx (remove adhesive tab)
  97  4065 534B  
  98  4067 0000         EVEN
  99  4068 4072 SUB11   DATA    SUB12
 100  406A 5C22         DATA    LDSK
 101  406C 04           BYTE    >04
 102  406D 4C44         TEXT    'LDSK'                  List files on DSKx
 102  406F 534B  
 103  4071 0000         EVEN
 104  4072 407C SUB12   DATA    SUB13
 105  4074 5C28         DATA    MDSK
 106  4076 04           BYTE    >04
 107  4077 4D44         TEXT    'MDSK'                  Map DOAD to DSKx
 107  4079 534B  
 108  407B 0000         EVEN
 109  407C 4086 SUB13   DATA    SUB14
 110  407E 5C2E         DATA    NDSK
 111  4080 04           BYTE    >04
 112  4081 4E44         TEXT    'NDSK'                  reName mapped DSKx
 112  4083 534B  
 113  4085 0000         EVEN
 114  4086 4090 SUB14   DATA    SUB15
 115  4088 5C34         DATA    RDSK
 116  408A 04           BYTE    >04
 117  408B 5244         TEXT    'RDSK'                  Remove DOAD from SD card
 117  408D 534B  
 118  408F 0000         EVEN
 119  4090 409A SUB15   DATA    SUB16
 120  4092 5C3A         DATA    FGET
 121  4094 04           BYTE    >04
 122  4095 4647         TEXT    'FGET'                  Load DOAD from FTP server
 122  4097 4554  
 123  4099 0000         EVEN
 124  409A 40A4 SUB16   DATA    SUB17
 125  409C 5C40         DATA    FPUT
 126  409E 04           BYTE    >04
 127  409F 4650         TEXT    'FPUT'                  Save DOAD to FTP server
 127  40A1 5554  
 128  40A3 0000         EVEN
 129  40A4 40AE SUB17   DATA    SUB18
 130  40A6 5C46         DATA    ADSR
 131  40A8 04           BYTE    >04
 132  40A9 4144         TEXT    'ADSR'                  APEDSK99 DSR load / initialise / set default
 132  40AB 5352  
 133  40AD 0000         EVEN
 134  40AE 40B8 SUB18   DATA    SUB19
 135  40B0 5C4C         DATA    CDIR
 136  40B2 04           BYTE    >04
 137  40B3 4344         TEXT    'CDIR'                  Change working /Folder
 137  40B5 4952  
 138  40B7 0000         EVEN
 139  40B8 40C2 SUB19   DATA    SUB20
 140  40BA 5C52         DATA    SMAP
 141  40BC 04           BYTE    >04
 142  40BD 534D         TEXT    'SMAP'                  Show DOAD mappings for DSK[1-3] + available working /Folders
 142  40BF 4150  
 143  40C1 0000         EVEN
 144  40C2 40CC SUB20   DATA    SUB21
 145  40C4 5C58         DATA    LDIR
 146  40C6 04           BYTE    >04
 147  40C7 4C44         TEXT    'LDIR'                  List DOAD files on SD card
 147  40C9 4952  
 148  40CB 0000         EVEN
 149  40CC 40D6 SUB21   DATA    SUB22
 150  40CE 5C5E         DATA    AHLP
 151  40D0 04           BYTE    >04
 152  40D1 4148         TEXT    'AHLP'                  APEDSK99 CALL help screen
 152  40D3 4C50  
 153  40D5 0000         EVEN
 154  40D6 40E0 SUB22   DATA    SUB23
 155  40D8 5C64         DATA    ACHR
 156  40DA 04           BYTE    >04
 157  40DB 4143         TEXT    'ACHR'                  Load real lower case characters
 157  40DD 4852  
 158  40DF 0000         EVEN
 159  40E0 40EA SUB23   DATA    SUB24
 160  40E2 5C6A         DATA    ARST
 161  40E4 04           BYTE    >04
 162  40E5 4152         TEXT    'ARST'                  APEDSK99 Reset
 162  40E7 5354  
 163  40E9 0000         EVEN
 164  40EA 40F4 SUB24   DATA    SUB25
 165  40EC 5C70         DATA    TIME
 166  40EE 04           BYTE    >04
 167  40EF 5449         TEXT    'TIME'                  NTP date/time display / assign to NTP$
 167  40F1 4D45  
 168  40F3 0000         EVEN
 169  40F4 0000 SUB25   DATA    >0000                   APEDSK99 configuration (IP address etc)
 170  40F6 5C76         DATA    ACFG
 171  40F8 04           BYTE    >04
 172  40F9 4143         TEXT    'ACFG'
 172  40FB 4647  
 173  40FD 0000         EVEN
 174            *
 175  40FE 0000 PWRUP   DATA    >0000                   power-up chain (no more)
 176  4100 412A         DATA    EPWRUP                  address of power-up routine
 177  4102 0000         DATA    >0000                   no name
 178            *                                       
 179  4104 410C DSR01   DATA    DSR02                   DSR chain
 180  4106 4D38         DATA    EDSR01                  address of DSR
 181  4108 03           BYTE    >03                     name size
 182  4109 4453         TEXT    'DSK'                   DSR name
 182  410B 4B    
 183  410C 4116 DSR02   DATA    DSR03                   
 184  410E 4D46         DATA    EDSR02                  
 185  4110 04           BYTE    >04                     
 186  4111 4453         TEXT    'DSK1'                  
 186  4113 4B31  
 187  4115 0000         EVEN                            
 188  4116 4120 DSR03   DATA    DSR04                   
 189  4118 4D4C         DATA    EDSR03                  
 190  411A 04           BYTE    >04                     
 191  411B 4453         TEXT    'DSK2'                  
 191  411D 4B32  
 192  411F 0000         EVEN                            
 193  4120 0000 DSR04   DATA    >0000                   no more
 194  4122 4D52         DATA    EDSR04                  
 195  4124 04           BYTE    >04                     
 196  4125 4453         TEXT    'DSK3'                  
 196  4127 4B33  
 197  4129 0000         EVEN            
 198            *
 199            *=====================================
 200            * Power-up routine
 201            *=====================================                                          
 202            *
 203  412A 028C EPWRUP  CI      R12,>1000               Dhr. F.G. Kaal check: are we powering up 1st CRU (>1000) peripheral?
 203  412C 1000  
 204  412E 1633         JNE     NOCRU                   nope; return
 205            *
 206  4130 C1CB         MOV     R11,R7                  yes; save return address
 207  4132 02A9         STWP    R9                      get workspace (should be >83E0)
 208  4134 0229         AI      R9,-224                 point to top of scratch-pad mem (>8300)
 208  4136 FF20  
 209  4138 C0A9         MOV     @>0070(R9),R2           highest free address in vdp mem (>8370)
 209  413A 0070  
 210  413C C002         MOV     R2,R0                   save it
 211  413E 0222         AI      R2,-2088                we'll need >828 bytes
 211  4140 F7D8  
 212  4142 CA42         MOV     R2,@>0070(R9)           update address
 212  4144 0070  
 213  4146 0582         INC     R2
 214  4148 06A0         BL      @VDPWRI                 set VDP address
 214  414A 4322  
 215  414C 0201         LI      R1,2088                 
 215  414E 0828  
 216  4150 04EF H001    CLR     @-2(R15)                clear these >828 bytes
 216  4152 FFFE  
 217  4154 0601         DEC     R1                      
 218  4156 16FC         JNE     H001                    
 219  4158 06A0         BL      @VDPWRI                 set VDP address (same)
 219  415A 4322  
 220  415C 0203         LI      R3,>AA03                        
 220  415E AA03  
 221  4160 DBC3         MOVB    R3,@-2(R15)             write buffer ID mark
 221  4162 FFFE  
 222  4164 1000         NOP                             
 223  4166 DBC0         MOVB    R0,@-2(R15)             write old highest free address
 223  4168 FFFE  
 224  416A 06C0         SWPB    R0
 225  416C DBC0         MOVB    R0,@-2(R15)
 225  416E FFFE  
 226  4170 1000         NOP                             
 227  4172 DBCC         MOVB    R12,@-2(R15)            write CRU address (>1000 for APEDSK99)
 227  4174 FFFE  
 228  4176 06C3         SWPB    R3                      
 229  4178 DBC3         MOVB    R3,@-2(R15)             write number of files (3)
 229  417A FFFE  
 230  417C 06A0         BL      @PRPRTN                 preparation routine
 230  417E 4412  
 231  4180 06A0         BL      @CALSUB                 call subroutine
 231  4182 4344  
 232  4184 42B2         DATA    RSTDRV                  reset all drives
 233  4186 04E9         CLR     @>0054(R9)              name length = 0 for power-up
 233  4188 0054  
 234  418A 0429         BLWP    @>005A(R9)              retrieve R7 (saved by PRPRTN)
 234  418C 005A  
 235  418E 0011         DATA    >0011                   put it into R11
 236  4190 CA60         MOV     @K001,@>006C(R9)        ???
 236  4192 4198  
 236  4194 006C  
 237  4196 045B NOCRU   B       *R11                    return
 238            *                               
 239  4198 0404 K001    DATA    >0404                   
 240            *
 241            *---------------------------------------
 242            * Sector read/write
 243            *---------------------------------------                                        
 244            *
 245  419A DA60 SECRW1  MOVB    @K002,@>0050(R9)        APEDSK99: no error
 245  419C 433E  
 245  419E 0050  
 246  41A0 06A0         BL      @SELDRV                 select drive
 246  41A2 4284  
 247            *
 248  41A4 C069         MOV     @>004A(R9),R1           sector #
 248  41A6 004A  
 249  41A8 0281         CI      R1,>05A0                APEDSK99: max 1440 (DS/DD/40T or DS/SD/80T)?
 249  41AA 05A0  
 250  41AC 1A03         JL      H002                    APEDSK99: yes; sector# within range
 251  41AE 06A0         BL      @ERROR1                 APEDSK99: no -> "device error"
 251  41B0 42E0  
 252  41B2 0600         DATA    >0600   
 253            
 254  41B4 C801 H002    MOV     R1,@WSECTR              APEDSK99: sector# to FD1771 write sector register (16bits)
 254  41B6 5FFC  
 255            *
 256  41B8 C0A9         MOV     @>004E(R9),R2           data buffer address
 256  41BA 004E  
 257  41BC D029         MOVB    @>004D(R9),R0           read or write ?
 257  41BE 004D  
 258  41C0 1312         JEQ     H005                    write
 259  41C2 06A0         BL      @VDPWRI                 read FD = write to VDP buffer
 259  41C4 4322  
 260  41C6 0206         LI      R6,256                  
 260  41C8 0100  
 261  41CA C806         MOV     R6,@RDINT               APEDSK99: interrupt Arduino for read operation 
 261  41CC 5FEA  
 262  41CE 06A0         BL      @SNDCMD                 send command
 262  41D0 42F6  
 263  41D2 8800         DATA    >8800                   APEDSK99: read sector
 264            *
 265  41D4 D020 H003    MOVB    @RDATA,R0               get 1 byte from FDC
 265  41D6 5FF6  
 266  41D8 DBC0         MOVB    R0,@-2(R15)             save it to VDP
 266  41DA FFFE  
 267  41DC 0620         DEC     @RDINT                  APEDSK99: interrupt Arduino for read operation
 267  41DE 5FEA  
 268  41E0 16F9         JNE     H003                    next byte
 269            *
 270  41E2 0460 H004    B       @RTURN1                 return
 270  41E4 4362  
 271            
 272            *       
 273  41E6 06A0 H005    BL      @VDPRD                  write to FD = read from VDP buffer
 273  41E8 432C  
 274  41EA 0206         LI      R6,256                  256 bytes to write
 274  41EC 0100  
 275            *
 276            * APEDSK99: the first byte to be written needs to be in the data register before the write command is given
 277            *
 278  41EE D02F         MOVB    @-1026(R15),R0          APEDSK99: get a byte from data buffer
 278  41F0 FBFE  
 279  41F2 D800         MOVB    R0,@WDATA               APEDSK99: write first byte to data register
 279  41F4 5FFE  
 280  41F6 06A0         BL      @SNDCMD                 send command
 280  41F8 42F6  
 281  41FA A800         DATA    >A800                   APEDSK99: write sector
 282            *
 283  41FC D02F H006    MOVB    @-1026(R15),R0          get a byte from data buffer
 283  41FE FBFE  
 284  4200 D800         MOVB    R0,@WDATA               pass it to data register
 284  4202 5FFE  
 285  4204 0606         DEC     R6                      
 286  4206 16FA         JNE     H006                    next byte
 287            *
 288  4208 06A0         BL      @WTCPT1                 APEDSK99: check for Write Protect
 288  420A 4276  
 289  420C 0A20         SLA     R0,2                    APEDSK99: WP bit in Carry
 290  420E 1801         JOC     ERROR3                  write protect: error 34
 291  4210 10E8         JMP     H004                    APEDSK99: no need to verify             
 292            *                                       
 293  4212 06A0 ERROR3  BL      @ERROR1                 error 34 (Write Protect)
 293  4214 42E0  
 294  4216 3400         DATA    >3400                   
 295            *
 296            *--------------------------------------------------------------------
 297            * Format disk - APEDSK99: we don't do any physical formatting anymore
 298            *--------------------------------------------------------------------
 299            *
 300  4218 04E9 FMTDSK  CLR     @>004A(R9)              called by subprogram >11
 300  421A 004A  
 301            *                                       
 302  421C 5A60         SZCB    @K004,@>004C(R9)        clear DSR version flags
 302  421E 4340  
 302  4220 004C  
 303            *
 304  4222 06A0         BL      @SELDRV                 select drive
 304  4224 4284  
 305            *
 306  4226 D029         MOVB    @>004D(R9),R0           APEDSK99: get # of tracks
 306  4228 004D  
 307  422A 9829         CB      @>0051(R9),@K005        APEDSK99: double sided?
 307  422C 0051  
 307  422E 4341  
 308  4230 1601         JNE     H007                    APEDSK99: single-side
 309            *
 310  4232 0A10         SLA     R0,1                    times two (since 2 sides)
 311            *
 312  4234 0980 H007    SRL     R0,8                    APEDSK99: make it a byte
 313  4236 0206         LI      R6,9                    APEDSK99: start with single density
 313  4238 0009  
 314  423A 9829         CB      @>0050(R9),@K005        APEDSK99: double density required?
 314  423C 0050  
 314  423E 4341  
 315  4240 1601         JNE     H008                    APEDSK99: no, leave R6 alone
 316  4242 0A16         SLA     R6,1                    APEDSK99: yes, R6*2
 317            *               
 318  4244 3806 H008    MPY     R6,R0                   APEDSK99: #sectors/track * #tracks
 319  4246 0281         CI      R1,>05A0                APEDSK99: >1440 sectors?
 319  4248 05A0  
 320  424A 1203         JLE     H009                    APEDSK99: nope; continue
 321  424C 06A0         BL      @ERROR1                 APEDSK99: yes; "device error"
 321  424E 42E0  
 322  4250 0600         DATA    >0600   
 323            *
 324  4252 CA41 H009    MOV     R1,@>004A(R9)           pass total # of sectors per disk
 324  4254 004A  
 325  4256 06C6         SWPB    R6
 326  4258 DA46         MOVB    R6,@>004D(R9)           APEDSK99: pass # of sectors per track
 326  425A 004D  
 327  425C DA60         MOVB    @K002,@>0050(R9)        no error
 327  425E 433E  
 327  4260 0050  
 328            *
 329  4262 06A0         BL      @NTPDT                  APEDSK99: update DOAD FAT time/date
 329  4264 5F5C  
 330            *
 331  4266 0460         B       @RTURN1                 return
 331  4268 4362  
 332            *                                       
 333                                                    
 334  426A C1BB VDPRPW  MOV     *R11+,R6                VDP repeated write
 335  426C DBC0 H010    MOVB    R0,@-2(R15)
 335  426E FFFE  
 336  4270 0606         DEC     R6                      byte in R0
 337  4272 16FC         JNE     H010                    number of repeats in data word
 338  4274 045B         B       *R11                    
 339            *
 340  4276 D020 WTCPT1  MOVB    @RSTAT,R0               get status. APEDSK99: Not Ready >80 / Write Protect >40
 340  4278 5FF0  
 341  427A 1101         JLT     ERROR4                  drive not ready. APEDSK99: Not Ready set when DOAD file is unavailable
 342  427C 045B         B       *R11                    
 343            *
 344  427E 06A0 ERROR4  BL      @ERROR1                 exit with error code 6, reseting all drives
 344  4280 42E0  
 345  4282 0600         DATA    >0600                   
 346            *                                       
 347  4284 C1CB SELDRV  MOV     R11,R7                  select a drive
 348  4286 C0A9         MOV     @>0058(R9),R2
 348  4288 0058  
 349  428A 0222         AI      R2,-10                  point to drive info
 349  428C FFF6  
 350  428E 04C0         CLR     R0                      
 351  4290 D029         MOVB    @>004C(R9),R0           get drive #
 351  4292 004C  
 352  4294 130B         JEQ     H011                    can't be >00: error #7
 353  4296 0280         CI      R0,>0300                        
 353  4298 0300  
 354  429A 1B08         JH      H011                    drive number can't be higher than 3: error #7
 355  429C 06A0         BL      @VDPWRI                 set VDP to write, address in R2
 355  429E 4322  
 356  42A0 DBC0         MOVB    R0,@-2(R15)             modify last drive accessed              
 356  42A2 FFFE  
 357            *
 358  42A4 0A10         SLA     R0,1                    APEDSK99: bit 0 is side select, 1-3 is drive #
 359  42A6 D800         MOVB    R0,@CRUWRI              APEDSK99: select drive
 359  42A8 5FEE  
 360  42AA 0457         B       *R7                     
 361            *                                       
 362  42AC 06A0 H011    BL      @ERROR1                 exit with error #7
 362  42AE 42E0  
 363  42B0 0700         DATA    >0700                   
 364            *                                       
 365  42B2 5820 RSTDRV  SZCB    @DSDRVS,@CRUWRI         APEDSK99: reset all drives including side
 365  42B4 4342  
 365  42B6 5FEE  
 366  42B8 D820         MOVB    @K013,@WCOMND           send Force Interrupt with no interrupt flag set
 366  42BA 42F0  
 366  42BC 5FF8  
 367  42BE C0A9         MOV     @>0058(R9),R2           ptr to VIB buffer
 367  42C0 0058  
 368  42C2 0222         AI      R2,-10                  now points to drive info buffer
 368  42C4 FFF6  
 369  42C6 06A0         BL      @VDPWRI                 set VDP to write to address in R2
 369  42C8 4322  
 370  42CA 0200         LI      R0,4                    
 370  42CC 0004  
 371  42CE DBC0 H012    MOVB    R0,@-2(R15)             write four >00 (i.e. clear drive info)
 371  42D0 FFFE  
 372  42D2 0600         DEC     R0                      
 373  42D4 16FC         JNE     H012                    
 374  42D6 DA60         MOVB    @K002,@>0050(R9)        no error
 374  42D8 433E  
 374  42DA 0050  
 375  42DC 0460         B       @RTURN1                 get return address from stack
 375  42DE 4362  
 376            *                                       
 377  42E0 C01B ERROR1  MOV     *R11,R0                 exit with error
 378  42E2 DA40         MOVB    R0,@>0050(R9)           place err code in >8350
 378  42E4 0050  
 379  42E6 0280         CI      R0,>0600                check if device error
 379  42E8 0600  
 380  42EA 1603         JNE     H013                    no: exit
 381  42EC 06A0         BL      @SNDCMD                 yes: reset drives
 381  42EE 42F6  
 382            *
 383  42F0 0000 K013    DATA    >0000                   APEDSK99: send Restore command
 384            *
 385  42F2 0460 H013    B       @RTURN1                 return to caller (address from stack)
 385  42F4 4362  
 386            *                               
 387  42F6 C03B SNDCMD  MOV     *R11+,R0                send command to FDC from data word
 388  42F8 D800         MOVB    R0,@WCOMND              send command
 388  42FA 5FF8  
 389  42FC 045B         B       *R11                    
 390            *                                       
 391  42FE 04C0 LASTRK  CLR     R0                      get last track # for this drive
 392  4300 D029         MOVB    @>004C(R9),R0           get drive #
 392  4302 004C  
 393  4304 130B         JEQ     H014                    can't be 0
 394  4306 06C0         SWPB    R0                      
 395  4308 0280         CI      R0,3                    
 395  430A 0003  
 396  430C 1B07         JH      H014                    can't be higher than 3
 397  430E C0A9         MOV     @>0058(R9),R2                   
 397  4310 0058  
 398  4312 0222         AI      R2,-10                  point to last drive accessed
 398  4314 FFF6  
 399  4316 A080         A       R0,R2                   point to last track for this drive
 400  4318 0460         B       @VDPRD                  prepare VDP to read from address in R2
 400  431A 432C  
 401            *                                       
 402  431C 06A0 H014    BL      @ERROR1                 exit with error code 7
 402  431E 42E0  
 403  4320 0700         DATA    >0700                   
 404            *                                       
 405  4322 0262 VDPWRI  ORI     R2,>4000                set VDP address to write
 405  4324 4000  
 406  4326 0242         ANDI    R2,>7FFF                not to a register
 406  4328 7FFF  
 407  432A 1002         JMP     H015                    
 408  432C 0242 VDPRD   ANDI    R2,>3FFF                set VDP address to read
 408  432E 3FFF  
 409  4330 06C2 H015    SWPB    R2                      
 410  4332 D7C2         MOVB    R2,*R15                 write address
 411  4334 06C2         SWPB    R2                      
 412  4336 D7C2         MOVB    R2,*R15                 
 413  4338 0242         ANDI    R2,>3FFF                        
 413  433A 3FFF  
 414  433C 045B         B       *R11                    
 415            *                                       
 416  433E 00   K002    BYTE    >00                     
 417  433F 09   K007    BYTE    >09                                             
 418  4340 F0   K004    BYTE    >F0                     
 419  4341 02   K005    BYTE    2
 420  4342 0F   DSDRVS  BYTE    >0F                     APEDSK99: deselect all drives + side (reset CRUWRI bits 7,6,5 and 4)                    
 421            *
 422  4343 0000         EVEN
 423            *                               
 424  4344 0669 CALSUB  DECT    @>0066(R9)              call subroutine, return address in stack
 424  4346 0066  
 425  4348 C2A9         MOV     @>0066(R9),R10
 425  434A 0066  
 426  434C 0429         BLWP    @>005A(R9)              set VDP to write to address in R10
 426  434E 005A  
 427  4350 0143         DATA    >0143                   
 428  4352 C2BB         MOV     *R11+,R10               get next data word
 429  4354 06CB         SWPB    R11                     write return address to VDP
 430  4356 DBCB         MOVB    R11,@-2(R15)                    
 430  4358 FFFE  
 431  435A 06CB         SWPB    R11                     
 432  435C DBCB         MOVB    R11,@-2(R15)                    
 432  435E FFFE  
 433  4360 045A         B       *R10                    branch to address in data word
 434            *                               
 435  4362 C2E9 RTURN1  MOV     @>0066(R9),R11          get return address from VDP stack
 435  4364 0066  
 436  4366 0429         BLWP    @>005A(R9)              
 436  4368 005A  
 437  436A 0162         DATA    >0162                   set VDP to read from address in R11
 438  436C D2EF         MOVB    @-1026(R15),R11                 
 438  436E FBFE  
 439  4370 06CB         SWPB    R11                     
 440  4372 D2EF         MOVB    @-1026(R15),R11                 
 440  4374 FBFE  
 441  4376 05E9         INCT    @>0066(R9)                      
 441  4378 0066  
 442  437A 045B         B       *R11                    
 443            *
 444            *---------------------------------------
 445            * Custom routines, dealing with VDP memory
 446            * Format is >pppr where r is routine number (0-3)
 447            * and ppp contains parameters
 448            * The workspace it >8300. Called by BLWP @>005A(9).
 449            *---------------------------------------                                        
 450            *
 451  437C C28D ECUSTM  MOV     R13,R10                 save wregs ptr
 452  437E C23E         MOV     *R14+,R8                get next data word
 453  4380 C248         MOV     R8,R9                   save it
 454  4382 0949         SRL     R9,4                    keep parameter
 455  4384 0248         ANDI    R8,3                    four possible operations
 455  4386 0003  
 456  4388 A208         A       R8,R8                   make it a word ptr
 457  438A C2ED         MOV     @>001E(R13),R11         get old R15, i.e. VDP port (>8C02)
 457  438C 001E  
 458  438E C228         MOV     @VECRTN(R8),R8          get vector for operation
 458  4390 4394  
 459  4392 0458         B       *R8                     branch to it
 460            *                                       
 461  4394 439C VECRTN  DATA    SVRVDP                  save registers to VDP stack
 462  4396 43C8         DATA    RVRVDP                  retrieve registers
 463  4398 43FE         DATA    SVDPRD                  set VDP address to read
 464  439A 43F4         DATA    SVDPWR                  set VDP address to write
 465            *                                       
 466  439C 022A SVRVDP  AI      R10,22                  0: save registers in VDP mem
 466  439E 0016  
 467  43A0 0919 H016    SRL     R9,1                    start with R12
 468  43A2 1710         JNC     H017                    bits in >ppp tell which register to save (R0-R11)
 469  43A4 064C         DECT    R12                     previous address in VDP stack (grows down)
 470  43A6 C21A         MOV     *R10,R8                 get register contents
 471  43A8 06CC         SWPB    R12                     set VDP address to write
 472  43AA D6CC         MOVB    R12,*R11                R12 is >8366: VDP stack ptr
 473  43AC 06CC         SWPB    R12                     
 474  43AE 026C         ORI     R12,>4000                       
 474  43B0 4000  
 475  43B2 D6CC         MOVB    R12,*R11                        
 476  43B4 06C8         SWPB    R8                      save register to VDP mem
 477  43B6 DAC8         MOVB    R8,@-2(R11)                     
 477  43B8 FFFE  
 478  43BA 06C8         SWPB    R8                      
 479  43BC DAC8         MOVB    R8,@-2(R11)                     
 479  43BE FFFE  
 480  43C0 C249         MOV     R9,R9                   more to come?
 481  43C2 1317         JEQ     H020                    no:return
 482  43C4 064A H017    DECT    R10                     point to previous register
 483  43C6 10EC         JMP     H016                    
 484            *                               
 485  43C8 0A49 RVRVDP  SLA     R9,4                    1: retrieve registers from VDP mem
 486  43CA 0A19 H018    SLA     R9,1                    each bit tells whether to load
 487  43CC 1710         JNC     H019                    don't retrieve that one
 488  43CE 06CC         SWPB    R12                     set VDP address to read
 489  43D0 D6CC         MOVB    R12,*R11                R12 is >8366: VDP stack ptr
 490  43D2 06CC         SWPB    R12                     
 491  43D4 024C         ANDI    R12,>3FFF                       
 491  43D6 3FFF  
 492  43D8 D6CC         MOVB    R12,*R11                        
 493  43DA 1000         NOP                             
 494  43DC D22B         MOVB    @-1026(R11),R8          get a 2-byte value from VDP
 494  43DE FBFE  
 495  43E0 06C8         SWPB    R8                      
 496  43E2 D22B         MOVB    @-1026(R11),R8                  
 496  43E4 FBFE  
 497  43E6 C688         MOV     R8,*R10                 save it to register
 498  43E8 05CC         INCT    R12                     increment ptr (stack grows downwards)
 499  43EA C249         MOV     R9,R9                   more to come?
 500  43EC 1302         JEQ     H020                    no: return
 501  43EE 05CA H019    INCT    R10                     next register
 502  43F0 10EC         JMP     H018                    
 503  43F2 0380 H020    RTWP                            
 504            *                                       
 505  43F4 A24D SVDPWR  A       R13,R9                  2: set VDP for a write
 506  43F6 C219         MOV     *R9,R8                  
 507  43F8 0268         ORI     R8,>4000                get address from reg in >..p2 (*2)
 507  43FA 4000  
 508  43FC 1004         JMP     H021                    
 509            *                                       
 510  43FE A24D SVDPRD  A       R13,R9                  3: set VDP for a read
 511  4400 C219         MOV     *R9,R8
 512  4402 0248         ANDI    R8,>3FFF                get register from reg in >..p3 (*2)
 512  4404 3FFF  
 513  4406 06C8 H021    SWPB    R8                      set VDP address
 514  4408 D6C8         MOVB    R8,*R11                 
 515  440A 06C8         SWPB    R8                      
 516  440C D6C8         MOVB    R8,*R11                 
 517  440E 0380         RTWP                            
 518            *
 519            *---------------------------------------
 520            * Preparation subroutine
 521            * Sets up the 4 custom subroutines
 522            * Gets a few pointers to VDP buffers
 523            *  >8358: copy of VIB  >8366: VDP stack ptr (grows down from drive info)
 524            *  >8354: PAB          >8356: ptr to end-of-buffer
 525            *---------------------------------------                                        
 526            *
 527  4410 05C7 PRPFDO  INCT    R7                      stop scanning upon return
 528  4412 C28B PRPRTN  MOV     R11,R10                 save return address
 529  4414 02A9         STWP    R9                      get workspace (should be >83E0)
 530  4416 0229         AI      R9,-224                 top of scratch/pad mem (>8300)
 530  4418 FF20  
 531  441A 0200         LI      R0,ECUSTM               entry to 4 custom routines
 531  441C 437C  
 532  441E CA40         MOV     R0,@>005C(R9)           put it in >835C
 532  4420 005C  
 533  4422 C009         MOV     R9,R0                   
 534  4424 0220         AI      R0,>004E                workspace for these four (>834E)
 534  4426 004E  
 535  4428 CA40         MOV     R0,@>005A(R9)           put it in >835A
 535  442A 005A  
 536            *                                       
 537  442C C229         MOV     @>0070(R9),R8           highest free address in VDP mem
 537  442E 0070  
 538  4430 05C8         INCT    R8                      point to end-of-buffer word
 539  4432 06A0         BL      @VDPR2B                 read 2 bytes from VDP address R8, into R0
 539  4434 4862  
 540  4436 C088         MOV     R8,R2                   save current R8
 541  4438 C200         MOV     R0,R8                   get end-of-buffer word
 542  443A 0228         AI      R8,-266                 yes: point to volume information block
 542  443C FEF6  
 543  443E CA48         MOV     R8,@>0058(R9)           save it in >8358
 543  4440 0058  
 544  4442 0228         AI      R8,-10                  point to disk drive info (drive #, last tracks)
 544  4444 FFF6  
 545  4446 CA48         MOV     R8,@>0066(R9)           save in >8366: VDP stack ptr (DECT before writing)
 545  4448 0066  
 546  444A 0429         BLWP    @>005A(R9)              save R7 (return address)
 546  444C 005A  
 547  444E 0100         DATA    >0100                   
 548  4450 C1E9         MOV     @>0056(R9),R7           ptr to PAB: end of DSR name
 548  4452 0056  
 549  4454 C0C7         MOV     R7,R3                   save it
 550  4456 61E9         S       @>0054(R9),R7           start of DSR name
 550  4458 0054  
 551  445A CA42         MOV     R2,@>0056(R9)           >8356: ptr to end-of-buffer word in VDP mem
 551  445C 0056  
 552  445E 0607         DEC     R7                      point to name length byte
 553  4460 04C2         CLR     R2                      
 554  4462 0429         BLWP    @>005A(R9)              set VDP to read from address in R2
 554  4464 005A  
 555  4466 00E2         DATA    >00E2                   
 556  4468 D0AF         MOVB    @-1026(R15),R2          get name length byte
 556  446A FBFE  
 557  446C 06C2         SWPB    R2                      make it a word
 558  446E 60A9         S       @>0054(R9),R2           minus DSR name size: lenght of .parameters
 558  4470 0054  
 559  4472 0227         AI      R7,-9                   point to top of PAB
 559  4474 FFF7  
 560  4476 CA47         MOV     R7,@>0054(R9)           save it in >8354
 560  4478 0054  
 561  447A 045A         B       *R10                    
 562            *                               
 563  447C 06A0 CRFIL1  BL      @CALSUB                 create file
 563  447E 4344  
 564  4480 4AEE         DATA    FNDFDR                  find a FDR in disk
 565  4482 C104 CRFIL2  MOV     R4,R4                   found?
 566  4484 1604         JNE     CRFIL3                  no
 567  4486 06A0         BL      @CALSUB                 yes: delete old file
 567  4488 4344  
 568  448A 45C6         DATA    FFSVIB                  free file sector in VIB bitmap
 569  448C 1045         JMP     H024                    clear its FDR
 570            *                               
 571  448E 06A0 CRFIL3  BL      @INSFDR                 new file: insert a FDR in sector 1
 571  4490 47F6  
 572  4492 0701         SETO    R1                      
 573  4494 06A0         BL      @CALSUB                 call subroutine
 573  4496 4344  
 574  4498 4BE2         DATA    FFSBMP                  find a free sector in VIB bitmap
 575  449A C000         MOV     R0,R0                   found?
 576  449C 1603         JNE     H022                    yes: # in R0
 577  449E 06A0         BL      @ERROR5                 no: update data, then return with error
 577  44A0 495E  
 578  44A2 8000         DATA    >8000                   memory full (APEDSK99: doubles as subcommand flag)
 579            *                               
 580  44A4 0429 H022    BLWP    @>005A(R9)              set VDP to write
 580  44A6 005A  
 581  44A8 0103         DATA    >0103                   address in R8
 582  44AA DBC0         MOVB    R0,@-2(R15)             write sector # for FDR in sector 1
 582  44AC FFFE  
 583  44AE 06C0         SWPB    R0                      
 584  44B0 DBC0         MOVB    R0,@-2(R15)                     
 584  44B2 FFFE  
 585  44B4 06C0         SWPB    R0                      
 586  44B6 C069         MOV     @>0056(R9),R1           ptr to FDR in VDP buffers
 586  44B8 0056  
 587  44BA 0221         AI      R1,-4                   ptr to sector # for FDR
 587  44BC FFFC  
 588  44BE 0429         BLWP    @>005A(R9)              set VDP to write
 588  44C0 005A  
 589  44C2 0023         DATA    >0023                   address in R1
 590  44C4 DBC0         MOVB    R0,@-2(R15)             write sector # for FDR in VDP buffer
 590  44C6 FFFE  
 591  44C8 06C0         SWPB    R0                      
 592  44CA DBC0         MOVB    R0,@-2(R15)                     
 592  44CC FFFE  
 593  44CE 0221         AI      R1,3                    ptr to drive #
 593  44D0 0003  
 594  44D2 0429         BLWP    @>005A(R9)              set VDP to write
 594  44D4 005A  
 595  44D6 0023         DATA    >0023                   address in R1
 596  44D8 DBC6         MOVB    R6,@-2(R15)             write drive # before FDR in VDP buffer
 596  44DA FFFE  
 597  44DC 04C2         CLR     R2                      code for write
 598  44DE 0581         INC     R1                      
 599  44E0 06A0         BL      @CALSUB                 call subroutine
 599  44E2 4344  
 600  44E4 4A22         DATA    WRSEC1                  write sector 1
 601  44E6 C169         MOV     @>0058(R9),R5           ptr to VIB in VDP buffers
 601  44E8 0058  
 602  44EA 04C4         CLR     R4                      sector 0
 603  44EC 06A0         BL      @CALSUB                 call subroutine
 603  44EE 4344  
 604  44F0 4A3A         DATA    RWSEC                   write VIB to sector 0
 605  44F2 C0C5         MOV     R5,R3                   copy filename from compare buffer to FDR
 606  44F4 0223         AI      R3,257                  ptr to file compare buffer
 606  44F6 0101  
 607  44F8 0202         LI      R2,10                   10 chars per filename
 607  44FA 000A  
 608  44FC 0429 H023    BLWP    @>005A(R9)              set VDP to read
 608  44FE 005A  
 609  4500 0062         DATA    >0062                   address in R3
 610  4502 D02F         MOVB    @-1026(R15),R0          get 1 char
 610  4504 FBFE  
 611  4506 0583         INC     R3                      increment source ptr
 612  4508 0429         BLWP    @>005A(R9)              set VDP to write
 612  450A 005A  
 613  450C 0023         DATA    >0023                   address in R1
 614  450E DBC0         MOVB    R0,@-2(R15)             copy 1 char
 614  4510 FFFE  
 615  4512 0581         INC     R1                      increment destination ptr
 616  4514 0602         DEC     R2                      # of chars in R2
 617  4516 16F2         JNE     H023                    next
 618            *
 619  4518 06A0 H024    BL      @NTPDT                  APEDSK99: update DOAD FAT time/date
 619  451A 5F5C  
 620            *
 621  451C C069         MOV     @>0056(R9),R1           FDR ptr
 621  451E 0056  
 622  4520 0221         AI      R1,10                   skip filename
 622  4522 000A  
 623  4524 0202         LI      R2,246                  remaining bytes in FDR
 623  4526 00F6  
 624  4528 0429         BLWP    @>005A(R9)              set VDP to write
 624  452A 005A  
 625  452C 0023         DATA    >0023                   address in R1
 626  452E DBC2 H025    MOVB    R2,@-2(R15)             write >00
 626  4530 FFFE  
 627  4532 0602         DEC     R2                      clear remainder of new FDR
 628  4534 16FC         JNE     H025                    next byte
 629  4536 1010         JMP     H028                    write FDR to disk return to caller
 630            *                                       
 631  4538 C169 H026    MOV     @>0056(R9),R5           check if FDR must be updated
 631  453A 0056  
 632  453C 0429         BLWP    @>005A(R9)              set VDP to read
 632  453E 005A  
 633  4540 00A2         DATA    >00A2                   address in R5
 634  4542 D12F         MOVB    @-1026(R15),R4          get filename in file ctrl block
 634  4544 FBFE  
 635  4546 1101         JLT     H027                    flag: FDR was modified, update it
 636  4548 100A         JMP     H029                    
 637  454A 0244 H027    ANDI    R4,>7F00                clear flag bit
 637  454C 7F00  
 638  454E 0429         BLWP    @>005A(R9)              st VDP to write
 638  4550 005A  
 639  4552 00A3         DATA    >00A3                   address in R5
 640  4554 DBC4         MOVB    R4,@-2(R15)             write back filename without flag bit
 640  4556 FFFE  
 641  4558 04C2 H028    CLR     R2                      code for write
 642  455A 0460         B       @WRFDR                  write FDR to disk
 642  455C 4A2C  
 643  455E 0460 H029    B       @RTURN1                 return to caller
 643  4560 4362  
 644            *                               
 645  4562 06A0 UPDFDR  BL      @CALSUB                 update FDR + data
 645  4564 4344  
 646  4566 4582         DATA    UPDBF                   update data buffer if necessary
 647  4568 06A0         BL      @CALSUB                 call subroutine
 647  456A 4344  
 648  456C 4538         DATA    H026                    update FDR if necessary
 649  456E C169 CLRFBT  MOV     @>0056(R9),R5                   
 649  4570 0056  
 650  4572 04C6         CLR     R6                      
 651  4574 0429         BLWP    @>005A(R9)              set VDP to write
 651  4576 005A  
 652  4578 00A3         DATA    >00A3                   address in R5
 653  457A DBC6         MOVB    R6,@-2(R15)             clr first byte of filename in FDR
 653  457C FFFE  
 654  457E 0460         B       @RWVIB                  
 654  4580 49BE  
 655            *                                       
 656  4582 C129 UPDBF   MOV     @>0056(R9),R4           check if data buffer must be updated
 656  4584 0056  
 657  4586 0604         DEC     R4                      
 658  4588 0429         BLWP    @>005A(R9)              set VDP to read
 658  458A 005A  
 659  458C 0082         DATA    >0082                   address in R4
 660  458E D06F         MOVB    @-1026(R15),R1          get drive #
 660  4590 FBFE  
 661  4592 1101         JLT     H030                    flag: must be updated
 662  4594 1016         JMP     H031                    no need to update: return
 663  4596 0241 H030    ANDI    R1,>7F00                erase flag
 663  4598 7F00  
 664  459A 0429         BLWP    @>005A(R9)              set VDP to write
 664  459C 005A  
 665  459E 0083         DATA    >0083                   address in R4
 666  45A0 DBC1         MOVB    R1,@-2(R15)             write back drive # without flag
 666  45A2 FFFE  
 667  45A4 0224         AI      R4,-5                   point to current logical record offset
 667  45A6 FFFB  
 668  45A8 0429         BLWP    @>005A(R9)              set VDP to read
 668  45AA 005A  
 669  45AC 0082         DATA    >0082                   address in R4
 670  45AE D0EF         MOVB    @-1026(R15),R3          get current logical record offset
 670  45B0 FBFE  
 671  45B2 06C3         SWPB    R3                      
 672  45B4 D0EF         MOVB    @-1026(R15),R3                  
 672  45B6 FBFE  
 673  45B8 06C3         SWPB    R3                      
 674  45BA C1C4         MOV     R4,R7                   
 675  45BC 0227         AI      R7,262                  point to data buffer area
 675  45BE 0106  
 676  45C0 103A         JMP     WROFSC                  
 677  45C2 0460 H031    B       @RTURN1                 return to caller
 677  45C4 4362  
 678            *                               
 679  45C6 C0A9 FFSVIB  MOV     @>0056(R9),R2           free file sectors in VIB bitmap
 679  45C8 0056  
 680  45CA 0222         AI      R2,12                   
 680  45CC 000C  
 681  45CE 0429         BLWP    @>005A(R9)              set VDP to read
 681  45D0 005A  
 682  45D2 0042         DATA    >0042                   address in R2
 683  45D4 D02F         MOVB    @-1026(R15),R0          get file status byte from FDR
 683  45D6 FBFE  
 684  45D8 0240         ANDI    R0,>0800                write protected?
 684  45DA 0800  
 685  45DC 1303         JEQ     H032                    no
 686  45DE 06A0         BL      @ERROR5                 update data if needed, the return with error
 686  45E0 495E  
 687  45E2 2000         DATA    >2000                   write protected
 688            *                                       
 689  45E4 C229 H032    MOV     @>0056(R9),R8           get ptr to FDR
 689  45E6 0056  
 690  45E8 0228         AI      R8,28                   point to clusters list
 690  45EA 001C  
 691  45EC 0704         SETO    R4                      previous offset
 692  45EE 06A0 H033    BL      @DECDCI                 decode cluster info: sector in R1, offset in R2
 692  45F0 4BA2  
 693  45F2 0228         AI      R8,3                    next cluster ptr
 693  45F4 0003  
 694  45F6 C041         MOV     R1,R1                   
 695  45F8 130C         JEQ     H034                    sector 0 = no more clusters
 696  45FA C002         MOV     R2,R0                   total offset
 697  45FC 6084         S       R4,R2                   minus previous cluster offset = cluster size
 698  45FE C100         MOV     R0,R4                   new previous cluster offset
 699  4600 06A0         BL      @CALSUB                 call subroutine
 699  4602 4344  
 700  4604 4CAE         DATA    FRSCB1                  free sectors in bitmap (from R1, # in R2)
 701  4606 C048         MOV     R8,R1                   
 702  4608 6069         S       @>0056(R9),R1                   
 702  460A 0056  
 703  460C 0281         CI      R1,>0100                end of FDR reached?
 703  460E 0100  
 704  4610 16EE         JNE     H033                    not yet
 705  4612 0460 H034    B       @RTURN1                 return to caller
 705  4614 4362  
 706            *                                       
 707  4616 06A0 RDOFSC  BL      @FDR2B1                 read a sector from offset in file
 707  4618 485C  
 708  461A 000E         DATA    14                      get # of sectors
 709  461C 80C0         C       R0,R3                   is desired sector in file?
 710  461E 1B03         JH      H035                    yes
 711  4620 06A0         BL      @ERROR5                 no: update data, then return with error
 711  4622 495E  
 712  4624 A000         DATA    >A000                   past end-of-file
 713  4626 06A0 H035    BL      @CALSUB                 call subroutine
 713  4628 4344  
 714  462A 4736         DATA    FSCTOF                  find sector from cluster list
 715  462C A101         A       R1,R4                   put sector in R4
 716  462E 0702         SETO    R2                      code for read
 717  4630 C147 H036    MOV     R7,R5                   buffer ptr
 718  4632 0460         B       @RWSEC                  read/write sector
 718  4634 4A3A  
 719            *                                       
 720  4636 0429 WROFSC  BLWP    @>005A(R9)              write sector to offset in file offset in R3
 720  4638 005A  
 721  463A 8100         DATA    >8100                   save R0 and R7
 722  463C 06A0         BL      @CALSUB                 call subroutine
 722  463E 4344  
 723  4640 464C         DATA    APSCTS                  append enough sectors to reach that offset
 724  4642 0429         BLWP    @>005A(R9)              retrieve R0 and R7
 724  4644 005A  
 725  4646 8101         DATA    >8101                   
 726  4648 04C2         CLR     R2                      code for write
 727  464A 10F2         JMP     H036                    write sector
 728            *                               
 729  464C 06A0 APSCTS  BL      @FDR2B1                 append sector(s) to a file to get offset in R3
 729  464E 485C  
 730  4650 000E         DATA    14                      get # of sect from FDR
 731            *                                       
 732  4652 80C0         C       R0,R3                   is desired sector in file?
 733  4654 1B47         JH      H045                    yes: find it and return
 734  4656 C000         MOV     R0,R0                   
 735  4658 1301         JEQ     H037                    empty file
 736  465A 0600         DEC     R0                      last sector #
 737  465C C143 H037    MOV     R3,R5                   save desired sector offset
 738  465E C0C0         MOV     R0,R3                   last sector in file
 739  4660 06A0         BL      @CALSUB                 call subroutine
 739  4662 4344  
 740  4664 4736         DATA    FSCTOF                  find sector # from offset in file
 741  4666 0429         BLWP    @>005A(R9)              save R1 (sector #)
 741  4668 005A  
 742  466A 4000         DATA    >4000                   
 743  466C A044         A       R4,R1                   # of last sector in cluster
 744  466E C105         MOV     R5,R4                   offset of desired sector
 745  4670 06A0 H038    BL      @CALSUB                 call subroutine
 745  4672 4344  
 746  4674 4BE2         DATA    FFSBMP                  find free sector in bitmap, starting from R1
 747  4676 C000         MOV     R0,R0                   found?
 748  4678 1604         JNE     H039                    yes: # in R0
 749  467A C142         MOV     R2,R5                   no: save # of sectors
 750  467C 06A0         BL      @ADDSEC                 update FDR
 750  467E 46F0  
 751  4680 101B         JMP     H040                    return with memory full
 752            *                                       
 753  4682 C041 H039    MOV     R1,R1                   
 754  4684 1320         JEQ     H043                    empty cluster
 755  4686 0581         INC     R1                      one more sector in cluster
 756  4688 8040         C       R0,R1                   same as the one found in bitmap?
 757  468A 131C         JEQ     H042                    yes: just increase cluster size
 758  468C 0429         BLWP    @>005A(R9)              no: retrieve R1 (sector #)
 758  468E 005A  
 759  4690 4001         DATA    >4001                   
 760  4692 0429         BLWP    @>005A(R9)              save R0 + R2
 760  4694 005A  
 761  4696 A000         DATA    >A000                   
 762  4698 06A0         BL      @UPDCLI                 update current cluster info
 762  469A 4BBE  
 763  469C 0429         BLWP    @>005A(R9)              retrieve R0 + R2
 763  469E 005A  
 764  46A0 A001         DATA    >A001                   
 765  46A2 0228         AI      R8,3                    ptr to next cluster info
 765  46A4 0003  
 766  46A6 C048         MOV     R8,R1                   
 767  46A8 6069         S       @>0056(R9),R1           current FDR size
 767  46AA 0056  
 768  46AC 0281         CI      R1,>0100                room enough?
 768  46AE 0100  
 769  46B0 1605         JNE     H041                    yes
 770  46B2 06A0         BL      @CALSUB                 no: call subroutine
 770  46B4 4344  
 771  46B6 4CA8         DATA    FFSBM                   free sector in bitmap
 772  46B8 0460 H040    B       @ERROR6                 return with memory full
 772  46BA 4B14  
 773            *                                       
 774  46BC C040 H041    MOV     R0,R1                   new sector #
 775  46BE 0429         BLWP    @>005A(R9)              save R1
 775  46C0 005A  
 776  46C2 4000         DATA    >4000                   
 777  46C4 1007 H042    JMP     H044                    make a new cluster
 778            *                                       
 779  46C6 0429 H043    BLWP    @>005A(R9)              retrieve R1
 779  46C8 005A  
 780  46CA 4001         DATA    >4001                   
 781  46CC 0429         BLWP    @>005A(R9)              save R0
 781  46CE 005A  
 782  46D0 8000         DATA    >8000                   
 783  46D2 0702         SETO    R2                      empty file: start from offset 0
 784  46D4 C040 H044    MOV     R0,R1                   sector #
 785  46D6 0582         INC     R2                      increment cluster size
 786  46D8 8102         C       R2,R4                   enough?
 787  46DA 16CA         JNE     H038                    no: get one more sector
 788  46DC C144         MOV     R4,R5                   
 789  46DE 06A0         BL      @ADDSEC                 add sector to FDR
 789  46E0 46F0  
 790  46E2 1004         JMP     H046                    done
 791            *                               
 792  46E4 06A0 H045    BL      @CALSUB                 call subroutine
 792  46E6 4344  
 793  46E8 4736         DATA    FSCTOF                  find a sector from offset in file
 794  46EA A101         A       R1,R4                   last sector in cluster
 795  46EC 0460 H046    B       @RTURN1                 return to caller
 795  46EE 4362  
 796            *                                       
 797  46F0 C28B ADDSEC  MOV     R11,R10                 add sector to FDR
 798  46F2 C101         MOV     R1,R4                   
 799  46F4 0429         BLWP    @>005A(R9)              retrieve R1
 799  46F6 005A  
 800  46F8 4001         DATA    >4001                   
 801  46FA C041         MOV     R1,R1                   sector #
 802  46FC 131B         JEQ     H047                    none: return
 803  46FE 06A0         BL      @UPDCLI                 write info for R1 cluster
 803  4700 4BBE  
 804  4702 C0A9         MOV     @>0056(R9),R2           pointer to FDR
 804  4704 0056  
 805  4706 0429         BLWP    @>005A(R9)              set VDP to read
 805  4708 005A  
 806  470A 0042         DATA    >0042                   address in R2
 807  470C D06F         MOVB    @-1026(R15),R1          first char of filename
 807  470E FBFE  
 808  4710 0261         ORI     R1,>8000                flag
 808  4712 8000  
 809  4714 0429         BLWP    @>005A(R9)              set VDP to write
 809  4716 005A  
 810  4718 0043         DATA    >0043                   address in R2
 811  471A DBC1         MOVB    R1,@-2(R15)                     
 811  471C FFFE  
 812  471E 0222         AI      R2,14                   ptr to # of sectors
 812  4720 000E  
 813  4722 0585         INC     R5                      new # of sectors
 814  4724 0429         BLWP    @>005A(R9)              set VDP to write
 814  4726 005A  
 815  4728 0043         DATA    >0043                   address in R2
 816  472A DBC5         MOVB    R5,@-2(R15)             update # of sectors
 816  472C FFFE  
 817  472E 06C5         SWPB    R5                      
 818  4730 DBC5         MOVB    R5,@-2(R15)                     
 818  4732 FFFE  
 819  4734 045A H047    B       *R10                    
 820            *                                       
 821  4736 C229 FSCTOF  MOV     @>0056(R9),R8           find sector from offset in file
 821  4738 0056  
 822  473A 0228         AI      R8,28                   cluster list
 822  473C 001C  
 823  473E C103         MOV     R3,R4                   desired sector offset is in R3
 824  4740 06A0 H048    BL      @DECDCI                 decode info: sector in R1, offset in R2
 824  4742 4BA2  
 825  4744 80C2         C       R2,R3                   reached yet?
 826  4746 1101         JLT     H049                    no
 827  4748 1006         JMP     H050                    yes: return
 828  474A 0228 H049    AI      R8,3                    point to next cluster info
 828  474C 0003  
 829  474E C103         MOV     R3,R4                   
 830  4750 6102         S       R2,R4                   
 831  4752 0604         DEC     R4                      size of the desired cluster (if it's the next)
 832  4754 10F5         JMP     H048                    keep trying
 833  4756 0460 H050    B       @RTURN1                 return to caller
 833  4758 4362  
 834            *
 835            *---------------------------------
 836            * Opcode 7: Delete
 837            * ----------------
 838            * PAB 0: >07
 839            *     1:            <--- error code
 840            *   2-3:
 841            *     4:
 842            *     5:
 843            *   6-7:
 844            *     8:
 845            *---------------------------------                                      
 846            *
 847  475A 06A0 DELETE  BL      @CALSUB                 delete file
 847  475C 4344  
 848  475E 4A90         DATA    FFFDRV                  find file FDR in VDP buffers
 849  4760 C104         MOV     R4,R4                   found?
 850  4762 1307         JEQ     H051                    yes
 851  4764 06A0         BL      @CALSUB                 no: call subroutine
 851  4766 4344  
 852  4768 4AF8         DATA    FFDRDK                  find FDR on disk
 853  476A C104         MOV     R4,R4                   found?
 854  476C 1313         JEQ     H053                    yes
 855  476E 0460         B       @RTURN1                 no: return to caller
 855  4770 4362  
 856            *                                       
 857  4772 0581 H051    INC     R1                      FDR found, point to it
 858  4774 CA41         MOV     R1,@>0056(R9)           save it for other routines
 858  4776 0056  
 859  4778 06A0         BL      @CALSUB                 call subroutine
 859  477A 4344  
 860  477C 4A20         DATA    RDSEC1                  read sector 1
 861  477E 06A0         BL      @FDR2B1                 read 2 bytes from VDP at >8356+offset
 861  4780 485C  
 862  4782 FFFC         DATA    -4                      i.e. get sector # of FRD in R0
 863  4784 C0C0         MOV     R0,R3                   save it for later
 864  4786 C205         MOV     R5,R8                   ptr to top of sector 1
 865  4788 06A0 H052    BL      @VDPR2B                 read 2 bytes from VDP at R8 into R0
 865  478A 4862  
 866  478C 05C8         INCT    R8                      next FDR ptr in sector 1
 867  478E 80C0         C       R0,R3                   is this the one we want?
 868  4790 16FB         JNE     H052                    not yet
 869  4792 0648         DECT    R8                      yes: point back to it
 870            *
 871  4794 06A0 H053    BL      @NTPDT                  APEDSK99: update DOAD FAT time/date
 871  4796 5F5C  
 872            *
 873  4798 0429         BLWP    @>005A(R9)              save R8
 873  479A 005A  
 874  479C 0080         DATA    >0080                   
 875  479E 06A0         BL      @CALSUB                 call subroutine
 875  47A0 4344  
 876  47A2 45C6         DATA    FFSVIB                  free file sectors in VIB bitmap
 877  47A4 0429         BLWP    @>005A(R9)              retrieve R8
 877  47A6 005A  
 878  47A8 0081         DATA    >0081                   
 879  47AA 06A0         BL      @RMFPTR                 remove FDR ptr from sector 1
 879  47AC 47C6  
 880  47AE 04C2         CLR     R2                      code for write
 881  47B0 06A0         BL      @CALSUB                 call subroutine
 881  47B2 4344  
 882  47B4 4A22         DATA    WRSEC1                  write sector 1
 883  47B6 06A0         BL      @FDR2B1                 get 2 bytes from VDP at >8356+offset in R0
 883  47B8 485C  
 884  47BA FFFC         DATA    -4                      i.e. sector # of FDR
 885  47BC 06A0         BL      @CALSUB                 call subroutine
 885  47BE 4344  
 886  47C0 4CA8         DATA    FFSBM                   free sector in R0 in VIB bitmap
 887  47C2 0460         B       @CLRFBT                 clear 1rst byte of filename in VDP
 887  47C4 456E  
 888            *
 889            * Sector 1 contains an alphabetically sorted list of FDR pointers
 890            * Each pointer is 2 bytes long and contains the sector # of this FDR
 891            * The list must end with a >0000 mark. Thus there can be 127 files at most
 892            *
 893  47C6 C169 RMFPTR  MOV     @>0056(R9),R5           remove FDR ptr from sector 1
 893  47C8 0056  
 894  47CA 0225         AI      R5,256                  
 894  47CC 0100  
 895  47CE C0C5         MOV     R5,R3                   pointer to data buffer
 896  47D0 0223         AI      R3,256                  point to next ctrl block
 896  47D2 0100  
 897  47D4 C088         MOV     R8,R2                   shift up FDR list, erasing FDR pointed by R8
 898  47D6 05C2         INCT    R2                      point to next FDR ptr in sector 1
 899  47D8 0429 H054    BLWP    @>005A(R9)              set VDP to read
 899  47DA 005A  
 900  47DC 0042         DATA    >0042                   address in R2
 901  47DE D02F         MOVB    @-1026(R15),R0          get 1 byte
 901  47E0 FBFE  
 902  47E2 0582         INC     R2                      inc source ptr
 903  47E4 0429         BLWP    @>005A(R9)              set VDP to write
 903  47E6 005A  
 904  47E8 0103         DATA    >0103                   address in R8
 905  47EA DBC0         MOVB    R0,@-2(R15)             copy 1 byte
 905  47EC FFFE  
 906  47EE 0588         INC     R8                      inc dest pointer
 907  47F0 80C2         C       R2,R3                   done?
 908  47F2 16F2         JNE     H054                    not yet
 909  47F4 045B         B       *R11                    
 910            *                                       
 911  47F6 C28B INSFDR  MOV     R11,R10                 insert a FDR in sector 1
 912  47F8 C048         MOV     R8,R1                   
 913  47FA 06A0         BL      @FDR2B1                 get 2 bytes from VDP at >8356+offset
 913  47FC 485C  
 914  47FE 01FC         DATA    508                     i.e. last FDR slot in sector 1 (list ends with 0)
 915  4800 C000         MOV     R0,R0                   
 916  4802 1302         JEQ     H055                    
 917  4804 0460         B       @ERROR6                 memory full error
 917  4806 4B14  
 918  4808 0608 H055    DEC     R8                      previous byte
 919  480A 0429         BLWP    @>005A(R9)              set VDP to read
 919  480C 005A  
 920  480E 0102         DATA    >0102                   address in R8
 921  4810 D02F         MOVB    @-1026(R15),R0          get 1 byte
 921  4812 FBFE  
 922  4814 05C8         INCT    R8                      
 923  4816 0429         BLWP    @>005A(R9)              set VDP to write
 923  4818 005A  
 924  481A 0103         DATA    >0103                   address in R8
 925  481C DBC0         MOVB    R0,@-2(R15)             copy byte two bytes further down
 925  481E FFFE  
 926  4820 0648         DECT    R8                      
 927  4822 8048         C       R8,R1                   done ?
 928  4824 16F1         JNE     H055                    not yet
 929  4826 045A         B       *R10                    
 930            *                               
 931  4828 C0A9 CMPFN   MOV     @>0058(R9),R2           compare filenames
 931  482A 0058  
 932  482C 0222         AI      R2,256                  
 932  482E 0100  
 933  4830 0429 H056    BLWP    @>005A(R9)              set VDP to read
 933  4832 005A  
 934  4834 0022         DATA    >0022                   address in R1 (ptr to filename)
 935  4836 D02F         MOVB    @-1026(R15),R0          get 1 char
 935  4838 FBFE  
 936  483A 0240         ANDI    R0,>7FFF                clear flag (on drive #)
 936  483C 7FFF  
 937  483E 0429         BLWP    @>005A(R9)              set VDP to read
 937  4840 005A  
 938  4842 0042         DATA    >0042                   address in R2 (filename compare buffer)
 939  4844 D0EF         MOVB    @-1026(R15),R3          get 1 char
 939  4846 FBFE  
 940  4848 90C0         CB      R0,R3                   compare chars
 941  484A 1604         JNE     H057                    mismatch
 942  484C 0581         INC     R1                      match: increment pointers
 943  484E 0582         INC     R2                      
 944  4850 0604         DEC     R4                      
 945  4852 16EE         JNE     H056                    next char
 946  4854 045B H057    B       *R11                    if complete match: ret with EQ set
 947            *                                       
 948  4856 C229 PABR2B  MOV     @>0054(R9),R8           get two bytes from PAB
 948  4858 0054  
 949  485A 1002         JMP     FDR2B2                  
 950            *                                       
 951  485C C229 FDR2B1  MOV     @>0056(R9),R8           get two bytes from FDR
 951  485E 0056  
 952  4860 A23B FDR2B2  A       *R11+,R8                offset in data word
 953            *                                       
 954  4862 0429 VDPR2B  BLWP    @>005A(R9)              get two byte from VDP at R8
 954  4864 005A  
 955  4866 0102         DATA    >0102                   set VDP to read at R8
 956  4868 D02F         MOVB    @-1026(R15),R0          get two bytes of data
 956  486A FBFE  
 957  486C 06C0         SWPB    R0                      
 958  486E D02F         MOVB    @-1026(R15),R0                  
 958  4870 FBFE  
 959  4872 0B80         SRC     R0,8                    why not swpb ?
 960  4874 045B         B       *R11                    
 961            *                       
 962  4876 C069 FDSKDR  MOV     @>0058(R9),R1           find disk from name (ptr in R3)
 962  4878 0058  
 963  487A 0221         AI      R1,256                  
 963  487C 0100  
 964  487E 06A0         BL      @CPCKFN                 copy filename from VDP at R3 to compare buffer
 964  4880 4900  
 965  4882 0429         BLWP    @>005A(R9)              save R2 + R3
 965  4884 005A  
 966  4886 3000         DATA    >3000                   
 967  4888 C000         MOV     R0,R0                   last char copied
 968  488A 1101         JLT     H058                    flagged
 969  488C 1005         JMP     H059                    
 970  488E C180 H058    MOV     R0,R6                   
 971  4890 0246         ANDI    R6,>0300                        
 971  4892 0300  
 972  4894 1337         JEQ     ERROR7                  return with file error
 973  4896 102F         JMP     H062                    return to caller
 974  4898 04C6 H059    CLR     R6                      don't read any drive
 975  489A 06A0         BL      @CALSUB                 call subroutine
 975  489C 4344  
 976  489E 49BE         DATA    RWVIB                   save current VIB
 977  48A0 0226 H060    AI      R6,>0100                next drive
 977  48A2 0100  
 978  48A4 0707         SETO    R7                      error flags
 979  48A6 0702         SETO    R2                      code for read
 980  48A8 04C4         CLR     R4                      sector 0
 981  48AA 06A0         BL      @CALSUB                 call subroutine
 981  48AC 4344  
 982  48AE 4A3C         DATA    RWSECA                  read sector 0
 983  48B0 C1C7         MOV     R7,R7                   ok?
 984  48B2 161D         JNE     H061                    no: try next drive
 985  48B4 0204         LI      R4,10                   yes: diskname size
 985  48B6 000A  
 986  48B8 C069         MOV     @>0058(R9),R1           VIB ptr
 986  48BA 0058  
 987  48BC 0429         BLWP    @>005A(R9)              save R1-R3
 987  48BE 005A  
 988  48C0 7000         DATA    >7000                   
 989  48C2 06A0         BL      @CMPFN                  compare names (ptr in R1 + compare buffer)
 989  48C4 4828  
 990  48C6 0429         BLWP    @>005A(R9)                      
 990  48C8 005A  
 991  48CA 7001         DATA    >7001                   retrieve R1-R3
 992  48CC C104         MOV     R4,R4                   name matched?
 993  48CE 160F         JNE     H061                    no: try next drive
 994  48D0 C006         MOV     R6,R0                   drive #
 995  48D2 0260         ORI     R0,>8000                add update flag
 995  48D4 8000  
 996  48D6 0429         BLWP    @>005A(R9)              set VDP to write
 996  48D8 005A  
 997  48DA 0063         DATA    >0063                   address in R3
 998  48DC DBC0         MOVB    R0,@-2(R15)             copy drive+flag before diskname in source
 998  48DE FFFE  
 999  48E0 0605         DEC     R5                      before sector 0 copy
1000  48E2 0429         BLWP    @>005A(R9)              set VDP to write
1000  48E4 005A  
1001  48E6 00A3         DATA    >00A3                   address in R5
1002  48E8 DBC6         MOVB    R6,@-2(R15)             copy drive # before VIB
1002  48EA FFFE  
1003  48EC 1004         JMP     H062                    done
1004            *                               
1005  48EE 0286 H061    CI      R6,>0300                did we do all drives?
1005  48F0 0300  
1006  48F2 16D6         JNE     H060                    no: try next on
1007  48F4 1007         JMP     ERROR7                  return with file error
1008            *                                       
1009  48F6 0429 H062    BLWP    @>005A(R9)              retrieve R2 + R3
1009  48F8 005A  
1010  48FA 3001         DATA    >3001                   
1011  48FC 0460         B       @RTURN1                 return to caller
1011  48FE 4362  
1012            *                               
1013  4900 0602 CPCKFN  DEC     R2                      
1014  4902 1B03         JH      H063                    
1015  4904 06A0 ERROR7  BL      @RETERR                 return with error
1015  4906 498A  
1016  4908 E000         DATA    >E000                   file error
1017            *                                       
1018  490A 0200 H063    LI      R0,>2000                copy (+check) filename in VDP from R3 to R1 (space)
1018  490C 2000  
1019  490E 0429         BLWP    @>005A(R9)              set VDP to write
1019  4910 005A  
1020  4912 0023         DATA    >0023                   address in R1
1021  4914 0208         LI      R8,10                   10 chars per filename
1021  4916 000A  
1022  4918 DBC0 H064    MOVB    R0,@-2(R15)             fill filename with spaces
1022  491A FFFE  
1023  491C 0608         DEC     R8                      
1024  491E 16FC         JNE     H064                    
1025  4920 0208         LI      R8,11                   11 chars countring drive #
1025  4922 000B  
1026  4924 0583 H065    INC     R3                      increment source ptr
1027  4926 0429         BLWP    @>005A(R9)              set VDP to read
1027  4928 005A  
1028  492A 0062         DATA    >0062                   address in R3
1029  492C D02F         MOVB    @-1026(R15),R0          get a char
1029  492E FBFE  
1030  4930 13E9         JEQ     ERROR7                  >00: return with file error
1031  4932 1110         JLT     H066                    flag bit set
1032  4934 0280         CI      R0,>2E00                        
1032  4936 2E00  
1033  4938 130D         JEQ     H066                    '.'
1034  493A 0608         DEC     R8                      
1035  493C 13E3         JEQ     ERROR7                  name to long: return with file error
1036  493E 0280         CI      R0,>2000                        
1036  4940 2000  
1037  4942 13E0         JEQ     ERROR7                  name can't contain spaces: file error again
1038  4944 0429         BLWP    @>005A(R9)              set VDP to write
1038  4946 005A  
1039  4948 0023         DATA    >0023                   address in R1
1040  494A DBC0         MOVB    R0,@-2(R15)             copy 1 char
1040  494C FFFE  
1041  494E 0581         INC     R1                      increment destination pointer
1042  4950 0602         DEC     R2                      more?
1043  4952 16E8         JNE     H065                    yes
1044  4954 0288 H066    CI      R8,>000B                name can't be 0 chars long
1044  4956 000B  
1045  4958 13D5         JEQ     ERROR7                  else return with file error
1046  495A 045B         B       *R11                    
1047            *                                       
1048  495C AA00 K014    DATA    >AA00                   
1049            *                               
1050  495E C00B ERROR5  MOV     R11,R0                  update data, then error
1051  4960 C0E9         MOV     @>0056(R9),R3           
1051  4962 0056  
1052  4964 0603         DEC     R3                      see what >8356 is pointing at
1053  4966 0429         BLWP    @>005A(R9)              set VDP to read
1053  4968 005A  
1054  496A 0062         DATA    >0062                   address in R3
1055  496C D0AF         MOVB    @-1026(R15),R2          get 1 byte
1055  496E FBFE  
1056  4970 9802         CB      R2,@K014                is it >AA (disk buffer area mark)
1056  4972 495C  
1057  4974 1309         JEQ     H067                    yes: announce error (code in data word)
1058  4976 0429         BLWP    @>005A(R9)              no: >8356 points to a FDR. Save R0
1058  4978 005A  
1059  497A 8000         DATA    >8000                   
1060  497C 06A0         BL      @CALSUB                 call subroutine
1060  497E 4344  
1061  4980 4562         DATA    UPDFDR                  update FRD and data buffer if needed
1062  4982 0429         BLWP    @>005A(R9)              retrieve R0
1062  4984 005A  
1063  4986 8001         DATA    >8001                   
1064  4988 C2C0 H067    MOV     R0,R11                  
1065            *                               
1066  498A C069 RETERR  MOV     @>0054(R9),R1           annouce error
1066  498C 0054  
1067  498E 130D         JEQ     H068                    no PAB
1068  4990 0581         INC     R1                      for DSRs: ptr to status byte
1069  4992 0429         BLWP    @>005A(R9)              set VDP to read
1069  4994 005A  
1070  4996 0022         DATA    >0022                   address in R2
1071  4998 D0AF         MOVB    @-1026(R15),R2          get file status byte
1071  499A FBFE  
1072  499C E0BB         SOC     *R11+,R2                add error code
1073  499E 0429         BLWP    @>005A(R9)              set VDP to write
1073  49A0 005A  
1074  49A2 0023         DATA    >0023                   address in R2
1075  49A4 DBC2         MOVB    R2,@-2(R15)             write back status byte
1075  49A6 FFFE  
1076  49A8 1002         JMP     H069                    
1077  49AA CA7B H068    MOV     *R11+,@>0050(R9)        for subs: error code in >8350
1077  49AC 0050  
1078  49AE C229 H069    MOV     @>0058(R9),R8           get stack ptr
1078  49B0 0058  
1079  49B2 0228         AI      R8,-12                  point back to initial caller
1079  49B4 FFF4  
1080  49B6 CA48         MOV     R8,@>0066(R9)           update pointer
1080  49B8 0066  
1081  49BA 0460         B       @RTURN1                 return to caller
1081  49BC 4362  
1082            *                               
1083  49BE 0429 RWVIB   BLWP    @>005A(R9)              read VIB (drive # in R6)
1083  49C0 005A  
1084  49C2 3000         DATA    >3000                   save R2 + R3
1085  49C4 C169         MOV     @>0058(R9),R5           pointer to VIB in ctrl block
1085  49C6 0058  
1086  49C8 0605         DEC     R5                      ptr to drive #
1087  49CA 0429         BLWP    @>005A(R9)              set VDP for read
1087  49CC 005A  
1088  49CE 00A2         DATA    >00A2                   address in R5
1089  49D0 D0AF         MOVB    @-1026(R15),R2          get drive #
1089  49D2 FBFE  
1090  49D4 C0C2         MOV     R2,R3                   
1091  49D6 04C4         CLR     R4                      sector 0 for VIB
1092  49D8 0242         ANDI    R2,>0300                clear flag (>80 = update data)
1092  49DA 0300  
1093  49DC 9182         CB      R2,R6                   wanted drive?
1094  49DE 131A         JEQ     H073                    yes: return
1095  49E0 C0C3         MOV     R3,R3                   no: shall we update VIB?
1096  49E2 1101         JLT     H070                    yes
1097  49E4 100A         JMP     H071                    no
1098  49E6 0429 H070    BLWP    @>005A(R9)              set VDP to write
1098  49E8 005A  
1099  49EA 00A3         DATA    >00A3                   address in R5
1100  49EC DBC4         MOVB    R4,@-2(R15)             clr drive #
1100  49EE FFFE  
1101  49F0 0585         INC     R5                      point back to VIB buffer
1102  49F2 06A0         BL      @CALSUB                 call subroutine
1102  49F4 4344  
1103  49F6 4A3E         DATA    RWSECB                  write sector 0 to old drive (in R2)
1104  49F8 0605         DEC     R5                      point to drive #
1105  49FA 0702 H071    SETO    R2                      flag for read
1106  49FC D086         MOVB    R6,R2                   APEDSK99: error in original disassembly (was R5)
1107  49FE 1305         JEQ     H072                    none
1108  4A00 0585         INC     R5                      point at VIB buffer
1109  4A02 06A0         BL      @CALSUB                 call subroutine
1109  4A04 4344  
1110  4A06 4A3C         DATA    RWSECA                  read sector (in R4) to buffer (in R5)
1111  4A08 0605         DEC     R5                      point at drive #
1112  4A0A 0429 H072    BLWP    @>005A(R9)              set VDP to write
1112  4A0C 005A  
1113  4A0E 00A3         DATA    >00A3                   address in R5
1114  4A10 DBC6         MOVB    R6,@-2(R15)             write drive # in control block, before FDR
1114  4A12 FFFE  
1115  4A14 0585 H073    INC     R5                      point back to FDR
1116  4A16 0429         BLWP    @>005A(R9)                      
1116  4A18 005A  
1117  4A1A 3001         DATA    >3001                   retrieve R2 + R3 from stack
1118  4A1C 0460         B       @RTURN1                 branch to address on stack
1118  4A1E 4362  
1119            *                               
1120  4A20 0702 RDSEC1  SETO    R2                      read sector 1
1121  4A22 0204 WRSEC1  LI      R4,1
1121  4A24 0001  
1122  4A26 0205         LI      R5,>0100                into data buffer area of current ctrl block
1122  4A28 0100  
1123  4A2A 1005         JMP     RDFDR1                  
1124            *                               
1125  4A2C 06A0 WRFDR   BL      @FDR2B1                 read FDR
1125  4A2E 485C  
1126  4A30 FFFC         DATA    -4                      get sector # of FDR from control block
1127            *                               
1128  4A32 C100 RDFDR2  MOV     R0,R4                   sector read/write
1129  4A34 04C5         CLR     R5
1130  4A36 A169 RDFDR1  A       @>0056(R9),R5           point to FDR or data buffer
1130  4A38 0056  
1131  4A3A 04C7 RWSEC   CLR     R7                      
1132  4A3C D086 RWSECA  MOVB    R6,R2                   add drive # for r/w flag
1133  4A3E 0429 RWSECB  BLWP    @>005A(R9)              save R0-R8
1133  4A40 005A  
1134  4A42 FF80         DATA    >FF80                   
1135  4A44 CA44         MOV     R4,@>004A(R9)           sector #
1135  4A46 004A  
1136  4A48 CA42         MOV     R2,@>004C(R9)           drive | r/w flag
1136  4A4A 004C  
1137  4A4C CA45         MOV     R5,@>004E(R9)           buffer ptr
1137  4A4E 004E  
1138  4A50 06A0         BL      @CALSUB                 call subroutine
1138  4A52 4344  
1139  4A54 419A         DATA    SECRW1                  sector read/write
1140  4A56 0429         BLWP    @>005A(R9)              retrieve R0-R8
1140  4A58 005A  
1141  4A5A FF81         DATA    >FF81                   
1142  4A5C D1E9         MOVB    @>0050(R9),R7           get error code | flags
1142  4A5E 0050  
1143  4A60 06C7         SWPB    R7                      
1144  4A62 1312         JEQ     H077                    
1145  4A64 C1C7         MOV     R7,R7                   
1146  4A66 1501         JGT     H074                    
1147  4A68 100B         JMP     H076                    
1148  4A6A 0247 H074    ANDI    R7,>00FF                        
1148  4A6C 00FF  
1149  4A6E 0287         CI      R7,>0034                        
1149  4A70 0034  
1150  4A72 1603         JNE     H075                    
1151  4A74 06A0         BL      @ERROR5                 
1151  4A76 495E  
1152  4A78 2000         DATA    >2000                   write protected
1153  4A7A 06A0 H075    BL      @ERROR5                 
1153  4A7C 495E  
1154  4A7E C000         DATA    >C000                   device error
1155  4A80 DA69 H076    MOVB    @>004D(R9),@>004D(R9)   read or write?
1155  4A82 004D  
1155  4A84 004D  
1156  4A86 13F1         JEQ     H074                    write
1157  4A88 0247 H077    ANDI    R7,>00FF                        
1157  4A8A 00FF  
1158  4A8C 0460         B       @RTURN1                 return to caller
1158  4A8E 4362  
1159            *                               
1160  4A90 C069 FFFDRV  MOV     @>0058(R9),R1           save filename in compare buffer and find its FDR
1160  4A92 0058  
1161  4A94 0221         AI      R1,256                  
1161  4A96 0100  
1162  4A98 0429         BLWP    @>005A(R9)              set VDP to write
1162  4A9A 005A  
1163  4A9C 0023         DATA    >0023                   address in R1: filename compare buffer
1164  4A9E DBC6         MOVB    R6,@-2(R15)             write drive #
1164  4AA0 FFFE  
1165  4AA2 0581         INC     R1                      
1166  4AA4 06A0         BL      @CPCKFN                 copy (+ check) filename from R3 to R1
1166  4AA6 4900  
1167  4AA8 C082         MOV     R2,R2                   all chars copied (or was there a . or a >00
1168  4AAA 1302         JEQ     FFDRVB                  
1169  4AAC 0460 H078    B       @ERROR7                 return with file error
1169  4AAE 4904  
1170            *                                       
1171  4AB0 C069 FFDRVB  MOV     @>0056(R9),R1           find filename in buffered FDRs
1171  4AB2 0056  
1172  4AB4 0221         AI      R1,3                    
1172  4AB6 0003  
1173  4AB8 0429         BLWP    @>005A(R9)              set VDP to read
1173  4ABA 005A  
1174  4ABC 0022         DATA    >0022                   address in R1
1175  4ABE D0AF         MOVB    @-1026(R15),R2          get # of files
1175  4AC0 FBFE  
1176  4AC2 0982         SRL     R2,8                    make it a word
1177  4AC4 C0C2         MOV     R2,R3                   save it
1178  4AC6 0221         AI      R1,6                    ptr to drive #
1178  4AC8 0006  
1179  4ACA 0204 H079    LI      R4,11                   compare 11 bytes (drive + filename)
1179  4ACC 000B  
1180  4ACE 0429         BLWP    @>005A(R9)              save R1-R3
1180  4AD0 005A  
1181  4AD2 7000         DATA    >7000                   
1182  4AD4 06A0         BL      @CMPFN                  compare with name in compare buffer
1182  4AD6 4828  
1183  4AD8 0429         BLWP    @>005A(R9)              retrieve R1-R3
1183  4ADA 005A  
1184  4ADC 7001         DATA    >7001                   
1185  4ADE C104         MOV     R4,R4                   fully compared?
1186  4AE0 1304         JEQ     H080                    yes: done
1187  4AE2 0221         AI      R1,518                  move to next FDR in VDP mem
1187  4AE4 0206  
1188  4AE6 0602         DEC     R2                      
1189  4AE8 16F0         JNE     H079                    next file
1190  4AEA 0460 H080    B       @RTURN1                 return to caller (R4=0 if successfull)
1190  4AEC 4362  
1191            *                               
1192  4AEE 06A0 FNDFDR  BL      @CALSUB                 
1192  4AF0 4344  
1193  4AF2 4A90         DATA    FFFDRV                  save name in comp buffer, find FDR in VDP buffers
1194            *                                       
1195  4AF4 C104 FFDROD  MOV     R4,R4                   find FDR on disk (from filename)
1196  4AF6 13DA         JEQ     H078                    file error
1197  4AF8 C169 FFDRDK  MOV     @>0056(R9),R5           ptr to top of disk buffer in VDP mem
1197  4AFA 0056  
1198  4AFC 0225         AI      R5,10                   ptr to drive # in first file control block
1198  4AFE 000A  
1199  4B00 0429 H081    BLWP    @>005A(R9)              set VDP to read
1199  4B02 005A  
1200  4B04 00A2         DATA    >00A2                   address in R5
1201  4B06 D0AF         MOVB    @-1026(R15),R2          get drive #
1201  4B08 FBFE  
1202  4B0A 1307         JEQ     H082                    free control block found
1203  4B0C 0225         AI      R5,518                  ptr to file control block
1203  4B0E 0206  
1204  4B10 0603         DEC     R3                      
1205  4B12 16F6         JNE     H081                    more files ?
1206  4B14 06A0 ERROR6  BL      @ERROR5                 no:
1206  4B16 495E  
1207  4B18 8000         DATA    >8000                   memory full
1208            *                               
1209  4B1A CA45 H082    MOV     R5,@>0056(R9)           save ptr to free ctrl block (drive #)
1209  4B1C 0056  
1210  4B1E 06A0         BL      @CALSUB                 call subroutine
1210  4B20 4344  
1211  4B22 4A20         DATA    RDSEC1                  read sector 1
1212  4B24 C229 FFDRFN  MOV     @>0056(R9),R8           entry point if sector 1 already read
1212  4B26 0056  
1213  4B28 0228         AI      R8,382                  point to middle of sector 1
1213  4B2A 017E  
1214  4B2C 0202         LI      R2,64                   distance: start with 1/4 sector
1214  4B2E 0040  
1215  4B30 0704 H083    SETO    R4                      
1216  4B32 06A0         BL      @VDPR2B                 read 2 bytes in R0 from VDP address in R8
1216  4B34 4862  
1217  4B36 C000         MOV     R0,R0                   
1218  4B38 132E         JEQ     H085                    no file here: move up
1219  4B3A 0429         BLWP    @>005A(R9)              save R2
1219  4B3C 005A  
1220  4B3E 2000         DATA    >2000                   
1221  4B40 0702         SETO    R2                      code for read
1222  4B42 06A0         BL      @CALSUB                 call subroutine
1222  4B44 4344  
1223  4B46 4A32         DATA    RDFDR2                  read FDR, sector # in R0
1224  4B48 C045         MOV     R5,R1                   RDFDR2 sets R5 as FDR ptr
1225  4B4A 0225         AI      R5,-4                   point to sector # of FDR in ctrl block
1225  4B4C FFFC  
1226  4B4E 0429         BLWP    @>005A(R9)              set VDP to write
1226  4B50 005A  
1227  4B52 00A3         DATA    >00A3                   address in R5
1228  4B54 DBC4         MOVB    R4,@-2(R15)             RDFDR2 puts sector # in R4
1228  4B56 FFFE  
1229  4B58 06C4         SWPB    R4                      copy it to ctrl block
1230  4B5A DBC4         MOVB    R4,@-2(R15)                     
1230  4B5C FFFE  
1231  4B5E C141         MOV     R1,R5                   FDR ptr
1232  4B60 0601         DEC     R1                      now point to drive #
1233  4B62 0429         BLWP    @>005A(R9)              set VDP to write
1233  4B64 005A  
1234  4B66 0023         DATA    >0023                   address in R1
1235  4B68 DBC6         MOVB    R6,@-2(R15)             save drive #
1235  4B6A FFFE  
1236  4B6C 0204         LI      R4,11                   size to compare (drive # + filename)
1236  4B6E 000B  
1237  4B70 06A0         BL      @CMPFN                  compare filenames
1237  4B72 4828  
1238  4B74 0429         BLWP    @>005A(R9)              retrieve R2
1238  4B76 005A  
1239  4B78 2001         DATA    >2001                   
1240  4B7A 130B         JEQ     H084                    compared ok: return
1241  4B7C 0429         BLWP    @>005A(R9)              set VDP to write
1241  4B7E 005A  
1242  4B80 00A3         DATA    >00A3                   address in R5
1243  4B82 DBC4         MOVB    R4,@-2(R15)             remaining chars to compare
1243  4B84 FFFE  
1244  4B86 80C0         C       R0,R3                   what kind of mismatch occured?
1245  4B88 1B06         JH      H085                    too far down the alphabet
1246  4B8A A202         A       R2,R8                   too far up: move half-way down
1247  4B8C C082         MOV     R2,R2                   
1248  4B8E 1606         JNE     H086                    then divide distance by 2
1249  4B90 05C8         INCT    R8                      already checked: reset EQ
1250  4B92 0460 H084    B       @RTURN1                 return (from stack)
1250  4B94 4362  
1251            *                               
1252  4B96 6202 H085    S       R2,R8                   move half-way up
1253  4B98 C082         MOV     R2,R2                   
1254  4B9A 13FB         JEQ     H084                    can't: already checked
1255  4B9C 0922 H086    SRL     R2,2                    divide distance by 2
1256  4B9E A082         A       R2,R2                   but keep it even
1257  4BA0 10C7         JMP     H083                    
1258            *
1259            * The cluster info list is located in the FDR, bytes >1C to >FF
1260            * A cluster info consists in 3 bytes, i.e 6 nibbles
1261            * 3 nibbles specify the beginning sector for that cluster, and
1262            * 3 nibbles specify the total file offset in sectors, including this cluster.
1263            * The nibbles are arranged as EG SB OF, to be combined as BEG OFS
1264            *
1265  4BA2 C28B DECDCI  MOV     R11,R10                 decode cluster info
1266  4BA4 06A0         BL      @VDPR2B                 read 2 bytes VDP at R8 in R0
1266  4BA6 4862  
1267  4BA8 06C0         SWPB    R0                      
1268  4BAA D0AF         MOVB    @-1026(R15),R2          get third byte from cluster list
1268  4BAC FBFE  
1269  4BAE C040         MOV     R0,R1                   
1270  4BB0 0241         ANDI    R1,>0FFF                start sector in R1
1270  4BB2 0FFF  
1271  4BB4 4001         SZC     R1,R0                   remove it from R0
1272  4BB6 0982         SRL     R2,8                    
1273  4BB8 E080         SOC     R0,R2                   combine offset nibbles
1274  4BBA 0BC2         SRC     R2,12                   offset in R2
1275  4BBC 045A         B       *R10                    
1276            *                               
1277  4BBE 0B42 UPDCLI  SRC     R2,4                    write info for 1 cluster
1278  4BC0 C002         MOV     R2,R0                   
1279  4BC2 0240         ANDI    R0,>F000                sector in R1, offset in R2
1279  4BC4 F000  
1280  4BC6 E040         SOC     R0,R1                   copy nibble 3 of offset before nibble 1 of sector
1281  4BC8 0429         BLWP    @>005A(R9)              set VDP to write
1281  4BCA 005A  
1282  4BCC 0103         DATA    >0103                   address in R8
1283  4BCE 06C1         SWPB    R1                      write cluster info
1284  4BD0 DBC1         MOVB    R1,@-2(R15)             as 3 bytes
1284  4BD2 FFFE  
1285  4BD4 06C1         SWPB    R1                      
1286  4BD6 DBC1         MOVB    R1,@-2(R15)                     
1286  4BD8 FFFE  
1287  4BDA 06C2         SWPB    R2                      
1288  4BDC DBC2         MOVB    R2,@-2(R15)                     
1288  4BDE FFFE  
1289  4BE0 045B         B       *R11                    
1290            *
1291            * The sector bitmap is located in the VIB (i.e. sector 0) at bytes >38 to >FF
1292            * In each byte a bit defines a sector, from right to left: "0"=free, "1"=used                                   
1293            *
1294  4BE2 0429 FFSBMP  BLWP    @>005A(R9)              find a free sector in bitmap
1294  4BE4 005A  
1295  4BE6 7800         DATA    >7800                   
1296  4BE8 06A0         BL      @CALSUB                 call subroutine
1296  4BEA 4344  
1297  4BEC 49BE         DATA    RWVIB                   load VIB for drive in R6
1298  4BEE C041         MOV     R1,R1                   first sector specified in R1 ?
1299  4BF0 1602         JNE     H087                    yes
1300  4BF2 0201         LI      R1,33                   no: start with sector 34
1300  4BF4 0021  
1301  4BF6 0581 H087    INC     R1                      
1302  4BF8 C001         MOV     R1,R0                   
1303  4BFA 0931         SRL     R1,3                    div by 8 since 8 sect/byte in bitmap
1304  4BFC 0202         LI      R2,>00FF                        
1304  4BFE 00FF  
1305  4C00 0240         ANDI    R0,>0007                bit number in bitmap byte
1305  4C02 0007  
1306  4C04 1301         JEQ     H088                    
1307  4C06 0A02         SLA     R2,0                    get that bit
1308  4C08 C0C1 H088    MOV     R1,R3                   byte #
1309  4C0A A0C5         A       R5,R3                   add VIB ptr
1310  4C0C 0223         AI      R3,56                   ptr to sector in bitmap
1310  4C0E 0038  
1311  4C10 0281         CI      R1,>00C8                end of VIB?
1311  4C12 00C8  
1312  4C14 1101         JLT     H089                    no
1313  4C16 04C1         CLR     R1                      yes: top of bitmap
1314  4C18 A045 H089    A       R5,R1                   
1315  4C1A 0221         AI      R1,56                   make another bitmap ptr
1315  4C1C 0038  
1316  4C1E 0429         BLWP    @>005A(R9)              set VDP to read
1316  4C20 005A  
1317  4C22 0022         DATA    >0022                   address in R1
1318  4C24 0700 H090    SETO    R0                      
1319  4C26 D02F         MOVB    @-1026(R15),R0          get bitmap byte
1319  4C28 FBFE  
1320  4C2A C100         MOV     R0,R4                   save it
1321  4C2C E002         SOC     R2,R0                   mask previous sectors
1322  4C2E 04C2         CLR     R2                      
1323  4C30 0580         INC     R0                      get 1 more sector
1324  4C32 1610         JNE     H092                    ok
1325  4C34 0581         INC     R1                      byte full: try next
1326  4C36 C001         MOV     R1,R0                   
1327  4C38 0220         AI      R0,-256                 won't change if byte # became >100
1327  4C3A FF00  
1328  4C3C 8140         C       R0,R5                   still in VIB?
1329  4C3E 1605         JNE     H091                    yes
1330  4C40 0221         AI      R1,-200                 no: to top of bitmap
1330  4C42 FF38  
1331  4C44 0429         BLWP    @>005A(R9)              set VDP to read
1331  4C46 005A  
1332  4C48 0022         DATA    >0022                   address in R1
1333  4C4A 80C1 H091    C       R1,R3                   are we back to where we started?
1334  4C4C 16EB         JNE     H090                    no: seach that byte for a free sector
1335  4C4E C004         MOV     R4,R0                   get original byte
1336  4C50 0580         INC     R0                      try sectors just before ours (no mask this time)
1337  4C52 1325         JEQ     H095                    full: return with EQ
1338  4C54 0600 H092    DEC     R0                      restore original byte
1339  4C56 C080         MOV     R0,R2                   
1340  4C58 04C0         CLR     R0                      bit counter
1341  4C5A 06C2         SWPB    R2                      
1342  4C5C 0580 H093    INC     R0                      increment bit count
1343  4C5E 0B12         SRC     R2,1                    find first 0 bit from the right
1344  4C60 18FD         JOC     H093                    not yet
1345  4C62 0202         LI      R2,>0080                        
1345  4C64 0080  
1346  4C66 0A02         SLA     R2,0                    make a mask for that bit
1347  4C68 0600         DEC     R0                      bit # (0-7)
1348  4C6A E102         SOC     R2,R4                   mark sector as used in bitmap byte
1349  4C6C 0429         BLWP    @>005A(R9)              set VDP to write
1349  4C6E 005A  
1350  4C70 0023         DATA    >0023                   address in R1
1351  4C72 DBC4         MOVB    R4,@-2(R15)             update bitmap
1351  4C74 FFFE  
1352  4C76 0221         AI      R1,-56                  
1352  4C78 FFC8  
1353  4C7A 6045         S       R5,R1                   byte # in bitmap
1354  4C7C 0A31         SLA     R1,3                    times 8 (8 sect per byte)
1355  4C7E E040         SOC     R0,R1                   add bit #: = sector #
1356  4C80 C001         MOV     R1,R0                   save it
1357            *                               
1358  4C82 0605 H094    DEC     R5                      point to drive #
1359  4C84 0429         BLWP    @>005A(R9)              set VDP to read
1359  4C86 005A  
1360  4C88 00A2         DATA    >00A2                   address in R5
1361  4C8A D06F         MOVB    @-1026(R15),R1          get drive #
1361  4C8C FBFE  
1362  4C8E 0261         ORI     R1,>8000                add flag: update VIB
1362  4C90 8000  
1363  4C92 0429         BLWP    @>005A(R9)              set VDP to write
1363  4C94 005A  
1364  4C96 00A3         DATA    >00A3                   address in R5
1365  4C98 DBC1         MOVB    R1,@-2(R15)             write back flagged drive #
1365  4C9A FFFE  
1366  4C9C 0585         INC     R5                      point to VIB (& return with NEQ)
1367  4C9E 0429 H095    BLWP    @>005A(R9)              retrieve R1-R4
1367  4CA0 005A  
1368  4CA2 7801         DATA    >7801                   
1369  4CA4 0460         B       @RTURN1                 return to caller
1369  4CA6 4362  
1370            *                               
1371  4CA8 C040 FFSBM   MOV     R0,R1                   free sector(s) in bitmap
1372  4CAA 0202         LI      R2,1                    1 sector only
1372  4CAC 0001  
1373  4CAE 0429 FRSCB1  BLWP    @>005A(R9)              entry point if more than 1 sector
1373  4CB0 005A  
1374  4CB2 7800         DATA    >7800                   save R1-R4
1375  4CB4 06A0         BL      @CALSUB                 call subroutine
1375  4CB6 4344  
1376  4CB8 49BE         DATA    RWVIB                   load VIB for drive in R6
1377  4CBA C001         MOV     R1,R0                   sector #
1378  4CBC 0240         ANDI    R0,>0007                bit in bitmap byte (8 per byte)
1378  4CBE 0007  
1379  4CC0 0931         SRL     R1,3                    byte in bitmap
1380  4CC2 A045         A       R5,R1                   add VIB buffer
1381  4CC4 0221         AI      R1,56                   add bitmap offset in VIB
1381  4CC6 0038  
1382  4CC8 C0C0         MOV     R0,R3                   
1383  4CCA 0500         NEG     R0                      
1384  4CCC 0220         AI      R0,8                    change 0-7 into 8-1
1384  4CCE 0008  
1385  4CD0 0204         LI      R4,>00FF                mask to erase
1385  4CD2 00FF  
1386  4CD4 8002         C       R2,R0                   how many to erase?
1387  4CD6 1101         JLT     H096                    less than in that byte
1388  4CD8 100A         JMP     H099                    
1389            *                               
1390  4CDA 0200 H096    LI      R0,8                    free sectors in first byte
1390  4CDC 0008  
1391  4CDE 6002         S       R2,R0                   
1392  4CE0 0B04         SRC     R4,0                    adjust mask
1393  4CE2 C003         MOV     R3,R0                   original bit # of starting sector
1394  4CE4 1301         JEQ     H097                    
1395  4CE6 0A04         SLA     R4,0                    don't erase before starting sector
1396  4CE8 1000 H097    JMP     H098                    
1397            *                               
1398  4CEA 06C4 H098    SWPB    R4                      
1399  4CEC 1019         JMP     H102                    goto erase last byte
1400            *                                       
1401  4CEE 0B04 H099    SRC     R4,0                    adjust mask
1402  4CF0 6080 H100    S       R0,R2                   that many will be freed
1403  4CF2 0429         BLWP    @>005A(R9)              set VDP to read
1403  4CF4 005A  
1404  4CF6 0022         DATA    >0022                   address in R1
1405  4CF8 D02F         MOVB    @-1026(R15),R0          get bitmap byte
1405  4CFA FBFE  
1406  4CFC 4004         SZC     R4,R0                   mark sectors as free
1407  4CFE 0429         BLWP    @>005A(R9)              set VDP to write
1407  4D00 005A  
1408  4D02 0023         DATA    >0023                   address in R1
1409  4D04 DBC0         MOVB    R0,@-2(R15)             write it back
1409  4D06 FFFE  
1410  4D08 0204         LI      R4,>FF00                clear full byte
1410  4D0A FF00  
1411  4D0C 0581         INC     R1                      next byte
1412  4D0E 0200         LI      R0,8                    i.e. 8 sectors
1412  4D10 0008  
1413  4D12 8002         C       R2,R0                   how many more sectors?
1414  4D14 1101         JLT     H101                    less than 8
1415  4D16 10EC         JMP     H100                    8 or more: next byte
1416            *                                       
1417  4D18 C002 H101    MOV     R2,R0                   remaining sectors
1418  4D1A 0204         LI      R4,>00FF                        
1418  4D1C 00FF  
1419  4D1E 0A04         SLA     R4,0                    coin mask
1420  4D20 0429 H102    BLWP    @>005A(R9)              set VDP to read
1420  4D22 005A  
1421  4D24 0022         DATA    >0022                   address in R1
1422  4D26 D02F         MOVB    @-1026(R15),R0          get bitmap byte
1422  4D28 FBFE  
1423  4D2A 4004         SZC     R4,R0                   mark sectors as free
1424  4D2C 0429         BLWP    @>005A(R9)              set VDP to write
1424  4D2E 005A  
1425  4D30 0023         DATA    >0023                   address in R1
1426  4D32 DBC0         MOVB    R0,@-2(R15)             write it back
1426  4D34 FFFE  
1427  4D36 10A5         JMP     H094                    done: flag drive # and return
1428            *
1429            *===================================
1430            * DSR entry points
1431            *===================================                                    
1432            *
1433  4D38 C1CB EDSR01  MOV     R11,R7                  DSK
1434  4D3A 06A0         BL      @PRPFDO                 --- prepare file operations
1434  4D3C 4410  
1435  4D3E 06A0         BL      @CALSUB                 call subroutine
1435  4D40 4344  
1436  4D42 4876         DATA    FDSKDR                  find disk in drive (name ptr in R3)
1437  4D44 100B         JMP     H104                    
1438            *                                       
1439  4D46 0206 EDSR02  LI      R6,>0100                DSK1
1439  4D48 0100  
1440  4D4A 1005         JMP     H103                    ----
1441            *                                       
1442  4D4C 0206 EDSR03  LI      R6,>0200                DSK2
1442  4D4E 0200  
1443  4D50 1002         JMP     H103                    ----
1444            *                                       
1445  4D52 0206 EDSR04  LI      R6,>0300                DSK3
1445  4D54 0300  
1446            *                                       
1447  4D56 C1CB H103    MOV     R11,R7                  save return address
1448  4D58 06A0         BL      @PRPFDO                 prepare file operations
1448  4D5A 4410  
1449  4D5C C029 H104    MOV     @>0054(R9),R0           PAB ptr
1449  4D5E 0054  
1450  4D60 0429         BLWP    @>005A(R9)              set VDP to read
1450  4D62 005A  
1451  4D64 0002         DATA    >0002                   address in R0
1452  4D66 D06F         MOVB    @-1026(R15),R1          get opcode
1452  4D68 FBFE  
1453  4D6A 0981         SRL     R1,8                    
1454  4D6C 0281         CI      R1,>0009                check range
1454  4D6E 0009  
1455  4D70 1B19         JH      ERROR8                  illegal opcode
1456  4D72 0282         CI      R2,>0001                filename lenght (including . )
1456  4D74 0001  
1457  4D76 1605         JNE     H105                    no filename: dir
1458  4D78 0221         AI      R1,10                   only allow open, close and read
1458  4D7A 000A  
1459  4D7C 0281         CI      R1,>000C                        
1459  4D7E 000C  
1460  4D80 1B11         JH      ERROR8                  others are illegal
1461  4D82 A041 H105    A       R1,R1                   make it a word ptr
1462  4D84 C061         MOV     @OPCVEC(R1),R1          get vector
1462  4D86 4D8A  
1463  4D88 0451         B       *R1                     branch to it
1464            *                                       
1465  4D8A 4DAA OPCVEC  DATA    OPEN                    open
1466  4D8C 4FBC         DATA    CLOSE                   close
1467  4D8E 4FC6         DATA    READ                    read
1468  4D90 50B0         DATA    WRITE                   write
1469  4D92 5364         DATA    RWIND1                  rewind
1470  4D94 53B8         DATA    LOAD                    load
1471  4D96 545A         DATA    SAVE                    save
1472  4D98 475A         DATA    DELETE                  delete
1473  4D9A 498A         DATA    RETERR                  scratch record: return with bad attribute error
1474  4D9C 54DE         DATA    STATUS                  status
1475            *                                       
1476  4D9E 559E         DATA    OPNDIR                  open directory
1477  4DA0 55FC         DATA    CLSDIR                  close directory
1478  4DA2 5612         DATA    RDDIR                   read directory
1479            *                                       
1480  4DA4 06A0 ERROR8  BL      @ERROR5                 return with error
1480  4DA6 495E  
1481  4DA8 6000         DATA    >6000                   illegal opcode
1482            *
1483            *---------------------------------
1484            * Opcode 0: Open
1485            * --------------
1486            * PAB 0: >00
1487            *     1: file type  <--- error code
1488            *   2-3:
1489            *     4: record length
1490            *     5:
1491            *   6-7: # of records (if output)
1492            *     8:
1493            *---------------------------------                                      
1494            *
1495  4DAA 04C0 OPEN    CLR     R0                      
1496  4DAC D02F         MOVB    @-1026(R15),R0          get file attributes
1496  4DAE FBFE  
1497  4DB0 0429         BLWP    @>005A(R9)                      
1497  4DB2 005A  
1498  4DB4 8000         DATA    >8000                   save R0
1499  4DB6 0240         ANDI    R0,>1600                keep fix/var and access mode
1499  4DB8 1600  
1500  4DBA 0280         CI      R0,>0600                        
1500  4DBC 0600  
1501  4DBE 1603         JNE     H106                    
1502  4DC0 06A0 ERROR9  BL      @ERROR5                 dis/fix, open as append: return with error
1502  4DC2 495E  
1503  4DC4 4000         DATA    >4000                   bad attribute
1504            *                                       
1505  4DC6 120A H106    JLE     H107                    
1506  4DC8 C040         MOV     R0,R1                   var
1507  4DCA 06A0         BL      @PABR2B                 get 2 bytes from PAB into R0
1507  4DCC 4856  
1508  4DCE 0004         DATA    4                       rec len and char count
1509  4DD0 0280         CI      R0,>FF00                is rec len 255?
1509  4DD2 FF00  
1510  4DD4 14F5         JHE     ERROR9                  yes: bad attribute
1511  4DD6 C001         MOV     R1,R0                   retrieve attributes
1512  4DD8 0240         ANDI    R0,>0600                keep only access mode
1512  4DDA 0600  
1513            *                                       
1514  4DDC 0280 H107    CI      R0,>0200                is it output?
1514  4DDE 0200  
1515  4DE0 1657         JNE     H113                    no
1516  4DE2 06A0         BL      @CALSUB                 call subroutine
1516  4DE4 4344  
1517  4DE6 447C         DATA    CRFIL1                  create file
1518  4DE8 06A0 H108    BL      @PRFDRS                 coin status byte in FDR style
1518  4DEA 4F6A  
1519  4DEC 0429         BLWP    @>005A(R9)              set VDP to write
1519  4DEE 005A  
1520  4DF0 0083         DATA    >0083                   address in R4: status byte in FDR buffer
1521  4DF2 DBC2         MOVB    R2,@-2(R15)             write file status in FDR
1521  4DF4 FFFE  
1522  4DF6 C0E9         MOV     @>0054(R9),R3           PAB ptr
1522  4DF8 0054  
1523  4DFA 0223         AI      R3,4                    ptr to rec len
1523  4DFC 0004  
1524  4DFE 04C5         CLR     R5                      
1525  4E00 0429         BLWP    @>005A(R9)              set VDP to read
1525  4E02 005A  
1526  4E04 0062         DATA    >0062                   address in R3
1527  4E06 D16F         MOVB    @-1026(R15),R5          get record length
1527  4E08 FBFE  
1528  4E0A 1607         JNE     H109                    
1529  4E0C 0205         LI      R5,>5000                >00: default it 80
1529  4E0E 5000  
1530  4E10 0429         BLWP    @>005A(R9)              set VDP to write
1530  4E12 005A  
1531  4E14 0063         DATA    >0063                   address in R3
1532  4E16 DBC5         MOVB    R5,@-2(R15)             write default rec len
1532  4E18 FFFE  
1533  4E1A 0224 H109    AI      R4,5                    point to rec len byte in FDR
1533  4E1C 0005  
1534  4E1E 0429         BLWP    @>005A(R9)              set VDP to write
1534  4E20 005A  
1535  4E22 0083         DATA    >0083                   address in R4
1536  4E24 DBC5         MOVB    R5,@-2(R15)             write rec len in FDR buffer
1536  4E26 FFFE  
1537  4E28 0201         LI      R1,256                  256 bytes/sector
1537  4E2A 0100  
1538  4E2C C082         MOV     R2,R2                   var or dis?
1539  4E2E 1101         JLT     H110                    var
1540  4E30 1002         JMP     H111                    dis
1541  4E32 A141 H110    A       R1,R5                   var: rec len +1
1542  4E34 0601         DEC     R1                      254 bytes only (needs size byte)
1543  4E36 06C5 H111    SWPB    R5                      make it a word
1544  4E38 04C0         CLR     R0                      
1545  4E3A 3C05         DIV     R5,R0                   how many times in 254/255 bytes?
1546  4E3C 0224         AI      R4,-4                   point to # of rec/sect in FDR
1546  4E3E FFFC  
1547  4E40 C040         MOV     R0,R1                   save result for later
1548  4E42 06C0         SWPB    R0                      
1549  4E44 0429         BLWP    @>005A(R9)              set VDP to write
1549  4E46 005A  
1550  4E48 0083         DATA    >0083                   address in R4
1551  4E4A DBC0         MOVB    R0,@-2(R15)             write # of rec/sect in FDR
1551  4E4C FFFE  
1552  4E4E C229         MOV     @>0056(R9),R8           point to filename in FDR
1552  4E50 0056  
1553  4E52 0429         BLWP    @>005A(R9)              set VDP to read
1553  4E54 005A  
1554  4E56 0102         DATA    >0102                   address in R8
1555  4E58 D02F         MOVB    @-1026(R15),R0          get first char
1555  4E5A FBFE  
1556  4E5C 0260         ORI     R0,>8000                flag it: update FDR before leaving
1556  4E5E 8000  
1557  4E60 0429         BLWP    @>005A(R9)              set VDP to write
1557  4E62 005A  
1558  4E64 0103         DATA    >0103                   address in R8
1559  4E66 DBC0         MOVB    R0,@-2(R15)             write it back
1559  4E68 FFFE  
1560  4E6A 0429         BLWP    @>005A(R9)                      
1560  4E6C 005A  
1561  4E6E 8001         DATA    >8001                   retrieve R0 (access mode)
1562  4E70 06A0         BL      @PABR2B                 get 2 bytes from PAB into R0
1562  4E72 4856  
1563  4E74 0006         DATA    6                       required size in records
1564  4E76 C100         MOV     R0,R4                   
1565  4E78 1309         JEQ     H112                    no size specified
1566  4E7A 11A2         JLT     ERROR9                  return with bad attribute error
1567  4E7C A101         A       R1,R4                   round up to record size
1568  4E7E 0604         DEC     R4                      
1569  4E80 04C3         CLR     R3                      
1570  4E82 3CC1         DIV     R1,R3                   how many sectors will this be?
1571  4E84 0603         DEC     R3                      offset start from 0
1572  4E86 06A0         BL      @CALSUB                 call subroutine
1572  4E88 4344  
1573  4E8A 464C         DATA    APSCTS                  add sectors to FDR to match offset in R3
1574  4E8C 0460 H112    B       @RWIND2                 initialise file control block and return to caller
1574  4E8E 5392  
1575            *                                       
1576  4E90 0429 H113    BLWP    @>005A(R9)              not output
1576  4E92 005A  
1577  4E94 8000         DATA    >8000                   save R0
1578  4E96 06A0         BL      @CALSUB                 call subroutine
1578  4E98 4344  
1579  4E9A 4AEE         DATA    FNDFDR                  find FDR on disk
1580  4E9C 0429         BLWP    @>005A(R9)                      
1580  4E9E 005A  
1581  4EA0 8001         DATA    >8001                   retrieve R0 (access mode)
1582  4EA2 C104         MOV     R4,R4                   found FDR?
1583  4EA4 1309         JEQ     H115                    yes
1584  4EA6 0280         CI      R0,>0400                no: is file open as input?
1584  4EA8 0400  
1585  4EAA 1304         JEQ     H114                    yes: must exist
1586  4EAC 06A0         BL      @CALSUB                 no: call subroutine
1586  4EAE 4344  
1587  4EB0 448E         DATA    CRFIL3                  create file
1588  4EB2 109A         JMP     H108                    
1589            *                                       
1590  4EB4 0460 H114    B       @ERROR9                 return with bad attribute error
1590  4EB6 4DC0  
1591            *                                       
1592  4EB8 C1C0 H115    MOV     R0,R7                   save access mode
1593  4EBA 06A0         BL      @PRFDRS                 prepare status byte for FDR
1593  4EBC 4F6A  
1594  4EBE 0429         BLWP    @>005A(R9)              set VDP to read
1594  4EC0 005A  
1595  4EC2 0082         DATA    >0082                   address in R4 (status byte in FDR)
1596  4EC4 D02F         MOVB    @-1026(R15),R0          get current file status
1596  4EC6 FBFE  
1597  4EC8 C0C0         MOV     R0,R3                   save it
1598  4ECA 0243         ANDI    R3,>0800                is file write protected?
1598  4ECC 0800  
1599  4ECE 1306         JEQ     H116                    no
1600  4ED0 0287         CI      R7,>0400                yes: is it open as input?
1600  4ED2 0400  
1601  4ED4 1303         JEQ     H116                    no
1602  4ED6 06A0         BL      @ERROR5                 yes: return with error
1602  4ED8 495E  
1603  4EDA 2000         DATA    >2000                   write protected
1604            *                                       
1605  4EDC 0240 H116    ANDI    R0,>8300                keep only file type bits (V/F, D/I, Prg/Data)
1605  4EDE 8300  
1606  4EE0 2802         XOR     R2,R0                   compare with new (coined by PRFDRS)
1607  4EE2 16E8         JNE     H114                    different: bad attribute
1608  4EE4 C0E9         MOV     @>0054(R9),R3           PAB ptr
1608  4EE6 0054  
1609  4EE8 0223         AI      R3,4                    ptr to rec len in PAB
1609  4EEA 0004  
1610  4EEC 0224         AI      R4,5                    ptr to rec len in FDR
1610  4EEE 0005  
1611  4EF0 0429         BLWP    @>005A(R9)              set VDP to read
1611  4EF2 005A  
1612  4EF4 0082         DATA    >0082                   address in R4
1613  4EF6 D02F         MOVB    @-1026(R15),R0          get rec len from FDR
1613  4EF8 FBFE  
1614  4EFA 0429         BLWP    @>005A(R9)              set VDP to read
1614  4EFC 005A  
1615  4EFE 0062         DATA    >0062                   address in R3
1616  4F00 D0AF         MOVB    @-1026(R15),R2          get rec len from PAB
1616  4F02 FBFE  
1617  4F04 1302         JEQ     H117                    0 = keep current one
1618  4F06 9080         CB      R0,R2                   are they identical?
1619  4F08 16D5         JNE     H114                    no: bad attribute
1620  4F0A 0429 H117    BLWP    @>005A(R9)              set VDP to write
1620  4F0C 005A  
1621  4F0E 0063         DATA    >0063                   address in R3
1622  4F10 DBC0         MOVB    R0,@-2(R15)             update rec len in PAB (in case it was 0)
1622  4F12 FFFE  
1623  4F14 0429         BLWP    @>005A(R9)              retrieve R0 (open mode)
1623  4F16 005A  
1624  4F18 8001         DATA    >8001                   
1625  4F1A 0240         ANDI    R0,>0600                keep only access mode
1625  4F1C 0600  
1626  4F1E 04C2         CLR     R2                      
1627  4F20 0703         SETO    R3                      
1628  4F22 0280         CI      R0,>0600                is it append
1628  4F24 0600  
1629  4F26 161D         JNE     H118                    no
1630  4F28 C129         MOV     @>0056(R9),R4           yes: get FDR ptr
1630  4F2A 0056  
1631  4F2C C1C4         MOV     R4,R7                   save it
1632  4F2E 0224         AI      R4,14                   ptr to # of sectors
1632  4F30 000E  
1633  4F32 0429         BLWP    @>005A(R9)              set VDP to read
1633  4F34 005A  
1634  4F36 0082         DATA    >0082                   address in R4
1635  4F38 D0EF         MOVB    @-1026(R15),R3          get # of sectors in file
1635  4F3A FBFE  
1636  4F3C 06C3         SWPB    R3                      
1637  4F3E D0EF         MOVB    @-1026(R15),R3                  
1637  4F40 FBFE  
1638  4F42 06C3         SWPB    R3                      
1639  4F44 D0AF         MOVB    @-1026(R15),R2          get eof offset
1639  4F46 FBFE  
1640  4F48 0603         DEC     R3                      offset starts from 0
1641  4F4A 110B         JLT     H118                    file is empty (0 sectors)
1642  4F4C 0429         BLWP    @>005A(R9)                      
1642  4F4E 005A  
1643  4F50 3000         DATA    >3000                   save R2 + R3
1644  4F52 0227         AI      R7,256                  ptr to data buffer area for this file
1644  4F54 0100  
1645  4F56 06A0         BL      @CALSUB                 call subroutine
1645  4F58 4344  
1646  4F5A 4616         DATA    RDOFSC                  read a sector, from offset in R3
1647  4F5C 0429         BLWP    @>005A(R9)                      
1647  4F5E 005A  
1648  4F60 3001         DATA    >3001                   retrieve R2 + R3
1649  4F62 06A0 H118    BL      @UPDFCB                 update current record offset in file ctrl block
1649  4F64 4F94  
1650  4F66 0460         B       @RTURN1                 return to caller
1650  4F68 4362  
1651            *                                       
1652  4F6A 0429 PRFDRS  BLWP    @>005A(R9)              prepare file status byte for FDR
1652  4F6C 005A  
1653  4F6E 8001         DATA    >8001                   access mode in R0
1654  4F70 0429         BLWP    @>005A(R9)                      
1654  4F72 005A  
1655  4F74 8000         DATA    >8000                   save it back
1656  4F76 0202         LI      R2,2                    int in FDR status byte
1656  4F78 0002  
1657  4F7A C129         MOV     @>0056(R9),R4           FDR pointer
1657  4F7C 0056  
1658  4F7E 0A40         SLA     R0,4                    fix or var?
1659  4F80 1703         JNC     H119                    fix
1660  4F82 0202         LI      R2,>0082                int var in FDR
1660  4F84 0082  
1661  4F86 C000         MOV     R0,R0                   dis or int?
1662  4F88 1101 H119    JLT     H120                    int
1663  4F8A 0642         DECT    R2                      dis: remove the int from FDR status
1664  4F8C 0224 H120    AI      R4,12                   point at file status byte in FDR
1664  4F8E 000C  
1665  4F90 06C2         SWPB    R2                      
1666  4F92 045B         B       *R11                    
1667            *                                       
1668  4F94 C129 UPDFCB  MOV     @>0056(R9),R4           update sect + rec offsets in file control block
1668  4F96 0056  
1669  4F98 0224         AI      R4,-6                   
1669  4F9A FFFA  
1670  4F9C 0429         BLWP    @>005A(R9)              set VDP to write
1670  4F9E 005A  
1671  4FA0 0083         DATA    >0083                   address in R4
1672  4FA2 DBC3         MOVB    R3,@-2(R15)             write current sect offset
1672  4FA4 FFFE  
1673  4FA6 06C3         SWPB    R3                      
1674  4FA8 DBC3         MOVB    R3,@-2(R15)                     
1674  4FAA FFFE  
1675  4FAC 0224         AI      R4,4                    point to logical rec offset (for var files)
1675  4FAE 0004  
1676  4FB0 0429         BLWP    @>005A(R9)              set VDP to write
1676  4FB2 005A  
1677  4FB4 0083         DATA    >0083                   address in R4
1678  4FB6 DBC2         MOVB    R2,@-2(R15)             write record offset
1678  4FB8 FFFE  
1679  4FBA 045B         B       *R11                    
1680            *
1681            *----------------------------------
1682            * Opcode 1: Close
1683            * --------------
1684            * PAB 0: >01
1685            *     1:           <--- error code
1686            *   2-3:
1687            *     4:
1688            *     5:
1689            *   6-7:
1690            *     8:
1691            *----------------------------------                                     
1692            *
1693  4FBC 06A0 CLOSE   BL      @CALSUB                 call subroutine
1693  4FBE 4344  
1694  4FC0 51BA         DATA    FFDRVP                  find file FDR
1695  4FC2 0460         B       @UPDFDR                 update FDR + data area, get VIB, return to caller
1695  4FC4 4562  
1696            *
1697            *----------------------------------
1698            * Opcode 2: Read
1699            * --------------
1700            * PAB 0: >02
1701            *     1: file type <--- error code
1702            *   2-3: data buffer address in VDP mem
1703            *     4:
1704            *     5: bytes read
1705            *   6-7: record #
1706            *     8:
1707            *
1708            * Logical records organisation whithin sectors
1709            *
1710            * Fixed records (e.g. rec length = 6)
1711            * 11 11 11 11 11 11 22 22 22 22 22 22 33 33 33 33 33 33 xx xx xx
1712            * Where 11=data for record 1, 22=record 2, 33=record 3, xx=junk bytes
1713            *
1714            * Variable records:
1715            * sz 11 11 11 11 11 11 11 sz 22 22 22 22 22 sz 33 33 FF xx xx xx
1716            * Where sz=record size, 11,22,33=record data, FF=end-of-sector mark, xx=junk
1717            *----------------------------------                                     
1718            *
1719  4FC6 06A0 READ    BL      @CALSUB                 call subroutine
1719  4FC8 4344  
1720  4FCA 51BA         DATA    FFDRVP                  find FDR in VDP buffers, get status from PAB
1721  4FCC 0240         ANDI    R0,>0200                what type of access?
1721  4FCE 0200  
1722  4FD0 1302         JEQ     H122                    update or input: ok
1723  4FD2 0460 H121    B       @ERROR8                 append or output: error illegal opcode
1723  4FD4 4DA4  
1724  4FD6 06A0 H122    BL      @RFDRST                 get status byte in R0, from FDR
1724  4FD8 51E6  
1725  4FDA 110A         JLT     H125                    var
1726  4FDC 06A0         BL      @RRNPAB                 fix: get rec # compare to # of recs/file
1726  4FDE 51FA  
1727  4FE0 1A03         JL      H124                    ok: in file
1728  4FE2 06A0 H123    BL      @ERROR5                 update data and return with error
1728  4FE4 495E  
1729  4FE6 A000         DATA    >A000                   eof reached
1730  4FE8 06A0 H124    BL      @CALSUB                 call subroutine
1730  4FEA 4344  
1731  4FEC 5260         DATA    RRFDR                   load record from disk into FDR data buffer area
1732  4FEE 1011         JMP     H126                    
1733            *                                       
1734  4FF0 06A0 H125    BL      @CALSUB                 var: call subroutine
1734  4FF2 4344  
1735  4FF4 504C         DATA    RRSEC                   load proper sector, point to rec in it
1736  4FF6 10F5         JMP     H123                    skipped if ok: return with eof reached
1737            *                                       
1738  4FF8 0582         INC     R2                      next byte in data buffer
1739  4FFA A004         A       R4,R0                   add rec size to offset
1740  4FFC 0580         INC     R0                      room for end-of-sector mark
1741  4FFE C169         MOV     @>0056(R9),R5           FDR ptr
1741  5000 0056  
1742  5002 0645         DECT    R5                      point to var record offset in sector
1743  5004 06C0         SWPB    R0                      
1744  5006 0429         BLWP    @>005A(R9)              set VDP to write
1744  5008 005A  
1745  500A 00A3         DATA    >00A3                   address in R5
1746  500C DBC0         MOVB    R0,@-2(R15)             update var record offset in sector
1746  500E FFFE  
1747  5010 C004         MOV     R4,R0                   save # of bytes to be read
1748  5012 C129 H126    MOV     @>0054(R9),R4           PAB ptr
1748  5014 0054  
1749  5016 0224         AI      R4,5                    point to char count
1749  5018 0005  
1750  501A 06C0         SWPB    R0                      
1751  501C 0429         BLWP    @>005A(R9)              set VDP to write
1751  501E 005A  
1752  5020 0083         DATA    >0083                   address in R4
1753  5022 DBC0         MOVB    R0,@-2(R15)             write # of char to be read
1753  5024 FFFE  
1754  5026 06C0         SWPB    R0                      make it a word
1755            *                                       
1756  5028 C000 WFDRPB  MOV     R0,R0                   check it
1757  502A 130E         JEQ     H128                    none: return
1758  502C 0429 H127    BLWP    @>005A(R9)              set VDP to read
1758  502E 005A  
1759  5030 0042         DATA    >0042                   address in R2
1760  5032 D0EF         MOVB    @-1026(R15),R3          read 1 byte from FDR data buffer area
1760  5034 FBFE  
1761  5036 0582         INC     R2                      increment source ptr
1762  5038 0429         BLWP    @>005A(R9)              set VDP to write
1762  503A 005A  
1763  503C 0023         DATA    >0023                   address in R1
1764  503E DBC3         MOVB    R3,@-2(R15)             write the byte in PAB data buffer
1764  5040 FFFE  
1765  5042 0581         INC     R1                      increment destination ptr
1766  5044 0600         DEC     R0                      more to read?
1767  5046 16F2         JNE     H127                    yes
1768  5048 0460 H128    B       @RTURN1                 return to caller
1768  504A 4362  
1769            *                                       
1770  504C 06A0 RRSEC   BL      @RCOFCB                 load sector, point to record in it
1770  504E 533A  
1771  5050 C0C3         MOV     R3,R3                   sector offset
1772  5052 1101         JLT     H129                    -1: top of file
1773  5054 1012         JMP     H130                    in file
1774  5056 C003 H129    MOV     R3,R0                   
1775  5058 0580         INC     R0                      next sector
1776  505A 8080         C       R0,R2                   compare to # of sect/file
1777  505C 13F5         JEQ     H128                    end-of-file reached: return to caller (JMP to err)
1778  505E 06A0         BL      @CALSUB                 call subroutine
1778  5060 4344  
1779  5062 4582         DATA    UPDBF                   update data buffer, if needed
1780  5064 C0C0         MOV     R0,R3                   desired offset
1781  5066 04C5         CLR     R5                      
1782  5068 06A0         BL      @UCOFCB                 update sect + rec offsets in control block
1782  506A 52D8  
1783  506C 0227         AI      R7,256                  point to data buffer area (R7 set by UCOFCB)
1783  506E 0100  
1784  5070 06A0         BL      @CALSUB                 call subroutine
1784  5072 4344  
1785  5074 4616         DATA    RDOFSC                  read a sector, from offset in file (in R3)
1786  5076 04C0         CLR     R0                      
1787  5078 1004         JMP     H131                    
1788            *                                       
1789  507A C000 H130    MOV     R0,R0                   in file: test var rec offset (from RCOFCB)
1790  507C 1602         JNE     H131                    inside sector
1791  507E 8080         C       R0,R2                   at beg of sector
1792  5080 13E3         JEQ     H128                    file is empty: return
1793  5082 C080 H131    MOV     R0,R2                   FDR data buffer will be added to R2 by AFDRPT
1794  5084 06A0         BL      @CALSUB                 call subroutine
1794  5086 4344  
1795  5088 52B4         DATA    AFDRPT                  R2=byte in FDR data buf, R1=top of PAB data buf
1796  508A 0429         BLWP    @>005A(R9)              set VDP to read
1796  508C 005A  
1797  508E 0042         DATA    >0042                   address in R2
1798  5090 D12F         MOVB    @-1026(R15),R4          get first byte (rec length)
1798  5092 FBFE  
1799  5094 0984         SRL     R4,8                    make it a word
1800  5096 C000         MOV     R0,R0                   var rec offset
1801  5098 1306         JEQ     H132                    
1802  509A 0284         CI      R4,>00FF                is it >FF (end of sector mark) ?
1802  509C 00FF  
1803  509E 1603         JNE     H132                    no
1804  50A0 06A0         BL      @RCOFCB                 yes: get sect + rec offsets from control block
1804  50A2 533A  
1805  50A4 10D8         JMP     H129                    try again with next sector
1806            *                                       
1807  50A6 0429 H132    BLWP    @>005A(R9)                      
1807  50A8 005A  
1808  50AA 0011         DATA    >0011                   retrieve return address from stack in R11
1809  50AC 05CB         INCT    R11                     skip the JMP to eof reached error
1810  50AE 045B         B       *R11                    
1811            *
1812            *------------------------------------
1813            * Opcode 3: Write
1814            * --------------
1815            * PAB 0: >03
1816            *     1: file type <--- error code
1817            *   2-3: data buffer address in VDP mem
1818            *     4:
1819            *     5: bytes to write
1820            *   6-7: record #
1821            *     8:
1822            *------------------------------------                                   
1823            *
1824  50B0 06A0 WRITE   BL      @CALSUB                 call subroutine
1824  50B2 4344  
1825  50B4 51BA         DATA    FFDRVP                  find FDR in VDP buffers
1826  50B6 0240         ANDI    R0,>0600                keep only access mode
1826  50B8 0600  
1827  50BA 0280         CI      R0,>0400                is it input
1827  50BC 0400  
1828  50BE 1389         JEQ     H121                    yes: return with error illegal opcode
1829  50C0 06A0         BL      @RFDRST                 get file status byte from FDR
1829  50C2 51E6  
1830  50C4 1113         JLT     H134                    var                     
1831  50C6 06A0         BL      @RRNPAB                 fix: get rec # from PAB, sect # in R0
1831  50C8 51FA  
1832  50CA 1A0C         JL      H133                    less that total rec/file
1833  50CC 0429         BLWP    @>005A(R9)              past eof: expand file
1833  50CE 005A  
1834  50D0 D800         DATA    >D800                   save R0, R1, R3, R4
1835  50D2 C0C0         MOV     R0,R3                   desired sector offset
1836  50D4 06A0         BL      @CALSUB                 call subroutine
1836  50D6 4344  
1837  50D8 464C         DATA    APSCTS                  append enough sectors to reach offset in R3
1838  50DA 0429         BLWP    @>005A(R9)                      
1838  50DC 005A  
1839  50DE D801         DATA    >D801                   restore R0, R1, R3, R4
1840  50E0 06A0         BL      @URFFDR                 update # of rec/file in FDR
1840  50E2 5304  
1841            *                                       
1842  50E4 06A0 H133    BL      @CALSUB                 in file: call subroutine
1842  50E6 4344  
1843  50E8 5260         DATA    RRFDR                   fetch rec from disk into FDR data buffer area
1844  50EA 1053         JMP     H138                    set update data flag, write data, return
1845            *                                       
1846  50EC 06A0 H134    BL      @RCOFCB                 var: R2=sect/file R3=sect offset R0=rec offset
1846  50EE 533A  
1847  50F0 C0C3         MOV     R3,R3                   sector offset in file
1848  50F2 1101         JLT     H135                    -1: top of file
1849  50F4 100B         JMP     H136                    in file
1850  50F6 0429 H135    BLWP    @>005A(R9)              next sector loop
1850  50F8 005A  
1851  50FA 3000         DATA    >3000                   save R2 + R3
1852  50FC 06A0         BL      @CALSUB                 call subroutine
1852  50FE 4344  
1853  5100 4582         DATA    UPDBF                   update data buffer if needed
1854  5102 0429         BLWP    @>005A(R9)                      
1854  5104 005A  
1855  5106 3001         DATA    >3001                   retrieve R2 + R3
1856  5108 0583         INC     R3                      next sector
1857  510A 04C0         CLR     R0                      init char offset in sector
1858            *                                       
1859  510C 8083 H136    C       R3,R2                   did we reach last sector?
1860  510E 1609         JNE     H137                    no
1861  5110 0429         BLWP    @>005A(R9)              yes: expand file
1861  5112 005A  
1862  5114 9000         DATA    >9000                   save R0 + R4
1863  5116 06A0         BL      @CALSUB                 call subroutine
1863  5118 4344  
1864  511A 464C         DATA    APSCTS                  get last sector then append sectors to reach R3
1865  511C 0429         BLWP    @>005A(R9)                      
1865  511E 005A  
1866  5120 9001         DATA    >9001                   retrieve R0 + R4
1867            *                                       
1868  5122 C169 H137    MOV     @>0054(R9),R5           PAB ptr
1868  5124 0054  
1869  5126 0225         AI      R5,5                    point to char count
1869  5128 0005  
1870  512A 0429         BLWP    @>005A(R9)              set VDP to read
1870  512C 005A  
1871  512E 00A2         DATA    >00A2                   address in R5
1872  5130 D12F         MOVB    @-1026(R15),R4          get # of chars to write
1872  5132 FBFE  
1873  5134 0984         SRL     R4,8                    make it a word
1874  5136 C144         MOV     R4,R5                   
1875  5138 A140         A       R0,R5                   add current char offset in sector
1876  513A 0585         INC     R5                      make room for size byte
1877  513C 0285         CI      R5,>00FF                past end of sector?
1877  513E 00FF  
1878  5140 1BDA         JH      H135                    yes: not enough room, try next sector
1879  5142 0702         SETO    R2                      ok: rec will fit in sector
1880  5144 C069         MOV     @>0056(R9),R1           FDR ptr
1880  5146 0056  
1881  5148 A045         A       R5,R1                   past-last-byte offset
1882  514A 0221         AI      R1,256                  ptr to data buffer area
1882  514C 0100  
1883  514E 0429         BLWP    @>005A(R9)              set VDP to write
1883  5150 005A  
1884  5152 0023         DATA    >0023                   address in R1
1885  5154 DBC2         MOVB    R2,@-2(R15)             write end-of-sect mark to FDR data buffer area
1885  5156 FFFE  
1886  5158 0429         BLWP    @>005A(R9)                      
1886  515A 005A  
1887  515C 8000         DATA    >8000                   save R0 (current byte offset in sector)
1888  515E C003         MOV     R3,R0                   
1889  5160 06A0         BL      @UCOFCB                 update sect + rec offsets in control block
1889  5162 52D8  
1890  5164 0221         AI      R1,18                   point to eof offset in FDR (R1 modified by UCOFCB)
1890  5166 0012  
1891  5168 0429         BLWP    @>005A(R9)              set VDP to write
1891  516A 005A  
1892  516C 0023         DATA    >0023                   address in R1
1893  516E DBC5         MOVB    R5,@-2(R15)             update eof offset in last sector, in FDR
1893  5170 FFFE  
1894  5172 06A0         BL      @URFFDR                 update # of rec/file in FDR
1894  5174 5304  
1895  5176 0429         BLWP    @>005A(R9)                      
1895  5178 005A  
1896  517A 2001         DATA    >2001                   retrieve old R0 in R2 (current byte offset)
1897  517C C004         MOV     R4,R0                   record size
1898  517E 06A0         BL      @CALSUB                 call subroutine
1898  5180 4344  
1899  5182 52B4         DATA    AFDRPT                  get FDR data buffer in R2, PAB data buffer in R1
1900  5184 06C4         SWPB    R4                      
1901  5186 0429         BLWP    @>005A(R9)              set VDP to write
1901  5188 005A  
1902  518A 0043         DATA    >0043                   address in R2
1903  518C DBC4         MOVB    R4,@-2(R15)             write size byte to FDR data buffer
1903  518E FFFE  
1904  5190 0582         INC     R2                      increment dest pointer
1905            *                                       
1906  5192 C0C2 H138    MOV     R2,R3                   invert source and dest
1907  5194 C081         MOV     R1,R2                   so we can use the same read-write loop
1908  5196 C043         MOV     R3,R1                   than the read opcode
1909  5198 C129         MOV     @>0056(R9),R4           FDR ptr
1909  519A 0056  
1910  519C 0604         DEC     R4                      pointer to drive # for that file
1911  519E 0429         BLWP    @>005A(R9)              set VDP to read
1911  51A0 005A  
1912  51A2 0082         DATA    >0082                   address in R4
1913  51A4 D16F         MOVB    @-1026(R15),R5          get drive #
1913  51A6 FBFE  
1914  51A8 0265         ORI     R5,>8000                add update data area flag
1914  51AA 8000  
1915  51AC 0429         BLWP    @>005A(R9)              set VDP to write
1915  51AE 005A  
1916  51B0 0083         DATA    >0083                   address in R4
1917  51B2 DBC5         MOVB    R5,@-2(R15)             write back flagged byte
1917  51B4 FFFE  
1918  51B6 0460         B       @WFDRPB                 to read-write loop
1918  51B8 5028  
1919            *                                       
1920  51BA 06A0 FFDRVP  BL      @CALSUB                 find FDR in VDP buffer
1920  51BC 4344  
1921  51BE 4A90         DATA    FFFDRV                  find file FDR
1922  51C0 C104         MOV     R4,R4                   found?
1923  51C2 1303         JEQ     AFPGPF                  yes
1924  51C4 06A0         BL      @ERROR5                 no: return with error
1924  51C6 495E  
1925  51C8 E000         DATA    >E000                   file error
1926  51CA 0581 AFPGPF  INC     R1                      point to filename in FDR
1927  51CC CA41         MOV     R1,@>0056(R9)           new FDR ptr
1927  51CE 0056  
1928  51D0 C129         MOV     @>0054(R9),R4           get PAB ptr
1928  51D2 0054  
1929  51D4 0584         INC     R4                      point to status byte
1930  51D6 04C0         CLR     R0                      
1931  51D8 0429         BLWP    @>005A(R9)              set VDP to read
1931  51DA 005A  
1932  51DC 0082         DATA    >0082                   address in R4
1933  51DE D02F         MOVB    @-1026(R15),R0          get file status
1933  51E0 FBFE  
1934  51E2 0460         B       @RTURN1                 return to caller
1934  51E4 4362  
1935            *                                       
1936  51E6 C129 RFDRST  MOV     @>0056(R9),R4           get status byte from FDR
1936  51E8 0056  
1937  51EA 0224         AI      R4,12                   point to status byte
1937  51EC 000C  
1938  51EE 0429         BLWP    @>005A(R9)              set VDP to read
1938  51F0 005A  
1939  51F2 0082         DATA    >0082                   address in R4
1940  51F4 D02F         MOVB    @-1026(R15),R0          read status byte
1940  51F6 FBFE  
1941  51F8 045B         B       *R11                    
1942            *                                       
1943  51FA D16F RRNPAB  MOVB    @-1026(R15),R5          get record # from PAB, check if valid
1943  51FC FBFE  
1944  51FE 0985         SRL     R5,8                    
1945  5200 1602         JNE     H139                    get # of rec/sector from FDR
1946  5202 0205         LI      R5,256                  0: default to 256
1946  5204 0100  
1947  5206 C0E9 H139    MOV     @>0054(R9),R3           PAB ptr
1947  5208 0054  
1948  520A 0223         AI      R3,6                    point to rec #
1948  520C 0006  
1949  520E 0429         BLWP    @>005A(R9)              set VDP to read
1949  5210 005A  
1950  5212 0062         DATA    >0062                   address in R3
1951  5214 D06F         MOVB    @-1026(R15),R1          get record # from PAB
1951  5216 FBFE  
1952  5218 06C1         SWPB    R1                      
1953  521A D06F         MOVB    @-1026(R15),R1                  
1953  521C FBFE  
1954  521E 06C1         SWPB    R1                      
1955  5220 C001         MOV     R1,R0                   save it
1956  5222 1101         JLT     H140                    too big
1957  5224 1003         JMP     H141                    ok
1958  5226 06A0 H140    BL      @ERROR5                 update data then return with error
1958  5228 495E  
1959  522A 8000         DATA    >8000                   memory full
1960  522C 0580 H141    INC     R0                      next record
1961  522E 0429         BLWP    @>005A(R9)              set VDP to write
1961  5230 005A  
1962  5232 0063         DATA    >0063                   address in R3
1963  5234 DBC0         MOVB    R0,@-2(R15)             write back # of future record
1963  5236 FFFE  
1964  5238 06C0         SWPB    R0                      
1965  523A DBC0         MOVB    R0,@-2(R15)                     
1965  523C FFFE  
1966  523E 04C0         CLR     R0                      
1967  5240 C0C1         MOV     R1,R3                   save # of desired rec
1968  5242 3C05         DIV     R5,R0                   divide by # of rec/sector = sect # in R0
1969  5244 C0A9 RNFISE  MOV     @>0056(R9),R2           FDR ptr
1969  5246 0056  
1970  5248 0222         AI      R2,18                   point to total # of rec (# of sectors for var)
1970  524A 0012  
1971  524C 0429         BLWP    @>005A(R9)              set VDP to read
1971  524E 005A  
1972  5250 0042         DATA    >0042                   address in R2
1973  5252 D0AF         MOVB    @-1026(R15),R2          get total # of recs/file (sect/file for var)
1973  5254 FBFE  
1974  5256 06C2         SWPB    R2                      
1975  5258 D0AF         MOVB    @-1026(R15),R2          remember: bytes are swapped
1975  525A FBFE  
1976  525C 8083         C       R3,R2                   compare with desired record (ignored by var)
1977  525E 045B         B       *R11                    
1978            *                                       
1979  5260 0429 RRFDR   BLWP    @>005A(R9)              fetch record into FDR data buffer area
1979  5262 005A  
1980  5264 4000         DATA    >4000                   save R1
1981  5266 0224         AI      R4,-18                  ptr to top of control block
1981  5268 FFEE  
1982  526A 0429         BLWP    @>005A(R9)              set VDP to read
1982  526C 005A  
1983  526E 0082         DATA    >0082                   address in R4
1984  5270 D16F         MOVB    @-1026(R15),R5          get current sector offset in file
1984  5272 FBFE  
1985  5274 06C5         SWPB    R5                      
1986  5276 D16F         MOVB    @-1026(R15),R5                  
1986  5278 FBFE  
1987  527A 0B85         SRC     R5,8                    
1988  527C 1105         JLT     H142                    -1: top of file
1989  527E 8005         C       R5,R0                   compare with desired offset (from RRNPAB)
1990  5280 130B         JEQ     H143                    same
1991  5282 06A0         BL      @CALSUB                 call subroutine
1991  5284 4344  
1992  5286 4582         DATA    UPDBF                   update data buffer if needed
1993  5288 C0C0 H142    MOV     R0,R3                   desired sector offset in file
1994  528A 06A0         BL      @UCOFCB                 update sect + rec offsets in control block
1994  528C 52D8  
1995  528E 0227         AI      R7,256                  point to data buffer area (R7 set by UCOFCB)
1995  5290 0100  
1996  5292 06A0         BL      @CALSUB                 call subroutine
1996  5294 4344  
1997  5296 4616         DATA    RDOFSC                  read a sector from offset in file (in R3)
1998  5298 0429 H143    BLWP    @>005A(R9)                      
1998  529A 005A  
1999  529C 4001         DATA    >4001                   retrieve R1
2000  529E C0E9         MOV     @>0056(R9),R3           FDR ptr
2000  52A0 0056  
2001  52A2 0223         AI      R3,17                   point to record length
2001  52A4 0011  
2002  52A6 0429         BLWP    @>005A(R9)              set VDP to read
2002  52A8 005A  
2003  52AA 0062         DATA    >0062                   address in R3
2004  52AC D02F         MOVB    @-1026(R15),R0          get rec length in bytes
2004  52AE FBFE  
2005  52B0 0980         SRL     R0,8                    make it a word
2006  52B2 3840         MPY     R0,R1                   calc file offset in bytes
2007  52B4 A0A9 AFDRPT  A       @>0056(R9),R2           add FDR ptr
2007  52B6 0056  
2008  52B8 0222         AI      R2,256                  point inside data buffer area
2008  52BA 0100  
2009  52BC C0E9         MOV     @>0054(R9),R3           PAB ptr
2009  52BE 0054  
2010  52C0 05C3         INCT    R3                      point to data buffer address
2011  52C2 0429         BLWP    @>005A(R9)              set VDP to read
2011  52C4 005A  
2012  52C6 0062         DATA    >0062                   address in R3
2013  52C8 D06F         MOVB    @-1026(R15),R1          get PAB data buffer address
2013  52CA FBFE  
2014  52CC 06C1         SWPB    R1                      
2015  52CE D06F         MOVB    @-1026(R15),R1                  
2015  52D0 FBFE  
2016  52D2 06C1         SWPB    R1                      
2017  52D4 0460         B       @RTURN1                 return
2017  52D6 4362  
2018            *                               
2019  52D8 C1E9 UCOFCB  MOV     @>0056(R9),R7           update sect + rec offsets in control block
2019  52DA 0056  
2020  52DC C047         MOV     R7,R1                   FDR ptr
2021  52DE 0221         AI      R1,-6                   top of file control block
2021  52E0 FFFA  
2022  52E2 0429         BLWP    @>005A(R9)              set VDP to write
2022  52E4 005A  
2023  52E6 0023         DATA    >0023                   address in R1
2024  52E8 DBC0         MOVB    R0,@-2(R15)             current sector offset in file
2024  52EA FFFE  
2025  52EC 06C0         SWPB    R0                      
2026  52EE DBC0         MOVB    R0,@-2(R15)                     
2026  52F0 FFFE  
2027  52F2 0221         AI      R1,4                    point to var rec offset in sector
2027  52F4 0004  
2028  52F6 06C5         SWPB    R5                      
2029  52F8 0429         BLWP    @>005A(R9)              set VDP to write
2029  52FA 005A  
2030  52FC 0023         DATA    >0023                   address in R1
2031  52FE DBC5         MOVB    R5,@-2(R15)             first free byte in current sector
2031  5300 FFFE  
2032  5302 045B         B       *R11                    
2033            *                                       
2034  5304 C0A9 URFFDR  MOV     @>0056(R9),R2           update # of rec/file in FDR
2034  5306 0056  
2035  5308 0429         BLWP    @>005A(R9)              set VDP to read
2035  530A 005A  
2036  530C 0042         DATA    >0042                   address in R2 (FDR ptr)
2037  530E D2AF         MOVB    @-1026(R15),R10         get first char of filename
2037  5310 FBFE  
2038  5312 026A         ORI     R10,>8000               set was modified flag
2038  5314 8000  
2039  5316 0429         BLWP    @>005A(R9)              set VDP to write
2039  5318 005A  
2040  531A 0043         DATA    >0043                   address in R2
2041  531C DBCA         MOVB    R10,@-2(R15)            write flagged char back
2041  531E FFFE  
2042  5320 0222         AI      R2,18                   point to # of recs/file in FDR
2042  5322 0012  
2043  5324 0583         INC     R3                      one more
2044  5326 0429         BLWP    @>005A(R9)              set VDP to write
2044  5328 005A  
2045  532A 0043         DATA    >0043                   address in R2
2046  532C 06C3         SWPB    R3                      update # of recs/file
2047  532E DBC3         MOVB    R3,@-2(R15)                     
2047  5330 FFFE  
2048  5332 06C3         SWPB    R3                      
2049  5334 DBC3         MOVB    R3,@-2(R15)                     
2049  5336 FFFE  
2050  5338 045B         B       *R11                    
2051            *                                       
2052  533A C229 RCOFCB  MOV     @>0056(R9),R8           get rec offset, compare sect with total
2052  533C 0056  
2053  533E C108         MOV     R8,R4                   FDR ptr
2054  5340 0224         AI      R4,256                  point to data buffer area
2054  5342 0100  
2055  5344 0648         DECT    R8                      point to var record offset
2056  5346 0429         BLWP    @>005A(R9)              set VDP to read
2056  5348 005A  
2057  534A 0102         DATA    >0102                   address in R8
2058  534C D0AF         MOVB    @-1026(R15),R2          get var rec offset in current sector
2058  534E FBFE  
2059  5350 0982         SRL     R2,8                    make it a word
2060  5352 C28B         MOV     R11,R10                 save return point
2061  5354 06A0         BL      @FDR2B2                 get 2 bytes from FDR (at R8-4) into R0
2061  5356 4860  
2062  5358 FFFC         DATA    -4                      current sector offset in file
2063  535A C0C0         MOV     R0,R3                   save it
2064  535C C2CA         MOV     R10,R11                 restore return point
2065  535E C002         MOV     R2,R0                   var record offset
2066  5360 0460         B       @RNFISE                 get # of sect/file from FDR, return
2066  5362 5244  
2067            *
2068            *------------------------------------
2069            * Opcode 4: Rewind
2070            * --------------
2071            * PAB 0: >04
2072            *     1: file type <--- error code
2073            *   2-3:
2074            *     4:
2075            *     5:
2076            *   6-7: record #  <--- >0000 if sequential
2077            *     8:
2078            *------------------------------------                                   
2079            *
2080  5364 06A0 RWIND1  BL      @CALSUB                 call subroutine
2080  5366 4344  
2081  5368 51BA         DATA    FFDRVP                  find FDR in VDP buffers, read status from PAB
2082  536A 0429         BLWP    @>005A(R9)                      
2082  536C 005A  
2083  536E 8000         DATA    >8000                   save R0 (status from PAB)
2084  5370 0240         ANDI    R0,>0600                keep only access mode
2084  5372 0600  
2085  5374 1305         JEQ     H144                    update is ok
2086  5376 0280         CI      R0,>0400                is it input?
2086  5378 0400  
2087  537A 1302         JEQ     H144                    yes: ok
2088  537C 0460         B       @ERROR8                 output or append: return with illegal opcode
2088  537E 4DA4  
2089  5380 06A0 H144    BL      @CALSUB                 call subroutine
2089  5382 4344  
2090  5384 4582         DATA    UPDBF                   update data buffer if needed
2091  5386 0429         BLWP    @>005A(R9)                      
2091  5388 005A  
2092  538A 8001         DATA    >8001                   retrieve R0 (status from PAB)
2093  538C 0240         ANDI    R0,>0100                sequential or reloc?
2093  538E 0100  
2094  5390 1611         JNE     H145                    reloc: don't do anything, return
2095            *                                       
2096  5392 04C2 RWIND2  CLR     R2                      rewind file: record offset = 0
2097  5394 0703         SETO    R3                      current record = -1 (none)
2098  5396 06A0         BL      @UPDFCB                 update file control block
2098  5398 4F94  
2099  539A 04C0         CLR     R0                      record 0
2100  539C C229         MOV     @>0054(R9),R8           get PAB ptr
2100  539E 0054  
2101  53A0 0228         AI      R8,6                    point to record #
2101  53A2 0006  
2102  53A4 0429         BLWP    @>005A(R9)              set VDP to write
2102  53A6 005A  
2103  53A8 0103         DATA    >0103                   address in R8
2104  53AA DBC0         MOVB    R0,@-2(R15)             write record #
2104  53AC FFFE  
2105  53AE 1000         NOP                             
2106  53B0 DBC0         MOVB    R0,@-2(R15)                     
2106  53B2 FFFE  
2107  53B4 0460 H145    B       @RTURN1                 return to caller
2107  53B6 4362  
2108            *
2109            *------------------------------------
2110            * Opcode 5: Load
2111            * --------------
2112            * PAB 0: >05
2113            *     1: file type  <--- error code
2114            *   2-3: data buffer address in VDP mem
2115            *     4:
2116            *     5:
2117            *   6-7: maximum # of bytes (size of buffer)
2118            *     8:
2119            *------------------------------------                                   
2120            *
2121  53B8 06A0 LOAD    BL      @CALSUB                 call subroutine
2121  53BA 4344  
2122  53BC 4AEE         DATA    FNDFDR                  find FDR on disk
2123  53BE C104         MOV     R4,R4                   found?
2124  53C0 1303         JEQ     H147                    yes
2125  53C2 06A0 H146    BL      @ERROR5                 no: return with error
2125  53C4 495E  
2126  53C6 E000         DATA    >E000                   file error
2127  53C8 06A0 H147    BL      @FDR2B1                 get 2 bytes from FDR into R0
2127  53CA 485C  
2128  53CC 000C         DATA    12                      file status byte
2129  53CE 0240         ANDI    R0,>0100                is it program?
2129  53D0 0100  
2130  53D2 13F7         JEQ     H146                    no: file error
2131  53D4 05C8         INCT    R8                      point to # of sect/file in FDR
2132  53D6 0429         BLWP    @>005A(R9)              set VDP to read
2132  53D8 005A  
2133  53DA 0102         DATA    >0102                   address in R8
2134  53DC D06F         MOVB    @-1026(R15),R1          get # of sectors in file
2134  53DE FBFE  
2135  53E0 06C1         SWPB    R1                      
2136  53E2 D06F         MOVB    @-1026(R15),R1                  
2136  53E4 FBFE  
2137  53E6 0B81         SRC     R1,8                    
2138  53E8 13EC         JEQ     H146                    0=empty file: return with file error
2139  53EA 06A0         BL      @RBANB                  get data buffer address in R7, # of sectors in R2
2139  53EC 54AA  
2140  53EE 05C8         INCT    R8                      point to eof offset in FDR
2141  53F0 04C4         CLR     R4                      
2142  53F2 0429         BLWP    @>005A(R9)              set VDP to read
2142  53F4 005A  
2143  53F6 0102         DATA    >0102                   address in R8
2144  53F8 D12F         MOVB    @-1026(R15),R4          get # of bytes in last sector
2144  53FA FBFE  
2145  53FC 8081         C       R1,R2                   compare # of sect with max in PAB
2146  53FE 1BE1         JH      H146                    file is too big: return with file error
2147  5400 1602         JNE     H148                    file is smaller
2148  5402 8100         C       R0,R4                   same # of sect: check bytes in last sector
2149  5404 1ADE         JL      H146                    file is too big: file error
2150  5406 04C3 H148    CLR     R3                      sector offset in file
2151  5408 06C4         SWPB    R4                      
2152  540A 0601 H149    DEC     R1                      next sector
2153  540C 130D         JEQ     H150                    done
2154  540E 0429         BLWP    @>005A(R9)                      
2154  5410 005A  
2155  5412 D900         DATA    >D900                   save R0, R1, R3, R4, R7
2156  5414 06A0         BL      @CALSUB                 call subroutine
2156  5416 4344  
2157  5418 4616         DATA    RDOFSC                  read a sector from offset in R3
2158  541A 0429         BLWP    @>005A(R9)              restore R0, R1, R3, R4, R7
2158  541C 005A  
2159  541E D901         DATA    >D901                   
2160  5420 0583         INC     R3                      next sector
2161  5422 0227         AI      R7,256                  256 bytes further in PAB buffer
2161  5424 0100  
2162  5426 10F1         JMP     H149                    keep going
2163            *                                       
2164  5428 C104 H150    MOV     R4,R4                   
2165  542A 1604         JNE     H151                    
2166  542C 06A0         BL      @CALSUB                 call subroutine
2166  542E 4344  
2167  5430 4616         DATA    RDOFSC                  read a sector from offset in R3
2168  5432 1011         JMP     H152                    done
2169            *                                       
2170  5434 C147 H151    MOV     R7,R5                   save PAB data buffer ptr
2171  5436 C1E9         MOV     @>0056(R9),R7           FDR ptr
2171  5438 0056  
2172  543A 0227         AI      R7,256                  point to FDR data area
2172  543C 0100  
2173  543E 0429         BLWP    @>005A(R9)                      
2173  5440 005A  
2174  5442 0D00         DATA    >0D00                   save R4, R5, R7
2175  5444 06A0         BL      @CALSUB                 call subroutine
2175  5446 4344  
2176  5448 4616         DATA    RDOFSC                  read a sector from offset in R3
2177  544A 0429         BLWP    @>005A(R9)              restore R4 in R0, R5 in R1, R7 in R2
2177  544C 005A  
2178  544E E001         DATA    >E001                   
2179  5450 06A0         BL      @CALSUB                 call subroutine
2179  5452 4344  
2180  5454 5028         DATA    WFDRPB                  write bytes from FDR data buffer to PAB data buf
2181  5456 0460 H152    B       @UPDFDR                 update FDR, data buffer, VIB and return to caller
2181  5458 4562  
2182            *
2183            *------------------------------------
2184            * Opcode 6: Save
2185            * --------------
2186            * PAB 0: >06
2187            *     1: file type  <--- error code
2188            *   2-3: data buffer address in VDP mem
2189            *     4:
2190            *     5:
2191            *   6-7: # of bytes to save
2192            *     8:
2193            *------------------------------------                                   
2194            *
2195  545A 06A0 SAVE    BL      @CALSUB                 call subroutine
2195  545C 4344  
2196  545E 447C         DATA    CRFIL1                  create file
2197  5460 06A0         BL      @RBANB                  get PAB buffer ptr + # of bytes
2197  5462 54AA  
2198  5464 04C3         CLR     R3                      sector offset 0
2199  5466 0429 H153    BLWP    @>005A(R9)                      
2199  5468 005A  
2200  546A B100         DATA    >B100                   save R0, R2, R3, R7
2201  546C 06A0         BL      @CALSUB                 call subroutine
2201  546E 4344  
2202  5470 4636         DATA    WROFSC                  write sector to offset in R3
2203  5472 0429         BLWP    @>005A(R9)                      
2203  5474 005A  
2204  5476 B101         DATA    >B101                   retrieve R0, R2, R3, R7
2205  5478 0583         INC     R3                      next sector
2206  547A 0227         AI      R7,256                  256 bytes further in PAB data buffer
2206  547C 0100  
2207  547E 0602         DEC     R2                      next sector
2208  5480 16F2         JNE     H153                    more to do
2209            *                                       
2210  5482 C069         MOV     @>0056(R9),R1           FDR ptr
2210  5484 0056  
2211  5486 0221         AI      R1,12                   point to file status byte
2211  5488 000C  
2212  548A 0202         LI      R2,>0100                value for program file
2212  548C 0100  
2213  548E 0429         BLWP    @>005A(R9)              set VDP to write
2213  5490 005A  
2214  5492 0023         DATA    >0023                   address in R1
2215  5494 DBC2         MOVB    R2,@-2(R15)             write file status byte in FDR
2215  5496 FFFE  
2216  5498 0221         AI      R1,4                    point to eof offset byte in FDR
2216  549A 0004  
2217  549C 0429         BLWP    @>005A(R9)              set VDP to write
2217  549E 005A  
2218  54A0 0023         DATA    >0023                   address in R1
2219  54A2 DBC0         MOVB    R0,@-2(R15)             # of bytes in last sector
2219  54A4 FFFE  
2220  54A6 0460         B       @UPDFDR                 update FDR, data buffer, VIB then return to caller
2220  54A8 4562  
2221            *                                       
2222  54AA C029 RBANB   MOV     @>0054(R9),R0           get buffer address + # of bytes
2222  54AC 0054  
2223  54AE 05C0         INCT    R0                      data buffer in PAB
2224  54B0 0429         BLWP    @>005A(R9)              set VDP to read
2224  54B2 005A  
2225  54B4 0002         DATA    >0002                   address in R0
2226  54B6 D1EF         MOVB    @-1026(R15),R7          get data buffer address
2226  54B8 FBFE  
2227  54BA 06C7         SWPB    R7                      
2228  54BC D1EF         MOVB    @-1026(R15),R7                  
2228  54BE FBFE  
2229  54C0 06C7         SWPB    R7                      
2230  54C2 0220         AI      R0,4                    point to # of bytes to transfer
2230  54C4 0004  
2231  54C6 0429         BLWP    @>005A(R9)              set VDP to read
2231  54C8 005A  
2232  54CA 0002         DATA    >0002                   address in R0
2233  54CC D0AF         MOVB    @-1026(R15),R2          get # of bytes to be transfered
2233  54CE FBFE  
2234  54D0 0982         SRL     R2,8                    make it # of sectors (256 bytes each)
2235  54D2 04C0         CLR     R0                      
2236  54D4 D02F         MOVB    @-1026(R15),R0          see if one more is needed
2236  54D6 FBFE  
2237  54D8 1301         JEQ     H154                    no
2238  54DA 0582         INC     R2                      yes: one more sector
2239  54DC 045B H154    B       *R11                    
2240            *
2241            *-------------------------------------
2242            * Opcode 9: Status
2243            * --------------
2244            * PAB 0: >09
2245            *     1:
2246            *   2-3:
2247            *     4:
2248            *     5:
2249            *   6-7: record #
2250            *     8:           <--- file status
2251            *
2252            * Status bits, returned in PAB byte 8:
2253            * >80: file not found
2254            * >40: file is protected
2255            * >20:
2256            * >10: internal (else display or program)
2257            * >08: program file
2258            * >04: variable (else fixed or program)
2259            * >02: memory full
2260            * >01: end-of-file reached
2261            *-------------------------------------                                  
2262            *
2263  54DE 06A0 STATUS  BL      @CALSUB                 call subroutine
2263  54E0 4344  
2264  54E2 4A90         DATA    FFFDRV                  save filename in comp buf, then find FDR in VDP
2265  54E4 C104         MOV     R4,R4                   found?
2266  54E6 1310         JEQ     H155                    yes
2267            *                                       
2268  54E8 06A0         BL      @CALSUB                 no: call subroutine
2268  54EA 4344  
2269  54EC 4AF8         DATA    FFDRDK                  find FDR on disk
2270  54EE 0200         LI      R0,>8000                value for file not found
2270  54F0 8000  
2271  54F2 C104         MOV     R4,R4                   found?
2272  54F4 1649         JNE     H164                    no: return with that value
2273  54F6 C069         MOV     @>0056(R9),R1           yes: ptr to FDR
2273  54F8 0056  
2274  54FA 04C2         CLR     R2                      
2275  54FC 0429         BLWP    @>005A(R9)              set VDP to write
2275  54FE 005A  
2276  5500 0023         DATA    >0023                   address in R1
2277  5502 DBC2         MOVB    R2,@-2(R15)             invalidate that FDR (file not open)
2277  5504 FFFE  
2278  5506 1036         JMP     H162                    transfer FDR status to PAB status byte
2279            *                                       
2280  5508 06A0 H155    BL      @CALSUB                 file is open: call subroutine
2280  550A 4344  
2281  550C 51CA         DATA    AFPGPF                  adjust FDR ptr, get PAB file type into R4
2282  550E 06A0         BL      @RFDRST                 get status byte from FDR
2282  5510 51E6  
2283  5512 1101         JLT     H156                    var
2284  5514 1006         JMP     H157                    fix
2285            *                                       
2286  5516 06A0 H156    BL      @CALSUB                 var: call subroutine
2286  5518 4344  
2287  551A 504C         DATA    RRSEC                   load wanted sector, point to wanted rec in buffer
2288  551C 1013         JMP     H159                    out of range
2289  551E 04C2         CLR     R2                      ok: clear flag
2290  5520 1029         JMP     H162                    copy status byte from FDR into PAB, return
2291            *                                       
2292  5522 D16F H157    MOVB    @-1026(R15),R5          fix: get rec/sect byte
2292  5524 FBFE  
2293  5526 0985         SRL     R5,8                    make it a word
2294  5528 1602         JNE     H158                    
2295  552A 0205         LI      R5,>0100                00 (program files) means 256
2295  552C 0100  
2296  552E 06A0 H158    BL      @PABR2B                 get 2 bytes from PAB into R0
2296  5530 4856  
2297  5532 0006         DATA    6                       # of wanted record
2298  5534 C0C0         MOV     R0,R3                   save it
2299  5536 111C         JLT     H161                    too big: set memory full bit in PAB status byte
2300  5538 06A0         BL      @RNFISE                 get # recs/file into R2, comp with R3
2300  553A 5244  
2301  553C 04C2         CLR     R2                      
2302  553E 1A1A         JL      H162                    in file: copy file type bits, return
2303  5540 3C85         DIV     R5,R2                   how many sectors do we need?
2304  5542 C0C2         MOV     R2,R3                   save result
2305            *                                       
2306  5544 06A0 H159    BL      @FDR2B1                 get 2 bytes from FDR into R0
2306  5546 485C  
2307  5548 000E         DATA    14                      # of sectors/file
2308  554A 0583         INC     R3                      plus 1 sector for FDR
2309  554C 0202         LI      R2,>0100                value for eof reached in PAB status
2309  554E 0100  
2310  5550 60C0         S       R0,R3                   are there enough sectors in file for these recs?
2311  5552 1501         JGT     H160                    
2312  5554 100F         JMP     H162                    yes: we reached the eof
2313  5556 06A0 H160    BL      @CALSUB                 call subroutine
2313  5558 4344  
2314  555A 49BE         DATA    RWVIB                   load VIB (sector 0)
2315  555C C103         MOV     R3,R4                   number of sectors that will be needed
2316  555E C205         MOV     R5,R8                   VIB ptr
2317  5560 0228         AI      R8,10                   skip 10 bytes (required by CFSVIB)
2317  5562 000A  
2318  5564 06A0         BL      @CFSVIB                 count free sectors in bitmap, into R3
2318  5566 5752  
2319  5568 0202         LI      R2,>0100                value for eof reached
2319  556A 0100  
2320  556C 8103         C       R3,R4                   are there that many free sectors?
2321  556E 1402         JHE     H162                    yes
2322  5570 0202 H161    LI      R2,>0200                value for memory full
2322  5572 0200  
2323            *                                       
2324  5574 06A0 H162    BL      @FDR2B1                 get 2 bytes from FDR into R0
2324  5576 485C  
2325  5578 000C         DATA    12                      file status byte
2326  557A 0240         ANDI    R0,>8F00                mask irrelevant bits
2326  557C 8F00  
2327  557E 1502         JGT     H163                    
2328  5580 0260         ORI     R0,>0080                var: put var bit in PAB status style
2328  5582 0080  
2329  5584 0A30 H163    SLA     R0,3                    get rid of var bit in FDR style
2330  5586 F002         SOCB    R2,R0                   add eof and mem full bits
2331            *                                       
2332  5588 C069 H164    MOV     @>0054(R9),R1           PAB ptr
2332  558A 0054  
2333  558C 0221         AI      R1,8                    point to bias/status return byte
2333  558E 0008  
2334  5590 0429         BLWP    @>005A(R9)              set VDP to write
2334  5592 005A  
2335  5594 0023         DATA    >0023                   address in R1
2336  5596 DBC0         MOVB    R0,@-2(R15)             write file status to PAB
2336  5598 FFFE  
2337  559A 0460         B       @RTURN1                 return to caller
2337  559C 4362  
2338            *
2339            *---------------------------------
2340            * Disk directory access
2341            * ---------------------
2342            * The directory is accessed by omiting the filename in the DSR name: "DSK1."
2343            * It must be opened for input only, as an Int/Fix 38 file.
2344            * It consists in upto 128 records, the first one contains the disk informations,
2345            * the others the informations for upto 127 files (in alphabetical order).
2346            * Each record consists in an ascii string and three floating point numbers.
2347            *
2348            * Record 0 contains:
2349            * - Diskname (an ascii string of upto 10 chars).
2350            * - The number zero.
2351            * - The number of sectors on disk.
2352            * - The number of free sectors on disk.
2353            *
2354            * Other records contain:
2355            * - Filename (an ascii string of upto 10 chars).
2356            * - Filetype: 1=D/F, 2=D/V, 3=I/F, 4=I/V, 5=Prog, 0=end of directory.
2357            *   If the file is protected, this number is negative (-1=D/F, etc).
2358            * - File size in sectors (including the FDR itself).
2359            * - File record length (0 for programs).
2360            *---------------------------------
2361             
2362            *---------------------------------
2363            * Open disk directory pseudo-file
2364            *---------------------------------                                      
2365            *
2366  559E D02F OPNDIR  MOVB    @-1026(R15),R0          get file type from PAB
2366  55A0 FBFE  
2367  55A2 0240         ANDI    R0,>1E00                mask irrelavant bits (rel/seq)
2367  55A4 1E00  
2368  55A6 0280         CI      R0,>0C00                is it int/fix in output mode?
2368  55A8 0C00  
2369  55AA 1303         JEQ     H166                    yes
2370  55AC 06A0 H165    BL      @RETERR                 return with error
2370  55AE 498A  
2371  55B0 4000         DATA    >4000                   bad attributes
2372  55B2 06A0 H166    BL      @PABR2B                 get 2 bytes from PAB into R0
2372  55B4 4856  
2373  55B6 0004         DATA    4                       rec length
2374  55B8 0980         SRL     R0,8                    make it a word
2375  55BA 1303         JEQ     H167                    >00= default: set it to 38
2376  55BC 0280         CI      R0,>0026                is it 38?
2376  55BE 0026  
2377  55C0 16F5         JNE     H165                    no: return with bad attributes error
2378  55C2 0200 H167    LI      R0,>2600                set rec len to 38
2378  55C4 2600  
2379  55C6 0429         BLWP    @>005A(R9)              set VDP to write
2379  55C8 005A  
2380  55CA 0103         DATA    >0103                   address in R8 (from PABR2B)
2381  55CC DBC0         MOVB    R0,@-2(R15)             write rec len to PAB
2381  55CE FFFE  
2382            *                                       
2383  55D0 04C7         CLR     R7                      
2384  55D2 06A0         BL      @FNDRV                  find matching drive in file control blocks
2384  55D4 578C  
2385  55D6 55DE         DATA    H168                    go there if not found
2386  55D8 06A0 ERRR10  BL      @ERROR5                 update data then return with error
2386  55DA 495E  
2387  55DC E000         DATA    >E000                   file error
2388  55DE C1C7 H168    MOV     R7,R7                   did we find a free slot?
2389  55E0 1603         JNE     H169                    yes
2390  55E2 06A0         BL      @RETERR                 no: return with error
2390  55E4 498A  
2391  55E6 8000         DATA    >8000                   memory full
2392  55E8 0429 H169    BLWP    @>005A(R9)              set VDP to write
2392  55EA 005A  
2393  55EC 00E3         DATA    >00E3                   address in R7
2394  55EE DBC3         MOVB    R3,@-2(R15)             write drive #
2394  55F0 FFFE  
2395  55F2 06C3         SWPB    R3                      
2396  55F4 DBC3         MOVB    R3,@-2(R15)             and a space as filename (illegal, indicates dir)
2396  55F6 FFFE  
2397  55F8 0460         B       @RTURN1                 return to caller
2397  55FA 4362  
2398            *
2399            *---------------------------------
2400            * Close disk directory
2401            *---------------------------------                                      
2402  55FC 06A0 CLSDIR  BL      @FNDRV                  find matching drive in file control blocks
2402  55FE 578C  
2403  5600 55D8         DATA    ERRR10                  go there if not found: return with file error
2404  5602 04C0         CLR     R0                      
2405  5604 0429         BLWP    @>005A(R9)              set VDP to write
2405  5606 005A  
2406  5608 0103         DATA    >0103                   address in R8
2407  560A DBC0         MOVB    R0,@-2(R15)             clear drive #
2407  560C FFFE  
2408  560E 0460         B       @RTURN1                 return to caller
2408  5610 4362  
2409            *
2410            *---------------------------------
2411            * Read a record from disk directory
2412            *---------------------------------                                      
2413            *
2414  5612 06A0 RDDIR   BL      @FNDRV                  find matching drive in file control blocks
2414  5614 578C  
2415  5616 55D8         DATA    ERRR10                  go ther it not found: return with file error
2416  5618 0588         INC     R8                      
2417  561A C148         MOV     R8,R5                   save ptr to FDR
2418  561C 06A0         BL      @PABR2B                 get 2 bytes from PAB into R0
2418  561E 4856  
2419  5620 0006         DATA    6                       record #
2420  5622 C080         MOV     R0,R2                   save it
2421  5624 0582         INC     R2                      
2422  5626 0429         BLWP    @>005A(R9)              set VDP to write
2422  5628 005A  
2423  562A 0103         DATA    >0103                   address in R8
2424  562C DBC2         MOVB    R2,@-2(R15)             write record number in FDR
2424  562E FFFE  
2425  5630 06C2         SWPB    R2                      after first char of filename!
2426  5632 DBC2         MOVB    R2,@-2(R15)                     
2426  5634 FFFE  
2427  5636 0A10         SLA     R0,1                    since two byte per file ptr
2428  5638 D000         MOVB    R0,R0                   is rec # greater than 128?
2429  563A 1303         JEQ     H170                    no
2430  563C 06A0         BL      @ERROR5                 yes: update data then return with error
2430  563E 495E  
2431  5640 A000         DATA    >A000                   past eof
2432  5642 0702 H170    SETO    R2                      code for read
2433  5644 C100         MOV     R0,R4                   record #
2434  5646 133B         JEQ     H175                    0=disk parameters
2435  5648 0204         LI      R4,1                    sector #1
2435  564A 0001  
2436  564C 06A0         BL      @CALSUB                 call subroutine
2436  564E 4344  
2437  5650 4A3A         DATA    RWSEC                   read sector into buffer in R5
2438  5652 C205         MOV     R5,R8                   buffer ptr
2439  5654 0225         AI      R5,255                  point to data buffer area in this ctrl block
2439  5656 00FF  
2440  5658 0640         DECT    R0                      don't count record 0
2441  565A A200         A       R0,R8                   point to desired file ptr
2442  565C 06A0         BL      @VDPR2B                 get two byte from VDP at R8 into R0
2442  565E 4862  
2443  5660 C100         MOV     R0,R4                   sector where that FDR is to be found
2444  5662 1328         JEQ     H173                    no more
2445  5664 06A0         BL      @CALSUB                 call subroutine
2445  5666 4344  
2446  5668 4A3A         DATA    RWSEC                   read FDR sector into data buffer area
2447  566A 06A0         BL      @FDR2B1                 get 2 bytes from FDR into R0
2447  566C 485C  
2448  566E 010E         DATA    270                     # of sect/file
2449  5670 C180         MOV     R0,R6                   save it to output file size
2450  5672 0586         INC     R6                      include the FDR itself
2451  5674 D0EF         MOVB    @-1026(R15),R3          ignore eof offset
2451  5676 FBFE  
2452  5678 0202         LI      R2,>0A00                10 chars per filename
2452  567A 0A00  
2453  567C D0EF         MOVB    @-1026(R15),R3          get rec length
2453  567E FBFE  
2454  5680 0983         SRL     R3,8                    make it a word
2455  5682 0648         DECT    R8                      point to status byte in FDR
2456  5684 0429         BLWP    @>005A(R9)              set VDP to read
2456  5686 005A  
2457  5688 0102         DATA    >0102                   address in R8
2458  568A D02F         MOVB    @-1026(R15),R0          get file status byte
2458  568C FBFE  
2459  568E C1C0         MOV     R0,R7                   
2460  5690 0240         ANDI    R0,>0800                keep only write protected bit
2460  5692 0800  
2461  5694 51C0         SZCB    R0,R7                   clear write protected bit (if it was set)
2462  5696 0987         SRL     R7,8                    make it a word
2463  5698 0587         INC     R7                      types are numbered from 1
2464  569A 0287         CI      R7,>0002                is it a program file?
2464  569C 0002  
2465  569E 1602         JNE     H171                    no
2466  56A0 0227         AI      R7,3                    yes: make it type 5
2466  56A2 0003  
2467  56A4 0287 H171    CI      R7,>0008                is it var?
2467  56A6 0008  
2468  56A8 1A02         JL      H172                    no
2469  56AA 0227         AI      R7,-127                 yes: add 1 and clear var bit
2469  56AC FF81  
2470  56AE 0A40 H172    SLA     R0,4                    write protect bit will be >80
2471  56B0 E1C0         SOC     R0,R7                   add it to file type
2472  56B2 1004         JMP     H174                    
2473            *                                       
2474  56B4 04C2 H173    CLR     R2                      no more files: filename size = 0
2475  56B6 04C6         CLR     R6                      file size = 0
2476  56B8 04C3         CLR     R3                      rec length = 0
2477  56BA 04C7         CLR     R7                      type = 0
2478  56BC 100F H174    JMP     H176                    output that
2479            *                                       
2480  56BE 0225 H175    AI      R5,255                  disk info: point to data buffer area in ctrl block
2480  56C0 00FF  
2481  56C2 06A0         BL      @CALSUB                 call subroutine
2481  56C4 4344  
2482  56C6 4A3A         DATA    RWSEC                   read sector 0
2483  56C8 06A0         BL      @FDR2B1                 get 2 bytes from FDR into R0
2483  56CA 485C  
2484  56CC 010A         DATA    266                     # of sectors on disk
2485  56CE C180         MOV     R0,R6                   duplicate it
2486  56D0 0646         DECT    R6                      minus directory itself (sect 0 + 1)
2487  56D2 06A0         BL      @CFSVIB                 count free sectors in bitmap, result in R3
2487  56D4 5752  
2488  56D6 04C7         CLR     R7                      filetype is not used
2489  56D8 0202         LI      R2,>0A00                diskname is 10 chars
2489  56DA 0A00  
2490            *                                       
2491  56DC 06A0 H176    BL      @PABR2B                 get 2 bytes from PAB into R0
2491  56DE 4856  
2492  56E0 0002         DATA    2                       APEDSK99: error in source listing (was R2)
2493  56E2 C200         MOV     R0,R8                   duplicate it
2494  56E4 0588         INC     R8                      skip first byte
2495  56E6 0982         SRL     R2,8                    filename length (or diskname)
2496  56E8 1316         JEQ     H179                    0: skip filename copying
2497  56EA 04C1         CLR     R1                      
2498  56EC 0429 H177    BLWP    @>005A(R9)              set VDP to read
2498  56EE 005A  
2499  56F0 00A2         DATA    >00A2                   address in R5 (FDR ptr)
2500  56F2 D06F         MOVB    @-1026(R15),R1          get 1 char from filename in FDR
2500  56F4 FBFE  
2501  56F6 0281         CI      R1,>2000                is it a space?
2501  56F8 2000  
2502  56FA 1309         JEQ     H178                    yes: end of name
2503  56FC 0429         BLWP    @>005A(R9)              no: set VDP to write
2503  56FE 005A  
2504  5700 0103         DATA    >0103                   address in R8 (PAB data buffer ptr)
2505  5702 DBC1         MOVB    R1,@-2(R15)             copy char in PAB data buffer
2505  5704 FFFE  
2506  5706 0585         INC     R5                      increment source ptr
2507  5708 0588         INC     R8                      increment destination ptr
2508  570A 0602         DEC     R2                      next char
2509  570C 16EF         JNE     H177                    
2510  570E 0502 H178    NEG     R2                      number of trailing spaces
2511  5710 0222         AI      R2,10                   number of chars in filename
2511  5712 000A  
2512  5714 06C2         SWPB    R2                      
2513  5716 0429 H179    BLWP    @>005A(R9)              set VDP to write
2513  5718 005A  
2514  571A 0003         DATA    >0003                   address in R0 (beg of PAB data buffer)
2515  571C DBC2         MOVB    R2,@-2(R15)             write string length byte
2515  571E FFFE  
2516            *                                       
2517  5720 0429         BLWP    @>005A(R9)              set VDP to write
2517  5722 005A  
2518  5724 0103         DATA    >0103                   address in R8
2519  5726 C047         MOV     R7,R1                   file type + protection
2520  5728 06A0         BL      @INT2FP                 make it a float number
2520  572A 57D0  
2521  572C C046         MOV     R6,R1                   file size in sectors, including FDR
2522  572E 06A0         BL      @INT2FP                 make it a float number
2522  5730 57D0  
2523  5732 C043         MOV     R3,R1                   record length
2524  5734 06A0         BL      @INT2FP                 make it a float number
2524  5736 57D0  
2525  5738 C229         MOV     @>0054(R9),R8           get PAB ptr
2525  573A 0054  
2526  573C 0228         AI      R8,5                    point to character count
2526  573E 0005  
2527  5740 0200         LI      R0,>2600                always 38 bytes
2527  5742 2600  
2528  5744 0429         BLWP    @>005A(R9)              set VDP to write
2528  5746 005A  
2529  5748 0103         DATA    >0103                   address in R8
2530  574A DBC0         MOVB    R0,@-2(R15)             write # of characters in record
2530  574C FFFE  
2531  574E 0460         B       @RTURN1                 return to caller
2531  5750 4362  
2532            *                                       
2533  5752 0228 CFSVIB  AI      R8,46                   count free sectors in VIB bitmap
2533  5754 002E  
2534  5756 0202         LI      R2,200                  bitmap size
2534  5758 00C8  
2535  575A 04C3         CLR     R3                      free sectors counter
2536  575C 0429         BLWP    @>005A(R9)              set VDP to read
2536  575E 005A  
2537  5760 0102         DATA    >0102                   address in R8
2538  5762 D06F H180    MOVB    @-1026(R15),R1          get a byte from bitmap
2538  5764 FBFE  
2539  5766 0221         AI      R1,256                  
2539  5768 0100  
2540  576A 0981         SRL     R1,8                    
2541  576C 130C         JEQ     H184                    was >FF: no free sectors, next byte
2542  576E 0601         DEC     R1                      was it >00?
2543  5770 1603         JNE     H181                    no: count bits
2544  5772 0223         AI      R3,8                    yes: 8 more free sectors
2544  5774 0008  
2545  5776 1007         JMP     H184                    next byte
2546  5778 0200 H181    LI      R0,8                    8 bits per byte
2546  577A 0008  
2547  577C 0911 H182    SRL     R1,1                    test a bit
2548  577E 1801         JOC     H183                    was 1: sector is used
2549  5780 0583         INC     R3                      was 0: one more free sector
2550  5782 0600 H183    DEC     R0                      next bit in byte
2551  5784 16FB         JNE     H182                    more to come
2552  5786 0602 H184    DEC     R2                      next bitmap byte
2553  5788 16EC         JNE     H180                    more to come
2554  578A 045B         B       *R11                    
2555            *                                       
2556  578C C2BB FNDRV   MOV     *R11+,R10               find drive in file control blocks
2557  578E C14B         MOV     R11,R5                  save 2 returns
2558  5790 C229         MOV     @>0056(R9),R8           top of mem word in VDP buffers header
2558  5792 0056  
2559  5794 0228         AI      R8,3                    point to max # of files
2559  5796 0003  
2560  5798 0429         BLWP    @>005A(R9)              set VDP to read
2560  579A 005A  
2561  579C 0102         DATA    >0102                   address in R8
2562  579E D0AF         MOVB    @-1026(R15),R2          get # of files
2562  57A0 FBFE  
2563  57A2 0882         SRA     R2,8                    make it a word
2564  57A4 0228         AI      R8,6                    point to drive # in file ctrl block
2564  57A6 0006  
2565  57A8 0203         LI      R3,>0020                filename begin with space (illegal: flag for dir)
2565  57AA 0020  
2566  57AC D0C6         MOVB    R6,R3                   APEDSK99: error in original disassembly (was R5)
2567  57AE 06A0 H185    BL      @VDPR2B                 read 2 bytes from VDP at R8 into R0
2567  57B0 4862  
2568  57B2 8003         C       R3,R0                   match with that control block?
2569  57B4 1309         JEQ     H187                    yes
2570  57B6 0240         ANDI    R0,>00FF                keep only first char of filename
2570  57B8 00FF  
2571  57BA 1601         JNE     H186                    valid filename: a FDR is loaded here
2572  57BC C1C8         MOV     R8,R7                   this space is free: save ptr
2573  57BE 0228 H186    AI      R8,518                  point to next file control block
2573  57C0 0206  
2574  57C2 0602         DEC     R2                      next file
2575  57C4 16F4         JNE     H185                    more to come
2576  57C6 045A         B       *R10                    not found: return to address passed in data word
2577  57C8 0588 H187    INC     R8                      drive matches: point to FDR
2578  57CA CA48         MOV     R8,@>0056(R9)           save ptr
2578  57CC 0056  
2579  57CE 0455         B       *R5                     return to caller after data word
2580            *
2581            *--------------------------------------
2582            * Floating point format
2583            * ---------------------
2584            * Float numbers are 8 bytes long: EE 12 34 56 78 9A BC
2585            * EE is the exponent in radix 100 (not in radix 10 as usual!). It is biased
2586            * by 64: >40=0, 41=1 (i.e *100), >42=2 (i.e * 10,000) >3F= -1 (i.e /100), etc
2587            *
2588            * 12 ... BC are the mantissa in binary coded decimal: each byte encodes two
2589            * decimal digits from 00 to 99
2590            *
2591            * For negative numbers, the first word is negated
2592            * For zero, the first word is >0000 the others are irrelevant
2593            *
2594            * Examples: 40 08 00 00 00 00 00 00 is 8.0
2595            *           41 02 37 00 00 00 00 00 is 255.0 (>37 hex = 55 decimal)
2596            *           BF F8 00 00 00 00 00 00 is -8.0
2597            *           43 01 02 03 04 05 06 07 is 1020304.050607
2598            *--------------------------------------                                 
2599            *
2600  57D0 0202 INT2FP  LI      R2,>0800                write an integer in floating point format
2600  57D2 0800  
2601  57D4 DBC2         MOVB    R2,@-2(R15)             size=8
2601  57D6 FFFE  
2602  57D8 C141         MOV     R1,R5                   integer is in R1: save it for sign processing
2603  57DA 0241         ANDI    R1,>7FFF                clear sign bit
2603  57DC 7FFF  
2604  57DE 0281         CI      R1,100                  is it less than 100?
2604  57E0 0064  
2605  57E2 1A07         JL      H188                    yes
2606  57E4 04C0         CLR     R0                      100 or over
2607  57E6 0204         LI      R4,100                  
2607  57E8 0064  
2608  57EA 3C04         DIV     R4,R0                   divide by 100
2609  57EC 0260         ORI     R0,>4100                add exponent 2 to hundreths
2609  57EE 4100  
2610  57F0 1005         JMP     H190                    
2611            *                                       
2612  57F2 C001 H188    MOV     R1,R0                   is it 0?
2613  57F4 1302         JEQ     H189                    yes: exponent is 0
2614  57F6 0260         ORI     R0,>4000                no: add exponent 1
2614  57F8 4000  
2615  57FA 04C1 H189    CLR     R1                      next digits will be 0
2616            *                                       
2617  57FC C145 H190    MOV     R5,R5                   test sign bit
2618  57FE 1101         JLT     H191                    negative
2619  5800 1001         JMP     H192                    positive or zero
2620  5802 0500 H191    NEG     R0                      negate first word
2621  5804 DBC0 H192    MOVB    R0,@-2(R15)             write exponent to VDP at preset address
2621  5806 FFFE  
2622  5808 06C0         SWPB    R0                      
2623  580A DBC0         MOVB    R0,@-2(R15)             write first first 2 digits (or hundreths)
2623  580C FFFE  
2624  580E 06C1         SWPB    R1                      
2625  5810 DBC1         MOVB    R1,@-2(R15)             write last 2 digits (if any)
2625  5812 FFFE  
2626  5814 0202         LI      R2,5                    the remaining bytes are all 0 with integers
2626  5816 0005  
2627  5818 DBC2 H193    MOVB    R2,@-2(R15)             write 0 to VDP
2627  581A FFFE  
2628  581C 0602         DEC     R2                      next byte
2629  581E 16FC         JNE     H193                    more to do
2630  5820 045B         B       *R11                    
2631            *
2632            *---------------------------------------
2633            * Subprogram >10: sector R/W
2634            * --------------
2635            * >834A: (n/a)      <--- sector #
2636            * >834C: drive #
2637            * >834D: R/W code (write if >00)
2638            * >834E: VDP buffer
2639            * >8350: sector #   <--- error code
2640            *---------------------------------------                                        
2641            *
2642  5822 C1CB ESUB01  MOV     R11,R7                  
2643  5824 06A0         BL      @PRPFDO                 prepare disk operations
2643  5826 4410  
2644  5828 CA69         MOV     @>0050(R9),@>004A(R9)   copy sector #
2644  582A 0050  
2644  582C 004A  
2645  582E 0460         B       @SECRW1                 
2645  5830 419A  
2646            *
2647            *---------------------------------------
2648            * Subprogram >11: format disk
2649            * --------------                                        
2650            *
2651  5832 C1CB ESUB02  MOV     R11,R7                  
2652  5834 06A0         BL      @PRPFDO                 prepare disk operations
2652  5836 4410  
2653  5838 0460         B       @FMTDSK                 
2653  583A 4218  
2654            *
2655            *---------------------------------------
2656            * Subprogram >12: file (un)protect
2657            * --------------
2658            * >834C: drive #
2659            * >834D: protect code (>00 unprotect)
2660            * >834E: ptr to filename
2661            * >8350: (n/a)      <--- error code
2662            *---------------------------------------                                
2663            *
2664  583C C1CB ESUB03  MOV     R11,R7                  
2665  583E 06A0         BL      @PRPFDO                 prepare disk operations
2665  5840 4410  
2666  5842 D029         MOVB    @>004D(R9),R0           get protection code
2666  5844 004D  
2667  5846 0240         ANDI    R0,>0800                keep the bit that will be needed
2667  5848 0800  
2668  584A 0429         BLWP    @>005A(R9)              save R0 on stack
2668  584C 005A  
2669  584E 8000         DATA    >8000                   
2670  5850 C029         MOV     @>004E(R9),R0           get pointer to filename
2670  5852 004E  
2671  5854 06A0         BL      @CALSUB                 call subroutine
2671  5856 4344  
2672  5858 593E         DATA    RFDRVB                  load FDR in VDP buffer
2673  585A 0429         BLWP    @>005A(R9)              retrieve old R0, in R2
2673  585C 005A  
2674  585E 2001         DATA    >2001                   
2675  5860 06A0         BL      @FDR2B1                 read two bytes in R0 from top of FDR + offset
2675  5862 485C  
2676  5864 000C         DATA    12                      file status byte
2677  5866 0240         ANDI    R0,>F700                clear protection flag
2677  5868 F700  
2678  586A F002         SOCB    R2,R0                   set it if needed
2679  586C 0429         BLWP    @>005A(R9)              set VDP for write
2679  586E 005A  
2680  5870 0103         DATA    >0103                   address in R8
2681  5872 DBC0         MOVB    R0,@-2(R15)             write back file status to FDR
2681  5874 FFFE  
2682            *                                       
2683  5876 C229 UWFLVB  MOV     @>0056(R9),R8           FDR address in VDP mem
2683  5878 0056  
2684  587A 0429         BLWP    @>005A(R9)              set VDP for read
2684  587C 005A  
2685  587E 0102         DATA    >0102                   address in R8
2686  5880 D02F         MOVB    @-1026(R15),R0          get drive # in ctrl block
2686  5882 FBFE  
2687  5884 0260         ORI     R0,>8000                flag it
2687  5886 8000  
2688  5888 0429         BLWP    @>005A(R9)              set VDP for write
2688  588A 005A  
2689  588C 0103         DATA    >0103                   address in R8
2690  588E DBC0         MOVB    R0,@-2(R15)             write it back
2690  5890 FFFE  
2691  5892 0460         B       @UPDFDR                 update FDR, load VIB
2691  5894 4562  
2692            *
2693            *---------------------------------
2694            * Subprogram >13: file rename
2695            * --------------
2696            * >834C: drive #
2697            * >834E: ptr to new name
2698            * >8350: ptr to old name <--- error code
2699            *---------------------------------                                      
2700            *
2701  5896 C1CB ESUB04  MOV     R11,R7                  
2702  5898 06A0         BL      @PRPFDO                 prepare disk operations
2702  589A 4410  
2703  589C C029         MOV     @>004E(R9),R0           get ptr to new filename
2703  589E 004E  
2704  58A0 0429         BLWP    @>005A(R9)              save R0 on stack
2704  58A2 005A  
2705  58A4 8000         DATA    >8000                   
2706  58A6 C029         MOV     @>0050(R9),R0           get ptr to old filename
2706  58A8 0050  
2707  58AA 06A0         BL      @CALSUB                 call subroutine
2707  58AC 4344  
2708  58AE 593E         DATA    RFDRVB                  put FDR in VDP buffer
2709  58B0 06A0         BL      @RMFPTR                 remove FDR ptr from sector 1
2709  58B2 47C6  
2710  58B4 06A0         BL      @FDR2B1                 get 2 bytes from FDR
2710  58B6 485C  
2711  58B8 000C         DATA    12                      file status byte
2712  58BA 0240         ANDI    R0,>0800                protected?
2712  58BC 0800  
2713  58BE 1303         JEQ     H194                    no
2714  58C0 06A0         BL      @ERROR5                 yes: return with error
2714  58C2 495E  
2715  58C4 2000         DATA    >2000                   write protected
2716  58C6 06A0 H194    BL      @FDR2B1                 get 2 bytes from FDR
2716  58C8 485C  
2717  58CA FFFC         DATA    -4                      sector # of FDR
2718  58CC C040         MOV     R0,R1                   
2719  58CE 0429         BLWP    @>005A(R9)              retrieve R0 from stack
2719  58D0 005A  
2720  58D2 8001         DATA    >8001                   ptr to new filename
2721  58D4 0429         BLWP    @>005A(R9)              save R1 on stack
2721  58D6 005A  
2722  58D8 4000         DATA    >4000                   sector # of FDR
2723  58DA 06A0         BL      @UFNCB                  write drive # and filename in compare buffer
2723  58DC 5B60  
2724  58DE 06A0         BL      @CALSUB                 call subroutine
2724  58E0 4344  
2725  58E2 4B24         DATA    FFDRFN                  find FDR from filename
2726  58E4 C104         MOV     R4,R4                   found?
2727  58E6 1338         JEQ     H195                    yes: return with file error (name already exist)
2728  58E8 06A0         BL      @INSFDR                 insert a FDR in sector 1
2728  58EA 47F6  
2729  58EC 0429         BLWP    @>005A(R9)              retrieve sect # of FDR in R4
2729  58EE 005A  
2730  58F0 0801         DATA    >0801                   
2731  58F2 0429         BLWP    @>005A(R9)              set VDP to write
2731  58F4 005A  
2732  58F6 0103         DATA    >0103                   address in R8
2733  58F8 DBC4         MOVB    R4,@-2(R15)             write sector # of FDR
2733  58FA FFFE  
2734  58FC 06C4         SWPB    R4                      
2735  58FE DBC4         MOVB    R4,@-2(R15)                     
2735  5900 FFFE  
2736  5902 06C4         SWPB    R4                      sector #
2737  5904 0702         SETO    R2                      code for read
2738  5906 04C5         CLR     R5                      buffer offset: VDP at >8356
2739  5908 06A0         BL      @CALSUB                 call subroutine
2739  590A 4344  
2740  590C 4A36         DATA    RDFDR1                  read FDR
2741  590E C045         MOV     R5,R1                   
2742  5910 C029         MOV     @>0058(R9),R0                   
2742  5912 0058  
2743  5914 0220         AI      R0,257                  
2743  5916 0101  
2744  5918 0601         DEC     R1                      
2745  591A 06A0         BL      @CFNFDR                 copy filename in compare buffer to FDR
2745  591C 5B76  
2746  591E 04C2         CLR     R2                      code for write
2747  5920 06A0         BL      @CALSUB                 call subroutine
2747  5922 4344  
2748  5924 4A3A         DATA    RWSEC                   write FDR (with new name in it)
2749  5926 06A0         BL      @CALSUB                 call subroutine
2749  5928 4344  
2750  592A 4A22         DATA    WRSEC1                  write sector 1 (with new FDR ptr in it)
2751  592C C069         MOV     @>0056(R9),R1           FDR ptr
2751  592E 0056  
2752  5930 0429         BLWP    @>005A(R9)              prepare VDP to write
2752  5932 005A  
2753  5934 0023         DATA    >0023                   address in R1
2754  5936 DBC4         MOVB    R4,@-2(R15)             clear first char of FDR in buffer
2754  5938 FFFE  
2755  593A 0460         B       @RTURN1                 return to caller
2755  593C 4362  
2756            *                               
2757  593E 04C6 RFDRVB  CLR     R6                      put FDR in VDP buffer
2758  5940 D1A9         MOVB    @>004C(R9),R6           get drive #
2758  5942 004C  
2759  5944 06A0         BL      @UFNCB                  update filename compare buffer
2759  5946 5B60  
2760  5948 06A0         BL      @CALSUB                 call subroutine
2760  594A 4344  
2761  594C 4AB0         DATA    FFDRVB                  look if FDR already in VDP buffer
2762  594E 06A0         BL      @CALSUB                 call subroutine
2762  5950 4344  
2763  5952 4AF4         DATA    FFDROD                  file FDR on disk
2764  5954 C104         MOV     R4,R4                   found?
2765  5956 1303         JEQ     H196                    yes
2766  5958 06A0 H195    BL      @RETERR                 no: return with error code in >8350
2766  595A 498A  
2767  595C E000         DATA    >E000                   file error
2768  595E 0460 H196    B       @RTURN1                 return to caller
2768  5960 4362  
2769            *
2770            *-------------------------------------
2771            * Subprogram >14: file raw read
2772            * --------------
2773            * >834C: drive #                          <--- >00
2774            * >834D: # of sectors (>00=get file info) <--- sectors read
2775            * >834E: ptr to filename
2776            * >8350: file info buffer (>83xx)         <--- error code
2777            *                              |
2778            * >83xx  : VDP buffer       <--'
2779            * >83xx+2: first sector # (total # of sect when get file info)
2780            * >83xx+4: status flag
2781            * >83xx+5: recs/sector
2782            * >83xx+6: eof offset
2783            * >83xx+7: rec size
2784            * >83xx+8: # of recs
2785            *-------------------------------------                                  
2786            *
2787  5962 C1CB ESUB05  MOV     R11,R7                  
2788  5964 06A0         BL      @PRPFDO                 prepare disk operations
2788  5966 4410  
2789  5968 06A0         BL      @RFNPTR                 load filename and ptrs
2789  596A 5B98  
2790  596C 06A0         BL      @FFFDR                  find file FDR, load some info
2790  596E 5BBE  
2791  5970 C082         MOV     R2,R2                   # of sectors to read
2792  5972 131E         JEQ     H202                    >00: get file info
2793  5974 6003         S       R3,R0                   sectors in file - first sector to read
2794  5976 1502         JGT     H197                    in file
2795  5978 04C2         CLR     R2                      past eof
2796  597A 1017         JMP     H201                    
2797  597C 8002 H197    C       R2,R0                   sectors past first one vs sectors to load
2798  597E 1A01         JL      H198                    
2799  5980 C080         MOV     R0,R2                   load what's left
2800  5982 0429 H198    BLWP    @>005A(R9)                      
2800  5984 005A  
2801  5986 2000         DATA    >2000                   save R2
2802  5988 0429 H199    BLWP    @>005A(R9)                      
2802  598A 005A  
2803  598C 3100         DATA    >3100                   save R2, R3, R7
2804  598E 06A0         BL      @CALSUB                 call subroutine
2804  5990 4344  
2805  5992 4616         DATA    RDOFSC                  read sector from offset in file
2806  5994 0429         BLWP    @>005A(R9)                      
2806  5996 005A  
2807  5998 3101         DATA    >3101                   retrieve R2, R3, R7
2808  599A 0583         INC     R3                      next sector
2809  599C 0227         AI      R7,256                  increment VDP buffer ptr by 256 bytes
2809  599E 0100  
2810  59A0 0602         DEC     R2                      more to do?
2811  59A2 16F2         JNE     H199                    yes
2812  59A4 0429 H200    BLWP    @>005A(R9)                      
2812  59A6 005A  
2813  59A8 2001         DATA    >2001                   retrieve R2 (# of sectors read)
2814  59AA CA42 H201    MOV     R2,@>004C(R9)           update # of sectors in parameters
2814  59AC 004C  
2815  59AE 100A         JMP     H203                    
2816            *                                       
2817  59B0 CD00 H202    MOV     R0,*R4+                 get file info: sectors in file
2818  59B2 0648         DECT    R8                      
2819  59B4 05C2         INCT    R2                      copy 2 bytes (status + recs/sector)
2820  59B6 06A0         BL      @VDP2SP                 from VDP at R8 to file info structure
2820  59B8 5BF2  
2821  59BA 0202         LI      R2,4                    copy 4 bytes
2821  59BC 0004  
2822  59BE A202         A       R2,R8                   
2823  59C0 06A0         BL      @VDP2SP                 eof offset, rec len, # of recs (or # of sect)
2823  59C2 5BF2  
2824  59C4 06A0 H203    BL      @CALSUB                 call subroutine
2824  59C6 4344  
2825  59C8 4562         DATA    UPDFDR                  updata FDR (+ data) if needed, read VIB
2826  59CA 04E9         CLR     @>0050(R9)              clear error flag
2826  59CC 0050  
2827  59CE 0460         B       @RTURN1                 return to caller
2827  59D0 4362  
2828            *
2829            *--------------------------------------
2830            * Subprogram >15: file raw write
2831            * --------------
2832            * >834C: drive #                                  <--- >00
2833            * >834D: # of sectors (>00=create file from info) <--- # of sectors written
2834            * >834E: ptr to filename
2835            * >8350: file info buffer (>83xx)                 <--- error code
2836            *                              |
2837            * >83xx  : VDP buffer       <--'
2838            * >83xx+2: first sector # (total # of sectors when creating file)
2839            * >83xx+4: status flag
2840            * >83xx+5: recs/sector
2841            * >83xx+6: eof offset
2842            * >83xx+7: rec size
2843            * >83xx+8: # of recs
2844            *--------------------------------------                                 
2845            *
2846  59D2 C1CB ESUB06  MOV     R11,R7                  
2847  59D4 06A0         BL      @PRPFDO                 prepare disk operations
2847  59D6 4410  
2848  59D8 06A0         BL      @RFNPTR                 load drive + filename, + a few info
2848  59DA 5B98  
2849  59DC 1314         JEQ     H205                    sectors to write=0: create file
2850  59DE 06A0         BL      @FFFDR                  find file FDR
2850  59E0 5BBE  
2851  59E2 0429         BLWP    @>005A(R9)                      
2851  59E4 005A  
2852  59E6 2000         DATA    >2000                   save R2 (# of sectors to write)
2853  59E8 0429 H204    BLWP    @>005A(R9)                      
2853  59EA 005A  
2854  59EC 3100         DATA    >3100                   save R2, R3, R7
2855  59EE 06A0         BL      @CALSUB                 call subroutine
2855  59F0 4344  
2856  59F2 4636         DATA    WROFSC                  write sector from offset in file
2857  59F4 0429         BLWP    @>005A(R9)                      
2857  59F6 005A  
2858  59F8 3101         DATA    >3101                   retrieve R2, R3, R7
2859  59FA 0583         INC     R3                      next sector
2860  59FC 0227         AI      R7,256                  increment VDP ptr by 256 bytes
2860  59FE 0100  
2861  5A00 0602         DEC     R2                      more to do?
2862  5A02 16F2         JNE     H204                    yes
2863  5A04 10CF         JMP     H200                    update # of sectors written, in param. Then return
2864            *                               
2865  5A06 06A0 H205    BL      @CALSUB                 create file
2865  5A08 4344  
2866  5A0A 4AB0         DATA    FFDRVB                  find file FDR in VDP buffers
2867  5A0C 06A0         BL      @CALSUB                 call subroutine
2867  5A0E 4344  
2868  5A10 4AF4         DATA    FFDROD                  find file FDR on disk
2869  5A12 06A0         BL      @CALSUB                 call subroutine
2869  5A14 4344  
2870  5A16 4482         DATA    CRFIL2                  create file
2871  5A18 0429         BLWP    @>005A(R9)                      
2871  5A1A 005A  
2872  5A1C 0801         DATA    >0801                   retrieve R4 (file info ptr)
2873  5A1E C229         MOV     @>0056(R9),R8           FDR ptr
2873  5A20 0056  
2874  5A22 05C4         INCT    R4                      skip 2 bytes
2875  5A24 C0F4         MOV     *R4+,R3                 # of sector to create
2876  5A26 0228         AI      R8,10                   skip filename
2876  5A28 000A  
2877  5A2A 06A0         BL      @SP2VDP                 write 2 bytes in VDP at R8+2
2877  5A2C 5C02  
2878  5A2E 0002         DATA    2                       i.e. status + recs/sector
2879  5A30 06A0         BL      @SP2VDP                 write 4 bytes in VDP at new R8+4
2879  5A32 5C02  
2880  5A34 0004         DATA    4                       i.e. eof offset, rec len, # of recs (or # of
2881  5A36 0603         DEC     R3                      offset = # of sectors-1 (starts from 0)
2882  5A38 1103         JLT     H206                    create an empty file, FDR only
2883  5A3A 06A0         BL      @CALSUB                 
2883  5A3C 4344  
2884  5A3E 464C         DATA    APSCTS                  append enough sectors to reach offset
2885  5A40 0460 H206    B       @UWFLVB                 modify FDR, write it, load VIB, return
2885  5A42 5876  
2886            *
2887            *---------------------------------------
2888            * Subprogram FILES: number of files
2889            *---------------------------------------                                        
2890  5A44 C1CB ESUB08  MOV     R11,R7                  
2891  5A46 06A0         BL      @PRPFDO                 prepare disk operation
2891  5A48 4410  
2892  5A4A C229         MOV     @>002C(R9),R8           ptr to next basic token
2892  5A4C 002C  
2893  5A4E 0228         AI      R8,7                    skip FILES
2893  5A50 0007  
2894  5A52 06A0         BL      @VDPR2B                 get next two bytes in R0
2894  5A54 4862  
2895  5A56 0280         CI      R0,>C801                >C8=unquoted string, size=1 char
2895  5A58 C801  
2896  5A5A 161C         JNE     H207                    return (with error) if different
2897  5A5C 05C8         INCT    R8                      increment pointer
2898  5A5E 06A0         BL      @VDPR2B                 get next two bytes
2898  5A60 4862  
2899  5A62 06C0         SWPB    R0                      
2900  5A64 0220         AI      R0,>49D0                substact >B630: # of files >B6=closed parenthesis
2900  5A66 49D0  
2901  5A68 0280         CI      R0,>0009                only 9 files allowed in Basic !
2901  5A6A 0009  
2902  5A6C 1B13         JH      H207                    return with error if more
2903  5A6E 06C0         SWPB    R0                      
2904  5A70 DA40         MOVB    R0,@>004C(R9)           put new # of files in scratch-pad memory
2904  5A72 004C  
2905  5A74 06A0         BL      @CALSUB                 call subroutine
2905  5A76 4344  
2906  5A78 5A9E         DATA    PESB07                  subprogram >16 (private entry point)
2907  5A7A DA69         MOVB    @>0050(R9),@>0050(R9)   test result
2907  5A7C 0050  
2907  5A7E 0050  
2908  5A80 1609         JNE     H207                    error
2909  5A82 C229         MOV     @>002C(R9),R8           ok: get ptr to Basic token
2909  5A84 002C  
2910  5A86 0228         AI      R8,12                   skip the whole statement
2910  5A88 000C  
2911  5A8A CA48         MOV     R8,@>002C(R9)           update ptr
2911  5A8C 002C  
2912  5A8E 5A69         SZCB    @>0042(R9),@>0042(R9)   clear current token
2912  5A90 0042  
2912  5A92 0042  
2913  5A94 0460 H207    B       @RTURN1                 return to caller (i.e. Basic)
2913  5A96 4362  
2914            *
2915            *---------------------------------------
2916            * Subprogram >16: number of files
2917            * --------------
2918            * >834C: # of files
2919            * >8350: (n/a)      <--- error code
2920            *---------------------------------------                                        
2921            *
2922  5A98 C1CB ESUB07  MOV     R11,R7                  entry point from assembly
2923  5A9A 06A0         BL      @PRPFDO                 prepare disk operations
2923  5A9C 4410  
2924  5A9E 04C0 PESB07  CLR     R0                      entry point from call files
2925  5AA0 D029         MOVB    @>004C(R9),R0           get # of files
2925  5AA2 004C  
2926  5AA4 1359         JEQ     H214                    return with error
2927  5AA6 C229         MOV     @>0056(R9),R8           ptr to end of buffer word
2927  5AA8 0056  
2928  5AAA 0228         AI      R8,3                    point to # of files byte
2928  5AAC 0003  
2929  5AAE 04C3         CLR     R3                      
2930  5AB0 0429         BLWP    @>005A(R9)              set VDP to read
2930  5AB2 005A  
2931  5AB4 0102         DATA    >0102                   address in R8
2932  5AB6 D0EF         MOVB    @-1026(R15),R3          get current # of files
2932  5AB8 FBFE  
2933  5ABA 0205         LI      R5,518                  size of 1 file control block
2933  5ABC 0206  
2934  5ABE 90C0         CB      R0,R3                   compare required with current
2935  5AC0 1348         JEQ     H213                    same: return with no error
2936  5AC2 122B         JLE     H210                    less
2937  5AC4 C180         MOV     R0,R6                   more files needed
2938  5AC6 0280         CI      R0,>1000                maximum is 16
2938  5AC8 1000  
2939  5ACA 1B46         JH      H214                    return with error
2940  5ACC 6003         S       R3,R0                   how many to add
2941  5ACE 0980         SRL     R0,8                    make it a word
2942  5AD0 3805         MPY     R5,R0                   # of bytes to add
2943  5AD2 C101         MOV     R1,R4                   result in R0:R1
2944  5AD4 0504         NEG     R4                      
2945  5AD6 C0A9         MOV     @>0070(R9),R2           highest free address in VDP mem
2945  5AD8 0070  
2946  5ADA C002         MOV     R2,R0                   
2947  5ADC 6001         S       R1,R0                   what it would become
2948  5ADE 0280         CI      R0,>0800                is there room enough for VDP?
2948  5AE0 0800  
2949  5AE2 113A         JLT     H214                    no: return with error
2950  5AE4 C040         MOV     R0,R1                   ok: new base
2951  5AE6 0582 H208    INC     R2                      increment source ptr
2952  5AE8 0580         INC     R0                      increment destination ptr
2953  5AEA 0429         BLWP    @>005A(R9)              set VDP to read
2953  5AEC 005A  
2954  5AEE 0042         DATA    >0042                   address in R2
2955  5AF0 D0EF         MOVB    @-1026(R15),R3          get a byte
2955  5AF2 FBFE  
2956  5AF4 0429         BLWP    @>005A(R9)              set VDP to write
2956  5AF6 005A  
2957  5AF8 0003         DATA    >0003                   address in R0
2958  5AFA DBC3         MOVB    R3,@-2(R15)             copy a byte
2958  5AFC FFFE  
2959  5AFE 8202         C       R2,R8                   did we copy the whole header?
2960  5B00 16F2         JNE     H208                    not yet
2961  5B02 0429         BLWP    @>005A(R9)              set VDP to write
2961  5B04 005A  
2962  5B06 0003         DATA    >0003                   address in R0
2963  5B08 DBC6         MOVB    R6,@-2(R15)             new # of files
2963  5B0A FFFE  
2964  5B0C 04C6         CLR     R6                      
2965  5B0E 6080         S       R0,R2                   
2966  5B10 DBC6 H209    MOVB    R6,@-2(R15)             clear byte
2966  5B12 FFFE  
2967  5B14 0602         DEC     R2                      
2968  5B16 16FC         JNE     H209                    
2969  5B18 101A         JMP     H212                    
2970            *                                       
2971  5B1A 0429 H210    BLWP    @>005A(R9)              less files needed
2971  5B1C 005A  
2972  5B1E 0103         DATA    >0103                   set VDP to write to address in R8
2973  5B20 DBC0         MOVB    R0,@-2(R15)             new # of files in buffer header
2973  5B22 FFFE  
2974  5B24 60C0         S       R0,R3                   how many to remove
2975  5B26 0983         SRL     R3,8                    make it a word
2976  5B28 38C5         MPY     R5,R3                   # of bytes to remove
2977  5B2A C044         MOV     R4,R1                   result in R3:R4
2978  5B2C A048         A       R8,R1                   new address for buffer header
2979  5B2E C0A9         MOV     @>0070(R9),R2           highest free address in VDP mem
2979  5B30 0070  
2980  5B32 0429 H211    BLWP    @>005A(R9)              set VDP to read
2980  5B34 005A  
2981  5B36 0102         DATA    >0102                   address in R8
2982  5B38 D02F         MOVB    @-1026(R15),R0          read a byte
2982  5B3A FBFE  
2983  5B3C 0429         BLWP    @>005A(R9)              set VDP to write
2983  5B3E 005A  
2984  5B40 0023         DATA    >0023                   address in R1
2985  5B42 DBC0         MOVB    R0,@-2(R15)             write byte back
2985  5B44 FFFE  
2986  5B46 0601         DEC     R1                      decrement destination ptr
2987  5B48 0608         DEC     R8                      decrement source ptr
2988  5B4A 8088         C       R8,R2                   did we copy the whole header?
2989  5B4C 16F2         JNE     H211                    not yet
2990            *                                       
2991  5B4E CA41 H212    MOV     R1,@>0070(R9)           new first free address                                  
2991  5B50 0070  
2992  5B52 04E9 H213    CLR     @>0050(R9)              clear error flag
2992  5B54 0050  
2993  5B56 1002         JMP     H215                    
2994  5B58 0729 H214    SETO    @>0050(R9)              set error flag
2994  5B5A 0050  
2995  5B5C 0460 H215    B       @RTURN1                 return to caller
2995  5B5E 4362  
2996            *                                       
2997  5B60 04E9 UFNCB   CLR     @>0054(R9)              write drive # and filename in compare buffer
2997  5B62 0054  
2998  5B64 C069         MOV     @>0058(R9),R1           
2998  5B66 0058  
2999  5B68 0221         AI      R1,256                  ptr to filename compare buffer
2999  5B6A 0100  
3000  5B6C 0429         BLWP    @>005A(R9)              set VDP to write
3000  5B6E 005A  
3001  5B70 0023         DATA    >0023                   address in R1
3002  5B72 DBC6         MOVB    R6,@-2(R15)             write drive #
3002  5B74 FFFE  
3003  5B76 0202 CFNFDR  LI      R2,10                   filename must be exactly 10 chars
3003  5B78 000A  
3004  5B7A 0581 H216    INC     R1                      next char in compare buffer
3005  5B7C 0429         BLWP    @>005A(R9)              set VDP to read
3005  5B7E 005A  
3006  5B80 0002         DATA    >0002                   address in R0
3007  5B82 D0EF         MOVB    @-1026(R15),R3          get 1 char from filename
3007  5B84 FBFE  
3008  5B86 0580         INC     R0                      next char in provided filename
3009  5B88 0429         BLWP    @>005A(R9)              set VDP to write
3009  5B8A 005A  
3010  5B8C 0023         DATA    >0023                   address in R1
3011  5B8E DBC3         MOVB    R3,@-2(R15)             write 1 char to compare buffer
3011  5B90 FFFE  
3012  5B92 0602         DEC     R2                      
3013  5B94 16F2         JNE     H216                    next char
3014  5B96 045B         B       *R11                    
3015            *                                       
3016  5B98 C28B RFNPTR  MOV     R11,R10                 load compare buffer and ptrs
3017  5B9A 04C6         CLR     R6                      
3018  5B9C D1A9         MOVB    @>004C(R9),R6           drive #
3018  5B9E 004C  
3019  5BA0 C029         MOV     @>004E(R9),R0           ptr to filename
3019  5BA2 004E  
3020  5BA4 06A0         BL      @UFNCB                  write them in compare buffer
3020  5BA6 5B60  
3021  5BA8 D129         MOVB    @>0050(R9),R4           file info structure ptr
3021  5BAA 0050  
3022  5BAC 0984         SRL     R4,8                    
3023  5BAE A109         A       R9,R4                   make it a PAB address
3024  5BB0 D029         MOVB    @>004D(R9),R0           # of sectors (>00=get file info)
3024  5BB2 004D  
3025  5BB4 0429         BLWP    @>005A(R9)                      
3025  5BB6 005A  
3026  5BB8 0800         DATA    >0800                   save R4
3027  5BBA 0980         SRL     R0,8                    
3028  5BBC 045A         B       *R10                    EQ set for get file info
3029            *                                       
3030  5BBE 0429 FFFDR   BLWP    @>005A(R9)              find file FDR
3030  5BC0 005A  
3031  5BC2 8010         DATA    >8010                   save R0 + R11
3032  5BC4 06A0         BL      @CALSUB                 call subroutine
3032  5BC6 4344  
3033  5BC8 4AB0         DATA    FFDRVB                  find file FDR in VDP buffers
3034  5BCA 06A0         BL      @CALSUB                 call subroutine
3034  5BCC 4344  
3035  5BCE 4AF4         DATA    FFDROD                  find FDR on disk
3036  5BD0 C104         MOV     R4,R4                   found ?
3037  5BD2 1303         JEQ     H217                    yes
3038  5BD4 06A0         BL      @ERROR5                 no: return with error
3038  5BD6 495E  
3039  5BD8 E000         DATA    >E000                   file error
3040  5BDA 06A0 H217    BL      @FDR2B1                 get two bytes from FDR into R0
3040  5BDC 485C  
3041  5BDE 000E         DATA    14                      # of sectors in file
3042  5BE0 0429         BLWP    @>005A(R9)                      
3042  5BE2 005A  
3043  5BE4 2011         DATA    >2011                   retrieve R0 in R2 (# of sect to read), and R11
3044  5BE6 0429         BLWP    @>005A(R9)                      
3044  5BE8 005A  
3045  5BEA 0801         DATA    >0801                   retrieve R4 (ptr to file info structure)
3046  5BEC C1F4         MOV     *R4+,R7                 VDP buffer
3047  5BEE C0D4         MOV     *R4,R3                  first sector
3048  5BF0 045B         B       *R11                    
3049            *                                       
3050  5BF2 0429 VDP2SP  BLWP    @>005A(R9)              copy VDP bytes to scratch-pad
3050  5BF4 005A  
3051  5BF6 0102         DATA    >0102                   read from VDP at R8
3052  5BF8 DD2F H218    MOVB    @-1026(R15),*R4+        read bytes into scratch-pad at R4
3052  5BFA FBFE  
3053  5BFC 0602         DEC     R2                      # of byte in R2
3054  5BFE 16FC         JNE     H218                    next byte
3055  5C00 045B         B       *R11                    
3056            *                                       
3057  5C02 C0BB SP2VDP  MOV     *R11+,R2                copy scratch-pad bytes to VDP
3058  5C04 A202         A       R2,R8                   
3059  5C06 0429         BLWP    @>005A(R9)              set VDP to write
3059  5C08 005A  
3060  5C0A 0103         DATA    >0103                   address in R8 + offset in data word
3061  5C0C DBF4 H219    MOVB    *R4+,@-2(R15)           write byte from scratch-pad at R4
3061  5C0E FFFE  
3062  5C10 0602         DEC     R2                      # of bytes in R2, was in data word
3063  5C12 16FC         JNE     H219                    next byte
3064  5C14 045B         B       *R11    
3065            *
3066            * APEDSK99 CALL subprograms
3067            *
3068            * parameter is single digit -> 0x00
3069  5C16 0206 PDSK    LI      R6,>0100                Protect ACOMND 
3069  5C18 0100  
3070  5C1A 102F         JMP     ACLPRP                  generic prep
3071  5C1C 0206 UDSK    LI      R6,>0200                Unprotect ACOMND 
3071  5C1E 0200  
3072  5C20 102C         JMP     ACLPRP                  generic prep
3073  5C22 0206 LDSK    LI      R6,>0300                List Files on DSKx ACOMND 
3073  5C24 0300  
3074  5C26 1029         JMP     ACLPRP                  generic prep
3075            * parameters are single digit + character string -> 1x00; ! >1300 IS RESERVED (BL NTPDT+1) ! 
3076  5C28 0206 MDSK    LI      R6,>1000                Change DSK ACOMND
3076  5C2A 1000  
3077  5C2C 1026         JMP     ACLPRP                  generic prep
3078  5C2E 0206 NDSK    LI      R6,>1100                create new blank SS/SD DOAD image
3078  5C30 1100  
3079  5C32 1023         JMP     ACLPRP
3080            * parameter is a charachter string -> 2x00
3081  5C34 0206 RDSK    LI      R6,>2000                Remove DOAD from SD card ACOMND 
3081  5C36 2000  
3082  5C38 1020         JMP     ACLPRP                  generic prep
3083  5C3A 0206 FGET    LI      R6,>2100                get DOAD from FTP server ACOMND
3083  5C3C 2100  
3084  5C3E 101D         JMP     ACLPRP                  generic prep
3085  5C40 0206 FPUT    LI      R6,>2200                save DOAD to FTP server ACOMND 
3085  5C42 2200  
3086  5C44 101A         JMP     ACLPRP                  generic prep
3087  5C46 0206 ADSR    LI      R6,>2300                load DSR and reset ACOMND
3087  5C48 2300  
3088  5C4A 1017         JMP     ACLPRP                  generic prep
3089  5C4C 0206 CDIR    LI      R6,>2400                change root folder
3089  5C4E 2400  
3090  5C50 1014         JMP     ACLPRP                  generic prep
3091            * no parameters ->3x00
3092  5C52 0206 SMAP    LI      R6,>3000                Show DSKx mapping ACOMND
3092  5C54 3000  
3093  5C56 1011         JMP     ACLPRP                  generic prep
3094  5C58 0206 LDIR    LI      R6,>3100                List SD dir ACOMND
3094  5C5A 3100  
3095  5C5C 100E         JMP     ACLPRP                  generic prep
3096  5C5E 0206 AHLP    LI      R6,>3200                display APEDSK99 CALL()'s help screen
3096  5C60 3200  
3097  5C62 100B         JMP     ACLPRP                  generic prep
3098  5C64 0206 ACHR    LI      R6,>3300                load proper lowercase character set
3098  5C66 3300  
3099  5C68 1008         JMP     ACLPRP                  generic prep
3100  5C6A 0206 ARST    LI      R6,>3468                APEDSK99 reset ACOMND
3100  5C6C 3468  
3101  5C6E 1005         JMP     ACLPRP                  generic prep
3102  5C70 0206 TIME    LI      R6,>3500                show NTP time and date
3102  5C72 3500  
3103  5C74 1002         JMP     ACLPRP                  generic prep
3104  5C76 0206 ACFG    LI      R6,>3600                APEDSK99 configuration
3104  5C78 3600  
3105            *
3106            * Generic prep and return to TI BASIC for APEDSK99 CALL's
3107            *
3108  5C7A 04E0 ACLPRP  CLR     @XEMRET                 return to BASIC command prompt, not running BASIC program
3108  5C7C 404A  
3109  5C7E 06C6         SWPB    R6                      get optional subcommand in MSB
3110  5C80 D806         MOVB    R6,@ASUBCM              save
3110  5C82 5FE9  
3111  5C84 06C6         SWPB    R6                      back to primary command
3112            *
3113  5C86 C1CB         MOV     R11,R7                  save return-to-TI BASIC address
3114  5C88 06A0         BL      @PRPFDO                 prepare TI Controller DSR operations
3114  5C8A 4410  
3115            *
3116  5C8C C229         MOV     @>002C(R9),R8           ptr to next basic token
3116  5C8E 002C  
3117  5C90 0228         AI      R8,4                    skip length byte and 3 chars of CALL name
3117  5C92 0004  
3118  5C94 06A0         BL      @VDPR2B                 get CALL last char and "(" or "0" in R0
3118  5C96 4862  
3119  5C98 0A80         SLA     R0,8                    only interested in LSB
3120  5C9A 130E         JEQ     NOPARM                  0 = no parameters? SMAP / LDIR / AHLP / ACHR / ARST / TIME / ACFG (and special guest LDSK)
3121            *
3122  5C9C 0228         AI      R8,2                    adjust token pointer
3122  5C9E 0002  
3123  5CA0 06A0         BL      @VDPR2B                 get next two bytes in R0
3123  5CA2 4862  
3124  5CA4 0280         CI      R0,>C801                >C8=unquoted string, size=1 char?
3124  5CA6 C801  
3125  5CA8 1331         JEQ     USTRNG                  yes: PDSK / UDSK / LDSK / MDSK / NDSK
3126            *
3127  5CAA 0280         CI      R0,>C701                >C7=quoted string, minimum 1 character?
3127  5CAC C701  
3128  5CAE 1A02         JL      ACLERR
3129  5CB0 0460         B       @QSTRNG                 yes: RDSK / FGET / FPUT / ADSR / CDIR
3129  5CB2 5DA8  
3130            *
3131  5CB4 0460 ACLERR  B       @RTURN1                 expect the unexpected                           
3131  5CB6 4362  
3132            *
3133            * SMAP / LDIR / AHLP / ACHR / ARST / TIME / ACFG (and special guest LDSK)
3134            *
3135  5CB8 0286 NOPARM  CI      R6,>0300                LDSK without parameters is handy (re-use last used DSK#)
3135  5CBA 0300  
3136  5CBC 1303         JEQ     NOPRM2
3137  5CBE 0286         CI      R6,>3000                catch other CALL's without parameters -> error
3137  5CC0 3000  
3138  5CC2 1AF8         JL      ACLERR
3139            *
3140  5CC4 D820 NOPRM2  MOVB    @LSTDRV,@CALLBF         get last drive accessed (LDSK without parameters)
3140  5CC6 5FC7  
3140  5CC8 5FC8  
3141  5CCA D806         MOVB    R6,@ACOMND              execute LDSK / ACHR / ARST / TIME / ACFG
3141  5CCC 5FE8  
3142  5CCE 0286         CI      R6,>3300                ACHR / ARST / TIME / ACFG?      
3142  5CD0 3300  
3143  5CD2 1A3C         JL      LDSK2                   no; SMAP / LDIR / AHLP use LDSK display routine
3144            *
3145  5CD4 0208 QNOPRM  LI      R8,9                    current CALL length
3145  5CD6 0009  
3146  5CD8 0286         CI      R6,>3300                ACHR?
3146  5CDA 3300  
3147  5CDC 1306         JEQ     ACHR2                   yes; get some real characters
3148  5CDE 0286         CI      R6,>0300                LDSK()?
3148  5CE0 0300  
3149  5CE2 1602         JNE     A9901                   nope; exit with CALL lenght 9 for SMAP / LDIR / AHLP / ARST / TIME / ACFG
3150  5CE4 0228         AI      R8,3                    yep;  exit with CALL length 12 for LDSK
3150  5CE6 0003  
3151            *
3152  5CE8 1030 A9901   JMP     A9904
3153            *
3154  5CEA 9820 ACHR2   CB      @INT2FP+2,@CALLST
3154  5CEC 57D2  
3154  5CEE 5FC6  
3155  5CF0 132C         JEQ     A9904                   >08; no char definition file found
3156            *
3157  5CF2 C0A0         MOV     @PATTBL,R2              get start of <SPACE> pattern table entry (default >0400 for TI BASIC)
3157  5CF4 4044  
3158  5CF6 06A0         BL      @VDPWRI                 set VPD address
3158  5CF8 4322  
3159            *                       
3160  5CFA 06A0 A9902   BL      @DISSTS                 use existing display routine to write 4 definitions at a time
3160  5CFC 5E5A  
3161  5CFE 9820         CB      @K004,@CALLST           check Arduino ACHR return code
3161  5D00 4340  
3161  5D02 5FC6  
3162  5D04 1322         JEQ     A9904                   we're done
3163  5D06 05A0         INC     @RDINT                  generates interrupt for next lot
3163  5D08 5FEA  
3164  5D0A 10F7         JMP     A9902                   again
3165            *
3166            * PDSK / UDSK / LDSK / MDSK / NDSK
3167            *
3168  5D0C 0286 USTRNG  CI      R6,>2000                only PDSK / UDSK / LDSK / MDSK / NDSK?
3168  5D0E 2000  
3169  5D10 14D1         JHE     ACLERR                  no -> sneaky other commands don't belong here
3170  5D12 05C8         INCT    R8                      increment pointer
3171  5D14 06A0         BL      @VDPR2B                 get next two bytes              
3171  5D16 4862  
3172            *
3173  5D18 06C0         SWPB    R0
3174  5D1A 0220         AI      R0,>49D0                add 2's complement of >B630: MSB = >B3 / "," or >B6 / ")", LSB= # of files 
3174  5D1C 49D0  
3175  5D1E 1502         JGT     A9903                   >B6
3176  5D20 0220         AI      R0,768                  >B3, adjust R0 to positive range
3176  5D22 0300  
3177            *
3178  5D24 13C7 A9903   JEQ     ACLERR                  DSK0 not valid, * INCORRECT COMMAND
3179  5D26 0280         CI      R0,3                    only 3 DSK's allowed
3179  5D28 0003  
3180  5D2A 1BC4         JH      ACLERR                  DSK4+, * INCORRECT COMMAND
3181            *
3182  5D2C 06C0         SWPB    R0
3183  5D2E D800         MOVB    R0,@CALLBF              save DSKx
3183  5D30 5FC8  
3184  5D32 D800         MOVB    R0,@LSTDRV              remember last drive accessed for LDSK without parameter
3184  5D34 5FC7  
3185            *
3186  5D36 0286         CI      R6,>1000                MDSK or NDSK?
3186  5D38 1000  
3187  5D3A 1433         JHE     MNDSK2                  yep
3188            *
3189  5D3C D806 XEMUST  MOVB    R6,@ACOMND              send PDSK / UDSK / LDSK command to Arduino
3189  5D3E 5FE8  
3190            
3191  5D40 0286         CI      R6,>0300                LDSK?
3191  5D42 0300  
3192  5D44 1303         JEQ     LDSK2                   yep
3193            *
3194  5D46 0208 PUDSK2  LI      R8,12                   CALL length
3194  5D48 000C  
3195  5D4A 1054 A9904   JMP     ACLBAS                  return to BASIC         
3196            *                       
3197  5D4C 9820 LDSK2   CB      @K002,@CALLST
3197  5D4E 433E  
3197  5D50 5FC6  
3198  5D52 13C0         JEQ     QNOPRM                  LDSK: >00; no DOAD mapped
3199            *
3200  5D54 04C2 NXTSCR  CLR     R2                      clear screen; position 0
3201  5D56 06A0         BL      @VDPWRI
3201  5D58 4322  
3202            *
3203  5D5A 0200         LI      R0,>8000                space + TI BASIC bias
3203  5D5C 8000  
3204  5D5E 06A0         BL      @VDPRPW
3204  5D60 426A  
3205  5D62 02C0         DATA    704                     704 positions to clear
3206            *
3207  5D64 0202         LI      R2,32                   start 2nd screen line; 1st is lost due to BASIC scroll
3207  5D66 0020  
3208  5D68 06A0 A9905   BL      @VDPWRI                 
3208  5D6A 4322  
3209            *       
3210  5D6C 9820         CB      @K004,@CALLST           check Arduino LDSK / SDSK / LDIR / AHLP return code
3210  5D6E 4340  
3210  5D70 5FC6  
3211  5D72 13B0         JEQ     QNOPRM                  "More" (>F0); blank DSK or done last file / help txt
3212            *
3213  5D74 06A0         BL      @DISSTS                 LDSK / SDSK / LDIR / AHLP output to screen
3213  5D76 5E5A  
3214            *
3215  5D78 0222         AI      R2,32                   next screen position
3215  5D7A 0020  
3216  5D7C 0282         CI      R2,640                  end of display area?
3216  5D7E 0280  
3217  5D80 1303         JEQ     NXTPRP                  yes; show "more" symbol
3218            *
3219  5D82 05A0         INC     @RDINT                  generates interrupt for next file / help txt
3219  5D84 5FEA  
3220  5D86 10F0         JMP     A9905   
3221            *       
3222  5D88 0202 NXTPRP  LI      R2,702
3222  5D8A 02BE  
3223  5D8C 06A0         BL      @VDPWRI
3223  5D8E 4322  
3224  5D90 0205         LI      R5,>9E00                show ">", more file / help txt to display
3224  5D92 9E00  
3225  5D94 DBC5         MOVB    R5,@-2(R15)
3225  5D96 FFFE  
3226            *
3227  5D98 06A0         BL      @CHKKEY
3227  5D9A 5E6C  
3228            *
3229  5D9C 05A0         INC     @RDINT                  generates interrupt for next file / help txt
3229  5D9E 5FEA  
3230  5DA0 10D9         JMP     NXTSCR
3231            *
3232            * MDSK / NDSK / RDSK / FGET / FPUT / ADSR / CDIR
3233            *
3234  5DA2 05C8 MNDSK2  INCT    R8                      increment pointer
3235  5DA4 06A0         BL      @VDPR2B                 get next two digits
3235  5DA6 4862  
3236            *
3237  5DA8 0286 QSTRNG  CI      R6,>1000                further check on RDSK / FGET / FPUT / ADSR / CDIR
3237  5DAA 1000  
3238  5DAC 1A18         JL      A9907                   no -> sneaky PDSK / UDSK don't belong here      
3239  5DAE 0220         AI      R0,>3900                add 2's complement of >C700 =  only keep # of characters
3239  5DB0 3900  
3240  5DB2 1315         JEQ     A9907                   0 characters / empty string -> * INCORRECT COMMAND
3241  5DB4 0280         CI      R0,8                    max 8 characters?
3241  5DB6 0008  
3242  5DB8 1B12         JH      A9907                   no -> * INCORRECT COMMAND
3243            *
3244  5DBA C100         MOV     R0,R4                   save #characters
3245  5DBC 0205         LI      R5,CALLBF+2             buffer pointer to DOAD / DSR name       
3245  5DBE 5FCA  
3246  5DC0 05C8         INCT    R8                      increment pointer
3247  5DC2 C088         MOV     R8,R2                   for VDPRD, address must be in R2
3248  5DC4 06A0         BL      @VDPRD                  set VDP READ address
3248  5DC6 432C  
3249  5DC8 DD6F A9906   MOVB    @-1026(R15),*R5+        get character and save in CALL buffer
3249  5DCA FBFE  
3250  5DCC 0600         DEC     R0                      one less to go
3251  5DCE 16FC         JNE     A9906   
3252  5DD0 D560         MOVB    @K002,*R5               mark end of string with >00 (Arduino check for end of string)
3252  5DD2 433E  
3253            *
3254  5DD4 D02F         MOVB    @-1026(R15),R0          get next token
3254  5DD6 FBFE  
3255  5DD8 0280         CI      R0,>B600                is it a ")" ?
3255  5DDA B600  
3256  5DDC 1302         JEQ     A9908
3257  5DDE 0460 A9907   B       @ACLERR                 * INCORRECT COMMAND
3257  5DE0 5CB4  
3258            *
3259  5DE2 0208 A9908   LI      R8,13                   prep RDSK / FGET / FPUT / ADSR / CDIR CALL length ( CALL_XXXX("") )
3259  5DE4 000D  
3260  5DE6 A204         A       R4,R8                   add # of characters in string
3261                    
3262  5DE8 0286         CI      R6,>1100                MDSK or NDSK?
3262  5DEA 1100  
3263  5DEC 1B01         JH      A9909                   no; jump and execute RDSK / FGET / FPUT / ADSR / CDIR
3264  5DEE 05C8         INCT    R8                      adjust MDSK and NDSK CALL length
3265            *
3266  5DF0 D806 A9909   MOVB    R6,@ACOMND              command to Arduino
3266  5DF2 5FE8  
3267            *
3268  5DF4 9820 ACLBAS  CB      @CALLST,@K004           "More" or "AllGood" received from Arduino?      
3268  5DF6 5FC6  
3268  5DF8 4340  
3269  5DFA 1419         JHE     A9910                   yep
3270            *       
3271  5DFC 0205         LI      R5,GPLINT               no; GPL routine
3271  5DFE 006A  
3272  5E00 06A0         BL      @GPLXML                 
3272  5E02 5EFA  
3273  5E04 56CD         DATA    SCROLL                  scroll screen
3274  5E06 0202         LI      R2,736                  screen starting position for (error) message
3274  5E08 02E0  
3275  5E0A 06A0         BL      @VDPWRI                 set VDP address
3275  5E0C 4322  
3276  5E0E 06A0         BL      @DISSTS                 show (error) message
3276  5E10 5E5A  
3277  5E12 0205         LI      R5,GPLINT               GPL routine
3277  5E14 006A  
3278  5E16 06A0         BL      @GPLXML 
3278  5E18 5EFA  
3279  5E1A 56CD         DATA    SCROLL                  scroll screen
3280            *
3281  5E1C 9820         CB      @CALLST,@K007           error (status code 0 - 9)?
3281  5E1E 5FC6  
3281  5E20 433F  
3282  5E22 1405         JHE     A9910                   no, informational; be silent    
3283            *
3284  5E24 0205         LI      R5,GPLINT               yes: let's make some noise
3284  5E26 006A  
3285  5E28 06A0         BL      @GPLXML
3285  5E2A 5EFA  
3286  5E2C 0036         DATA    HONK                    GPL routine"bad tone"
3287            *
3288  5E2E 0286 A9910   CI      R6,>3500                TIME() ?
3288  5E30 3500  
3289  5E32 1331         JEQ     TIME2                   yes; see if we can assign date/time to NTP$
3290            *
3291  5E34 04C6 A9911   CLR     R6
3292  5E36 D1A0         MOVB    @ASUBCM,R6              any subcommand to execute?
3292  5E38 5FE9  
3293  5E3A 1302         JEQ     A9912                   no
3294  5E3C D806         MOVB    R6,@ACOMND              yes; execute (currently only ARST)
3294  5E3E 5FE8  
3295            *
3296  5E40 C2E0 A9912   MOV     @XEMRET,R11             APEDSK99: CALL LINK?
3296  5E42 404A  
3297  5E44 1301         JEQ     A9913                   nope
3298  5E46 045B         B       *R11                    yes; return to BASIC program
3299            *
3300  5E48 04E9 A9913   CLR     @>0050(R9)              clear error flag                
3300  5E4A 0050  
3301  5E4C AA48         A       R8, @>002C(R9)          add call length to token pointer                
3301  5E4E 002C  
3302  5E50 5A69         SZCB    @>0042(R9),@>0042(R9)   clear current token
3302  5E52 0042  
3302  5E54 0042  
3303  5E56 0460         B       @RTURN1                 return to caller (i.e. TI-BASIC)
3303  5E58 4362  
3304            *       
3305            * Display data, status messages and errors
3306            *
3307  5E5A 0205 DISSTS  LI      R5,CALLBF               start of file name buffer
3307  5E5C 5FC8  
3308  5E5E 0206         LI      R6,32                   32 bytes / 1 screen row of data to display
3308  5E60 0020  
3309  5E62 DBF5 A9914   MOVB    *R5+,@-2(R15)           store character in VDP screen memory
3309  5E64 FFFE  
3310  5E66 0606         DEC     R6
3311  5E68 16FC         JNE     A9914
3312  5E6A 045B         B       *R11
3313            *
3314            * Quick key test to display next screen after ">"
3315            * Keyboard column 0 (= space enter <nc> fctn shift ctrl <nc>)
3316            * Code copy from Thierry's TI's Tech Pages site
3317            *
3318  5E6C C10C CHKKEY  MOV     R12,R4                  save R12
3319  5E6E 04C1         CLR     R1                      test column 0
3320  5E70 020C         LI      R12,>0024               address for column selection
3320  5E72 0024  
3321  5E74 30C1 A9915   LDCR    R1,3                    select column
3322  5E76 1FF2         TB      -14                     test R12 address >0008
3323  5E78 1607         JNE     A9916                   <SPACE>
3324  5E7A 1FF3         TB      -13                     test R12 address >000A
3325  5E7C 13FB         JEQ     A9915                   no key; test again
3326            *
3327  5E7E D820         MOVB    @K004,@CALLST           signal ENTER to LDIR() command
3327  5E80 4340  
3327  5E82 5FC6  
3328  5E84 020B         LI      R11,QNOPRM              leave without clearing screen
3328  5E86 5CD4  
3329            *
3330  5E88 C304 A9916   MOV     R4,R12                  restore R12
3331  5E8A 0A24         SLA     R4,2                    debounce delay
3332  5E8C 0604 A9917   DEC     R4                      key debounce
3333  5E8E 16FE         JNE     A9917                   debounce some more
3334            *
3335  5E90 045B         B       *R11                    we got one; return for next screen
3336            *
3337            * prep for calling XML >16 and update BASIC variable NTP$               
3338            *
3339  5E92 4E54 VARINF  TEXT    'NTP$'
3339  5E94 5024  
3340  5E96 0204 TIME2   LI      R4,VARINF               variable name for XML >16 in FAC
3340  5E98 5E92  
3341  5E9A C149         MOV     R9,R5                   get scratchpad start address
3342  5E9C D974 A9918   MOVB    *R4+,@>004A(R5)         variable name in FAC
3342  5E9E 004A  
3343  5EA0 0585         INC     R5
3344  5EA2 0284         CI      R4,VARINF+4             done all chars?
3344  5EA4 5E96  
3345  5EA6 16FA         JNE     A9918                   
3346            *
3347  5EA8 0205         LI      R5,>0400                variable length for XML >16 in @>8359
3347  5EAA 0400  
3348  5EAC DA45         MOVB    R5,@>0059(R9)           
3348  5EAE 0059  
3349            *
3350  5EB0 0205         LI      R5,XML16                ROM routine: find NTP$ in VDP symbol table (returns to GPL interpreter)
3350  5EB2 15D6  
3351  5EB4 06A0         BL      @GPLXML
3351  5EB6 5EFA  
3352  5EB8 2244         DATA    XMLRTN                  GPL "RTN", escaping GPL interpreter
3353            *
3354  5EBA 9A60         CB      @VARINF,@>004A(R9)      found NTP$ in VDP symbol table?
3354  5EBC 5E92  
3354  5EBE 004A  
3355  5EC0 1318         JEQ     A9920                   no symbol table pointer; back to BASIC
3356            *
3357  5EC2 06A0         BL      @XML14                  ROM routine: get NTP$ VDP address and string length (returns through RT)
3357  5EC4 164E  
3358  5EC6 02A9         STWP    R9                      restore scratchpad pointer
3359  5EC8 0229         AI      R9,-224
3359  5ECA FF20  
3360            *       
3361  5ECC C169         MOV     @>0050(R9),R5           get string length
3361  5ECE 0050  
3362  5ED0 0285         CI      R5,16                   16 chars?
3362  5ED2 0010  
3363  5ED4 160E         JNE     A9920                   no NTP$ assignment for you
3364            *
3365  5ED6 C0A0         MOV     @>834E,R2               yes
3365  5ED8 834E  
3366  5EDA 06A0         BL      @VDPWRI                 set VDP write address
3366  5EDC 4322  
3367  5EDE 0205         LI      R5,CALLBF               CALL TIME data still in buffer
3367  5EE0 5FC8  
3368  5EE2 D0B5 A9919   MOVB    *R5+,R2                 read character
3369  5EE4 0222         AI      R2,>A000                remove TI BASIC bias
3369  5EE6 A000  
3370  5EE8 DBC2         MOVB    R2,@-2(R15)             save to NTP$ value space
3370  5EEA FFFE  
3371  5EEC 0285         CI      R5,CALLBF+16            done all 16 chars?
3371  5EEE 5FD8  
3372  5EF0 16F8         JNE     A9919                   no; one more
3373            *
3374  5EF2 10A0 A9920   JMP     A9911                   yes; back to BASIC
3375            *
3376            * execute GROM or XML routine (SCROLL, "bad sound" / HONK and XML >16)
3377            * DSR and GPL interpreter use same workspace (>83E0) so we need to save a few things
3378            *
3379  5EF4 0000 SAVGRA  BSS     2                       save current GROM address so we can return to BASIC
3380  5EF6 0000 SAVR11  BSS     2                       GPL interpreter uses R11
3381  5EF8 0000 SAVMEX  BSS     2                       save current >A018 value
3382            *
3383  5EFA D820 GPLXML  MOVB    @>9802,@SAVGRA          save current GROM address
3383  5EFC 9802  
3383  5EFE 5EF4  
3384  5F00 1000         NOP
3385  5F02 D820         MOVB    @>9802,@SAVGRA+1
3385  5F04 9802  
3385  5F06 5EF5  
3386  5F08 0620         DEC     @SAVGRA                 GRMWA returns address + 1; decrease for correct address
3386  5F0A 5EF4  
3387            *
3388  5F0C D83B         MOVB    *R11+,@>9C02            set GPL routine address
3388  5F0E 9C02  
3389  5F10 1000         NOP
3390  5F12 D83B         MOVB    *R11+,@>9C02
3390  5F14 9C02  
3391  5F16 C80B         MOV     R11,@SAVR11             save final DSR return address
3391  5F18 5EF6  
3392            *
3393  5F1A C820         MOV     @RTNBC,@SAVMEX          save >A018
3393  5F1C A018  
3393  5F1E 5EF8  
3394  5F20 020B         LI      R11,GXRTN               DSR return address after GPL routine
3394  5F22 5F3C  
3395  5F24 C80B         MOV     R11,@RTNBC              @>A018 is where XML >BC returns to
3395  5F26 A018  
3396            *
3397  5F28 05E0         INCT    @>8373                  increase stack pointer
3397  5F2A 8373  
3398  5F2C 06C9         SWPB    R9                      
3399  5F2E D260         MOVB    @>8373,R9
3399  5F30 8373  
3400  5F32 06C9         SWPB    R9                      complete stack pointer in R9
3401  5F34 020B         LI      R11,XMLBC               GROM pointer to >0FBC (= XML >BC)
3401  5F36 4409  
3402  5F38 C64B         MOV     R11,*R9                 save GROM pointer on stack
3403            *
3404  5F3A 0455         B       *R5                     execute GROM/ROM routine, return through GPL interpreter
3405            *
3406  5F3C D820 GXRTN   MOVB    @SAVGRA,@>9C02          and ... we're back; restore saved GROM address
3406  5F3E 5EF4  
3406  5F40 9C02  
3407  5F42 1000         NOP
3408  5F44 D820         MOVB    @SAVGRA+1,@>9C02
3408  5F46 5EF5  
3408  5F48 9C02  
3409            *
3410  5F4A C820         MOV     @SAVMEX,@RTNBC          restore original >A018 value
3410  5F4C 5EF8  
3410  5F4E A018  
3411            *
3412  5F50 02A9         STWP    R9                      restore scratchpad pointer
3413  5F52 0229         AI      R9,-224
3413  5F54 FF20  
3414            *
3415  5F56 C2E0         MOV     @SAVR11,R11             restore R11
3415  5F58 5EF6  
3416  5F5A 045B         B       *R11                    return to instruction after BL @GPLEXEC DATA statement
3417            *               
3418            * update FAT time/date for current DOAD after DSR Write / Format / Save
3419            *
3420  5F5C D820 NTPDT   MOVB    @NTPFAT+1,@ACOMND       "DSK NTP date/time update" command to Arduino           
3420  5F5E 4027  
3420  5F60 5FE8  
3421  5F62 045B         B       *R11                    return to Format / Close
3422            *
3423            *----------------------------------------------------------------------------------
3424            * >5F64 - >5FB3: 50 free bytes remaining
3425            * >5FC2 - >5FD3 is DSK1-3 parameters storage
3426            * >5FD4 is the CALL() status byte
3427            * >5FD6 - >5FE7 is buffer storage for APEDSK99 CALL's
3428            * >5FE8 is the Arduino Command Register (TI BASIC CALL support)
3429            * Word >5FEA maps to the read counter (R6, to generate interrupts when reading data) 
3430            * Bytes >5FEE maps to the CRU emulation write register
3431            * Bytes >5FF0 to >5FFE map to the FDC emulation registers
3432            *-----------------------------------------------------------------------------------                                    
3433            *
3434  5F64 0000         END
3434            


 Assembly Complete - Errors: 0,  Warnings: 0


 ------ Symbol Listing ------

 A9901  ABS:5CE8 A9901
 A9902  ABS:5CFA A9902
 A9903  ABS:5D24 A9903
 A9904  ABS:5D4A A9904
 A9905  ABS:5D68 A9905
 A9906  ABS:5DC8 A9906
 A9907  ABS:5DDE A9907
 A9908  ABS:5DE2 A9908
 A9909  ABS:5DF0 A9909
 A9910  ABS:5E2E A9910
 A9911  ABS:5E34 A9911
 A9912  ABS:5E40 A9912
 A9913  ABS:5E48 A9913
 A9914  ABS:5E62 A9914
 A9915  ABS:5E74 A9915
 A9916  ABS:5E88 A9916
 A9917  ABS:5E8C A9917
 A9918  ABS:5E9C A9918
 A9919  ABS:5EE2 A9919
 A9920  ABS:5EF2 A9920
 ACFG   ABS:5C76 ACFG
 ACHR   ABS:5C64 ACHR
 ACHR2  ABS:5CEA ACHR2
 ACLBAS ABS:5DF4 ACLBAS
 ACLERR ABS:5CB4 ACLERR
 ACLPRP ABS:5C7A ACLPRP
 ACOMND ABS:5FE8 ACOMND
 ADDSEC ABS:46F0 ADDSEC
 ADSR   ABS:5C46 ADSR
 AFDRPT ABS:52B4 AFDRPT
 AFPGPF ABS:51CA AFPGPF
 AHLP   ABS:5C5E AHLP
 APSCTS ABS:464C APSCTS
 ARST   ABS:5C6A ARST
 ASUBCM ABS:5FE9 ASUBCM
 AVERSN ABS:4046 AVERSN
 CALLBF ABS:5FC8 CALLBF
 CALLST ABS:5FC6 CALLST
 CALSUB ABS:4344 CALSUB
 CDIR   ABS:5C4C CDIR
 CFNFDR ABS:5B76 CFNFDR
 CFSVIB ABS:5752 CFSVIB
 CHKKEY ABS:5E6C CHKKEY
 CLOSE  ABS:4FBC CLOSE
 CLRFBT ABS:456E CLRFBT
 CLSDIR ABS:55FC CLSDIR
 CMPFN  ABS:4828 CMPFN
 CPCKFN ABS:4900 CPCKFN
 CRFIL1 ABS:447C CRFIL1
 CRFIL2 ABS:4482 CRFIL2
 CRFIL3 ABS:448E CRFIL3
 CRUWRI ABS:5FEE CRUWRI
 DECDCI ABS:4BA2 DECDCI
 DELETE ABS:475A DELETE
 DISSTS ABS:5E5A DISSTS
 DSDRVS ABS:4342 DSDRVS
 DSKPRM ABS:5FB4 DSKPRM
 DSR01  ABS:4104 DSR01
 DSR02  ABS:410C DSR02
 DSR03  ABS:4116 DSR03
 DSR04  ABS:4120 DSR04
 ECUSTM ABS:437C ECUSTM
 EDSR01 ABS:4D38 EDSR01
 EDSR02 ABS:4D46 EDSR02
 EDSR03 ABS:4D4C EDSR03
 EDSR04 ABS:4D52 EDSR04
 EPWRUP ABS:412A EPWRUP
 ERROR1 ABS:42E0 ERROR1
 ERROR3 ABS:4212 ERROR3
 ERROR4 ABS:427E ERROR4
 ERROR5 ABS:495E ERROR5
 ERROR6 ABS:4B14 ERROR6
 ERROR7 ABS:4904 ERROR7
 ERROR8 ABS:4DA4 ERROR8
 ERROR9 ABS:4DC0 ERROR9
 ERRR10 ABS:55D8 ERRR10
 ESUB01 ABS:5822 ESUB01
 ESUB02 ABS:5832 ESUB02
 ESUB03 ABS:583C ESUB03
 ESUB04 ABS:5896 ESUB04
 ESUB05 ABS:5962 ESUB05
 ESUB06 ABS:59D2 ESUB06
 ESUB07 ABS:5A98 ESUB07
 ESUB08 ABS:5A44 ESUB08
 FDR2B1 ABS:485C FDR2B1
 FDR2B2 ABS:4860 FDR2B2
 FDSKDR ABS:4876 FDSKDR
 FFDRDK ABS:4AF8 FFDRDK
 FFDRFN ABS:4B24 FFDRFN
 FFDROD ABS:4AF4 FFDROD
 FFDRVB ABS:4AB0 FFDRVB
 FFDRVP ABS:51BA FFDRVP
 FFFDR  ABS:5BBE FFFDR
 FFFDRV ABS:4A90 FFFDRV
 FFSBM  ABS:4CA8 FFSBM
 FFSBMP ABS:4BE2 FFSBMP
 FFSVIB ABS:45C6 FFSVIB
 FGET   ABS:5C3A FGET
 FMTDSK ABS:4218 FMTDSK
 FNDFDR ABS:4AEE FNDFDR
 FNDRV  ABS:578C FNDRV
 FPUT   ABS:5C40 FPUT
 FRSCB1 ABS:4CAE FRSCB1
 FSCTOF ABS:4736 FSCTOF
 GPLINT ABS:006A GPLINT
 GPLXML ABS:5EFA GPLXML
 GXRTN  ABS:5F3C GXRTN
 H001   ABS:4150 H001
 H002   ABS:41B4 H002
 H003   ABS:41D4 H003
 H004   ABS:41E2 H004
 H005   ABS:41E6 H005
 H006   ABS:41FC H006
 H007   ABS:4234 H007
 H008   ABS:4244 H008
 H009   ABS:4252 H009
 H010   ABS:426C H010
 H011   ABS:42AC H011
 H012   ABS:42CE H012
 H013   ABS:42F2 H013
 H014   ABS:431C H014
 H015   ABS:4330 H015
 H016   ABS:43A0 H016
 H017   ABS:43C4 H017
 H018   ABS:43CA H018
 H019   ABS:43EE H019
 H020   ABS:43F2 H020
 H021   ABS:4406 H021
 H022   ABS:44A4 H022
 H023   ABS:44FC H023
 H024   ABS:4518 H024
 H025   ABS:452E H025
 H026   ABS:4538 H026
 H027   ABS:454A H027
 H028   ABS:4558 H028
 H029   ABS:455E H029
 H030   ABS:4596 H030
 H031   ABS:45C2 H031
 H032   ABS:45E4 H032
 H033   ABS:45EE H033
 H034   ABS:4612 H034
 H035   ABS:4626 H035
 H036   ABS:4630 H036
 H037   ABS:465C H037
 H038   ABS:4670 H038
 H039   ABS:4682 H039
 H040   ABS:46B8 H040
 H041   ABS:46BC H041
 H042   ABS:46C4 H042
 H043   ABS:46C6 H043
 H044   ABS:46D4 H044
 H045   ABS:46E4 H045
 H046   ABS:46EC H046
 H047   ABS:4734 H047
 H048   ABS:4740 H048
 H049   ABS:474A H049
 H050   ABS:4756 H050
 H051   ABS:4772 H051
 H052   ABS:4788 H052
 H053   ABS:4794 H053
 H054   ABS:47D8 H054
 H055   ABS:4808 H055
 H056   ABS:4830 H056
 H057   ABS:4854 H057
 H058   ABS:488E H058
 H059   ABS:4898 H059
 H060   ABS:48A0 H060
 H061   ABS:48EE H061
 H062   ABS:48F6 H062
 H063   ABS:490A H063
 H064   ABS:4918 H064
 H065   ABS:4924 H065
 H066   ABS:4954 H066
 H067   ABS:4988 H067
 H068   ABS:49AA H068
 H069   ABS:49AE H069
 H070   ABS:49E6 H070
 H071   ABS:49FA H071
 H072   ABS:4A0A H072
 H073   ABS:4A14 H073
 H074   ABS:4A6A H074
 H075   ABS:4A7A H075
 H076   ABS:4A80 H076
 H077   ABS:4A88 H077
 H078   ABS:4AAC H078
 H079   ABS:4ACA H079
 H080   ABS:4AEA H080
 H081   ABS:4B00 H081
 H082   ABS:4B1A H082
 H083   ABS:4B30 H083
 H084   ABS:4B92 H084
 H085   ABS:4B96 H085
 H086   ABS:4B9C H086
 H087   ABS:4BF6 H087
 H088   ABS:4C08 H088
 H089   ABS:4C18 H089
 H090   ABS:4C24 H090
 H091   ABS:4C4A H091
 H092   ABS:4C54 H092
 H093   ABS:4C5C H093
 H094   ABS:4C82 H094
 H095   ABS:4C9E H095
 H096   ABS:4CDA H096
 H097   ABS:4CE8 H097
 H098   ABS:4CEA H098
 H099   ABS:4CEE H099
 H100   ABS:4CF0 H100
 H101   ABS:4D18 H101
 H102   ABS:4D20 H102
 H103   ABS:4D56 H103
 H104   ABS:4D5C H104
 H105   ABS:4D82 H105
 H106   ABS:4DC6 H106
 H107   ABS:4DDC H107
 H108   ABS:4DE8 H108
 H109   ABS:4E1A H109
 H110   ABS:4E32 H110
 H111   ABS:4E36 H111
 H112   ABS:4E8C H112
 H113   ABS:4E90 H113
 H114   ABS:4EB4 H114
 H115   ABS:4EB8 H115
 H116   ABS:4EDC H116
 H117   ABS:4F0A H117
 H118   ABS:4F62 H118
 H119   ABS:4F88 H119
 H120   ABS:4F8C H120
 H121   ABS:4FD2 H121
 H122   ABS:4FD6 H122
 H123   ABS:4FE2 H123
 H124   ABS:4FE8 H124
 H125   ABS:4FF0 H125
 H126   ABS:5012 H126
 H127   ABS:502C H127
 H128   ABS:5048 H128
 H129   ABS:5056 H129
 H130   ABS:507A H130
 H131   ABS:5082 H131
 H132   ABS:50A6 H132
 H133   ABS:50E4 H133
 H134   ABS:50EC H134
 H135   ABS:50F6 H135
 H136   ABS:510C H136
 H137   ABS:5122 H137
 H138   ABS:5192 H138
 H139   ABS:5206 H139
 H140   ABS:5226 H140
 H141   ABS:522C H141
 H142   ABS:5288 H142
 H143   ABS:5298 H143
 H144   ABS:5380 H144
 H145   ABS:53B4 H145
 H146   ABS:53C2 H146
 H147   ABS:53C8 H147
 H148   ABS:5406 H148
 H149   ABS:540A H149
 H150   ABS:5428 H150
 H151   ABS:5434 H151
 H152   ABS:5456 H152
 H153   ABS:5466 H153
 H154   ABS:54DC H154
 H155   ABS:5508 H155
 H156   ABS:5516 H156
 H157   ABS:5522 H157
 H158   ABS:552E H158
 H159   ABS:5544 H159
 H160   ABS:5556 H160
 H161   ABS:5570 H161
 H162   ABS:5574 H162
 H163   ABS:5584 H163
 H164   ABS:5588 H164
 H165   ABS:55AC H165
 H166   ABS:55B2 H166
 H167   ABS:55C2 H167
 H168   ABS:55DE H168
 H169   ABS:55E8 H169
 H170   ABS:5642 H170
 H171   ABS:56A4 H171
 H172   ABS:56AE H172
 H173   ABS:56B4 H173
 H174   ABS:56BC H174
 H175   ABS:56BE H175
 H176   ABS:56DC H176
 H177   ABS:56EC H177
 H178   ABS:570E H178
 H179   ABS:5716 H179
 H180   ABS:5762 H180
 H181   ABS:5778 H181
 H182   ABS:577C H182
 H183   ABS:5782 H183
 H184   ABS:5786 H184
 H185   ABS:57AE H185
 H186   ABS:57BE H186
 H187   ABS:57C8 H187
 H188   ABS:57F2 H188
 H189   ABS:57FA H189
 H190   ABS:57FC H190
 H191   ABS:5802 H191
 H192   ABS:5804 H192
 H193   ABS:5818 H193
 H194   ABS:58C6 H194
 H195   ABS:5958 H195
 H196   ABS:595E H196
 H197   ABS:597C H197
 H198   ABS:5982 H198
 H199   ABS:5988 H199
 H200   ABS:59A4 H200
 H201   ABS:59AA H201
 H202   ABS:59B0 H202
 H203   ABS:59C4 H203
 H204   ABS:59E8 H204
 H205   ABS:5A06 H205
 H206   ABS:5A40 H206
 H207   ABS:5A94 H207
 H208   ABS:5AE6 H208
 H209   ABS:5B10 H209
 H210   ABS:5B1A H210
 H211   ABS:5B32 H211
 H212   ABS:5B4E H212
 H213   ABS:5B52 H213
 H214   ABS:5B58 H214
 H215   ABS:5B5C H215
 H216   ABS:5B7A H216
 H217   ABS:5BDA H217
 H218   ABS:5BF8 H218
 H219   ABS:5C0C H219
 HONK   ABS:0036 HONK
 INSFDR ABS:47F6 INSFDR
 INT2FP ABS:57D0 INT2FP
 K001   ABS:4198 K001
 K002   ABS:433E K002
 K004   ABS:4340 K004
 K005   ABS:4341 K005
 K007   ABS:433F K007
 K013   ABS:42F0 K013
 K014   ABS:495C K014
 LASTRK ABS:42FE LASTRK
 LDIR   ABS:5C58 LDIR
 LDSK   ABS:5C22 LDSK
 LDSK2  ABS:5D4C LDSK2
 LOAD   ABS:53B8 LOAD
 LSTDRV ABS:5FC7 LSTDRV
 MDSK   ABS:5C28 MDSK
 MNDSK2 ABS:5DA2 MNDSK2
 NDSK   ABS:5C2E NDSK
 NOCRU  ABS:4196 NOCRU
 NOPARM ABS:5CB8 NOPARM
 NOPRM2 ABS:5CC4 NOPRM2
 NTPDT  ABS:5F5C NTPDT
 NTPFAT ABS:4026 NTPFAT
 NXTPRP ABS:5D88 NXTPRP
 NXTSCR ABS:5D54 NXTSCR
 OPCVEC ABS:4D8A OPCVEC
 OPEN   ABS:4DAA OPEN
 OPNDIR ABS:559E OPNDIR
 PABR2B ABS:4856 PABR2B
 PATTBL ABS:4044 PATTBL
 PDSK   ABS:5C16 PDSK
 PESB07 ABS:5A9E PESB07
 PRFDRS ABS:4F6A PRFDRS
 PRPFDO ABS:4410 PRPFDO
 PRPRTN ABS:4412 PRPRTN
 PUDSK2 ABS:5D46 PUDSK2
 PWRUP  ABS:40FE PWRUP
 QNOPRM ABS:5CD4 QNOPRM
 QSTRNG ABS:5DA8 QSTRNG
 R0     ABS:0000 R0
 R1     ABS:0001 R1
 R10    ABS:000A R10
 R11    ABS:000B R11
 R12    ABS:000C R12
 R13    ABS:000D R13
 R14    ABS:000E R14
 R15    ABS:000F R15
 R2     ABS:0002 R2
 R3     ABS:0003 R3
 R4     ABS:0004 R4
 R5     ABS:0005 R5
 R6     ABS:0006 R6
 R7     ABS:0007 R7
 R8     ABS:0008 R8
 R9     ABS:0009 R9
 RBANB  ABS:54AA RBANB
 RCOFCB ABS:533A RCOFCB
 RDATA  ABS:5FF6 RDATA
 RDDIR  ABS:5612 RDDIR
 RDFDR1 ABS:4A36 RDFDR1
 RDFDR2 ABS:4A32 RDFDR2
 RDINT  ABS:5FEA RDINT
 RDOFSC ABS:4616 RDOFSC
 RDSEC1 ABS:4A20 RDSEC1
 RDSK   ABS:5C34 RDSK
 READ   ABS:4FC6 READ
 RETERR ABS:498A RETERR
 RFDRST ABS:51E6 RFDRST
 RFDRVB ABS:593E RFDRVB
 RFNPTR ABS:5B98 RFNPTR
 RMFPTR ABS:47C6 RMFPTR
 RNFISE ABS:5244 RNFISE
 RRFDR  ABS:5260 RRFDR
 RRNPAB ABS:51FA RRNPAB
 RRSEC  ABS:504C RRSEC
 RSTAT  ABS:5FF0 RSTAT
 RSTDRV ABS:42B2 RSTDRV
 RTNBC  ABS:A018 RTNBC
 RTURN1 ABS:4362 RTURN1
 RVRVDP ABS:43C8 RVRVDP
 RWIND1 ABS:5364 RWIND1
 RWIND2 ABS:5392 RWIND2
 RWSEC  ABS:4A3A RWSEC
 RWSECA ABS:4A3C RWSECA
 RWSECB ABS:4A3E RWSECB
 RWVIB  ABS:49BE RWVIB
 SAVE   ABS:545A SAVE
 SAVGRA ABS:5EF4 SAVGRA
 SAVMEX ABS:5EF8 SAVMEX
 SAVR11 ABS:5EF6 SAVR11
 SCROLL ABS:56CD SCROLL
 SECRW1 ABS:419A SECRW1
 SELDRV ABS:4284 SELDRV
 SMAP   ABS:5C52 SMAP
 SNDCMD ABS:42F6 SNDCMD
 SP2VDP ABS:5C02 SP2VDP
 STATUS ABS:54DE STATUS
 SUB01  ABS:4010 SUB01
 SUB02  ABS:4016 SUB02
 SUB03  ABS:401C SUB03
 SUB04  ABS:4022 SUB04
 SUB05  ABS:4028 SUB05
 SUB06  ABS:402E SUB06
 SUB07  ABS:4034 SUB07
 SUB08  ABS:403A SUB08
 SUB09  ABS:4054 SUB09
 SUB10  ABS:405E SUB10
 SUB11  ABS:4068 SUB11
 SUB12  ABS:4072 SUB12
 SUB13  ABS:407C SUB13
 SUB14  ABS:4086 SUB14
 SUB15  ABS:4090 SUB15
 SUB16  ABS:409A SUB16
 SUB17  ABS:40A4 SUB17
 SUB18  ABS:40AE SUB18
 SUB19  ABS:40B8 SUB19
 SUB20  ABS:40C2 SUB20
 SUB21  ABS:40CC SUB21
 SUB22  ABS:40D6 SUB22
 SUB23  ABS:40E0 SUB23
 SUB24  ABS:40EA SUB24
 SUB25  ABS:40F4 SUB25
 SVDPRD ABS:43FE SVDPRD
 SVDPWR ABS:43F4 SVDPWR
 SVRVDP ABS:439C SVRVDP
 TIME   ABS:5C70 TIME
 TIME2  ABS:5E96 TIME2
 UCOFCB ABS:52D8 UCOFCB
 UDSK   ABS:5C1C UDSK
 UFNCB  ABS:5B60 UFNCB
 UPDBF  ABS:4582 UPDBF
 UPDCLI ABS:4BBE UPDCLI
 UPDFCB ABS:4F94 UPDFCB
 UPDFDR ABS:4562 UPDFDR
 URFFDR ABS:5304 URFFDR
 USTRNG ABS:5D0C USTRNG
 UWFLVB ABS:5876 UWFLVB
 VARINF ABS:5E92 VARINF
 VDP2SP ABS:5BF2 VDP2SP
 VDPR2B ABS:4862 VDPR2B
 VDPRD  ABS:432C VDPRD
 VDPRPW ABS:426A VDPRPW
 VDPWRI ABS:4322 VDPWRI
 VECRTN ABS:4394 VECRTN
 WCOMND ABS:5FF8 WCOMND
 WDATA  ABS:5FFE WDATA
 WFDRPB ABS:5028 WFDRPB
 WRFDR  ABS:4A2C WRFDR
 WRITE  ABS:50B0 WRITE
 WROFSC ABS:4636 WROFSC
 WRSEC1 ABS:4A22 WRSEC1
 WSECTR ABS:5FFC WSECTR
 WTCPT1 ABS:4276 WTCPT1
 XEMJMP ABS:404C XEMJMP
 XEMRET ABS:404A XEMRET
 XEMUST ABS:5D3C XEMUST
 XML14  ABS:164E XML14
 XML16  ABS:15D6 XML16
 XMLBC  ABS:4409 XMLBC
 XMLRTN ABS:2244 XMLRTN
