Asm994a TMS99000 Assembler - v3.010

                * Asm994a Generated Register Equates
                *
      0000 0000 R0      EQU     0 
      0000 0001 R1      EQU     1 
      0000 0002 R2      EQU     2 
      0000 0003 R3      EQU     3 
      0000 0004 R4      EQU     4 
      0000 0005 R5      EQU     5 
      0000 0006 R6      EQU     6 
      0000 0007 R7      EQU     7 
      0000 0008 R8      EQU     8 
      0000 0009 R9      EQU     9 
      0000 000A R10     EQU     10
      0000 000B R11     EQU     11
      0000 000C R12     EQU     12
      0000 000D R13     EQU     13
      0000 000E R14     EQU     14
      0000 000F R15     EQU     15
                *
   1            *===============================================================================================================
   2            * TI DISK CONTROLLER ROM   >4000-5FFF
   3            * 
   4            * initial commented disassembly by Thierry Nouspikel
   5            * (see http://www.unige.ch/medecine/nouspikel/ti99/titechpages.htm)
   6            *
   7            * and
   8            * 
   9            * Monty Schmidt's book: TI Technical Drive
  10            *
  11            * adapted for APEDSK99 by Jochen Buur
  12            * github.com/jambuur/APEDSK99
  13            *
  14            * v12r: support for Double Density / 80 tracks (max 1440 AU's)
  15            *================================================================================================================
  16  0000 5FB4 DSKPRM  EQU     >5FB4                   per DSKx: Mbyte #sectors, Lbyte #sectors, #sectors/track, #tracks, #sides
  17  0000 5FC6 CALLST  EQU     >5FC6                   CALL() execution status: finished, still active, error
  18  0000 5FC7 LSTDRV  EQU     >5FC7                   remember last drive accessed for LDSK without argument
  19  0000 5FC8 CALLBF  EQU     >5FC8                   2-way buffer for TI BASIC CALL's (1 screen line, 32 characters)
  20  0000 5FE8 ACOMND  EQU     >5FE8                   APEDSK99-specific Command register
  21  0000 5FEA RDINT   EQU     >5FEA                   issue read interrupt (R6 counter) 
  22  0000 5FEE CRUWRI  EQU     >5FEE                   emulated 8 CRU output bits
  23  0000 5FF0 RSTAT   EQU     >5FF0                   read FD1771 Status register
  24  0000 5FF6 RDATA   EQU     >5FF6                   read FD1771 Data register
  25  0000 5FF8 WCOMND  EQU     >5FF8                   write FD1771 Command register
  26  0000 5FFC WSECTR  EQU     >5FFC                   write FD1771 Sector register
  27  0000 5FFE WDATA   EQU     >5FFE                   write FD1771 Data register
  28            *
  29  0000 164E XML14   EQU     >164E                   ROM address for XML >14
  30  0000 15D6 XML16   EQU     >15D6                   ROM address for XML >16
  31            *
  32            *!!! CHECK GROM ADDRESS CONTENTS, NEEDS TO BE >0F5C; UNCOMMENT RELEVANT LINE (different GROM 0 versions)
  33            *
  34            *XML5C  EQU     >1039                   GROM address for XML >5C; GROM v2.2 consoles
  35            *XML5C  EQU     >1058                   GROM address for XML >5C; GROM - Heiner Martin version
  36  0000 105C XML5C   EQU     >105C                   GROM address for XML >5C; GROM - different pointers to character blocks
  37            *
  38  0000 006A GPLINT  EQU     >006A                   jump to GROM interpreter for SCROLL / HONK
  39  0000 2244 XMLRTN  EQU     >2244                   jump to GROM interpreter for RTN (after executing XML >14 / >16 routine)
  40  0000 56CD SCROLL  EQU     >56CD                   GROM address for scroll routine
  41            *
  42            *!!! CHECK GROM ADDRESS CONTENTS, NEEDS TO BE >BF58; UNCOMMENT RELEVANT LINE (different GROM 0 versions)
  43            *
  44            *HONK   EQU     >03AF                   GROM address for "bad tone"; GROM v2.2 consoles
  45            *HONK   EQU     >03D3                   GROM address for "bad tone"; GROM - Heiner Martin version
  46  0000 03D6 HONK    EQU     >03D6                   GROM address for "bad tone"; GROM - different pointers to character blocks
  47            *
  48                    AORG    >4000
  49            *
  50  4000 AA           BYTE    >AA                     standard header mark
  51  4001 02           BYTE    >02                     version 2
  52  4002 0000         DATA    >0000                   no programs
  53  4004 40E8         DATA    PWRUP                   power-up chain ptr
  54  4006 0000         DATA    >0000                   programs chain ptr (none)
  55  4008 40EE         DATA    DSR01                   DSR chain ptr
  56  400A 4010         DATA    SUB01                   subprograms chain ptr
  57  400C 0000         DATA    >0000                   ISR chain ptr (none)
  58  400E 0000         DATA    >0000                   
  59            *                                       
  60  4010 4016 SUB01   DATA    SUB02                   link to next subprogram
  61  4012 580C         DATA    ESUB01                  address of that one
  62  4014 0110         DATA    >0110                   subprogram name: >10 (sector R/W)
  63  4016 401C SUB02   DATA    SUB03                   
  64  4018 581C         DATA    ESUB02                  
  65  401A 0111         DATA    >0111                   subprogram >11 (format disk)
  66  401C 4022 SUB03   DATA    SUB04                   
  67  401E 5826         DATA    ESUB03                  
  68  4020 0112         DATA    >0112                   subprogram >12 (file un/protect)
  69  4022 402C SUB04   DATA    SUB05                   
  70  4024 5880         DATA    ESUB04                  
  71  4026 0113 NTPFAT  DATA    >0113                   subprogram >13 (file rename); doubles as FAT update flag
  72            *
  73  4028 0000 RTN5C   DATA    >0000                   save GPL return address (needs to be @>4028 for XML >5C!)
  74  402A 0400 PATTBL  DATA    >0400                   TI BASIC VDP RAM address for Pattern Table; change before calling ALOW from assembly
  75            *
  76  402C 4032 SUB05   DATA    SUB06                   
  77  402E 594C         DATA    ESUB05                  
  78  4030 0114         DATA    >0114                   subprogram >14 (file direct input)              
  79  4032 4038 SUB06   DATA    SUB07                   
  80  4034 59BC         DATA    ESUB06                  
  81  4036 0115         DATA    >0115                   subprogram >15 (file direct output)
  82  4038 403E SUB07   DATA    SUB08                   
  83  403A 5A82         DATA    ESUB07                  
  84  403C 0116         DATA    >0116                   subprogram >16 (number of files)
  85  403E 4048 SUB08   DATA    SUB09                   
  86  4040 5A2E         DATA    ESUB08                  
  87  4042 05           BYTE    >05                     
  88  4043 4649         TEXT    'FILES'                 same as >16, called from Basic
  88  4045 4C45  
  88  4047 53    
  89            *
  90  4048 4052 SUB09   DATA    SUB10
  91  404A 5C00         DATA    PDSK
  92  404C 04           BYTE    >04
  93  404D 5044         TEXT    'PDSK'                  Protect DSKx (apply adhesive tab)
  93  404F 534B  
  94  4051 0000         EVEN
  95  4052 405C SUB10   DATA    SUB11                   
  96  4054 5C06         DATA    UDSK
  97  4056 04           BYTE    >04
  98  4057 5544         TEXT    'UDSK'                  Un-protect DSKx (remove adhesive tab)
  98  4059 534B  
  99  405B 0000         EVEN
 100  405C 4066 SUB11   DATA    SUB12
 101  405E 5C0C         DATA    LDSK
 102  4060 04           BYTE    >04
 103  4061 4C44         TEXT    'LDSK'                  List files on DSKx
 103  4063 534B  
 104  4065 0000         EVEN
 105  4066 4070 SUB12   DATA    SUB13
 106  4068 5C12         DATA    MDSK
 107  406A 04           BYTE    >04
 108  406B 4D44         TEXT    'MDSK'                  Map DOAD to DSKx
 108  406D 534B  
 109  406F 0000         EVEN
 110  4070 407A SUB13   DATA    SUB14
 111  4072 5C18         DATA    NDSK
 112  4074 04           BYTE    >04
 113  4075 4E44         TEXT    'NDSK'
 113  4077 534B  
 114  4079 0000         EVEN
 115  407A 4084 SUB14   DATA    SUB15
 116  407C 5C1E         DATA    RDSK
 117  407E 04           BYTE    >04
 118  407F 5244         TEXT    'RDSK'                  Remove DOAD from SD card
 118  4081 534B  
 119  4083 0000         EVEN
 120  4084 408E SUB15   DATA    SUB16
 121  4086 5C24         DATA    FGET
 122  4088 04           BYTE    >04
 123  4089 4647         TEXT    'FGET'                  Load DOAD from FTP server
 123  408B 4554  
 124  408D 0000         EVEN
 125  408E 4098 SUB16   DATA    SUB17
 126  4090 5C2A         DATA    FPUT
 127  4092 04           BYTE    >04
 128  4093 4650         TEXT    'FPUT'                  Save DOAD to FTP server
 128  4095 5554  
 129  4097 0000         EVEN
 130  4098 40A2 SUB17   DATA    SUB18
 131  409A 5C30         DATA    ADSR
 132  409C 04           BYTE    >04
 133  409D 4144         TEXT    'ADSR'                  APEDSK99 load DSR
 133  409F 5352  
 134  40A1 0000         EVEN
 135  40A2 40AC SUB18   DATA    SUB19
 136  40A4 5C36         DATA    NDIR
 137  40A6 04           BYTE    >04
 138  40A7 4E44         TEXT    'NDIR'
 138  40A9 4952  
 139  40AB 0000         EVEN
 140  40AC 40B6 SUB19   DATA    SUB20
 141  40AE 5C3C         DATA    SDSK
 142  40B0 04           BYTE    >04
 143  40B1 5344         TEXT    'SDSK'                  Show DOAD mapping for DSKx
 143  40B3 534B  
 144  40B5 0000         EVEN
 145  40B6 40C0 SUB20   DATA    SUB21
 146  40B8 5C42         DATA    SDIR
 147  40BA 04           BYTE    >04
 148  40BB 5344         TEXT    'SDIR'                  List DOAD files on SD card
 148  40BD 4952  
 149  40BF 0000         EVEN
 150  40C0 40CA SUB21   DATA    SUB22
 151  40C2 5C48         DATA    AHLP
 152  40C4 04           BYTE    >04
 153  40C5 4148         TEXT    'AHLP'                  APEDSK99 CALL help screen
 153  40C7 4C50  
 154  40C9 0000         EVEN
 155  40CA 40D4 SUB22   DATA    SUB23
 156  40CC 5C4E         DATA    ALOW
 157  40CE 04           BYTE    >04
 158  40CF 414C         TEXT    'ALOW'                  Load real lower case characters
 158  40D1 4F57  
 159  40D3 0000         EVEN
 160  40D4 40DE SUB23   DATA    SUB24
 161  40D6 5C54         DATA    ARST
 162  40D8 04           BYTE    >04
 163  40D9 4152         TEXT    'ARST'                  APEDSK99 Reset
 163  40DB 5354  
 164  40DD 0000         EVEN
 165  40DE 0000 SUB24   DATA    >0000
 166  40E0 5C5A         DATA    TIME
 167  40E2 04           BYTE    >04
 168  40E3 5449         TEXT    'TIME'                  NTP date/time display / assign to NTP$
 168  40E5 4D45  
 169  40E7 0000         EVEN
 170            *
 171  40E8 0000 PWRUP   DATA    >0000                   power-up chain (no more)
 172  40EA 4114         DATA    EPWRUP                  address of power-up routine
 173  40EC 0000         DATA    >0000                   no name
 174            *                                       
 175  40EE 40F6 DSR01   DATA    DSR02                   DSR chain
 176  40F0 4D22         DATA    EDSR01                  address of DSR
 177  40F2 03           BYTE    >03                     name size
 178  40F3 4453         TEXT    'DSK'                   DSR name
 178  40F5 4B    
 179  40F6 4100 DSR02   DATA    DSR03                   
 180  40F8 4D30         DATA    EDSR02                  
 181  40FA 04           BYTE    >04                     
 182  40FB 4453         TEXT    'DSK1'                  
 182  40FD 4B31  
 183  40FF 0000         EVEN                            
 184  4100 410A DSR03   DATA    DSR04                   
 185  4102 4D36         DATA    EDSR03                  
 186  4104 04           BYTE    >04                     
 187  4105 4453         TEXT    'DSK2'                  
 187  4107 4B32  
 188  4109 0000         EVEN                            
 189  410A 0000 DSR04   DATA    >0000                   no more
 190  410C 4D3C         DATA    EDSR04                  
 191  410E 04           BYTE    >04                     
 192  410F 4453         TEXT    'DSK3'                  
 192  4111 4B33  
 193  4113 0000         EVEN            
 194            *
 195            *=====================================
 196            * Power-up routine
 197            *=====================================                                          
 198            *
 199  4114 028C EPWRUP  CI      R12,>1000               Dhr. F.G. Kaal check: are we powering up 1st CRU (>1000) peripheral?
 199  4116 1000  
 200  4118 1633         JNE     NOCRU                   nope; return
 201            *
 202  411A C1CB         MOV     R11,R7                  yes; save return address
 203  411C 02A9         STWP    R9                      get workspace (should be >83E0)
 204  411E 0229         AI      R9,-224                 point to top of scratch-pad mem (>8300)
 204  4120 FF20  
 205  4122 C0A9         MOV     @>0070(R9),R2           highest free address in vdp mem (>8370)
 205  4124 0070  
 206  4126 C002         MOV     R2,R0                   save it
 207  4128 0222         AI      R2,-2088                we'll need >828 bytes
 207  412A F7D8  
 208  412C CA42         MOV     R2,@>0070(R9)           update address
 208  412E 0070  
 209  4130 0582         INC     R2
 210  4132 06A0         BL      @VDPWRI                 set VDP address
 210  4134 430C  
 211  4136 0201         LI      R1,2088                 
 211  4138 0828  
 212  413A 04EF H001    CLR     @-2(R15)                clear these >828 bytes
 212  413C FFFE  
 213  413E 0601         DEC     R1                      
 214  4140 16FC         JNE     H001                    
 215  4142 06A0         BL      @VDPWRI                 set VDP address (same)
 215  4144 430C  
 216  4146 0203         LI      R3,>AA03                        
 216  4148 AA03  
 217  414A DBC3         MOVB    R3,@-2(R15)             write buffer ID mark
 217  414C FFFE  
 218  414E 1000         NOP                             
 219  4150 DBC0         MOVB    R0,@-2(R15)             write old highest free address
 219  4152 FFFE  
 220  4154 06C0         SWPB    R0
 221  4156 DBC0         MOVB    R0,@-2(R15)
 221  4158 FFFE  
 222  415A 1000         NOP                             
 223  415C DBCC         MOVB    R12,@-2(R15)            write CRU address (>1000 for APEDSK99)
 223  415E FFFE  
 224  4160 06C3         SWPB    R3                      
 225  4162 DBC3         MOVB    R3,@-2(R15)             write number of files (3)
 225  4164 FFFE  
 226  4166 06A0         BL      @PRPRTN                 preparation routine
 226  4168 43FC  
 227  416A 06A0         BL      @CALSUB                 call subroutine
 227  416C 432E  
 228  416E 429C         DATA    RSTDRV                  reset all drives
 229  4170 04E9         CLR     @>0054(R9)              name length = 0 for power-up
 229  4172 0054  
 230  4174 0429         BLWP    @>005A(R9)              retrieve R7 (saved by PRPRTN)
 230  4176 005A  
 231  4178 0011         DATA    >0011                   put it into R11
 232  417A CA60         MOV     @K001,@>006C(R9)        ???
 232  417C 4182  
 232  417E 006C  
 233  4180 045B NOCRU   B       *R11                    return
 234            *                               
 235  4182 0404 K001    DATA    >0404                   
 236            *
 237            *---------------------------------------
 238            * Sector read/write
 239            *---------------------------------------                                        
 240            *
 241  4184 DA60 SECRW1  MOVB    @K002,@>0050(R9)        APEDSK99: no error
 241  4186 4328  
 241  4188 0050  
 242  418A 06A0         BL      @SELDRV                 select drive
 242  418C 426E  
 243            *
 244  418E C069         MOV     @>004A(R9),R1           sector #
 244  4190 004A  
 245  4192 0281         CI      R1,>05A0                APEDSK99: max 1440 (DS/DD/40T or DS/SD/80T)?
 245  4194 05A0  
 246  4196 1A03         JL      H005                    APEDSK99: yes; sector# within range
 247  4198 06A0         BL      @ERROR1                 APEDSK99: no -> "device error"
 247  419A 42CA  
 248  419C 0600         DATA    >0600   
 249            
 250  419E C801 H005    MOV     R1,@WSECTR              APEDSK99: sector# to FD1771 write sector register (16bits)
 250  41A0 5FFC  
 251            *
 252  41A2 C0A9 H013    MOV     @>004E(R9),R2           data buffer address
 252  41A4 004E  
 253  41A6 D029         MOVB    @>004D(R9),R0           read or write ?
 253  41A8 004D  
 254  41AA 1312         JEQ     H014                    write
 255  41AC 06A0         BL      @VDPWRI                 read FD = write to VDP buffer
 255  41AE 430C  
 256  41B0 0206 H015    LI      R6,256                  APEDSK99: re-arranged H015 to sync reading sector bytes
 256  41B2 0100  
 257  41B4 C806         MOV     R6,@RDINT               APEDSK99: interrupt Arduino for read operation 
 257  41B6 5FEA  
 258  41B8 06A0         BL      @SNDCMD                 send command
 258  41BA 42E0  
 259  41BC 8800         DATA    >8800                   APEDSK99: read sector
 260            *
 261  41BE D020 H016    MOVB    @RDATA,R0               get 1 byte from FDC
 261  41C0 5FF6  
 262  41C2 DBC0         MOVB    R0,@-2(R15)             save it to VDP
 262  41C4 FFFE  
 263  41C6 0620         DEC     @RDINT                  APEDSK99: interrupt Arduino for read operation
 263  41C8 5FEA  
 264  41CA 16F9         JNE     H016                    next byte
 265            *
 266  41CC 0460 H019    B       @RTURN1                 return
 266  41CE 434C  
 267            
 268            *       
 269  41D0 06A0 H014    BL      @VDPRD                  write to FD = read from VDP buffer
 269  41D2 4316  
 270  41D4 0206         LI      R6,256                  256 bytes to write
 270  41D6 0100  
 271            *
 272            * APEDSK99: the first byte to be written needs to be in the data register before the write command is given
 273            *
 274  41D8 D02F         MOVB    @-1026(R15),R0          APEDSK99: get a byte from data buffer
 274  41DA FBFE  
 275  41DC D800         MOVB    R0,@WDATA               APEDSK99: write first byte to data register
 275  41DE 5FFE  
 276  41E0 06A0         BL      @SNDCMD                 send command
 276  41E2 42E0  
 277  41E4 A800         DATA    >A800                   APEDSK99: write sector
 278            *
 279  41E6 D02F H024    MOVB    @-1026(R15),R0          get a byte from data buffer
 279  41E8 FBFE  
 280  41EA D800         MOVB    R0,@WDATA               pass it to data register
 280  41EC 5FFE  
 281  41EE 0606         DEC     R6                      
 282  41F0 16FA         JNE     H024                    next byte
 283            *
 284  41F2 06A0         BL      @WTCPT1                 APEDSK99: check for Write Protect
 284  41F4 4260  
 285  41F6 0A20         SLA     R0,2                    APEDSK99: WP bit in Carry
 286  41F8 1801         JOC     ERROR3                  write protect: error 34
 287  41FA 10E8         JMP     H019                    APEDSK99: no need to verify             
 288            *                                       
 289  41FC 06A0 ERROR3  BL      @ERROR1                 error 34 (Write Protect)
 289  41FE 42CA  
 290  4200 3400         DATA    >3400                   
 291            *
 292            *--------------------------------------------------------------------
 293            * Format disk - APEDSK99: we don't do any physical formatting anymore
 294            *--------------------------------------------------------------------
 295            *
 296  4202 04E9 FMTDSK  CLR     @>004A(R9)              called by subprogram >11
 296  4204 004A  
 297            *                                       
 298  4206 5A60 H027    SZCB    @K004,@>004C(R9)        clear DSR version flags
 298  4208 432A  
 298  420A 004C  
 299            *
 300  420C 06A0         BL      @SELDRV                 select drive
 300  420E 426E  
 301            *
 302  4210 D029         MOVB    @>004D(R9),R0           APEDSK99: get # of tracks
 302  4212 004D  
 303  4214 9829         CB      @>0051(R9),@K005        APEDSK99: double sided?
 303  4216 0051  
 303  4218 432B  
 304  421A 1601         JNE     H036                    APEDSK99: single-side
 305            *
 306  421C 0A10         SLA     R0,1                    times two (since 2 sides)
 307            *
 308  421E 0980 H036    SRL     R0,8                    APEDSK99: make it a byte
 309  4220 0206         LI      R6,9                    APEDSK99: start with single density
 309  4222 0009  
 310  4224 9829         CB      @>0050(R9),@K005        APEDSK99: double density required?
 310  4226 0050  
 310  4228 432B  
 311  422A 1601         JNE     H037                    APEDSK99: no, leave R6 alone
 312  422C 0A16         SLA     R6,1                    APEDSK99: yes, R6*2
 313            *               
 314  422E 3806 H037    MPY     R6,R0                   APEDSK99: #sectors/track * #tracks
 315  4230 0281         CI      R1,>05A0                APEDSK99: >1440 sectors?
 315  4232 05A0  
 316  4234 1203         JLE     H038                    APEDSK99: nope; continue
 317  4236 06A0         BL      @ERROR1                 APEDSK99: yes; "device error"
 317  4238 42CA  
 318  423A 0600         DATA    >0600   
 319            *
 320  423C CA41 H038    MOV     R1,@>004A(R9)           pass total # of sectors per disk
 320  423E 004A  
 321  4240 06C6         SWPB    R6
 322  4242 DA46         MOVB    R6,@>004D(R9)           APEDSK99: pass # of sectors per track
 322  4244 004D  
 323  4246 DA60         MOVB    @K002,@>0050(R9)        no error
 323  4248 4328  
 323  424A 0050  
 324            *
 325  424C 06A0         BL      @NTPDT                  APEDSK99: update DOAD FAT time/date
 325  424E 5F1A  
 326            *
 327  4250 0460         B       @RTURN1                 return
 327  4252 434C  
 328            *                                       
 329                                                    
 330  4254 C1BB VDPRPW  MOV     *R11+,R6                VDP repeated write
 331  4256 DBC0 H044    MOVB    R0,@-2(R15)
 331  4258 FFFE  
 332  425A 0606         DEC     R6                      byte in R0
 333  425C 16FC         JNE     H044                    number of repeats in data word
 334  425E 045B         B       *R11                    
 335            *
 336  4260 D020 WTCPT1  MOVB    @RSTAT,R0               get status. APEDSK99: Not Ready >80 / Write Protect >40
 336  4262 5FF0  
 337  4264 1101         JLT     ERROR4                  drive not ready. APEDSK99: Not Ready set when DOAD file is unavailable
 338  4266 045B         B       *R11                    
 339            *
 340  4268 06A0 ERROR4  BL      @ERROR1                 exit with error code 6, reseting all drives
 340  426A 42CA  
 341  426C 0600         DATA    >0600                   
 342            *                                       
 343  426E C1CB SELDRV  MOV     R11,R7                  select a drive
 344  4270 C0A9         MOV     @>0058(R9),R2
 344  4272 0058  
 345  4274 0222         AI      R2,-10                  point to drive info
 345  4276 FFF6  
 346  4278 04C0 H055    CLR     R0                      
 347  427A D029         MOVB    @>004C(R9),R0           get drive #
 347  427C 004C  
 348  427E 130B         JEQ     H056                    can't be >00: error #7
 349  4280 0280         CI      R0,>0300                        
 349  4282 0300  
 350  4284 1B08         JH      H056                    drive number can't be higher than 3: error #7
 351  4286 06A0         BL      @VDPWRI                 set VDP to write, address in R2
 351  4288 430C  
 352  428A DBC0         MOVB    R0,@-2(R15)             modify last drive accessed              
 352  428C FFFE  
 353            *
 354  428E 0A10 H057    SLA     R0,1                    APEDSK99: bit 0 is side select, 1-3 is drive #
 355  4290 D800         MOVB    R0,@CRUWRI              APEDSK99: select drive
 355  4292 5FEE  
 356  4294 0457 H058    B       *R7                     
 357            *                                       
 358  4296 06A0 H056    BL      @ERROR1                 exit with error #7
 358  4298 42CA  
 359  429A 0700         DATA    >0700                   
 360            *                                       
 361  429C 5820 RSTDRV  SZCB    @DSDRVS,@CRUWRI         APEDSK99: reset all drives including side
 361  429E 432C  
 361  42A0 5FEE  
 362  42A2 D820         MOVB    @K013,@WCOMND           send Force Interrupt with no interrupt flag set
 362  42A4 42DA  
 362  42A6 5FF8  
 363  42A8 C0A9         MOV     @>0058(R9),R2           ptr to VIB buffer
 363  42AA 0058  
 364  42AC 0222         AI      R2,-10                  now points to drive info buffer
 364  42AE FFF6  
 365  42B0 06A0         BL      @VDPWRI                 set VDP to write to address in R2
 365  42B2 430C  
 366  42B4 0200         LI      R0,4                    
 366  42B6 0004  
 367  42B8 DBC0 H061    MOVB    R0,@-2(R15)             write four >00 (i.e. clear drive info)
 367  42BA FFFE  
 368  42BC 0600         DEC     R0                      
 369  42BE 16FC         JNE     H061                    
 370  42C0 DA60         MOVB    @K002,@>0050(R9)        no error
 370  42C2 4328  
 370  42C4 0050  
 371  42C6 0460         B       @RTURN1                 get return address from stack
 371  42C8 434C  
 372            *                                       
 373  42CA C01B ERROR1  MOV     *R11,R0                 exit with error
 374  42CC DA40         MOVB    R0,@>0050(R9)           place err code in >8350
 374  42CE 0050  
 375  42D0 0280         CI      R0,>0600                check if device error
 375  42D2 0600  
 376  42D4 1603         JNE     H064                    no: exit
 377  42D6 06A0         BL      @SNDCMD                 yes: reset drives
 377  42D8 42E0  
 378            *
 379  42DA 0000 K013    DATA    >0000                   APEDSK99: send Restore command
 380            *
 381  42DC 0460 H064    B       @RTURN1                 return to caller (address from stack)
 381  42DE 434C  
 382            *                               
 383  42E0 C03B SNDCMD  MOV     *R11+,R0                send command to FDC from data word
 384  42E2 D800 H066    MOVB    R0,@WCOMND              send command
 384  42E4 5FF8  
 385  42E6 045B         B       *R11                    
 386            *                                       
 387  42E8 04C0 LASTRK  CLR     R0                      get last track # for this drive
 388  42EA D029         MOVB    @>004C(R9),R0           get drive #
 388  42EC 004C  
 389  42EE 130B         JEQ     H068                    can't be 0
 390  42F0 06C0         SWPB    R0                      
 391  42F2 0280         CI      R0,3                    
 391  42F4 0003  
 392  42F6 1B07         JH      H068                    can't be higher than 3
 393  42F8 C0A9         MOV     @>0058(R9),R2                   
 393  42FA 0058  
 394  42FC 0222         AI      R2,-10                  point to last drive accessed
 394  42FE FFF6  
 395  4300 A080         A       R0,R2                   point to last track for this drive
 396  4302 0460         B       @VDPRD                  prepare VDP to read from address in R2
 396  4304 4316  
 397            *                                       
 398  4306 06A0 H068    BL      @ERROR1                 exit with error code 7
 398  4308 42CA  
 399  430A 0700         DATA    >0700                   
 400            *                                       
 401  430C 0262 VDPWRI  ORI     R2,>4000                set VDP address to write
 401  430E 4000  
 402  4310 0242         ANDI    R2,>7FFF                not to a register
 402  4312 7FFF  
 403  4314 1002         JMP     H069                    
 404  4316 0242 VDPRD   ANDI    R2,>3FFF                set VDP address to read
 404  4318 3FFF  
 405  431A 06C2 H069    SWPB    R2                      
 406  431C D7C2         MOVB    R2,*R15                 write address
 407  431E 06C2         SWPB    R2                      
 408  4320 D7C2         MOVB    R2,*R15                 
 409  4322 0242         ANDI    R2,>3FFF                        
 409  4324 3FFF  
 410  4326 045B         B       *R11                    
 411            *                                       
 412  4328 00   K002    BYTE    >00                     
 413  4329 09   K007    BYTE    >09                                             
 414  432A F0   K004    BYTE    >F0                     
 415  432B 02   K005    BYTE    2
 416  432C 0F   DSDRVS  BYTE    >0F                     APEDSK99: deselect all drives + side (reset CRUWRI bits 7,6,5 and 4)                    
 417            *
 418  432D 0000         EVEN
 419            *                               
 420  432E 0669 CALSUB  DECT    @>0066(R9)              call subroutine, return address in stack
 420  4330 0066  
 421  4332 C2A9         MOV     @>0066(R9),R10
 421  4334 0066  
 422  4336 0429         BLWP    @>005A(R9)              set VDP to write to address in R10
 422  4338 005A  
 423  433A 0143         DATA    >0143                   
 424  433C C2BB         MOV     *R11+,R10               get next data word
 425  433E 06CB         SWPB    R11                     write return address to VDP
 426  4340 DBCB         MOVB    R11,@-2(R15)                    
 426  4342 FFFE  
 427  4344 06CB         SWPB    R11                     
 428  4346 DBCB         MOVB    R11,@-2(R15)                    
 428  4348 FFFE  
 429  434A 045A         B       *R10                    branch to address in data word
 430            *                               
 431  434C C2E9 RTURN1  MOV     @>0066(R9),R11          get return address from VDP stack
 431  434E 0066  
 432  4350 0429         BLWP    @>005A(R9)              
 432  4352 005A  
 433  4354 0162         DATA    >0162                   set VDP to read from address in R11
 434  4356 D2EF         MOVB    @-1026(R15),R11                 
 434  4358 FBFE  
 435  435A 06CB         SWPB    R11                     
 436  435C D2EF         MOVB    @-1026(R15),R11                 
 436  435E FBFE  
 437  4360 05E9         INCT    @>0066(R9)                      
 437  4362 0066  
 438  4364 045B         B       *R11                    
 439            *
 440            *---------------------------------------
 441            * Custom routines, dealing with VDP memory
 442            * Format is >pppr where r is routine number (0-3)
 443            * and ppp contains parameters
 444            * The workspace it >8300. Called by BLWP @>005A(9).
 445            *---------------------------------------                                        
 446            *
 447  4366 C28D ECUSTM  MOV     R13,R10                 save wregs ptr
 448  4368 C23E         MOV     *R14+,R8                get next data word
 449  436A C248         MOV     R8,R9                   save it
 450  436C 0949         SRL     R9,4                    keep parameter
 451  436E 0248         ANDI    R8,3                    four possible operations
 451  4370 0003  
 452  4372 A208         A       R8,R8                   make it a word ptr
 453  4374 C2ED         MOV     @>001E(R13),R11         get old R15, i.e. VDP port (>8C02)
 453  4376 001E  
 454  4378 C228         MOV     @VECRTN(R8),R8          get vector for operation
 454  437A 437E  
 455  437C 0458         B       *R8                     branch to it
 456            *                                       
 457  437E 4386 VECRTN  DATA    SVRVDP                  save registers to VDP stack
 458  4380 43B2         DATA    RVRVDP                  retrieve registers
 459  4382 43E8         DATA    SVDPRD                  set VDP address to read
 460  4384 43DE         DATA    SVDPWR                  set VDP address to write
 461            *                                       
 462  4386 022A SVRVDP  AI      R10,22                  0: save registers in VDP mem
 462  4388 0016  
 463  438A 0919 H072    SRL     R9,1                    start with R12
 464  438C 1710         JNC     H070                    bits in >ppp tell which register to save (R0-R11)
 465  438E 064C         DECT    R12                     previous address in VDP stack (grows down)
 466  4390 C21A         MOV     *R10,R8                 get register contents
 467  4392 06CC         SWPB    R12                     set VDP address to write
 468  4394 D6CC         MOVB    R12,*R11                R12 is >8366: VDP stack ptr
 469  4396 06CC         SWPB    R12                     
 470  4398 026C         ORI     R12,>4000                       
 470  439A 4000  
 471  439C D6CC         MOVB    R12,*R11                        
 472  439E 06C8         SWPB    R8                      save register to VDP mem
 473  43A0 DAC8         MOVB    R8,@-2(R11)                     
 473  43A2 FFFE  
 474  43A4 06C8         SWPB    R8                      
 475  43A6 DAC8         MOVB    R8,@-2(R11)                     
 475  43A8 FFFE  
 476  43AA C249         MOV     R9,R9                   more to come?
 477  43AC 1317         JEQ     H071                    no:return
 478  43AE 064A H070    DECT    R10                     point to previous register
 479  43B0 10EC         JMP     H072                    
 480            *                               
 481  43B2 0A49 RVRVDP  SLA     R9,4                    1: retrieve registers from VDP mem
 482  43B4 0A19 H074    SLA     R9,1                    each bit tells whether to load
 483  43B6 1710         JNC     H073                    don't retrieve that one
 484  43B8 06CC         SWPB    R12                     set VDP address to read
 485  43BA D6CC         MOVB    R12,*R11                R12 is >8366: VDP stack ptr
 486  43BC 06CC         SWPB    R12                     
 487  43BE 024C         ANDI    R12,>3FFF                       
 487  43C0 3FFF  
 488  43C2 D6CC         MOVB    R12,*R11                        
 489  43C4 1000         NOP                             
 490  43C6 D22B         MOVB    @-1026(R11),R8          get a 2-byte value from VDP
 490  43C8 FBFE  
 491  43CA 06C8         SWPB    R8                      
 492  43CC D22B         MOVB    @-1026(R11),R8                  
 492  43CE FBFE  
 493  43D0 C688         MOV     R8,*R10                 save it to register
 494  43D2 05CC         INCT    R12                     increment ptr (stack grows downwards)
 495  43D4 C249         MOV     R9,R9                   more to come?
 496  43D6 1302         JEQ     H071                    no: return
 497  43D8 05CA H073    INCT    R10                     next register
 498  43DA 10EC         JMP     H074                    
 499  43DC 0380 H071    RTWP                            
 500            *                                       
 501  43DE A24D SVDPWR  A       R13,R9                  2: set VDP for a write
 502  43E0 C219         MOV     *R9,R8                  
 503  43E2 0268         ORI     R8,>4000                get address from reg in >..p2 (*2)
 503  43E4 4000  
 504  43E6 1004         JMP     H075                    
 505            *                                       
 506  43E8 A24D SVDPRD  A       R13,R9                  3: set VDP for a read
 507  43EA C219         MOV     *R9,R8
 508  43EC 0248         ANDI    R8,>3FFF                get register from reg in >..p3 (*2)
 508  43EE 3FFF  
 509  43F0 06C8 H075    SWPB    R8                      set VDP address
 510  43F2 D6C8         MOVB    R8,*R11                 
 511  43F4 06C8         SWPB    R8                      
 512  43F6 D6C8         MOVB    R8,*R11                 
 513  43F8 0380         RTWP                            
 514            *
 515            *---------------------------------------
 516            * Preparation subroutine
 517            * Sets up the 4 custom subroutines
 518            * Gets a few pointers to VDP buffers
 519            *  >8358: copy of VIB  >8366: VDP stack ptr (grows down from drive info)
 520            *  >8354: PAB          >8356: ptr to end-of-buffer
 521            *---------------------------------------                                        
 522            *
 523  43FA 05C7 PRPFDO  INCT    R7                      stop scanning upon return
 524  43FC C28B PRPRTN  MOV     R11,R10                 save return address
 525  43FE 02A9         STWP    R9                      get workspace (should be >83E0)
 526  4400 0229         AI      R9,-224                 top of scratch/pad mem (>8300)
 526  4402 FF20  
 527  4404 0200         LI      R0,ECUSTM               entry to 4 custom routines
 527  4406 4366  
 528  4408 CA40         MOV     R0,@>005C(R9)           put it in >835C
 528  440A 005C  
 529  440C C009         MOV     R9,R0                   
 530  440E 0220         AI      R0,>004E                workspace for these four (>834E)
 530  4410 004E  
 531  4412 CA40         MOV     R0,@>005A(R9)           put it in >835A
 531  4414 005A  
 532            *                                       
 533  4416 C229         MOV     @>0070(R9),R8           highest free address in VDP mem
 533  4418 0070  
 534  441A 05C8 H076    INCT    R8                      point to end-of-buffer word
 535  441C 06A0         BL      @VDPR2B                 read 2 bytes from VDP address R8, into R0
 535  441E 484C  
 536  4420 C088         MOV     R8,R2                   save current R8
 537  4422 C200         MOV     R0,R8                   get end-of-buffer word
 538  4424 0228         AI      R8,-266                 yes: point to volume information block
 538  4426 FEF6  
 539  4428 CA48         MOV     R8,@>0058(R9)           save it in >8358
 539  442A 0058  
 540  442C 0228         AI      R8,-10                  point to disk drive info (drive #, last tracks)
 540  442E FFF6  
 541  4430 CA48         MOV     R8,@>0066(R9)           save in >8366: VDP stack ptr (DECT before writing)
 541  4432 0066  
 542  4434 0429         BLWP    @>005A(R9)              save R7 (return address)
 542  4436 005A  
 543  4438 0100         DATA    >0100                   
 544  443A C1E9         MOV     @>0056(R9),R7           ptr to PAB: end of DSR name
 544  443C 0056  
 545  443E C0C7         MOV     R7,R3                   save it
 546  4440 61E9         S       @>0054(R9),R7           start of DSR name
 546  4442 0054  
 547  4444 CA42         MOV     R2,@>0056(R9)           >8356: ptr to end-of-buffer word in VDP mem
 547  4446 0056  
 548  4448 0607         DEC     R7                      point to name length byte
 549  444A 04C2         CLR     R2                      
 550  444C 0429         BLWP    @>005A(R9)              set VDP to read from address in R2
 550  444E 005A  
 551  4450 00E2         DATA    >00E2                   
 552  4452 D0AF         MOVB    @-1026(R15),R2          get name length byte
 552  4454 FBFE  
 553  4456 06C2         SWPB    R2                      make it a word
 554  4458 60A9         S       @>0054(R9),R2           minus DSR name size: lenght of .parameters
 554  445A 0054  
 555  445C 0227         AI      R7,-9                   point to top of PAB
 555  445E FFF7  
 556  4460 CA47         MOV     R7,@>0054(R9)           save it in >8354
 556  4462 0054  
 557  4464 045A         B       *R10                    
 558            *                               
 559  4466 06A0 CRFIL1  BL      @CALSUB                 create file
 559  4468 432E  
 560  446A 4AD8         DATA    FNDFDR                  find a FDR in disk
 561  446C C104 CRFIL2  MOV     R4,R4                   found?
 562  446E 1604         JNE     CRFIL3                  no
 563  4470 06A0         BL      @CALSUB                 yes: delete old file
 563  4472 432E  
 564  4474 45B0         DATA    FFSVIB                  free file sector in VIB bitmap
 565  4476 1045         JMP     H077                    clear its FDR
 566            *                               
 567  4478 06A0 CRFIL3  BL      @INSFDR                 new file: insert a FDR in sector 1
 567  447A 47E0  
 568  447C 0701         SETO    R1                      
 569  447E 06A0         BL      @CALSUB                 call subroutine
 569  4480 432E  
 570  4482 4BCC         DATA    FFSBMP                  find a free sector in VIB bitmap
 571  4484 C000         MOV     R0,R0                   found?
 572  4486 1603         JNE     H078                    yes: # in R0
 573  4488 06A0         BL      @ERROR5                 no: update data, then return with error
 573  448A 4948  
 574  448C 8000         DATA    >8000                   memory full
 575            *                               
 576  448E 0429 H078    BLWP    @>005A(R9)              set VDP to write
 576  4490 005A  
 577  4492 0103         DATA    >0103                   address in R8
 578  4494 DBC0         MOVB    R0,@-2(R15)             write sector # for FDR in sector 1
 578  4496 FFFE  
 579  4498 06C0         SWPB    R0                      
 580  449A DBC0         MOVB    R0,@-2(R15)                     
 580  449C FFFE  
 581  449E 06C0         SWPB    R0                      
 582  44A0 C069         MOV     @>0056(R9),R1           ptr to FDR in VDP buffers
 582  44A2 0056  
 583  44A4 0221         AI      R1,-4                   ptr to sector # for FDR
 583  44A6 FFFC  
 584  44A8 0429         BLWP    @>005A(R9)              set VDP to write
 584  44AA 005A  
 585  44AC 0023         DATA    >0023                   address in R1
 586  44AE DBC0         MOVB    R0,@-2(R15)             write sector # for FDR in VDP buffer
 586  44B0 FFFE  
 587  44B2 06C0         SWPB    R0                      
 588  44B4 DBC0         MOVB    R0,@-2(R15)                     
 588  44B6 FFFE  
 589  44B8 0221         AI      R1,3                    ptr to drive #
 589  44BA 0003  
 590  44BC 0429         BLWP    @>005A(R9)              set VDP to write
 590  44BE 005A  
 591  44C0 0023         DATA    >0023                   address in R1
 592  44C2 DBC6         MOVB    R6,@-2(R15)             write drive # before FDR in VDP buffer
 592  44C4 FFFE  
 593  44C6 04C2         CLR     R2                      code for write
 594  44C8 0581         INC     R1                      
 595  44CA 06A0         BL      @CALSUB                 call subroutine
 595  44CC 432E  
 596  44CE 4A0C         DATA    WRSEC1                  write sector 1
 597  44D0 C169         MOV     @>0058(R9),R5           ptr to VIB in VDP buffers
 597  44D2 0058  
 598  44D4 04C4         CLR     R4                      sector 0
 599  44D6 06A0         BL      @CALSUB                 call subroutine
 599  44D8 432E  
 600  44DA 4A24         DATA    RWSEC                   write VIB to sector 0
 601  44DC C0C5         MOV     R5,R3                   copy filename from compare buffer to FDR
 602  44DE 0223         AI      R3,257                  ptr to file compare buffer
 602  44E0 0101  
 603  44E2 0202         LI      R2,10                   10 chars per filename
 603  44E4 000A  
 604  44E6 0429 H079    BLWP    @>005A(R9)              set VDP to read
 604  44E8 005A  
 605  44EA 0062         DATA    >0062                   address in R3
 606  44EC D02F         MOVB    @-1026(R15),R0          get 1 char
 606  44EE FBFE  
 607  44F0 0583         INC     R3                      increment source ptr
 608  44F2 0429         BLWP    @>005A(R9)              set VDP to write
 608  44F4 005A  
 609  44F6 0023         DATA    >0023                   address in R1
 610  44F8 DBC0         MOVB    R0,@-2(R15)             copy 1 char
 610  44FA FFFE  
 611  44FC 0581         INC     R1                      increment destination ptr
 612  44FE 0602         DEC     R2                      # of chars in R2
 613  4500 16F2         JNE     H079                    next
 614            *
 615  4502 06A0 H077    BL      @NTPDT                  APEDSK99: update DOAD FAT time/date
 615  4504 5F1A  
 616            *
 617  4506 C069         MOV     @>0056(R9),R1           FDR ptr
 617  4508 0056  
 618  450A 0221         AI      R1,10                   skip filename
 618  450C 000A  
 619  450E 0202         LI      R2,246                  remaining bytes in FDR
 619  4510 00F6  
 620  4512 0429         BLWP    @>005A(R9)              set VDP to write
 620  4514 005A  
 621  4516 0023         DATA    >0023                   address in R1
 622  4518 DBC2 H080    MOVB    R2,@-2(R15)             write >00
 622  451A FFFE  
 623  451C 0602         DEC     R2                      clear remainder of new FDR
 624  451E 16FC         JNE     H080                    next byte
 625  4520 1010         JMP     H081                    write FDR to disk return to caller
 626            *                                       
 627  4522 C169 H082    MOV     @>0056(R9),R5           check if FDR must be updated
 627  4524 0056  
 628  4526 0429         BLWP    @>005A(R9)              set VDP to read
 628  4528 005A  
 629  452A 00A2         DATA    >00A2                   address in R5
 630  452C D12F         MOVB    @-1026(R15),R4          get filename in file ctrl block
 630  452E FBFE  
 631  4530 1101         JLT     H083                    flag: FDR was modified, update it
 632  4532 100A         JMP     H084                    
 633  4534 0244 H083    ANDI    R4,>7F00                clear flag bit
 633  4536 7F00  
 634  4538 0429         BLWP    @>005A(R9)              st VDP to write
 634  453A 005A  
 635  453C 00A3         DATA    >00A3                   address in R5
 636  453E DBC4         MOVB    R4,@-2(R15)             write back filename without flag bit
 636  4540 FFFE  
 637  4542 04C2 H081    CLR     R2                      code for write
 638  4544 0460         B       @WRFDR                  write FDR to disk
 638  4546 4A16  
 639  4548 0460 H084    B       @RTURN1                 return to caller
 639  454A 434C  
 640            *                               
 641  454C 06A0 UPDFDR  BL      @CALSUB                 update FDR + data
 641  454E 432E  
 642  4550 456C         DATA    UPDBF                   update data buffer if necessary
 643  4552 06A0         BL      @CALSUB                 call subroutine
 643  4554 432E  
 644  4556 4522         DATA    H082                    update FDR if necessary
 645  4558 C169 CLRFBT  MOV     @>0056(R9),R5                   
 645  455A 0056  
 646  455C 04C6         CLR     R6                      
 647  455E 0429         BLWP    @>005A(R9)              set VDP to write
 647  4560 005A  
 648  4562 00A3         DATA    >00A3                   address in R5
 649  4564 DBC6         MOVB    R6,@-2(R15)             clr first byte of filename in FDR
 649  4566 FFFE  
 650  4568 0460         B       @RWVIB                  
 650  456A 49A8  
 651            *                                       
 652  456C C129 UPDBF   MOV     @>0056(R9),R4           check if data buffer must be updated
 652  456E 0056  
 653  4570 0604         DEC     R4                      
 654  4572 0429         BLWP    @>005A(R9)              set VDP to read
 654  4574 005A  
 655  4576 0082         DATA    >0082                   address in R4
 656  4578 D06F         MOVB    @-1026(R15),R1          get drive #
 656  457A FBFE  
 657  457C 1101         JLT     H085                    flag: must be updated
 658  457E 1016         JMP     H086                    no need to update: return
 659  4580 0241 H085    ANDI    R1,>7F00                erase flag
 659  4582 7F00  
 660  4584 0429         BLWP    @>005A(R9)              set VDP to write
 660  4586 005A  
 661  4588 0083         DATA    >0083                   address in R4
 662  458A DBC1         MOVB    R1,@-2(R15)             write back drive # without flag
 662  458C FFFE  
 663  458E 0224         AI      R4,-5                   point to current logical record offset
 663  4590 FFFB  
 664  4592 0429         BLWP    @>005A(R9)              set VDP to read
 664  4594 005A  
 665  4596 0082         DATA    >0082                   address in R4
 666  4598 D0EF         MOVB    @-1026(R15),R3          get current logical record offset
 666  459A FBFE  
 667  459C 06C3         SWPB    R3                      
 668  459E D0EF         MOVB    @-1026(R15),R3                  
 668  45A0 FBFE  
 669  45A2 06C3         SWPB    R3                      
 670  45A4 C1C4         MOV     R4,R7                   
 671  45A6 0227         AI      R7,262                  point to data buffer area
 671  45A8 0106  
 672  45AA 103A         JMP     WROFSC                  
 673  45AC 0460 H086    B       @RTURN1                 return to caller
 673  45AE 434C  
 674            *                               
 675  45B0 C0A9 FFSVIB  MOV     @>0056(R9),R2           free file sectors in VIB bitmap
 675  45B2 0056  
 676  45B4 0222         AI      R2,12                   
 676  45B6 000C  
 677  45B8 0429         BLWP    @>005A(R9)              set VDP to read
 677  45BA 005A  
 678  45BC 0042         DATA    >0042                   address in R2
 679  45BE D02F         MOVB    @-1026(R15),R0          get file status byte from FDR
 679  45C0 FBFE  
 680  45C2 0240         ANDI    R0,>0800                write protected?
 680  45C4 0800  
 681  45C6 1303         JEQ     H087                    no
 682  45C8 06A0         BL      @ERROR5                 update data if needed, the return with error
 682  45CA 4948  
 683  45CC 2000         DATA    >2000                   write protected
 684            *                                       
 685  45CE C229 H087    MOV     @>0056(R9),R8           get ptr to FDR
 685  45D0 0056  
 686  45D2 0228         AI      R8,28                   point to clusters list
 686  45D4 001C  
 687  45D6 0704         SETO    R4                      previous offset
 688  45D8 06A0 H089    BL      @DECDCI                 decode cluster info: sector in R1, offset in R2
 688  45DA 4B8C  
 689  45DC 0228         AI      R8,3                    next cluster ptr
 689  45DE 0003  
 690  45E0 C041         MOV     R1,R1                   
 691  45E2 130C         JEQ     H088                    sector 0 = no more clusters
 692  45E4 C002         MOV     R2,R0                   total offset
 693  45E6 6084         S       R4,R2                   minus previous cluster offset = cluster size
 694  45E8 C100         MOV     R0,R4                   new previous cluster offset
 695  45EA 06A0         BL      @CALSUB                 call subroutine
 695  45EC 432E  
 696  45EE 4C98         DATA    FRSCB1                  free sectors in bitmap (from R1, # in R2)
 697  45F0 C048         MOV     R8,R1                   
 698  45F2 6069         S       @>0056(R9),R1                   
 698  45F4 0056  
 699  45F6 0281         CI      R1,>0100                end of FDR reached?
 699  45F8 0100  
 700  45FA 16EE         JNE     H089                    not yet
 701  45FC 0460 H088    B       @RTURN1                 return to caller
 701  45FE 434C  
 702            *                                       
 703  4600 06A0 RDOFSC  BL      @FDR2B1                 read a sector from offset in file
 703  4602 4846  
 704  4604 000E         DATA    14                      get # of sectors
 705  4606 80C0         C       R0,R3                   is desired sector in file?
 706  4608 1B03         JH      H090                    yes
 707  460A 06A0         BL      @ERROR5                 no: update data, then return with error
 707  460C 4948  
 708  460E A000         DATA    >A000                   past end-of-file
 709  4610 06A0 H090    BL      @CALSUB                 call subroutine
 709  4612 432E  
 710  4614 4720         DATA    FSCTOF                  find sector from cluster list
 711  4616 A101         A       R1,R4                   put sector in R4
 712  4618 0702         SETO    R2                      code for read
 713  461A C147 H091    MOV     R7,R5                   buffer ptr
 714  461C 0460         B       @RWSEC                  read/write sector
 714  461E 4A24  
 715            *                                       
 716  4620 0429 WROFSC  BLWP    @>005A(R9)              write sector to offset in file offset in R3
 716  4622 005A  
 717  4624 8100         DATA    >8100                   save R0 and R7
 718  4626 06A0         BL      @CALSUB                 call subroutine
 718  4628 432E  
 719  462A 4636         DATA    APSCTS                  append enough sectors to reach that offset
 720  462C 0429         BLWP    @>005A(R9)              retrieve R0 and R7
 720  462E 005A  
 721  4630 8101         DATA    >8101                   
 722  4632 04C2         CLR     R2                      code for write
 723  4634 10F2         JMP     H091                    write sector
 724            *                               
 725  4636 06A0 APSCTS  BL      @FDR2B1                 append sector(s) to a file to get offset in R3
 725  4638 4846  
 726  463A 000E         DATA    14                      get # of sect from FDR
 727            *                                       
 728  463C 80C0         C       R0,R3                   is desired sector in file?
 729  463E 1B47         JH      H092                    yes: find it and return
 730  4640 C000         MOV     R0,R0                   
 731  4642 1301         JEQ     H093                    empty file
 732  4644 0600         DEC     R0                      last sector #
 733  4646 C143 H093    MOV     R3,R5                   save desired sector offset
 734  4648 C0C0         MOV     R0,R3                   last sector in file
 735  464A 06A0         BL      @CALSUB                 call subroutine
 735  464C 432E  
 736  464E 4720         DATA    FSCTOF                  find sector # from offset in file
 737  4650 0429         BLWP    @>005A(R9)              save R1 (sector #)
 737  4652 005A  
 738  4654 4000         DATA    >4000                   
 739  4656 A044         A       R4,R1                   # of last sector in cluster
 740  4658 C105         MOV     R5,R4                   offset of desired sector
 741  465A 06A0 H095    BL      @CALSUB                 call subroutine
 741  465C 432E  
 742  465E 4BCC         DATA    FFSBMP                  find free sector in bitmap, starting from R1
 743  4660 C000         MOV     R0,R0                   found?
 744  4662 1604         JNE     H094                    yes: # in R0
 745  4664 C142         MOV     R2,R5                   no: save # of sectors
 746  4666 06A0         BL      @ADDSEC                 update FDR
 746  4668 46DA  
 747  466A 101B         JMP     H096                    return with memory full
 748            *                                       
 749  466C C041 H094    MOV     R1,R1                   
 750  466E 1320         JEQ     H097                    empty cluster
 751  4670 0581         INC     R1                      one more sector in cluster
 752  4672 8040         C       R0,R1                   same as the one found in bitmap?
 753  4674 131C         JEQ     H098                    yes: just increase cluster size
 754  4676 0429         BLWP    @>005A(R9)              no: retrieve R1 (sector #)
 754  4678 005A  
 755  467A 4001         DATA    >4001                   
 756  467C 0429         BLWP    @>005A(R9)              save R0 + R2
 756  467E 005A  
 757  4680 A000         DATA    >A000                   
 758  4682 06A0         BL      @UPDCLI                 update current cluster info
 758  4684 4BA8  
 759  4686 0429         BLWP    @>005A(R9)              retrieve R0 + R2
 759  4688 005A  
 760  468A A001         DATA    >A001                   
 761  468C 0228         AI      R8,3                    ptr to next cluster info
 761  468E 0003  
 762  4690 C048         MOV     R8,R1                   
 763  4692 6069         S       @>0056(R9),R1           current FDR size
 763  4694 0056  
 764  4696 0281         CI      R1,>0100                room enough?
 764  4698 0100  
 765  469A 1605         JNE     H099                    yes
 766  469C 06A0         BL      @CALSUB                 no: call subroutine
 766  469E 432E  
 767  46A0 4C92         DATA    FFSBM                   free sector in bitmap
 768  46A2 0460 H096    B       @ERROR6                 return with memory full
 768  46A4 4AFE  
 769            *                                       
 770  46A6 C040 H099    MOV     R0,R1                   new sector #
 771  46A8 0429         BLWP    @>005A(R9)              save R1
 771  46AA 005A  
 772  46AC 4000         DATA    >4000                   
 773  46AE 1007 H098    JMP     H100                    make a new cluster
 774            *                                       
 775  46B0 0429 H097    BLWP    @>005A(R9)              retrieve R1
 775  46B2 005A  
 776  46B4 4001         DATA    >4001                   
 777  46B6 0429         BLWP    @>005A(R9)              save R0
 777  46B8 005A  
 778  46BA 8000         DATA    >8000                   
 779  46BC 0702         SETO    R2                      empty file: start from offset 0
 780  46BE C040 H100    MOV     R0,R1                   sector #
 781  46C0 0582         INC     R2                      increment cluster size
 782  46C2 8102         C       R2,R4                   enough?
 783  46C4 16CA         JNE     H095                    no: get one more sector
 784  46C6 C144         MOV     R4,R5                   
 785  46C8 06A0         BL      @ADDSEC                 add sector to FDR
 785  46CA 46DA  
 786  46CC 1004         JMP     H101                    done
 787            *                               
 788  46CE 06A0 H092    BL      @CALSUB                 call subroutine
 788  46D0 432E  
 789  46D2 4720         DATA    FSCTOF                  find a sector from offset in file
 790  46D4 A101         A       R1,R4                   last sector in cluster
 791  46D6 0460 H101    B       @RTURN1                 return to caller
 791  46D8 434C  
 792            *                                       
 793  46DA C28B ADDSEC  MOV     R11,R10                 add sector to FDR
 794  46DC C101         MOV     R1,R4                   
 795  46DE 0429         BLWP    @>005A(R9)              retrieve R1
 795  46E0 005A  
 796  46E2 4001         DATA    >4001                   
 797  46E4 C041         MOV     R1,R1                   sector #
 798  46E6 131B         JEQ     H102                    none: return
 799  46E8 06A0         BL      @UPDCLI                 write info for R1 cluster
 799  46EA 4BA8  
 800  46EC C0A9         MOV     @>0056(R9),R2           pointer to FDR
 800  46EE 0056  
 801  46F0 0429         BLWP    @>005A(R9)              set VDP to read
 801  46F2 005A  
 802  46F4 0042         DATA    >0042                   address in R2
 803  46F6 D06F         MOVB    @-1026(R15),R1          first char of filename
 803  46F8 FBFE  
 804  46FA 0261         ORI     R1,>8000                flag
 804  46FC 8000  
 805  46FE 0429         BLWP    @>005A(R9)              set VDP to write
 805  4700 005A  
 806  4702 0043         DATA    >0043                   address in R2
 807  4704 DBC1         MOVB    R1,@-2(R15)                     
 807  4706 FFFE  
 808  4708 0222         AI      R2,14                   ptr to # of sectors
 808  470A 000E  
 809  470C 0585         INC     R5                      new # of sectors
 810  470E 0429         BLWP    @>005A(R9)              set VDP to write
 810  4710 005A  
 811  4712 0043         DATA    >0043                   address in R2
 812  4714 DBC5         MOVB    R5,@-2(R15)             update # of sectors
 812  4716 FFFE  
 813  4718 06C5         SWPB    R5                      
 814  471A DBC5         MOVB    R5,@-2(R15)                     
 814  471C FFFE  
 815  471E 045A H102    B       *R10                    
 816            *                                       
 817  4720 C229 FSCTOF  MOV     @>0056(R9),R8           find sector from offset in file
 817  4722 0056  
 818  4724 0228         AI      R8,28                   cluster list
 818  4726 001C  
 819  4728 C103         MOV     R3,R4                   desired sector offset is in R3
 820  472A 06A0 H105    BL      @DECDCI                 decode info: sector in R1, offset in R2
 820  472C 4B8C  
 821  472E 80C2         C       R2,R3                   reached yet?
 822  4730 1101         JLT     H103                    no
 823  4732 1006         JMP     H104                    yes: return
 824  4734 0228 H103    AI      R8,3                    point to next cluster info
 824  4736 0003  
 825  4738 C103         MOV     R3,R4                   
 826  473A 6102         S       R2,R4                   
 827  473C 0604         DEC     R4                      size of the desired cluster (if it's the next)
 828  473E 10F5         JMP     H105                    keep trying
 829  4740 0460 H104    B       @RTURN1                 return to caller
 829  4742 434C  
 830            *
 831            *---------------------------------
 832            * Opcode 7: Delete
 833            * ----------------
 834            * PAB 0: >07
 835            *     1:            <--- error code
 836            *   2-3:
 837            *     4:
 838            *     5:
 839            *   6-7:
 840            *     8:
 841            *---------------------------------                                      
 842            *
 843  4744 06A0 DELETE  BL      @CALSUB                 delete file
 843  4746 432E  
 844  4748 4A7A         DATA    FFFDRV                  find file FDR in VDP buffers
 845  474A C104         MOV     R4,R4                   found?
 846  474C 1307         JEQ     H106                    yes
 847  474E 06A0         BL      @CALSUB                 no: call subroutine
 847  4750 432E  
 848  4752 4AE2         DATA    FFDRDK                  find FDR on disk
 849  4754 C104         MOV     R4,R4                   found?
 850  4756 1313         JEQ     H107                    yes
 851  4758 0460         B       @RTURN1                 no: return to caller
 851  475A 434C  
 852            *                                       
 853  475C 0581 H106    INC     R1                      FDR found, point to it
 854  475E CA41         MOV     R1,@>0056(R9)           save it for other routines
 854  4760 0056  
 855  4762 06A0         BL      @CALSUB                 call subroutine
 855  4764 432E  
 856  4766 4A0A         DATA    RDSEC1                  read sector 1
 857  4768 06A0         BL      @FDR2B1                 read 2 bytes from VDP at >8356+offset
 857  476A 4846  
 858  476C FFFC         DATA    -4                      i.e. get sector # of FRD in R0
 859  476E C0C0         MOV     R0,R3                   save it for later
 860  4770 C205         MOV     R5,R8                   ptr to top of sector 1
 861  4772 06A0 H108    BL      @VDPR2B                 read 2 bytes from VDP at R8 into R0
 861  4774 484C  
 862  4776 05C8         INCT    R8                      next FDR ptr in sector 1
 863  4778 80C0         C       R0,R3                   is this the one we want?
 864  477A 16FB         JNE     H108                    not yet
 865  477C 0648         DECT    R8                      yes: point back to it
 866            *
 867  477E 06A0 H107    BL      @NTPDT                  APEDSK99: update DOAD FAT time/date
 867  4780 5F1A  
 868            *
 869  4782 0429         BLWP    @>005A(R9)              save R8
 869  4784 005A  
 870  4786 0080         DATA    >0080                   
 871  4788 06A0         BL      @CALSUB                 call subroutine
 871  478A 432E  
 872  478C 45B0         DATA    FFSVIB                  free file sectors in VIB bitmap
 873  478E 0429         BLWP    @>005A(R9)              retrieve R8
 873  4790 005A  
 874  4792 0081         DATA    >0081                   
 875  4794 06A0         BL      @RMFPTR                 remove FDR ptr from sector 1
 875  4796 47B0  
 876  4798 04C2         CLR     R2                      code for write
 877  479A 06A0         BL      @CALSUB                 call subroutine
 877  479C 432E  
 878  479E 4A0C         DATA    WRSEC1                  write sector 1
 879  47A0 06A0         BL      @FDR2B1                 get 2 bytes from VDP at >8356+offset in R0
 879  47A2 4846  
 880  47A4 FFFC         DATA    -4                      i.e. sector # of FDR
 881  47A6 06A0         BL      @CALSUB                 call subroutine
 881  47A8 432E  
 882  47AA 4C92         DATA    FFSBM                   free sector in R0 in VIB bitmap
 883  47AC 0460         B       @CLRFBT                 clear 1rst byte of filename in VDP
 883  47AE 4558  
 884            *
 885            * Sector 1 contains an alphabetically sorted list of FDR pointers
 886            * Each pointer is 2 bytes long and contains the sector # of this FDR
 887            * The list must end with a >0000 mark. Thus there can be 127 files at most
 888            *
 889  47B0 C169 RMFPTR  MOV     @>0056(R9),R5           remove FDR ptr from sector 1
 889  47B2 0056  
 890  47B4 0225         AI      R5,256                  
 890  47B6 0100  
 891  47B8 C0C5         MOV     R5,R3                   pointer to data buffer
 892  47BA 0223         AI      R3,256                  point to next ctrl block
 892  47BC 0100  
 893  47BE C088         MOV     R8,R2                   shift up FDR list, erasing FDR pointed by R8
 894  47C0 05C2         INCT    R2                      point to next FDR ptr in sector 1
 895  47C2 0429 H109    BLWP    @>005A(R9)              set VDP to read
 895  47C4 005A  
 896  47C6 0042         DATA    >0042                   address in R2
 897  47C8 D02F         MOVB    @-1026(R15),R0          get 1 byte
 897  47CA FBFE  
 898  47CC 0582         INC     R2                      inc source ptr
 899  47CE 0429         BLWP    @>005A(R9)              set VDP to write
 899  47D0 005A  
 900  47D2 0103         DATA    >0103                   address in R8
 901  47D4 DBC0         MOVB    R0,@-2(R15)             copy 1 byte
 901  47D6 FFFE  
 902  47D8 0588         INC     R8                      inc dest pointer
 903  47DA 80C2         C       R2,R3                   done?
 904  47DC 16F2         JNE     H109                    not yet
 905  47DE 045B         B       *R11                    
 906            *                                       
 907  47E0 C28B INSFDR  MOV     R11,R10                 insert a FDR in sector 1
 908  47E2 C048         MOV     R8,R1                   
 909  47E4 06A0         BL      @FDR2B1                 get 2 bytes from VDP at >8356+offset
 909  47E6 4846  
 910  47E8 01FC         DATA    508                     i.e. last FDR slot in sector 1 (list ends with 0)
 911  47EA C000         MOV     R0,R0                   
 912  47EC 1302         JEQ     H110                    
 913  47EE 0460         B       @ERROR6                 memory full error
 913  47F0 4AFE  
 914  47F2 0608 H110    DEC     R8                      previous byte
 915  47F4 0429         BLWP    @>005A(R9)              set VDP to read
 915  47F6 005A  
 916  47F8 0102         DATA    >0102                   address in R8
 917  47FA D02F         MOVB    @-1026(R15),R0          get 1 byte
 917  47FC FBFE  
 918  47FE 05C8         INCT    R8                      
 919  4800 0429         BLWP    @>005A(R9)              set VDP to write
 919  4802 005A  
 920  4804 0103         DATA    >0103                   address in R8
 921  4806 DBC0         MOVB    R0,@-2(R15)             copy byte two bytes further down
 921  4808 FFFE  
 922  480A 0648         DECT    R8                      
 923  480C 8048         C       R8,R1                   done ?
 924  480E 16F1         JNE     H110                    not yet
 925  4810 045A         B       *R10                    
 926            *                               
 927  4812 C0A9 CMPFN   MOV     @>0058(R9),R2           compare filenames
 927  4814 0058  
 928  4816 0222         AI      R2,256                  
 928  4818 0100  
 929  481A 0429 H111    BLWP    @>005A(R9)              set VDP to read
 929  481C 005A  
 930  481E 0022         DATA    >0022                   address in R1 (ptr to filename)
 931  4820 D02F         MOVB    @-1026(R15),R0          get 1 char
 931  4822 FBFE  
 932  4824 0240         ANDI    R0,>7FFF                clear flag (on drive #)
 932  4826 7FFF  
 933  4828 0429         BLWP    @>005A(R9)              set VDP to read
 933  482A 005A  
 934  482C 0042         DATA    >0042                   address in R2 (filename compare buffer)
 935  482E D0EF         MOVB    @-1026(R15),R3          get 1 char
 935  4830 FBFE  
 936  4832 90C0         CB      R0,R3                   compare chars
 937  4834 1604         JNE     H112                    mismatch
 938  4836 0581         INC     R1                      match: increment pointers
 939  4838 0582         INC     R2                      
 940  483A 0604         DEC     R4                      
 941  483C 16EE         JNE     H111                    next char
 942  483E 045B H112    B       *R11                    if complete match: ret with EQ set
 943            *                                       
 944  4840 C229 PABR2B  MOV     @>0054(R9),R8           get two bytes from PAB
 944  4842 0054  
 945  4844 1002         JMP     FDR2B2                  
 946            *                                       
 947  4846 C229 FDR2B1  MOV     @>0056(R9),R8           get two bytes from FDR
 947  4848 0056  
 948  484A A23B FDR2B2  A       *R11+,R8                offset in data word
 949            *                                       
 950  484C 0429 VDPR2B  BLWP    @>005A(R9)              get two byte from VDP at R8
 950  484E 005A  
 951  4850 0102         DATA    >0102                   set VDP to read at R8
 952  4852 D02F         MOVB    @-1026(R15),R0          get two bytes of data
 952  4854 FBFE  
 953  4856 06C0         SWPB    R0                      
 954  4858 D02F         MOVB    @-1026(R15),R0                  
 954  485A FBFE  
 955  485C 0B80         SRC     R0,8                    why not swpb ?
 956  485E 045B         B       *R11                    
 957            *                       
 958  4860 C069 FDSKDR  MOV     @>0058(R9),R1           find disk from name (ptr in R3)
 958  4862 0058  
 959  4864 0221         AI      R1,256                  
 959  4866 0100  
 960  4868 06A0         BL      @CPCKFN                 copy filename from VDP at R3 to compare buffer
 960  486A 48EA  
 961  486C 0429         BLWP    @>005A(R9)              save R2 + R3
 961  486E 005A  
 962  4870 3000         DATA    >3000                   
 963  4872 C000         MOV     R0,R0                   last char copied
 964  4874 1101         JLT     H113                    flagged
 965  4876 1005         JMP     H114                    
 966  4878 C180 H113    MOV     R0,R6                   
 967  487A 0246         ANDI    R6,>0300                        
 967  487C 0300  
 968  487E 1337         JEQ     ERROR7                  return with file error
 969  4880 102F         JMP     H115                    return to caller
 970  4882 04C6 H114    CLR     R6                      don't read any drive
 971  4884 06A0         BL      @CALSUB                 call subroutine
 971  4886 432E  
 972  4888 49A8         DATA    RWVIB                   save current VIB
 973  488A 0226 H116    AI      R6,>0100                next drive
 973  488C 0100  
 974  488E 0707         SETO    R7                      error flags
 975  4890 0702         SETO    R2                      code for read
 976  4892 04C4         CLR     R4                      sector 0
 977  4894 06A0         BL      @CALSUB                 call subroutine
 977  4896 432E  
 978  4898 4A26         DATA    RWSECA                  read sector 0
 979  489A C1C7         MOV     R7,R7                   ok?
 980  489C 161D         JNE     H118                    no: try next drive
 981  489E 0204         LI      R4,10                   yes: diskname size
 981  48A0 000A  
 982  48A2 C069         MOV     @>0058(R9),R1           VIB ptr
 982  48A4 0058  
 983  48A6 0429         BLWP    @>005A(R9)              save R1-R3
 983  48A8 005A  
 984  48AA 7000         DATA    >7000                   
 985  48AC 06A0         BL      @CMPFN                  compare names (ptr in R1 + compare buffer)
 985  48AE 4812  
 986  48B0 0429         BLWP    @>005A(R9)                      
 986  48B2 005A  
 987  48B4 7001         DATA    >7001                   retrieve R1-R3
 988  48B6 C104         MOV     R4,R4                   name matched?
 989  48B8 160F         JNE     H118                    no: try next drive
 990  48BA C006         MOV     R6,R0                   drive #
 991  48BC 0260         ORI     R0,>8000                add update flag
 991  48BE 8000  
 992  48C0 0429         BLWP    @>005A(R9)              set VDP to write
 992  48C2 005A  
 993  48C4 0063         DATA    >0063                   address in R3
 994  48C6 DBC0         MOVB    R0,@-2(R15)             copy drive+flag before diskname in source
 994  48C8 FFFE  
 995  48CA 0605         DEC     R5                      before sector 0 copy
 996  48CC 0429         BLWP    @>005A(R9)              set VDP to write
 996  48CE 005A  
 997  48D0 00A3         DATA    >00A3                   address in R5
 998  48D2 DBC6         MOVB    R6,@-2(R15)             copy drive # before VIB
 998  48D4 FFFE  
 999  48D6 1004         JMP     H115                    done
1000            *                               
1001  48D8 0286 H118    CI      R6,>0300                did we do all drives?
1001  48DA 0300  
1002  48DC 16D6         JNE     H116                    no: try next on
1003  48DE 1007         JMP     ERROR7                  return with file error
1004            *                                       
1005  48E0 0429 H115    BLWP    @>005A(R9)              retrieve R2 + R3
1005  48E2 005A  
1006  48E4 3001         DATA    >3001                   
1007  48E6 0460         B       @RTURN1                 return to caller
1007  48E8 434C  
1008            *                               
1009  48EA 0602 CPCKFN  DEC     R2                      
1010  48EC 1B03         JH      H119                    
1011  48EE 06A0 ERROR7  BL      @RETERR                 return with error
1011  48F0 4974  
1012  48F2 E000         DATA    >E000                   file error
1013            *                                       
1014  48F4 0200 H119    LI      R0,>2000                copy (+check) filename in VDP from R3 to R1 (space)
1014  48F6 2000  
1015  48F8 0429         BLWP    @>005A(R9)              set VDP to write
1015  48FA 005A  
1016  48FC 0023         DATA    >0023                   address in R1
1017  48FE 0208         LI      R8,10                   10 chars per filename
1017  4900 000A  
1018  4902 DBC0 H120    MOVB    R0,@-2(R15)             fill filename with spaces
1018  4904 FFFE  
1019  4906 0608         DEC     R8                      
1020  4908 16FC         JNE     H120                    
1021  490A 0208         LI      R8,11                   11 chars countring drive #
1021  490C 000B  
1022  490E 0583 H122    INC     R3                      increment source ptr
1023  4910 0429         BLWP    @>005A(R9)              set VDP to read
1023  4912 005A  
1024  4914 0062         DATA    >0062                   address in R3
1025  4916 D02F         MOVB    @-1026(R15),R0          get a char
1025  4918 FBFE  
1026  491A 13E9         JEQ     ERROR7                  >00: return with file error
1027  491C 1110         JLT     H121                    flag bit set
1028  491E 0280         CI      R0,>2E00                        
1028  4920 2E00  
1029  4922 130D         JEQ     H121                    '.'
1030  4924 0608         DEC     R8                      
1031  4926 13E3         JEQ     ERROR7                  name to long: return with file error
1032  4928 0280         CI      R0,>2000                        
1032  492A 2000  
1033  492C 13E0         JEQ     ERROR7                  name can't contain spaces: file error again
1034  492E 0429         BLWP    @>005A(R9)              set VDP to write
1034  4930 005A  
1035  4932 0023         DATA    >0023                   address in R1
1036  4934 DBC0         MOVB    R0,@-2(R15)             copy 1 char
1036  4936 FFFE  
1037  4938 0581         INC     R1                      increment destination pointer
1038  493A 0602         DEC     R2                      more?
1039  493C 16E8         JNE     H122                    yes
1040  493E 0288 H121    CI      R8,>000B                name can't be 0 chars long
1040  4940 000B  
1041  4942 13D5         JEQ     ERROR7                  else return with file error
1042  4944 045B         B       *R11                    
1043            *                                       
1044  4946 AA00 K014    DATA    >AA00                   
1045            *                               
1046  4948 C00B ERROR5  MOV     R11,R0                  update data, then error
1047  494A C0E9         MOV     @>0056(R9),R3           
1047  494C 0056  
1048  494E 0603         DEC     R3                      see what >8356 is pointing at
1049  4950 0429         BLWP    @>005A(R9)              set VDP to read
1049  4952 005A  
1050  4954 0062         DATA    >0062                   address in R3
1051  4956 D0AF         MOVB    @-1026(R15),R2          get 1 byte
1051  4958 FBFE  
1052  495A 9802         CB      R2,@K014                is it >AA (disk buffer area mark)
1052  495C 4946  
1053  495E 1309         JEQ     H123                    yes: announce error (code in data word)
1054  4960 0429         BLWP    @>005A(R9)              no: >8356 points to a FDR. Save R0
1054  4962 005A  
1055  4964 8000         DATA    >8000                   
1056  4966 06A0         BL      @CALSUB                 call subroutine
1056  4968 432E  
1057  496A 454C         DATA    UPDFDR                  update FRD and data buffer if needed
1058  496C 0429         BLWP    @>005A(R9)              retrieve R0
1058  496E 005A  
1059  4970 8001         DATA    >8001                   
1060  4972 C2C0 H123    MOV     R0,R11                  
1061            *                               
1062  4974 C069 RETERR  MOV     @>0054(R9),R1           annouce error
1062  4976 0054  
1063  4978 130D         JEQ     H124                    no PAB
1064  497A 0581         INC     R1                      for DSRs: ptr to status byte
1065  497C 0429         BLWP    @>005A(R9)              set VDP to read
1065  497E 005A  
1066  4980 0022         DATA    >0022                   address in R2
1067  4982 D0AF         MOVB    @-1026(R15),R2          get file status byte
1067  4984 FBFE  
1068  4986 E0BB         SOC     *R11+,R2                add error code
1069  4988 0429         BLWP    @>005A(R9)              set VDP to write
1069  498A 005A  
1070  498C 0023         DATA    >0023                   address in R2
1071  498E DBC2         MOVB    R2,@-2(R15)             write back status byte
1071  4990 FFFE  
1072  4992 1002         JMP     H125                    
1073  4994 CA7B H124    MOV     *R11+,@>0050(R9)        for subs: error code in >8350
1073  4996 0050  
1074  4998 C229 H125    MOV     @>0058(R9),R8           get stack ptr
1074  499A 0058  
1075  499C 0228         AI      R8,-12                  point back to initial caller
1075  499E FFF4  
1076  49A0 CA48         MOV     R8,@>0066(R9)           update pointer
1076  49A2 0066  
1077  49A4 0460         B       @RTURN1                 return to caller
1077  49A6 434C  
1078            *                               
1079  49A8 0429 RWVIB   BLWP    @>005A(R9)              read VIB (drive # in R6)
1079  49AA 005A  
1080  49AC 3000         DATA    >3000                   save R2 + R3
1081  49AE C169         MOV     @>0058(R9),R5           pointer to VIB in ctrl block
1081  49B0 0058  
1082  49B2 0605         DEC     R5                      ptr to drive #
1083  49B4 0429         BLWP    @>005A(R9)              set VDP for read
1083  49B6 005A  
1084  49B8 00A2         DATA    >00A2                   address in R5
1085  49BA D0AF         MOVB    @-1026(R15),R2          get drive #
1085  49BC FBFE  
1086  49BE C0C2         MOV     R2,R3                   
1087  49C0 04C4         CLR     R4                      sector 0 for VIB
1088  49C2 0242         ANDI    R2,>0300                clear flag (>80 = update data)
1088  49C4 0300  
1089  49C6 9182         CB      R2,R6                   wanted drive?
1090  49C8 131A         JEQ     H126                    yes: return
1091  49CA C0C3         MOV     R3,R3                   no: shall we update VIB?
1092  49CC 1101         JLT     H127                    yes
1093  49CE 100A         JMP     H128                    no
1094  49D0 0429 H127    BLWP    @>005A(R9)              set VDP to write
1094  49D2 005A  
1095  49D4 00A3         DATA    >00A3                   address in R5
1096  49D6 DBC4         MOVB    R4,@-2(R15)             clr drive #
1096  49D8 FFFE  
1097  49DA 0585         INC     R5                      point back to VIB buffer
1098  49DC 06A0         BL      @CALSUB                 call subroutine
1098  49DE 432E  
1099  49E0 4A28         DATA    RWSECB                  write sector 0 to old drive (in R2)
1100  49E2 0605         DEC     R5                      point to drive #
1101  49E4 0702 H128    SETO    R2                      flag for read
1102  49E6 D086         MOVB    R6,R2                   APEDSK99: error in original disassembly (was R5)
1103  49E8 1305         JEQ     H129                    none
1104  49EA 0585         INC     R5                      point at VIB buffer
1105  49EC 06A0         BL      @CALSUB                 call subroutine
1105  49EE 432E  
1106  49F0 4A26         DATA    RWSECA                  read sector (in R4) to buffer (in R5)
1107  49F2 0605         DEC     R5                      point at drive #
1108  49F4 0429 H129    BLWP    @>005A(R9)              set VDP to write
1108  49F6 005A  
1109  49F8 00A3         DATA    >00A3                   address in R5
1110  49FA DBC6         MOVB    R6,@-2(R15)             write drive # in control block, before FDR
1110  49FC FFFE  
1111  49FE 0585 H126    INC     R5                      point back to FDR
1112  4A00 0429         BLWP    @>005A(R9)                      
1112  4A02 005A  
1113  4A04 3001         DATA    >3001                   retrieve R2 + R3 from stack
1114  4A06 0460         B       @RTURN1                 branch to address on stack
1114  4A08 434C  
1115            *                               
1116  4A0A 0702 RDSEC1  SETO    R2                      read sector 1
1117  4A0C 0204 WRSEC1  LI      R4,1
1117  4A0E 0001  
1118  4A10 0205         LI      R5,>0100                into data buffer area of current ctrl block
1118  4A12 0100  
1119  4A14 1005         JMP     RDFDR1                  
1120            *                               
1121  4A16 06A0 WRFDR   BL      @FDR2B1                 read FDR
1121  4A18 4846  
1122  4A1A FFFC         DATA    -4                      get sector # of FDR from control block
1123            *                               
1124  4A1C C100 RDFDR2  MOV     R0,R4                   sector read/write
1125  4A1E 04C5         CLR     R5
1126  4A20 A169 RDFDR1  A       @>0056(R9),R5           point to FDR or data buffer
1126  4A22 0056  
1127  4A24 04C7 RWSEC   CLR     R7                      
1128  4A26 D086 RWSECA  MOVB    R6,R2                   add drive # for r/w flag
1129  4A28 0429 RWSECB  BLWP    @>005A(R9)              save R0-R8
1129  4A2A 005A  
1130  4A2C FF80         DATA    >FF80                   
1131  4A2E CA44         MOV     R4,@>004A(R9)           sector #
1131  4A30 004A  
1132  4A32 CA42         MOV     R2,@>004C(R9)           drive | r/w flag
1132  4A34 004C  
1133  4A36 CA45         MOV     R5,@>004E(R9)           buffer ptr
1133  4A38 004E  
1134  4A3A 06A0         BL      @CALSUB                 call subroutine
1134  4A3C 432E  
1135  4A3E 4184         DATA    SECRW1                  sector read/write
1136  4A40 0429         BLWP    @>005A(R9)              retrieve R0-R8
1136  4A42 005A  
1137  4A44 FF81         DATA    >FF81                   
1138  4A46 D1E9         MOVB    @>0050(R9),R7           get error code | flags
1138  4A48 0050  
1139  4A4A 06C7         SWPB    R7                      
1140  4A4C 1312         JEQ     H130                    
1141  4A4E C1C7         MOV     R7,R7                   
1142  4A50 1501         JGT     H131                    
1143  4A52 100B         JMP     H132                    
1144  4A54 0247 H131    ANDI    R7,>00FF                        
1144  4A56 00FF  
1145  4A58 0287         CI      R7,>0034                        
1145  4A5A 0034  
1146  4A5C 1603         JNE     H133                    
1147  4A5E 06A0         BL      @ERROR5                 
1147  4A60 4948  
1148  4A62 2000         DATA    >2000                   write protected
1149  4A64 06A0 H133    BL      @ERROR5                 
1149  4A66 4948  
1150  4A68 C000         DATA    >C000                   device error
1151  4A6A DA69 H132    MOVB    @>004D(R9),@>004D(R9)   read or write?
1151  4A6C 004D  
1151  4A6E 004D  
1152  4A70 13F1         JEQ     H131                    write
1153  4A72 0247 H130    ANDI    R7,>00FF                        
1153  4A74 00FF  
1154  4A76 0460         B       @RTURN1                 return to caller
1154  4A78 434C  
1155            *                               
1156  4A7A C069 FFFDRV  MOV     @>0058(R9),R1           save filename in compare buffer and find its FDR
1156  4A7C 0058  
1157  4A7E 0221         AI      R1,256                  
1157  4A80 0100  
1158  4A82 0429         BLWP    @>005A(R9)              set VDP to write
1158  4A84 005A  
1159  4A86 0023         DATA    >0023                   address in R1: filename compare buffer
1160  4A88 DBC6         MOVB    R6,@-2(R15)             write drive #
1160  4A8A FFFE  
1161  4A8C 0581         INC     R1                      
1162  4A8E 06A0         BL      @CPCKFN                 copy (+ check) filename from R3 to R1
1162  4A90 48EA  
1163  4A92 C082         MOV     R2,R2                   all chars copied (or was there a . or a >00
1164  4A94 1302         JEQ     FFDRVB                  
1165  4A96 0460 H136    B       @ERROR7                 return with file error
1165  4A98 48EE  
1166            *                                       
1167  4A9A C069 FFDRVB  MOV     @>0056(R9),R1           find filename in buffered FDRs
1167  4A9C 0056  
1168  4A9E 0221         AI      R1,3                    
1168  4AA0 0003  
1169  4AA2 0429         BLWP    @>005A(R9)              set VDP to read
1169  4AA4 005A  
1170  4AA6 0022         DATA    >0022                   address in R1
1171  4AA8 D0AF         MOVB    @-1026(R15),R2          get # of files
1171  4AAA FBFE  
1172  4AAC 0982         SRL     R2,8                    make it a word
1173  4AAE C0C2         MOV     R2,R3                   save it
1174  4AB0 0221         AI      R1,6                    ptr to drive #
1174  4AB2 0006  
1175  4AB4 0204 H134    LI      R4,11                   compare 11 bytes (drive + filename)
1175  4AB6 000B  
1176  4AB8 0429         BLWP    @>005A(R9)              save R1-R3
1176  4ABA 005A  
1177  4ABC 7000         DATA    >7000                   
1178  4ABE 06A0         BL      @CMPFN                  compare with name in compare buffer
1178  4AC0 4812  
1179  4AC2 0429         BLWP    @>005A(R9)              retrieve R1-R3
1179  4AC4 005A  
1180  4AC6 7001         DATA    >7001                   
1181  4AC8 C104         MOV     R4,R4                   fully compared?
1182  4ACA 1304         JEQ     H135                    yes: done
1183  4ACC 0221         AI      R1,518                  move to next FDR in VDP mem
1183  4ACE 0206  
1184  4AD0 0602         DEC     R2                      
1185  4AD2 16F0         JNE     H134                    next file
1186  4AD4 0460 H135    B       @RTURN1                 return to caller (R4=0 if successfull)
1186  4AD6 434C  
1187            *                               
1188  4AD8 06A0 FNDFDR  BL      @CALSUB                 
1188  4ADA 432E  
1189  4ADC 4A7A         DATA    FFFDRV                  save name in comp buffer, find FDR in VDP buffers
1190            *                                       
1191  4ADE C104 FFDROD  MOV     R4,R4                   find FDR on disk (from filename)
1192  4AE0 13DA         JEQ     H136                    file error
1193  4AE2 C169 FFDRDK  MOV     @>0056(R9),R5           ptr to top of disk buffer in VDP mem
1193  4AE4 0056  
1194  4AE6 0225         AI      R5,10                   ptr to drive # in first file control block
1194  4AE8 000A  
1195  4AEA 0429 H138    BLWP    @>005A(R9)              set VDP to read
1195  4AEC 005A  
1196  4AEE 00A2         DATA    >00A2                   address in R5
1197  4AF0 D0AF         MOVB    @-1026(R15),R2          get drive #
1197  4AF2 FBFE  
1198  4AF4 1307         JEQ     H137                    free control block found
1199  4AF6 0225         AI      R5,518                  ptr to file control block
1199  4AF8 0206  
1200  4AFA 0603         DEC     R3                      
1201  4AFC 16F6         JNE     H138                    more files ?
1202  4AFE 06A0 ERROR6  BL      @ERROR5                 no:
1202  4B00 4948  
1203  4B02 8000         DATA    >8000                   memory full
1204            *                               
1205  4B04 CA45 H137    MOV     R5,@>0056(R9)           save ptr to free ctrl block (drive #)
1205  4B06 0056  
1206  4B08 06A0         BL      @CALSUB                 call subroutine
1206  4B0A 432E  
1207  4B0C 4A0A         DATA    RDSEC1                  read sector 1
1208  4B0E C229 FFDRFN  MOV     @>0056(R9),R8           entry point if sector 1 already read
1208  4B10 0056  
1209  4B12 0228         AI      R8,382                  point to middle of sector 1
1209  4B14 017E  
1210  4B16 0202         LI      R2,64                   distance: start with 1/4 sector
1210  4B18 0040  
1211  4B1A 0704 H139    SETO    R4                      
1212  4B1C 06A0         BL      @VDPR2B                 read 2 bytes in R0 from VDP address in R8
1212  4B1E 484C  
1213  4B20 C000         MOV     R0,R0                   
1214  4B22 132E         JEQ     H140                    no file here: move up
1215  4B24 0429         BLWP    @>005A(R9)              save R2
1215  4B26 005A  
1216  4B28 2000         DATA    >2000                   
1217  4B2A 0702         SETO    R2                      code for read
1218  4B2C 06A0         BL      @CALSUB                 call subroutine
1218  4B2E 432E  
1219  4B30 4A1C         DATA    RDFDR2                  read FDR, sector # in R0
1220  4B32 C045         MOV     R5,R1                   RDFDR2 sets R5 as FDR ptr
1221  4B34 0225         AI      R5,-4                   point to sector # of FDR in ctrl block
1221  4B36 FFFC  
1222  4B38 0429         BLWP    @>005A(R9)              set VDP to write
1222  4B3A 005A  
1223  4B3C 00A3         DATA    >00A3                   address in R5
1224  4B3E DBC4         MOVB    R4,@-2(R15)             RDFDR2 puts sector # in R4
1224  4B40 FFFE  
1225  4B42 06C4         SWPB    R4                      copy it to ctrl block
1226  4B44 DBC4         MOVB    R4,@-2(R15)                     
1226  4B46 FFFE  
1227  4B48 C141         MOV     R1,R5                   FDR ptr
1228  4B4A 0601         DEC     R1                      now point to drive #
1229  4B4C 0429         BLWP    @>005A(R9)              set VDP to write
1229  4B4E 005A  
1230  4B50 0023         DATA    >0023                   address in R1
1231  4B52 DBC6         MOVB    R6,@-2(R15)             save drive #
1231  4B54 FFFE  
1232  4B56 0204         LI      R4,11                   size to compare (drive # + filename)
1232  4B58 000B  
1233  4B5A 06A0         BL      @CMPFN                  compare filenames
1233  4B5C 4812  
1234  4B5E 0429         BLWP    @>005A(R9)              retrieve R2
1234  4B60 005A  
1235  4B62 2001         DATA    >2001                   
1236  4B64 130B         JEQ     H141                    compared ok: return
1237  4B66 0429         BLWP    @>005A(R9)              set VDP to write
1237  4B68 005A  
1238  4B6A 00A3         DATA    >00A3                   address in R5
1239  4B6C DBC4         MOVB    R4,@-2(R15)             remaining chars to compare
1239  4B6E FFFE  
1240  4B70 80C0         C       R0,R3                   what kind of mismatch occured?
1241  4B72 1B06         JH      H140                    too far down the alphabet
1242  4B74 A202         A       R2,R8                   too far up: move half-way down
1243  4B76 C082         MOV     R2,R2                   
1244  4B78 1606         JNE     H142                    then divide distance by 2
1245  4B7A 05C8         INCT    R8                      already checked: reset EQ
1246  4B7C 0460 H141    B       @RTURN1                 return (from stack)
1246  4B7E 434C  
1247            *                               
1248  4B80 6202 H140    S       R2,R8                   move half-way up
1249  4B82 C082         MOV     R2,R2                   
1250  4B84 13FB         JEQ     H141                    can't: already checked
1251  4B86 0922 H142    SRL     R2,2                    divide distance by 2
1252  4B88 A082         A       R2,R2                   but keep it even
1253  4B8A 10C7         JMP     H139                    
1254            *
1255            * The cluster info list is located in the FDR, bytes >1C to >FF
1256            * A cluster info consists in 3 bytes, i.e 6 nibbles
1257            * 3 nibbles specify the beginning sector for that cluster, and
1258            * 3 nibbles specify the total file offset in sectors, including this cluster.
1259            * The nibbles are arranged as EG SB OF, to be combined as BEG OFS
1260            *
1261  4B8C C28B DECDCI  MOV     R11,R10                 decode cluster info
1262  4B8E 06A0         BL      @VDPR2B                 read 2 bytes VDP at R8 in R0
1262  4B90 484C  
1263  4B92 06C0         SWPB    R0                      
1264  4B94 D0AF         MOVB    @-1026(R15),R2          get third byte from cluster list
1264  4B96 FBFE  
1265  4B98 C040         MOV     R0,R1                   
1266  4B9A 0241         ANDI    R1,>0FFF                start sector in R1
1266  4B9C 0FFF  
1267  4B9E 4001         SZC     R1,R0                   remove it from R0
1268  4BA0 0982         SRL     R2,8                    
1269  4BA2 E080         SOC     R0,R2                   combine offset nibbles
1270  4BA4 0BC2         SRC     R2,12                   offset in R2
1271  4BA6 045A         B       *R10                    
1272            *                               
1273  4BA8 0B42 UPDCLI  SRC     R2,4                    write info for 1 cluster
1274  4BAA C002         MOV     R2,R0                   
1275  4BAC 0240         ANDI    R0,>F000                sector in R1, offset in R2
1275  4BAE F000  
1276  4BB0 E040         SOC     R0,R1                   copy nibble 3 of offset before nibble 1 of sector
1277  4BB2 0429         BLWP    @>005A(R9)              set VDP to write
1277  4BB4 005A  
1278  4BB6 0103         DATA    >0103                   address in R8
1279  4BB8 06C1         SWPB    R1                      write cluster info
1280  4BBA DBC1         MOVB    R1,@-2(R15)             as 3 bytes
1280  4BBC FFFE  
1281  4BBE 06C1         SWPB    R1                      
1282  4BC0 DBC1         MOVB    R1,@-2(R15)                     
1282  4BC2 FFFE  
1283  4BC4 06C2         SWPB    R2                      
1284  4BC6 DBC2         MOVB    R2,@-2(R15)                     
1284  4BC8 FFFE  
1285  4BCA 045B         B       *R11                    
1286            *
1287            * The sector bitmap is located in the VIB (i.e. sector 0) at bytes >38 to >FF
1288            * In each byte a bit defines a sector, from right to left: "0"=free, "1"=used                                   
1289            *
1290  4BCC 0429 FFSBMP  BLWP    @>005A(R9)              find a free sector in bitmap
1290  4BCE 005A  
1291  4BD0 7800         DATA    >7800                   
1292  4BD2 06A0         BL      @CALSUB                 call subroutine
1292  4BD4 432E  
1293  4BD6 49A8         DATA    RWVIB                   load VIB for drive in R6
1294  4BD8 C041         MOV     R1,R1                   first sector specified in R1 ?
1295  4BDA 1602         JNE     H143                    yes
1296  4BDC 0201         LI      R1,33                   no: start with sector 34
1296  4BDE 0021  
1297  4BE0 0581 H143    INC     R1                      
1298  4BE2 C001         MOV     R1,R0                   
1299  4BE4 0931         SRL     R1,3                    div by 8 since 8 sect/byte in bitmap
1300  4BE6 0202         LI      R2,>00FF                        
1300  4BE8 00FF  
1301  4BEA 0240         ANDI    R0,>0007                bit number in bitmap byte
1301  4BEC 0007  
1302  4BEE 1301         JEQ     H144                    
1303  4BF0 0A02         SLA     R2,0                    get that bit
1304  4BF2 C0C1 H144    MOV     R1,R3                   byte #
1305  4BF4 A0C5         A       R5,R3                   add VIB ptr
1306  4BF6 0223         AI      R3,56                   ptr to sector in bitmap
1306  4BF8 0038  
1307  4BFA 0281         CI      R1,>00C8                end of VIB?
1307  4BFC 00C8  
1308  4BFE 1101         JLT     H145                    no
1309  4C00 04C1         CLR     R1                      yes: top of bitmap
1310  4C02 A045 H145    A       R5,R1                   
1311  4C04 0221         AI      R1,56                   make another bitmap ptr
1311  4C06 0038  
1312  4C08 0429         BLWP    @>005A(R9)              set VDP to read
1312  4C0A 005A  
1313  4C0C 0022         DATA    >0022                   address in R1
1314  4C0E 0700 H146    SETO    R0                      
1315  4C10 D02F         MOVB    @-1026(R15),R0          get bitmap byte
1315  4C12 FBFE  
1316  4C14 C100         MOV     R0,R4                   save it
1317  4C16 E002         SOC     R2,R0                   mask previous sectors
1318  4C18 04C2         CLR     R2                      
1319  4C1A 0580         INC     R0                      get 1 more sector
1320  4C1C 1610         JNE     H147                    ok
1321  4C1E 0581         INC     R1                      byte full: try next
1322  4C20 C001         MOV     R1,R0                   
1323  4C22 0220         AI      R0,-256                 won't change if byte # became >100
1323  4C24 FF00  
1324  4C26 8140         C       R0,R5                   still in VIB?
1325  4C28 1605         JNE     H148                    yes
1326  4C2A 0221         AI      R1,-200                 no: to top of bitmap
1326  4C2C FF38  
1327  4C2E 0429         BLWP    @>005A(R9)              set VDP to read
1327  4C30 005A  
1328  4C32 0022         DATA    >0022                   address in R1
1329  4C34 80C1 H148    C       R1,R3                   are we back to where we started?
1330  4C36 16EB         JNE     H146                    no: seach that byte for a free sector
1331  4C38 C004         MOV     R4,R0                   get original byte
1332  4C3A 0580         INC     R0                      try sectors just before ours (no mask this time)
1333  4C3C 1325         JEQ     H149                    full: return with EQ
1334  4C3E 0600 H147    DEC     R0                      restore original byte
1335  4C40 C080         MOV     R0,R2                   
1336  4C42 04C0         CLR     R0                      bit counter
1337  4C44 06C2         SWPB    R2                      
1338  4C46 0580 H150    INC     R0                      increment bit count
1339  4C48 0B12         SRC     R2,1                    find first 0 bit from the right
1340  4C4A 18FD         JOC     H150                    not yet
1341  4C4C 0202         LI      R2,>0080                        
1341  4C4E 0080  
1342  4C50 0A02         SLA     R2,0                    make a mask for that bit
1343  4C52 0600         DEC     R0                      bit # (0-7)
1344  4C54 E102         SOC     R2,R4                   mark sector as used in bitmap byte
1345  4C56 0429         BLWP    @>005A(R9)              set VDP to write
1345  4C58 005A  
1346  4C5A 0023         DATA    >0023                   address in R1
1347  4C5C DBC4         MOVB    R4,@-2(R15)             update bitmap
1347  4C5E FFFE  
1348  4C60 0221         AI      R1,-56                  
1348  4C62 FFC8  
1349  4C64 6045         S       R5,R1                   byte # in bitmap
1350  4C66 0A31         SLA     R1,3                    times 8 (8 sect per byte)
1351  4C68 E040         SOC     R0,R1                   add bit #: = sector #
1352  4C6A C001         MOV     R1,R0                   save it
1353            *                               
1354  4C6C 0605 H151    DEC     R5                      point to drive #
1355  4C6E 0429         BLWP    @>005A(R9)              set VDP to read
1355  4C70 005A  
1356  4C72 00A2         DATA    >00A2                   address in R5
1357  4C74 D06F         MOVB    @-1026(R15),R1          get drive #
1357  4C76 FBFE  
1358  4C78 0261         ORI     R1,>8000                add flag: update VIB
1358  4C7A 8000  
1359  4C7C 0429         BLWP    @>005A(R9)              set VDP to write
1359  4C7E 005A  
1360  4C80 00A3         DATA    >00A3                   address in R5
1361  4C82 DBC1         MOVB    R1,@-2(R15)             write back flagged drive #
1361  4C84 FFFE  
1362  4C86 0585         INC     R5                      point to VIB (& return with NEQ)
1363  4C88 0429 H149    BLWP    @>005A(R9)              retrieve R1-R4
1363  4C8A 005A  
1364  4C8C 7801         DATA    >7801                   
1365  4C8E 0460         B       @RTURN1                 return to caller
1365  4C90 434C  
1366            *                               
1367  4C92 C040 FFSBM   MOV     R0,R1                   free sector(s) in bitmap
1368  4C94 0202         LI      R2,1                    1 sector only
1368  4C96 0001  
1369  4C98 0429 FRSCB1  BLWP    @>005A(R9)              entry point if more than 1 sector
1369  4C9A 005A  
1370  4C9C 7800         DATA    >7800                   save R1-R4
1371  4C9E 06A0         BL      @CALSUB                 call subroutine
1371  4CA0 432E  
1372  4CA2 49A8         DATA    RWVIB                   load VIB for drive in R6
1373  4CA4 C001         MOV     R1,R0                   sector #
1374  4CA6 0240         ANDI    R0,>0007                bit in bitmap byte (8 per byte)
1374  4CA8 0007  
1375  4CAA 0931         SRL     R1,3                    byte in bitmap
1376  4CAC A045         A       R5,R1                   add VIB buffer
1377  4CAE 0221         AI      R1,56                   add bitmap offset in VIB
1377  4CB0 0038  
1378  4CB2 C0C0         MOV     R0,R3                   
1379  4CB4 0500         NEG     R0                      
1380  4CB6 0220         AI      R0,8                    change 0-7 into 8-1
1380  4CB8 0008  
1381  4CBA 0204         LI      R4,>00FF                mask to erase
1381  4CBC 00FF  
1382  4CBE 8002         C       R2,R0                   how many to erase?
1383  4CC0 1101         JLT     H152                    less than in that byte
1384  4CC2 100A         JMP     H153                    
1385            *                               
1386  4CC4 0200 H152    LI      R0,8                    free sectors in first byte
1386  4CC6 0008  
1387  4CC8 6002         S       R2,R0                   
1388  4CCA 0B04         SRC     R4,0                    adjust mask
1389  4CCC C003         MOV     R3,R0                   original bit # of starting sector
1390  4CCE 1301         JEQ     H154                    
1391  4CD0 0A04         SLA     R4,0                    don't erase before starting sector
1392  4CD2 1000 H154    JMP     H155                    
1393            *                               
1394  4CD4 06C4 H155    SWPB    R4                      
1395  4CD6 1019         JMP     H158                    goto erase last byte
1396            *                                       
1397  4CD8 0B04 H153    SRC     R4,0                    adjust mask
1398  4CDA 6080 H156    S       R0,R2                   that many will be freed
1399  4CDC 0429         BLWP    @>005A(R9)              set VDP to read
1399  4CDE 005A  
1400  4CE0 0022         DATA    >0022                   address in R1
1401  4CE2 D02F         MOVB    @-1026(R15),R0          get bitmap byte
1401  4CE4 FBFE  
1402  4CE6 4004         SZC     R4,R0                   mark sectors as free
1403  4CE8 0429         BLWP    @>005A(R9)              set VDP to write
1403  4CEA 005A  
1404  4CEC 0023         DATA    >0023                   address in R1
1405  4CEE DBC0         MOVB    R0,@-2(R15)             write it back
1405  4CF0 FFFE  
1406  4CF2 0204         LI      R4,>FF00                clear full byte
1406  4CF4 FF00  
1407  4CF6 0581         INC     R1                      next byte
1408  4CF8 0200         LI      R0,8                    i.e. 8 sectors
1408  4CFA 0008  
1409  4CFC 8002         C       R2,R0                   how many more sectors?
1410  4CFE 1101         JLT     H157                    less than 8
1411  4D00 10EC         JMP     H156                    8 or more: next byte
1412            *                                       
1413  4D02 C002 H157    MOV     R2,R0                   remaining sectors
1414  4D04 0204         LI      R4,>00FF                        
1414  4D06 00FF  
1415  4D08 0A04         SLA     R4,0                    coin mask
1416  4D0A 0429 H158    BLWP    @>005A(R9)              set VDP to read
1416  4D0C 005A  
1417  4D0E 0022         DATA    >0022                   address in R1
1418  4D10 D02F         MOVB    @-1026(R15),R0          get bitmap byte
1418  4D12 FBFE  
1419  4D14 4004         SZC     R4,R0                   mark sectors as free
1420  4D16 0429         BLWP    @>005A(R9)              set VDP to write
1420  4D18 005A  
1421  4D1A 0023         DATA    >0023                   address in R1
1422  4D1C DBC0         MOVB    R0,@-2(R15)             write it back
1422  4D1E FFFE  
1423  4D20 10A5         JMP     H151                    done: flag drive # and return
1424            *
1425            *===================================
1426            * DSR entry points
1427            *===================================                                    
1428            *
1429  4D22 C1CB EDSR01  MOV     R11,R7                  DSK
1430  4D24 06A0         BL      @PRPFDO                 --- prepare file operations
1430  4D26 43FA  
1431  4D28 06A0         BL      @CALSUB                 call subroutine
1431  4D2A 432E  
1432  4D2C 4860         DATA    FDSKDR                  find disk in drive (name ptr in R3)
1433  4D2E 100B         JMP     H159                    
1434            *                                       
1435  4D30 0206 EDSR02  LI      R6,>0100                DSK1
1435  4D32 0100  
1436  4D34 1005         JMP     H160                    ----
1437            *                                       
1438  4D36 0206 EDSR03  LI      R6,>0200                DSK2
1438  4D38 0200  
1439  4D3A 1002         JMP     H160                    ----
1440            *                                       
1441  4D3C 0206 EDSR04  LI      R6,>0300                DSK3
1441  4D3E 0300  
1442            *                                       
1443  4D40 C1CB H160    MOV     R11,R7                  save return address
1444  4D42 06A0         BL      @PRPFDO                 prepare file operations
1444  4D44 43FA  
1445  4D46 C029 H159    MOV     @>0054(R9),R0           PAB ptr
1445  4D48 0054  
1446  4D4A 0429         BLWP    @>005A(R9)              set VDP to read
1446  4D4C 005A  
1447  4D4E 0002         DATA    >0002                   address in R0
1448  4D50 D06F         MOVB    @-1026(R15),R1          get opcode
1448  4D52 FBFE  
1449  4D54 0981         SRL     R1,8                    
1450  4D56 0281         CI      R1,>0009                check range
1450  4D58 0009  
1451  4D5A 1B19         JH      ERROR8                  illegal opcode
1452  4D5C 0282         CI      R2,>0001                filename lenght (including . )
1452  4D5E 0001  
1453  4D60 1605         JNE     H161                    no filename: dir
1454  4D62 0221         AI      R1,10                   only allow open, close and read
1454  4D64 000A  
1455  4D66 0281         CI      R1,>000C                        
1455  4D68 000C  
1456  4D6A 1B11         JH      ERROR8                  others are illegal
1457  4D6C A041 H161    A       R1,R1                   make it a word ptr
1458  4D6E C061         MOV     @OPCVEC(R1),R1          get vector
1458  4D70 4D74  
1459  4D72 0451         B       *R1                     branch to it
1460            *                                       
1461  4D74 4D94 OPCVEC  DATA    OPEN                    open
1462  4D76 4FA6         DATA    CLOSE                   close
1463  4D78 4FB0         DATA    READ                    read
1464  4D7A 509A         DATA    WRITE                   write
1465  4D7C 534E         DATA    RWIND1                  rewind
1466  4D7E 53A2         DATA    LOAD                    load
1467  4D80 5444         DATA    SAVE                    save
1468  4D82 4744         DATA    DELETE                  delete
1469  4D84 4974         DATA    RETERR                  scratch record: return with bad attribute error
1470  4D86 54C8         DATA    STATUS                  status
1471            *                                       
1472  4D88 5588         DATA    OPNDIR                  open directory
1473  4D8A 55E6         DATA    CLSDIR                  close directory
1474  4D8C 55FC         DATA    RDDIR                   read directory
1475            *                                       
1476  4D8E 06A0 ERROR8  BL      @ERROR5                 return with error
1476  4D90 4948  
1477  4D92 6000         DATA    >6000                   illegal opcode
1478            *
1479            *---------------------------------
1480            * Opcode 0: Open
1481            * --------------
1482            * PAB 0: >00
1483            *     1: file type  <--- error code
1484            *   2-3:
1485            *     4: record length
1486            *     5:
1487            *   6-7: # of records (if output)
1488            *     8:
1489            *---------------------------------                                      
1490            *
1491  4D94 04C0 OPEN    CLR     R0                      
1492  4D96 D02F         MOVB    @-1026(R15),R0          get file attributes
1492  4D98 FBFE  
1493  4D9A 0429         BLWP    @>005A(R9)                      
1493  4D9C 005A  
1494  4D9E 8000         DATA    >8000                   save R0
1495  4DA0 0240         ANDI    R0,>1600                keep fix/var and access mode
1495  4DA2 1600  
1496  4DA4 0280         CI      R0,>0600                        
1496  4DA6 0600  
1497  4DA8 1603         JNE     H162                    
1498  4DAA 06A0 ERROR9  BL      @ERROR5                 dis/fix, open as append: return with error
1498  4DAC 4948  
1499  4DAE 4000         DATA    >4000                   bad attribute
1500            *                                       
1501  4DB0 120A H162    JLE     H163                    
1502  4DB2 C040         MOV     R0,R1                   var
1503  4DB4 06A0         BL      @PABR2B                 get 2 bytes from PAB into R0
1503  4DB6 4840  
1504  4DB8 0004         DATA    4                       rec len and char count
1505  4DBA 0280         CI      R0,>FF00                is rec len 255?
1505  4DBC FF00  
1506  4DBE 14F5         JHE     ERROR9                  yes: bad attribute
1507  4DC0 C001         MOV     R1,R0                   retrieve attributes
1508  4DC2 0240         ANDI    R0,>0600                keep only access mode
1508  4DC4 0600  
1509            *                                       
1510  4DC6 0280 H163    CI      R0,>0200                is it output?
1510  4DC8 0200  
1511  4DCA 1657         JNE     H164                    no
1512  4DCC 06A0         BL      @CALSUB                 call subroutine
1512  4DCE 432E  
1513  4DD0 4466         DATA    CRFIL1                  create file
1514  4DD2 06A0 H165    BL      @PRFDRS                 coin status byte in FDR style
1514  4DD4 4F54  
1515  4DD6 0429         BLWP    @>005A(R9)              set VDP to write
1515  4DD8 005A  
1516  4DDA 0083         DATA    >0083                   address in R4: status byte in FDR buffer
1517  4DDC DBC2         MOVB    R2,@-2(R15)             write file status in FDR
1517  4DDE FFFE  
1518  4DE0 C0E9         MOV     @>0054(R9),R3           PAB ptr
1518  4DE2 0054  
1519  4DE4 0223         AI      R3,4                    ptr to rec len
1519  4DE6 0004  
1520  4DE8 04C5         CLR     R5                      
1521  4DEA 0429         BLWP    @>005A(R9)              set VDP to read
1521  4DEC 005A  
1522  4DEE 0062         DATA    >0062                   address in R3
1523  4DF0 D16F         MOVB    @-1026(R15),R5          get record length
1523  4DF2 FBFE  
1524  4DF4 1607         JNE     H166                    
1525  4DF6 0205         LI      R5,>5000                >00: default it 80
1525  4DF8 5000  
1526  4DFA 0429         BLWP    @>005A(R9)              set VDP to write
1526  4DFC 005A  
1527  4DFE 0063         DATA    >0063                   address in R3
1528  4E00 DBC5         MOVB    R5,@-2(R15)             write default rec len
1528  4E02 FFFE  
1529  4E04 0224 H166    AI      R4,5                    point to rec len byte in FDR
1529  4E06 0005  
1530  4E08 0429         BLWP    @>005A(R9)              set VDP to write
1530  4E0A 005A  
1531  4E0C 0083         DATA    >0083                   address in R4
1532  4E0E DBC5         MOVB    R5,@-2(R15)             write rec len in FDR buffer
1532  4E10 FFFE  
1533  4E12 0201         LI      R1,256                  256 bytes/sector
1533  4E14 0100  
1534  4E16 C082         MOV     R2,R2                   var or dis?
1535  4E18 1101         JLT     H167                    var
1536  4E1A 1002         JMP     H168                    dis
1537  4E1C A141 H167    A       R1,R5                   var: rec len +1
1538  4E1E 0601         DEC     R1                      254 bytes only (needs size byte)
1539  4E20 06C5 H168    SWPB    R5                      make it a word
1540  4E22 04C0         CLR     R0                      
1541  4E24 3C05         DIV     R5,R0                   how many times in 254/255 bytes?
1542  4E26 0224         AI      R4,-4                   point to # of rec/sect in FDR
1542  4E28 FFFC  
1543  4E2A C040         MOV     R0,R1                   save result for later
1544  4E2C 06C0         SWPB    R0                      
1545  4E2E 0429         BLWP    @>005A(R9)              set VDP to write
1545  4E30 005A  
1546  4E32 0083         DATA    >0083                   address in R4
1547  4E34 DBC0         MOVB    R0,@-2(R15)             write # of rec/sect in FDR
1547  4E36 FFFE  
1548  4E38 C229         MOV     @>0056(R9),R8           point to filename in FDR
1548  4E3A 0056  
1549  4E3C 0429         BLWP    @>005A(R9)              set VDP to read
1549  4E3E 005A  
1550  4E40 0102         DATA    >0102                   address in R8
1551  4E42 D02F         MOVB    @-1026(R15),R0          get first char
1551  4E44 FBFE  
1552  4E46 0260         ORI     R0,>8000                flag it: update FDR before leaving
1552  4E48 8000  
1553  4E4A 0429         BLWP    @>005A(R9)              set VDP to write
1553  4E4C 005A  
1554  4E4E 0103         DATA    >0103                   address in R8
1555  4E50 DBC0         MOVB    R0,@-2(R15)             write it back
1555  4E52 FFFE  
1556  4E54 0429         BLWP    @>005A(R9)                      
1556  4E56 005A  
1557  4E58 8001         DATA    >8001                   retrieve R0 (access mode)
1558  4E5A 06A0         BL      @PABR2B                 get 2 bytes from PAB into R0
1558  4E5C 4840  
1559  4E5E 0006         DATA    6                       required size in records
1560  4E60 C100         MOV     R0,R4                   
1561  4E62 1309         JEQ     H169                    no size specified
1562  4E64 11A2         JLT     ERROR9                  return with bad attribute error
1563  4E66 A101         A       R1,R4                   round up to record size
1564  4E68 0604         DEC     R4                      
1565  4E6A 04C3         CLR     R3                      
1566  4E6C 3CC1         DIV     R1,R3                   how many sectors will this be?
1567  4E6E 0603         DEC     R3                      offset start from 0
1568  4E70 06A0         BL      @CALSUB                 call subroutine
1568  4E72 432E  
1569  4E74 4636         DATA    APSCTS                  add sectors to FDR to match offset in R3
1570  4E76 0460 H169    B       @RWIND2                 initialise file control block and return to caller
1570  4E78 537C  
1571            *                                       
1572  4E7A 0429 H164    BLWP    @>005A(R9)              not output
1572  4E7C 005A  
1573  4E7E 8000         DATA    >8000                   save R0
1574  4E80 06A0         BL      @CALSUB                 call subroutine
1574  4E82 432E  
1575  4E84 4AD8         DATA    FNDFDR                  find FDR on disk
1576  4E86 0429         BLWP    @>005A(R9)                      
1576  4E88 005A  
1577  4E8A 8001         DATA    >8001                   retrieve R0 (access mode)
1578  4E8C C104         MOV     R4,R4                   found FDR?
1579  4E8E 1309         JEQ     H170                    yes
1580  4E90 0280         CI      R0,>0400                no: is file open as input?
1580  4E92 0400  
1581  4E94 1304         JEQ     H171                    yes: must exist
1582  4E96 06A0         BL      @CALSUB                 no: call subroutine
1582  4E98 432E  
1583  4E9A 4478         DATA    CRFIL3                  create file
1584  4E9C 109A         JMP     H165                    
1585            *                                       
1586  4E9E 0460 H171    B       @ERROR9                 return with bad attribute error
1586  4EA0 4DAA  
1587            *                                       
1588  4EA2 C1C0 H170    MOV     R0,R7                   save access mode
1589  4EA4 06A0         BL      @PRFDRS                 prepare status byte for FDR
1589  4EA6 4F54  
1590  4EA8 0429         BLWP    @>005A(R9)              set VDP to read
1590  4EAA 005A  
1591  4EAC 0082         DATA    >0082                   address in R4 (status byte in FDR)
1592  4EAE D02F         MOVB    @-1026(R15),R0          get current file status
1592  4EB0 FBFE  
1593  4EB2 C0C0         MOV     R0,R3                   save it
1594  4EB4 0243         ANDI    R3,>0800                is file write protected?
1594  4EB6 0800  
1595  4EB8 1306         JEQ     H172                    no
1596  4EBA 0287         CI      R7,>0400                yes: is it open as input?
1596  4EBC 0400  
1597  4EBE 1303         JEQ     H172                    no
1598  4EC0 06A0         BL      @ERROR5                 yes: return with error
1598  4EC2 4948  
1599  4EC4 2000         DATA    >2000                   write protected
1600            *                                       
1601  4EC6 0240 H172    ANDI    R0,>8300                keep only file type bits (V/F, D/I, Prg/Data)
1601  4EC8 8300  
1602  4ECA 2802         XOR     R2,R0                   compare with new (coined by PRFDRS)
1603  4ECC 16E8         JNE     H171                    different: bad attribute
1604  4ECE C0E9         MOV     @>0054(R9),R3           PAB ptr
1604  4ED0 0054  
1605  4ED2 0223         AI      R3,4                    ptr to rec len in PAB
1605  4ED4 0004  
1606  4ED6 0224         AI      R4,5                    ptr to rec len in FDR
1606  4ED8 0005  
1607  4EDA 0429         BLWP    @>005A(R9)              set VDP to read
1607  4EDC 005A  
1608  4EDE 0082         DATA    >0082                   address in R4
1609  4EE0 D02F         MOVB    @-1026(R15),R0          get rec len from FDR
1609  4EE2 FBFE  
1610  4EE4 0429         BLWP    @>005A(R9)              set VDP to read
1610  4EE6 005A  
1611  4EE8 0062         DATA    >0062                   address in R3
1612  4EEA D0AF         MOVB    @-1026(R15),R2          get rec len from PAB
1612  4EEC FBFE  
1613  4EEE 1302         JEQ     H173                    0 = keep current one
1614  4EF0 9080         CB      R0,R2                   are they identical?
1615  4EF2 16D5         JNE     H171                    no: bad attribute
1616  4EF4 0429 H173    BLWP    @>005A(R9)              set VDP to write
1616  4EF6 005A  
1617  4EF8 0063         DATA    >0063                   address in R3
1618  4EFA DBC0         MOVB    R0,@-2(R15)             update rec len in PAB (in case it was 0)
1618  4EFC FFFE  
1619  4EFE 0429         BLWP    @>005A(R9)              retrieve R0 (open mode)
1619  4F00 005A  
1620  4F02 8001         DATA    >8001                   
1621  4F04 0240         ANDI    R0,>0600                keep only access mode
1621  4F06 0600  
1622  4F08 04C2         CLR     R2                      
1623  4F0A 0703         SETO    R3                      
1624  4F0C 0280         CI      R0,>0600                is it append
1624  4F0E 0600  
1625  4F10 161D         JNE     H174                    no
1626  4F12 C129         MOV     @>0056(R9),R4           yes: get FDR ptr
1626  4F14 0056  
1627  4F16 C1C4         MOV     R4,R7                   save it
1628  4F18 0224         AI      R4,14                   ptr to # of sectors
1628  4F1A 000E  
1629  4F1C 0429         BLWP    @>005A(R9)              set VDP to read
1629  4F1E 005A  
1630  4F20 0082         DATA    >0082                   address in R4
1631  4F22 D0EF         MOVB    @-1026(R15),R3          get # of sectors in file
1631  4F24 FBFE  
1632  4F26 06C3         SWPB    R3                      
1633  4F28 D0EF         MOVB    @-1026(R15),R3                  
1633  4F2A FBFE  
1634  4F2C 06C3         SWPB    R3                      
1635  4F2E D0AF         MOVB    @-1026(R15),R2          get eof offset
1635  4F30 FBFE  
1636  4F32 0603         DEC     R3                      offset starts from 0
1637  4F34 110B         JLT     H174                    file is empty (0 sectors)
1638  4F36 0429         BLWP    @>005A(R9)                      
1638  4F38 005A  
1639  4F3A 3000         DATA    >3000                   save R2 + R3
1640  4F3C 0227         AI      R7,256                  ptr to data buffer area for this file
1640  4F3E 0100  
1641  4F40 06A0         BL      @CALSUB                 call subroutine
1641  4F42 432E  
1642  4F44 4600         DATA    RDOFSC                  read a sector, from offset in R3
1643  4F46 0429         BLWP    @>005A(R9)                      
1643  4F48 005A  
1644  4F4A 3001         DATA    >3001                   retrieve R2 + R3
1645  4F4C 06A0 H174    BL      @UPDFCB                 update current record offset in file ctrl block
1645  4F4E 4F7E  
1646  4F50 0460         B       @RTURN1                 return to caller
1646  4F52 434C  
1647            *                                       
1648  4F54 0429 PRFDRS  BLWP    @>005A(R9)              prepare file status byte for FDR
1648  4F56 005A  
1649  4F58 8001         DATA    >8001                   access mode in R0
1650  4F5A 0429         BLWP    @>005A(R9)                      
1650  4F5C 005A  
1651  4F5E 8000         DATA    >8000                   save it back
1652  4F60 0202         LI      R2,2                    int in FDR status byte
1652  4F62 0002  
1653  4F64 C129         MOV     @>0056(R9),R4           FDR pointer
1653  4F66 0056  
1654  4F68 0A40         SLA     R0,4                    fix or var?
1655  4F6A 1703         JNC     H175                    fix
1656  4F6C 0202         LI      R2,>0082                int var in FDR
1656  4F6E 0082  
1657  4F70 C000         MOV     R0,R0                   dis or int?
1658  4F72 1101 H175    JLT     H176                    int
1659  4F74 0642         DECT    R2                      dis: remove the int from FDR status
1660  4F76 0224 H176    AI      R4,12                   point at file status byte in FDR
1660  4F78 000C  
1661  4F7A 06C2         SWPB    R2                      
1662  4F7C 045B         B       *R11                    
1663            *                                       
1664  4F7E C129 UPDFCB  MOV     @>0056(R9),R4           update sect + rec offsets in file control block
1664  4F80 0056  
1665  4F82 0224         AI      R4,-6                   
1665  4F84 FFFA  
1666  4F86 0429         BLWP    @>005A(R9)              set VDP to write
1666  4F88 005A  
1667  4F8A 0083         DATA    >0083                   address in R4
1668  4F8C DBC3         MOVB    R3,@-2(R15)             write current sect offset
1668  4F8E FFFE  
1669  4F90 06C3         SWPB    R3                      
1670  4F92 DBC3         MOVB    R3,@-2(R15)                     
1670  4F94 FFFE  
1671  4F96 0224         AI      R4,4                    point to logical rec offset (for var files)
1671  4F98 0004  
1672  4F9A 0429         BLWP    @>005A(R9)              set VDP to write
1672  4F9C 005A  
1673  4F9E 0083         DATA    >0083                   address in R4
1674  4FA0 DBC2         MOVB    R2,@-2(R15)             write record offset
1674  4FA2 FFFE  
1675  4FA4 045B         B       *R11                    
1676            *
1677            *----------------------------------
1678            * Opcode 1: Close
1679            * --------------
1680            * PAB 0: >01
1681            *     1:           <--- error code
1682            *   2-3:
1683            *     4:
1684            *     5:
1685            *   6-7:
1686            *     8:
1687            *----------------------------------                                     
1688            *
1689  4FA6 06A0 CLOSE   BL      @CALSUB                 call subroutine
1689  4FA8 432E  
1690  4FAA 51A4         DATA    FFDRVP                  find file FDR
1691  4FAC 0460         B       @UPDFDR                 update FDR + data area, get VIB, return to caller
1691  4FAE 454C  
1692            *
1693            *----------------------------------
1694            * Opcode 2: Read
1695            * --------------
1696            * PAB 0: >02
1697            *     1: file type <--- error code
1698            *   2-3: data buffer address in VDP mem
1699            *     4:
1700            *     5: bytes read
1701            *   6-7: record #
1702            *     8:
1703            *
1704            * Logical records organisation whithin sectors
1705            *
1706            * Fixed records (e.g. rec length = 6)
1707            * 11 11 11 11 11 11 22 22 22 22 22 22 33 33 33 33 33 33 xx xx xx
1708            * Where 11=data for record 1, 22=record 2, 33=record 3, xx=junk bytes
1709            *
1710            * Variable records:
1711            * sz 11 11 11 11 11 11 11 sz 22 22 22 22 22 sz 33 33 FF xx xx xx
1712            * Where sz=record size, 11,22,33=record data, FF=end-of-sector mark, xx=junk
1713            *----------------------------------                                     
1714            *
1715  4FB0 06A0 READ    BL      @CALSUB                 call subroutine
1715  4FB2 432E  
1716  4FB4 51A4         DATA    FFDRVP                  find FDR in VDP buffers, get status from PAB
1717  4FB6 0240         ANDI    R0,>0200                what type of access?
1717  4FB8 0200  
1718  4FBA 1302         JEQ     H177                    update or input: ok
1719  4FBC 0460 H179    B       @ERROR8                 append or output: error illegal opcode
1719  4FBE 4D8E  
1720  4FC0 06A0 H177    BL      @RFDRST                 get status byte in R0, from FDR
1720  4FC2 51D0  
1721  4FC4 110A         JLT     H178                    var
1722  4FC6 06A0         BL      @RRNPAB                 fix: get rec # compare to # of recs/file
1722  4FC8 51E4  
1723  4FCA 1A03         JL      H180                    ok: in file
1724  4FCC 06A0 H181    BL      @ERROR5                 update data and return with error
1724  4FCE 4948  
1725  4FD0 A000         DATA    >A000                   eof reached
1726  4FD2 06A0 H180    BL      @CALSUB                 call subroutine
1726  4FD4 432E  
1727  4FD6 524A         DATA    RRFDR                   load record from disk into FDR data buffer area
1728  4FD8 1011         JMP     H182                    
1729            *                                       
1730  4FDA 06A0 H178    BL      @CALSUB                 var: call subroutine
1730  4FDC 432E  
1731  4FDE 5036         DATA    RRSEC                   load proper sector, point to rec in it
1732  4FE0 10F5         JMP     H181                    skipped if ok: return with eof reached
1733            *                                       
1734  4FE2 0582         INC     R2                      next byte in data buffer
1735  4FE4 A004         A       R4,R0                   add rec size to offset
1736  4FE6 0580         INC     R0                      room for end-of-sector mark
1737  4FE8 C169         MOV     @>0056(R9),R5           FDR ptr
1737  4FEA 0056  
1738  4FEC 0645         DECT    R5                      point to var record offset in sector
1739  4FEE 06C0         SWPB    R0                      
1740  4FF0 0429         BLWP    @>005A(R9)              set VDP to write
1740  4FF2 005A  
1741  4FF4 00A3         DATA    >00A3                   address in R5
1742  4FF6 DBC0         MOVB    R0,@-2(R15)             update var record offset in sector
1742  4FF8 FFFE  
1743  4FFA C004         MOV     R4,R0                   save # of bytes to be read
1744  4FFC C129 H182    MOV     @>0054(R9),R4           PAB ptr
1744  4FFE 0054  
1745  5000 0224         AI      R4,5                    point to char count
1745  5002 0005  
1746  5004 06C0         SWPB    R0                      
1747  5006 0429         BLWP    @>005A(R9)              set VDP to write
1747  5008 005A  
1748  500A 0083         DATA    >0083                   address in R4
1749  500C DBC0         MOVB    R0,@-2(R15)             write # of char to be read
1749  500E FFFE  
1750  5010 06C0         SWPB    R0                      make it a word
1751            *                                       
1752  5012 C000 WFDRPB  MOV     R0,R0                   check it
1753  5014 130E         JEQ     H183                    none: return
1754  5016 0429 H184    BLWP    @>005A(R9)              set VDP to read
1754  5018 005A  
1755  501A 0042         DATA    >0042                   address in R2
1756  501C D0EF         MOVB    @-1026(R15),R3          read 1 byte from FDR data buffer area
1756  501E FBFE  
1757  5020 0582         INC     R2                      increment source ptr
1758  5022 0429         BLWP    @>005A(R9)              set VDP to write
1758  5024 005A  
1759  5026 0023         DATA    >0023                   address in R1
1760  5028 DBC3         MOVB    R3,@-2(R15)             write the byte in PAB data buffer
1760  502A FFFE  
1761  502C 0581         INC     R1                      increment destination ptr
1762  502E 0600         DEC     R0                      more to read?
1763  5030 16F2         JNE     H184                    yes
1764  5032 0460 H183    B       @RTURN1                 return to caller
1764  5034 434C  
1765            *                                       
1766  5036 06A0 RRSEC   BL      @RCOFCB                 load sector, point to record in it
1766  5038 5324  
1767  503A C0C3         MOV     R3,R3                   sector offset
1768  503C 1101         JLT     H185                    -1: top of file
1769  503E 1012         JMP     H186                    in file
1770  5040 C003 H185    MOV     R3,R0                   
1771  5042 0580         INC     R0                      next sector
1772  5044 8080         C       R0,R2                   compare to # of sect/file
1773  5046 13F5         JEQ     H183                    end-of-file reached: return to caller (JMP to err)
1774  5048 06A0         BL      @CALSUB                 call subroutine
1774  504A 432E  
1775  504C 456C         DATA    UPDBF                   update data buffer, if needed
1776  504E C0C0         MOV     R0,R3                   desired offset
1777  5050 04C5         CLR     R5                      
1778  5052 06A0         BL      @UCOFCB                 update sect + rec offsets in control block
1778  5054 52C2  
1779  5056 0227         AI      R7,256                  point to data buffer area (R7 set by UCOFCB)
1779  5058 0100  
1780  505A 06A0         BL      @CALSUB                 call subroutine
1780  505C 432E  
1781  505E 4600         DATA    RDOFSC                  read a sector, from offset in file (in R3)
1782  5060 04C0         CLR     R0                      
1783  5062 1004         JMP     H187                    
1784            *                                       
1785  5064 C000 H186    MOV     R0,R0                   in file: test var rec offset (from RCOFCB)
1786  5066 1602         JNE     H187                    inside sector
1787  5068 8080         C       R0,R2                   at beg of sector
1788  506A 13E3         JEQ     H183                    file is empty: return
1789  506C C080 H187    MOV     R0,R2                   FDR data buffer will be added to R2 by AFDRPT
1790  506E 06A0         BL      @CALSUB                 call subroutine
1790  5070 432E  
1791  5072 529E         DATA    AFDRPT                  R2=byte in FDR data buf, R1=top of PAB data buf
1792  5074 0429         BLWP    @>005A(R9)              set VDP to read
1792  5076 005A  
1793  5078 0042         DATA    >0042                   address in R2
1794  507A D12F         MOVB    @-1026(R15),R4          get first byte (rec length)
1794  507C FBFE  
1795  507E 0984         SRL     R4,8                    make it a word
1796  5080 C000         MOV     R0,R0                   var rec offset
1797  5082 1306         JEQ     H188                    
1798  5084 0284         CI      R4,>00FF                is it >FF (end of sector mark) ?
1798  5086 00FF  
1799  5088 1603         JNE     H188                    no
1800  508A 06A0         BL      @RCOFCB                 yes: get sect + rec offsets from control block
1800  508C 5324  
1801  508E 10D8         JMP     H185                    try again with next sector
1802            *                                       
1803  5090 0429 H188    BLWP    @>005A(R9)                      
1803  5092 005A  
1804  5094 0011         DATA    >0011                   retrieve return address from stack in R11
1805  5096 05CB         INCT    R11                     skip the JMP to eof reached error
1806  5098 045B         B       *R11                    
1807            *
1808            *------------------------------------
1809            * Opcode 3: Write
1810            * --------------
1811            * PAB 0: >03
1812            *     1: file type <--- error code
1813            *   2-3: data buffer address in VDP mem
1814            *     4:
1815            *     5: bytes to write
1816            *   6-7: record #
1817            *     8:
1818            *------------------------------------                                   
1819            *
1820  509A 06A0 WRITE   BL      @CALSUB                 call subroutine
1820  509C 432E  
1821  509E 51A4         DATA    FFDRVP                  find FDR in VDP buffers
1822  50A0 0240         ANDI    R0,>0600                keep only access mode
1822  50A2 0600  
1823  50A4 0280         CI      R0,>0400                is it input
1823  50A6 0400  
1824  50A8 1389         JEQ     H179                    yes: return with error illegal opcode
1825  50AA 06A0         BL      @RFDRST                 get file status byte from FDR
1825  50AC 51D0  
1826  50AE 1113         JLT     H189                    var                     
1827  50B0 06A0         BL      @RRNPAB                 fix: get rec # from PAB, sect # in R0
1827  50B2 51E4  
1828  50B4 1A0C         JL      H190                    less that total rec/file
1829  50B6 0429         BLWP    @>005A(R9)              past eof: expand file
1829  50B8 005A  
1830  50BA D800         DATA    >D800                   save R0, R1, R3, R4
1831  50BC C0C0         MOV     R0,R3                   desired sector offset
1832  50BE 06A0         BL      @CALSUB                 call subroutine
1832  50C0 432E  
1833  50C2 4636         DATA    APSCTS                  append enough sectors to reach offset in R3
1834  50C4 0429         BLWP    @>005A(R9)                      
1834  50C6 005A  
1835  50C8 D801         DATA    >D801                   restore R0, R1, R3, R4
1836  50CA 06A0         BL      @URFFDR                 update # of rec/file in FDR
1836  50CC 52EE  
1837            *                                       
1838  50CE 06A0 H190    BL      @CALSUB                 in file: call subroutine
1838  50D0 432E  
1839  50D2 524A         DATA    RRFDR                   fetch rec from disk into FDR data buffer area
1840  50D4 1053         JMP     H191                    set update data flag, write data, return
1841            *                                       
1842  50D6 06A0 H189    BL      @RCOFCB                 var: R2=sect/file R3=sect offset R0=rec offset
1842  50D8 5324  
1843  50DA C0C3         MOV     R3,R3                   sector offset in file
1844  50DC 1101         JLT     H192                    -1: top of file
1845  50DE 100B         JMP     H193                    in file
1846  50E0 0429 H192    BLWP    @>005A(R9)              next sector loop
1846  50E2 005A  
1847  50E4 3000         DATA    >3000                   save R2 + R3
1848  50E6 06A0         BL      @CALSUB                 call subroutine
1848  50E8 432E  
1849  50EA 456C         DATA    UPDBF                   update data buffer if needed
1850  50EC 0429         BLWP    @>005A(R9)                      
1850  50EE 005A  
1851  50F0 3001         DATA    >3001                   retrieve R2 + R3
1852  50F2 0583         INC     R3                      next sector
1853  50F4 04C0         CLR     R0                      init char offset in sector
1854            *                                       
1855  50F6 8083 H193    C       R3,R2                   did we reach last sector?
1856  50F8 1609         JNE     H194                    no
1857  50FA 0429         BLWP    @>005A(R9)              yes: expand file
1857  50FC 005A  
1858  50FE 9000         DATA    >9000                   save R0 + R4
1859  5100 06A0         BL      @CALSUB                 call subroutine
1859  5102 432E  
1860  5104 4636         DATA    APSCTS                  get last sector then append sectors to reach R3
1861  5106 0429         BLWP    @>005A(R9)                      
1861  5108 005A  
1862  510A 9001         DATA    >9001                   retrieve R0 + R4
1863            *                                       
1864  510C C169 H194    MOV     @>0054(R9),R5           PAB ptr
1864  510E 0054  
1865  5110 0225         AI      R5,5                    point to char count
1865  5112 0005  
1866  5114 0429         BLWP    @>005A(R9)              set VDP to read
1866  5116 005A  
1867  5118 00A2         DATA    >00A2                   address in R5
1868  511A D12F         MOVB    @-1026(R15),R4          get # of chars to write
1868  511C FBFE  
1869  511E 0984         SRL     R4,8                    make it a word
1870  5120 C144         MOV     R4,R5                   
1871  5122 A140         A       R0,R5                   add current char offset in sector
1872  5124 0585         INC     R5                      make room for size byte
1873  5126 0285         CI      R5,>00FF                past end of sector?
1873  5128 00FF  
1874  512A 1BDA         JH      H192                    yes: not enough room, try next sector
1875  512C 0702         SETO    R2                      ok: rec will fit in sector
1876  512E C069         MOV     @>0056(R9),R1           FDR ptr
1876  5130 0056  
1877  5132 A045         A       R5,R1                   past-last-byte offset
1878  5134 0221         AI      R1,256                  ptr to data buffer area
1878  5136 0100  
1879  5138 0429         BLWP    @>005A(R9)              set VDP to write
1879  513A 005A  
1880  513C 0023         DATA    >0023                   address in R1
1881  513E DBC2         MOVB    R2,@-2(R15)             write end-of-sect mark to FDR data buffer area
1881  5140 FFFE  
1882  5142 0429         BLWP    @>005A(R9)                      
1882  5144 005A  
1883  5146 8000         DATA    >8000                   save R0 (current byte offset in sector)
1884  5148 C003         MOV     R3,R0                   
1885  514A 06A0         BL      @UCOFCB                 update sect + rec offsets in control block
1885  514C 52C2  
1886  514E 0221         AI      R1,18                   point to eof offset in FDR (R1 modified by UCOFCB)
1886  5150 0012  
1887  5152 0429         BLWP    @>005A(R9)              set VDP to write
1887  5154 005A  
1888  5156 0023         DATA    >0023                   address in R1
1889  5158 DBC5         MOVB    R5,@-2(R15)             update eof offset in last sector, in FDR
1889  515A FFFE  
1890  515C 06A0         BL      @URFFDR                 update # of rec/file in FDR
1890  515E 52EE  
1891  5160 0429         BLWP    @>005A(R9)                      
1891  5162 005A  
1892  5164 2001         DATA    >2001                   retrieve old R0 in R2 (current byte offset)
1893  5166 C004         MOV     R4,R0                   record size
1894  5168 06A0         BL      @CALSUB                 call subroutine
1894  516A 432E  
1895  516C 529E         DATA    AFDRPT                  get FDR data buffer in R2, PAB data buffer in R1
1896  516E 06C4         SWPB    R4                      
1897  5170 0429         BLWP    @>005A(R9)              set VDP to write
1897  5172 005A  
1898  5174 0043         DATA    >0043                   address in R2
1899  5176 DBC4         MOVB    R4,@-2(R15)             write size byte to FDR data buffer
1899  5178 FFFE  
1900  517A 0582         INC     R2                      increment dest pointer
1901            *                                       
1902  517C C0C2 H191    MOV     R2,R3                   invert source and dest
1903  517E C081         MOV     R1,R2                   so we can use the same read-write loop
1904  5180 C043         MOV     R3,R1                   than the read opcode
1905  5182 C129         MOV     @>0056(R9),R4           FDR ptr
1905  5184 0056  
1906  5186 0604         DEC     R4                      pointer to drive # for that file
1907  5188 0429         BLWP    @>005A(R9)              set VDP to read
1907  518A 005A  
1908  518C 0082         DATA    >0082                   address in R4
1909  518E D16F         MOVB    @-1026(R15),R5          get drive #
1909  5190 FBFE  
1910  5192 0265         ORI     R5,>8000                add update data area flag
1910  5194 8000  
1911  5196 0429         BLWP    @>005A(R9)              set VDP to write
1911  5198 005A  
1912  519A 0083         DATA    >0083                   address in R4
1913  519C DBC5         MOVB    R5,@-2(R15)             write back flagged byte
1913  519E FFFE  
1914  51A0 0460         B       @WFDRPB                 to read-write loop
1914  51A2 5012  
1915            *                                       
1916  51A4 06A0 FFDRVP  BL      @CALSUB                 find FDR in VDP buffer
1916  51A6 432E  
1917  51A8 4A7A         DATA    FFFDRV                  find file FDR
1918  51AA C104         MOV     R4,R4                   found?
1919  51AC 1303         JEQ     AFPGPF                  yes
1920  51AE 06A0         BL      @ERROR5                 no: return with error
1920  51B0 4948  
1921  51B2 E000         DATA    >E000                   file error
1922  51B4 0581 AFPGPF  INC     R1                      point to filename in FDR
1923  51B6 CA41         MOV     R1,@>0056(R9)           new FDR ptr
1923  51B8 0056  
1924  51BA C129         MOV     @>0054(R9),R4           get PAB ptr
1924  51BC 0054  
1925  51BE 0584         INC     R4                      point to status byte
1926  51C0 04C0         CLR     R0                      
1927  51C2 0429         BLWP    @>005A(R9)              set VDP to read
1927  51C4 005A  
1928  51C6 0082         DATA    >0082                   address in R4
1929  51C8 D02F         MOVB    @-1026(R15),R0          get file status
1929  51CA FBFE  
1930  51CC 0460         B       @RTURN1                 return to caller
1930  51CE 434C  
1931            *                                       
1932  51D0 C129 RFDRST  MOV     @>0056(R9),R4           get status byte from FDR
1932  51D2 0056  
1933  51D4 0224         AI      R4,12                   point to status byte
1933  51D6 000C  
1934  51D8 0429         BLWP    @>005A(R9)              set VDP to read
1934  51DA 005A  
1935  51DC 0082         DATA    >0082                   address in R4
1936  51DE D02F         MOVB    @-1026(R15),R0          read status byte
1936  51E0 FBFE  
1937  51E2 045B         B       *R11                    
1938            *                                       
1939  51E4 D16F RRNPAB  MOVB    @-1026(R15),R5          get record # from PAB, check if valid
1939  51E6 FBFE  
1940  51E8 0985         SRL     R5,8                    
1941  51EA 1602         JNE     H195                    get # of rec/sector from FDR
1942  51EC 0205         LI      R5,256                  0: default to 256
1942  51EE 0100  
1943  51F0 C0E9 H195    MOV     @>0054(R9),R3           PAB ptr
1943  51F2 0054  
1944  51F4 0223         AI      R3,6                    point to rec #
1944  51F6 0006  
1945  51F8 0429         BLWP    @>005A(R9)              set VDP to read
1945  51FA 005A  
1946  51FC 0062         DATA    >0062                   address in R3
1947  51FE D06F         MOVB    @-1026(R15),R1          get record # from PAB
1947  5200 FBFE  
1948  5202 06C1         SWPB    R1                      
1949  5204 D06F         MOVB    @-1026(R15),R1                  
1949  5206 FBFE  
1950  5208 06C1         SWPB    R1                      
1951  520A C001         MOV     R1,R0                   save it
1952  520C 1101         JLT     H196                    too big
1953  520E 1003         JMP     H197                    ok
1954  5210 06A0 H196    BL      @ERROR5                 update data then return with error
1954  5212 4948  
1955  5214 8000         DATA    >8000                   memory full
1956  5216 0580 H197    INC     R0                      next record
1957  5218 0429         BLWP    @>005A(R9)              set VDP to write
1957  521A 005A  
1958  521C 0063         DATA    >0063                   address in R3
1959  521E DBC0         MOVB    R0,@-2(R15)             write back # of future record
1959  5220 FFFE  
1960  5222 06C0         SWPB    R0                      
1961  5224 DBC0         MOVB    R0,@-2(R15)                     
1961  5226 FFFE  
1962  5228 04C0         CLR     R0                      
1963  522A C0C1         MOV     R1,R3                   save # of desired rec
1964  522C 3C05         DIV     R5,R0                   divide by # of rec/sector = sect # in R0
1965  522E C0A9 RNFISE  MOV     @>0056(R9),R2           FDR ptr
1965  5230 0056  
1966  5232 0222         AI      R2,18                   point to total # of rec (# of sectors for var)
1966  5234 0012  
1967  5236 0429         BLWP    @>005A(R9)              set VDP to read
1967  5238 005A  
1968  523A 0042         DATA    >0042                   address in R2
1969  523C D0AF         MOVB    @-1026(R15),R2          get total # of recs/file (sect/file for var)
1969  523E FBFE  
1970  5240 06C2         SWPB    R2                      
1971  5242 D0AF         MOVB    @-1026(R15),R2          remember: bytes are swapped
1971  5244 FBFE  
1972  5246 8083         C       R3,R2                   compare with desired record (ignored by var)
1973  5248 045B         B       *R11                    
1974            *                                       
1975  524A 0429 RRFDR   BLWP    @>005A(R9)              fetch record into FDR data buffer area
1975  524C 005A  
1976  524E 4000         DATA    >4000                   save R1
1977  5250 0224         AI      R4,-18                  ptr to top of control block
1977  5252 FFEE  
1978  5254 0429         BLWP    @>005A(R9)              set VDP to read
1978  5256 005A  
1979  5258 0082         DATA    >0082                   address in R4
1980  525A D16F         MOVB    @-1026(R15),R5          get current sector offset in file
1980  525C FBFE  
1981  525E 06C5         SWPB    R5                      
1982  5260 D16F         MOVB    @-1026(R15),R5                  
1982  5262 FBFE  
1983  5264 0B85         SRC     R5,8                    
1984  5266 1105         JLT     H198                    -1: top of file
1985  5268 8005         C       R5,R0                   compare with desired offset (from RRNPAB)
1986  526A 130B         JEQ     H199                    same
1987  526C 06A0         BL      @CALSUB                 call subroutine
1987  526E 432E  
1988  5270 456C         DATA    UPDBF                   update data buffer if needed
1989  5272 C0C0 H198    MOV     R0,R3                   desired sector offset in file
1990  5274 06A0         BL      @UCOFCB                 update sect + rec offsets in control block
1990  5276 52C2  
1991  5278 0227         AI      R7,256                  point to data buffer area (R7 set by UCOFCB)
1991  527A 0100  
1992  527C 06A0         BL      @CALSUB                 call subroutine
1992  527E 432E  
1993  5280 4600         DATA    RDOFSC                  read a sector from offset in file (in R3)
1994  5282 0429 H199    BLWP    @>005A(R9)                      
1994  5284 005A  
1995  5286 4001         DATA    >4001                   retrieve R1
1996  5288 C0E9         MOV     @>0056(R9),R3           FDR ptr
1996  528A 0056  
1997  528C 0223         AI      R3,17                   point to record length
1997  528E 0011  
1998  5290 0429         BLWP    @>005A(R9)              set VDP to read
1998  5292 005A  
1999  5294 0062         DATA    >0062                   address in R3
2000  5296 D02F         MOVB    @-1026(R15),R0          get rec length in bytes
2000  5298 FBFE  
2001  529A 0980         SRL     R0,8                    make it a word
2002  529C 3840         MPY     R0,R1                   calc file offset in bytes
2003  529E A0A9 AFDRPT  A       @>0056(R9),R2           add FDR ptr
2003  52A0 0056  
2004  52A2 0222         AI      R2,256                  point inside data buffer area
2004  52A4 0100  
2005  52A6 C0E9         MOV     @>0054(R9),R3           PAB ptr
2005  52A8 0054  
2006  52AA 05C3         INCT    R3                      point to data buffer address
2007  52AC 0429         BLWP    @>005A(R9)              set VDP to read
2007  52AE 005A  
2008  52B0 0062         DATA    >0062                   address in R3
2009  52B2 D06F         MOVB    @-1026(R15),R1          get PAB data buffer address
2009  52B4 FBFE  
2010  52B6 06C1         SWPB    R1                      
2011  52B8 D06F         MOVB    @-1026(R15),R1                  
2011  52BA FBFE  
2012  52BC 06C1         SWPB    R1                      
2013  52BE 0460         B       @RTURN1                 return
2013  52C0 434C  
2014            *                               
2015  52C2 C1E9 UCOFCB  MOV     @>0056(R9),R7           update sect + rec offsets in control block
2015  52C4 0056  
2016  52C6 C047         MOV     R7,R1                   FDR ptr
2017  52C8 0221         AI      R1,-6                   top of file control block
2017  52CA FFFA  
2018  52CC 0429         BLWP    @>005A(R9)              set VDP to write
2018  52CE 005A  
2019  52D0 0023         DATA    >0023                   address in R1
2020  52D2 DBC0         MOVB    R0,@-2(R15)             current sector offset in file
2020  52D4 FFFE  
2021  52D6 06C0         SWPB    R0                      
2022  52D8 DBC0         MOVB    R0,@-2(R15)                     
2022  52DA FFFE  
2023  52DC 0221         AI      R1,4                    point to var rec offset in sector
2023  52DE 0004  
2024  52E0 06C5         SWPB    R5                      
2025  52E2 0429         BLWP    @>005A(R9)              set VDP to write
2025  52E4 005A  
2026  52E6 0023         DATA    >0023                   address in R1
2027  52E8 DBC5         MOVB    R5,@-2(R15)             first free byte in current sector
2027  52EA FFFE  
2028  52EC 045B         B       *R11                    
2029            *                                       
2030  52EE C0A9 URFFDR  MOV     @>0056(R9),R2           update # of rec/file in FDR
2030  52F0 0056  
2031  52F2 0429         BLWP    @>005A(R9)              set VDP to read
2031  52F4 005A  
2032  52F6 0042         DATA    >0042                   address in R2 (FDR ptr)
2033  52F8 D2AF         MOVB    @-1026(R15),R10         get first char of filename
2033  52FA FBFE  
2034  52FC 026A         ORI     R10,>8000               set was modified flag
2034  52FE 8000  
2035  5300 0429         BLWP    @>005A(R9)              set VDP to write
2035  5302 005A  
2036  5304 0043         DATA    >0043                   address in R2
2037  5306 DBCA         MOVB    R10,@-2(R15)            write flagged char back
2037  5308 FFFE  
2038  530A 0222         AI      R2,18                   point to # of recs/file in FDR
2038  530C 0012  
2039  530E 0583         INC     R3                      one more
2040  5310 0429         BLWP    @>005A(R9)              set VDP to write
2040  5312 005A  
2041  5314 0043         DATA    >0043                   address in R2
2042  5316 06C3         SWPB    R3                      update # of recs/file
2043  5318 DBC3         MOVB    R3,@-2(R15)                     
2043  531A FFFE  
2044  531C 06C3         SWPB    R3                      
2045  531E DBC3         MOVB    R3,@-2(R15)                     
2045  5320 FFFE  
2046  5322 045B         B       *R11                    
2047            *                                       
2048  5324 C229 RCOFCB  MOV     @>0056(R9),R8           get rec offset, compare sect with total
2048  5326 0056  
2049  5328 C108         MOV     R8,R4                   FDR ptr
2050  532A 0224         AI      R4,256                  point to data buffer area
2050  532C 0100  
2051  532E 0648         DECT    R8                      point to var record offset
2052  5330 0429         BLWP    @>005A(R9)              set VDP to read
2052  5332 005A  
2053  5334 0102         DATA    >0102                   address in R8
2054  5336 D0AF         MOVB    @-1026(R15),R2          get var rec offset in current sector
2054  5338 FBFE  
2055  533A 0982         SRL     R2,8                    make it a word
2056  533C C28B         MOV     R11,R10                 save return point
2057  533E 06A0         BL      @FDR2B2                 get 2 bytes from FDR (at R8-4) into R0
2057  5340 484A  
2058  5342 FFFC         DATA    -4                      current sector offset in file
2059  5344 C0C0         MOV     R0,R3                   save it
2060  5346 C2CA         MOV     R10,R11                 restore return point
2061  5348 C002         MOV     R2,R0                   var record offset
2062  534A 0460         B       @RNFISE                 get # of sect/file from FDR, return
2062  534C 522E  
2063            *
2064            *------------------------------------
2065            * Opcode 4: Rewind
2066            * --------------
2067            * PAB 0: >04
2068            *     1: file type <--- error code
2069            *   2-3:
2070            *     4:
2071            *     5:
2072            *   6-7: record #  <--- >0000 if sequential
2073            *     8:
2074            *------------------------------------                                   
2075            *
2076  534E 06A0 RWIND1  BL      @CALSUB                 call subroutine
2076  5350 432E  
2077  5352 51A4         DATA    FFDRVP                  find FDR in VDP buffers, read status from PAB
2078  5354 0429         BLWP    @>005A(R9)                      
2078  5356 005A  
2079  5358 8000         DATA    >8000                   save R0 (status from PAB)
2080  535A 0240         ANDI    R0,>0600                keep only access mode
2080  535C 0600  
2081  535E 1305         JEQ     H200                    update is ok
2082  5360 0280         CI      R0,>0400                is it input?
2082  5362 0400  
2083  5364 1302         JEQ     H200                    yes: ok
2084  5366 0460         B       @ERROR8                 output or append: return with illegal opcode
2084  5368 4D8E  
2085  536A 06A0 H200    BL      @CALSUB                 call subroutine
2085  536C 432E  
2086  536E 456C         DATA    UPDBF                   update data buffer if needed
2087  5370 0429         BLWP    @>005A(R9)                      
2087  5372 005A  
2088  5374 8001         DATA    >8001                   retrieve R0 (status from PAB)
2089  5376 0240         ANDI    R0,>0100                sequential or reloc?
2089  5378 0100  
2090  537A 1611         JNE     H201                    reloc: don't do anything, return
2091            *                                       
2092  537C 04C2 RWIND2  CLR     R2                      rewind file: record offset = 0
2093  537E 0703         SETO    R3                      current record = -1 (none)
2094  5380 06A0         BL      @UPDFCB                 update file control block
2094  5382 4F7E  
2095  5384 04C0         CLR     R0                      record 0
2096  5386 C229         MOV     @>0054(R9),R8           get PAB ptr
2096  5388 0054  
2097  538A 0228         AI      R8,6                    point to record #
2097  538C 0006  
2098  538E 0429         BLWP    @>005A(R9)              set VDP to write
2098  5390 005A  
2099  5392 0103         DATA    >0103                   address in R8
2100  5394 DBC0         MOVB    R0,@-2(R15)             write record #
2100  5396 FFFE  
2101  5398 1000         NOP                             
2102  539A DBC0         MOVB    R0,@-2(R15)                     
2102  539C FFFE  
2103  539E 0460 H201    B       @RTURN1                 return to caller
2103  53A0 434C  
2104            *
2105            *------------------------------------
2106            * Opcode 5: Load
2107            * --------------
2108            * PAB 0: >05
2109            *     1: file type  <--- error code
2110            *   2-3: data buffer address in VDP mem
2111            *     4:
2112            *     5:
2113            *   6-7: maximum # of bytes (size of buffer)
2114            *     8:
2115            *------------------------------------                                   
2116            *
2117  53A2 06A0 LOAD    BL      @CALSUB                 call subroutine
2117  53A4 432E  
2118  53A6 4AD8         DATA    FNDFDR                  find FDR on disk
2119  53A8 C104         MOV     R4,R4                   found?
2120  53AA 1303         JEQ     H203                    yes
2121  53AC 06A0 H202    BL      @ERROR5                 no: return with error
2121  53AE 4948  
2122  53B0 E000         DATA    >E000                   file error
2123  53B2 06A0 H203    BL      @FDR2B1                 get 2 bytes from FDR into R0
2123  53B4 4846  
2124  53B6 000C         DATA    12                      file status byte
2125  53B8 0240         ANDI    R0,>0100                is it program?
2125  53BA 0100  
2126  53BC 13F7         JEQ     H202                    no: file error
2127  53BE 05C8         INCT    R8                      point to # of sect/file in FDR
2128  53C0 0429         BLWP    @>005A(R9)              set VDP to read
2128  53C2 005A  
2129  53C4 0102         DATA    >0102                   address in R8
2130  53C6 D06F         MOVB    @-1026(R15),R1          get # of sectors in file
2130  53C8 FBFE  
2131  53CA 06C1         SWPB    R1                      
2132  53CC D06F         MOVB    @-1026(R15),R1                  
2132  53CE FBFE  
2133  53D0 0B81         SRC     R1,8                    
2134  53D2 13EC         JEQ     H202                    0=empty file: return with file error
2135  53D4 06A0         BL      @RBANB                  get data buffer address in R7, # of sectors in R2
2135  53D6 5494  
2136  53D8 05C8         INCT    R8                      point to eof offset in FDR
2137  53DA 04C4         CLR     R4                      
2138  53DC 0429         BLWP    @>005A(R9)              set VDP to read
2138  53DE 005A  
2139  53E0 0102         DATA    >0102                   address in R8
2140  53E2 D12F         MOVB    @-1026(R15),R4          get # of bytes in last sector
2140  53E4 FBFE  
2141  53E6 8081         C       R1,R2                   compare # of sect with max in PAB
2142  53E8 1BE1         JH      H202                    file is too big: return with file error
2143  53EA 1602         JNE     H204                    file is smaller
2144  53EC 8100         C       R0,R4                   same # of sect: check bytes in last sector
2145  53EE 1ADE         JL      H202                    file is too big: file error
2146  53F0 04C3 H204    CLR     R3                      sector offset in file
2147  53F2 06C4         SWPB    R4                      
2148  53F4 0601 H206    DEC     R1                      next sector
2149  53F6 130D         JEQ     H205                    done
2150  53F8 0429         BLWP    @>005A(R9)                      
2150  53FA 005A  
2151  53FC D900         DATA    >D900                   save R0, R1, R3, R4, R7
2152  53FE 06A0         BL      @CALSUB                 call subroutine
2152  5400 432E  
2153  5402 4600         DATA    RDOFSC                  read a sector from offset in R3
2154  5404 0429         BLWP    @>005A(R9)              restore R0, R1, R3, R4, R7
2154  5406 005A  
2155  5408 D901         DATA    >D901                   
2156  540A 0583         INC     R3                      next sector
2157  540C 0227         AI      R7,256                  256 bytes further in PAB buffer
2157  540E 0100  
2158  5410 10F1         JMP     H206                    keep going
2159            *                                       
2160  5412 C104 H205    MOV     R4,R4                   
2161  5414 1604         JNE     H207                    
2162  5416 06A0         BL      @CALSUB                 call subroutine
2162  5418 432E  
2163  541A 4600         DATA    RDOFSC                  read a sector from offset in R3
2164  541C 1011         JMP     H208                    done
2165            *                                       
2166  541E C147 H207    MOV     R7,R5                   save PAB data buffer ptr
2167  5420 C1E9         MOV     @>0056(R9),R7           FDR ptr
2167  5422 0056  
2168  5424 0227         AI      R7,256                  point to FDR data area
2168  5426 0100  
2169  5428 0429         BLWP    @>005A(R9)                      
2169  542A 005A  
2170  542C 0D00         DATA    >0D00                   save R4, R5, R7
2171  542E 06A0         BL      @CALSUB                 call subroutine
2171  5430 432E  
2172  5432 4600         DATA    RDOFSC                  read a sector from offset in R3
2173  5434 0429         BLWP    @>005A(R9)              restore R4 in R0, R5 in R1, R7 in R2
2173  5436 005A  
2174  5438 E001         DATA    >E001                   
2175  543A 06A0         BL      @CALSUB                 call subroutine
2175  543C 432E  
2176  543E 5012         DATA    WFDRPB                  write bytes from FDR data buffer to PAB data buf
2177  5440 0460 H208    B       @UPDFDR                 update FDR, data buffer, VIB and return to caller
2177  5442 454C  
2178            *
2179            *------------------------------------
2180            * Opcode 6: Save
2181            * --------------
2182            * PAB 0: >06
2183            *     1: file type  <--- error code
2184            *   2-3: data buffer address in VDP mem
2185            *     4:
2186            *     5:
2187            *   6-7: # of bytes to save
2188            *     8:
2189            *------------------------------------                                   
2190            *
2191  5444 06A0 SAVE    BL      @CALSUB                 call subroutine
2191  5446 432E  
2192  5448 4466         DATA    CRFIL1                  create file
2193  544A 06A0         BL      @RBANB                  get PAB buffer ptr + # of bytes
2193  544C 5494  
2194  544E 04C3         CLR     R3                      sector offset 0
2195  5450 0429 H209    BLWP    @>005A(R9)                      
2195  5452 005A  
2196  5454 B100         DATA    >B100                   save R0, R2, R3, R7
2197  5456 06A0         BL      @CALSUB                 call subroutine
2197  5458 432E  
2198  545A 4620         DATA    WROFSC                  write sector to offset in R3
2199  545C 0429         BLWP    @>005A(R9)                      
2199  545E 005A  
2200  5460 B101         DATA    >B101                   retrieve R0, R2, R3, R7
2201  5462 0583         INC     R3                      next sector
2202  5464 0227         AI      R7,256                  256 bytes further in PAB data buffer
2202  5466 0100  
2203  5468 0602         DEC     R2                      next sector
2204  546A 16F2         JNE     H209                    more to do
2205            *                                       
2206  546C C069         MOV     @>0056(R9),R1           FDR ptr
2206  546E 0056  
2207  5470 0221         AI      R1,12                   point to file status byte
2207  5472 000C  
2208  5474 0202         LI      R2,>0100                value for program file
2208  5476 0100  
2209  5478 0429         BLWP    @>005A(R9)              set VDP to write
2209  547A 005A  
2210  547C 0023         DATA    >0023                   address in R1
2211  547E DBC2         MOVB    R2,@-2(R15)             write file status byte in FDR
2211  5480 FFFE  
2212  5482 0221         AI      R1,4                    point to eof offset byte in FDR
2212  5484 0004  
2213  5486 0429         BLWP    @>005A(R9)              set VDP to write
2213  5488 005A  
2214  548A 0023         DATA    >0023                   address in R1
2215  548C DBC0         MOVB    R0,@-2(R15)             # of bytes in last sector
2215  548E FFFE  
2216  5490 0460         B       @UPDFDR                 update FDR, data buffer, VIB then return to caller
2216  5492 454C  
2217            *                                       
2218  5494 C029 RBANB   MOV     @>0054(R9),R0           get buffer address + # of bytes
2218  5496 0054  
2219  5498 05C0         INCT    R0                      data buffer in PAB
2220  549A 0429         BLWP    @>005A(R9)              set VDP to read
2220  549C 005A  
2221  549E 0002         DATA    >0002                   address in R0
2222  54A0 D1EF         MOVB    @-1026(R15),R7          get data buffer address
2222  54A2 FBFE  
2223  54A4 06C7         SWPB    R7                      
2224  54A6 D1EF         MOVB    @-1026(R15),R7                  
2224  54A8 FBFE  
2225  54AA 06C7         SWPB    R7                      
2226  54AC 0220         AI      R0,4                    point to # of bytes to transfer
2226  54AE 0004  
2227  54B0 0429         BLWP    @>005A(R9)              set VDP to read
2227  54B2 005A  
2228  54B4 0002         DATA    >0002                   address in R0
2229  54B6 D0AF         MOVB    @-1026(R15),R2          get # of bytes to be transfered
2229  54B8 FBFE  
2230  54BA 0982         SRL     R2,8                    make it # of sectors (256 bytes each)
2231  54BC 04C0         CLR     R0                      
2232  54BE D02F         MOVB    @-1026(R15),R0          see if one more is needed
2232  54C0 FBFE  
2233  54C2 1301         JEQ     H210                    no
2234  54C4 0582         INC     R2                      yes: one more sector
2235  54C6 045B H210    B       *R11                    
2236            *
2237            *-------------------------------------
2238            * Opcode 9: Status
2239            * --------------
2240            * PAB 0: >09
2241            *     1:
2242            *   2-3:
2243            *     4:
2244            *     5:
2245            *   6-7: record #
2246            *     8:           <--- file status
2247            *
2248            * Status bits, returned in PAB byte 8:
2249            * >80: file not found
2250            * >40: file is protected
2251            * >20:
2252            * >10: internal (else display or program)
2253            * >08: program file
2254            * >04: variable (else fixed or program)
2255            * >02: memory full
2256            * >01: end-of-file reached
2257            *-------------------------------------                                  
2258            *
2259  54C8 06A0 STATUS  BL      @CALSUB                 call subroutine
2259  54CA 432E  
2260  54CC 4A7A         DATA    FFFDRV                  save filename in comp buf, then find FDR in VDP
2261  54CE C104         MOV     R4,R4                   found?
2262  54D0 1310         JEQ     H211                    yes
2263            *                                       
2264  54D2 06A0         BL      @CALSUB                 no: call subroutine
2264  54D4 432E  
2265  54D6 4AE2         DATA    FFDRDK                  find FDR on disk
2266  54D8 0200         LI      R0,>8000                value for file not found
2266  54DA 8000  
2267  54DC C104         MOV     R4,R4                   found?
2268  54DE 1649         JNE     H212                    no: return with that value
2269  54E0 C069         MOV     @>0056(R9),R1           yes: ptr to FDR
2269  54E2 0056  
2270  54E4 04C2         CLR     R2                      
2271  54E6 0429         BLWP    @>005A(R9)              set VDP to write
2271  54E8 005A  
2272  54EA 0023         DATA    >0023                   address in R1
2273  54EC DBC2         MOVB    R2,@-2(R15)             invalidate that FDR (file not open)
2273  54EE FFFE  
2274  54F0 1036         JMP     H213                    transfer FDR status to PAB status byte
2275            *                                       
2276  54F2 06A0 H211    BL      @CALSUB                 file is open: call subroutine
2276  54F4 432E  
2277  54F6 51B4         DATA    AFPGPF                  adjust FDR ptr, get PAB file type into R4
2278  54F8 06A0         BL      @RFDRST                 get status byte from FDR
2278  54FA 51D0  
2279  54FC 1101         JLT     H214                    var
2280  54FE 1006         JMP     H215                    fix
2281            *                                       
2282  5500 06A0 H214    BL      @CALSUB                 var: call subroutine
2282  5502 432E  
2283  5504 5036         DATA    RRSEC                   load wanted sector, point to wanted rec in buffer
2284  5506 1013         JMP     H216                    out of range
2285  5508 04C2         CLR     R2                      ok: clear flag
2286  550A 1029         JMP     H213                    copy status byte from FDR into PAB, return
2287            *                                       
2288  550C D16F H215    MOVB    @-1026(R15),R5          fix: get rec/sect byte
2288  550E FBFE  
2289  5510 0985         SRL     R5,8                    make it a word
2290  5512 1602         JNE     H217                    
2291  5514 0205         LI      R5,>0100                00 (program files) means 256
2291  5516 0100  
2292  5518 06A0 H217    BL      @PABR2B                 get 2 bytes from PAB into R0
2292  551A 4840  
2293  551C 0006         DATA    6                       # of wanted record
2294  551E C0C0         MOV     R0,R3                   save it
2295  5520 111C         JLT     H218                    too big: set memory full bit in PAB status byte
2296  5522 06A0         BL      @RNFISE                 get # recs/file into R2, comp with R3
2296  5524 522E  
2297  5526 04C2         CLR     R2                      
2298  5528 1A1A         JL      H213                    in file: copy file type bits, return
2299  552A 3C85         DIV     R5,R2                   how many sectors do we need?
2300  552C C0C2         MOV     R2,R3                   save result
2301            *                                       
2302  552E 06A0 H216    BL      @FDR2B1                 get 2 bytes from FDR into R0
2302  5530 4846  
2303  5532 000E         DATA    14                      # of sectors/file
2304  5534 0583         INC     R3                      plus 1 sector for FDR
2305  5536 0202         LI      R2,>0100                value for eof reached in PAB status
2305  5538 0100  
2306  553A 60C0         S       R0,R3                   are there enough sectors in file for these recs?
2307  553C 1501         JGT     H219                    
2308  553E 100F         JMP     H213                    yes: we reached the eof
2309  5540 06A0 H219    BL      @CALSUB                 call subroutine
2309  5542 432E  
2310  5544 49A8         DATA    RWVIB                   load VIB (sector 0)
2311  5546 C103         MOV     R3,R4                   number of sectors that will be needed
2312  5548 C205         MOV     R5,R8                   VIB ptr
2313  554A 0228         AI      R8,10                   skip 10 bytes (required by CFSVIB)
2313  554C 000A  
2314  554E 06A0         BL      @CFSVIB                 count free sectors in bitmap, into R3
2314  5550 573C  
2315  5552 0202         LI      R2,>0100                value for eof reached
2315  5554 0100  
2316  5556 8103         C       R3,R4                   are there that many free sectors?
2317  5558 1402         JHE     H213                    yes
2318  555A 0202 H218    LI      R2,>0200                value for memory full
2318  555C 0200  
2319            *                                       
2320  555E 06A0 H213    BL      @FDR2B1                 get 2 bytes from FDR into R0
2320  5560 4846  
2321  5562 000C         DATA    12                      file status byte
2322  5564 0240         ANDI    R0,>8F00                mask irrelevant bits
2322  5566 8F00  
2323  5568 1502         JGT     H220                    
2324  556A 0260         ORI     R0,>0080                var: put var bit in PAB status style
2324  556C 0080  
2325  556E 0A30 H220    SLA     R0,3                    get rid of var bit in FDR style
2326  5570 F002         SOCB    R2,R0                   add eof and mem full bits
2327            *                                       
2328  5572 C069 H212    MOV     @>0054(R9),R1           PAB ptr
2328  5574 0054  
2329  5576 0221         AI      R1,8                    point to bias/status return byte
2329  5578 0008  
2330  557A 0429         BLWP    @>005A(R9)              set VDP to write
2330  557C 005A  
2331  557E 0023         DATA    >0023                   address in R1
2332  5580 DBC0         MOVB    R0,@-2(R15)             write file status to PAB
2332  5582 FFFE  
2333  5584 0460         B       @RTURN1                 return to caller
2333  5586 434C  
2334            *
2335            *---------------------------------
2336            * Disk directory access
2337            * ---------------------
2338            * The directory is accessed by omiting the filename in the DSR name: "DSK1."
2339            * It must be opened for input only, as an Int/Fix 38 file.
2340            * It consists in upto 128 records, the first one contains the disk informations,
2341            * the others the informations for upto 127 files (in alphabetical order).
2342            * Each record consists in an ascii string and three floating point numbers.
2343            *
2344            * Record 0 contains:
2345            * - Diskname (an ascii string of upto 10 chars).
2346            * - The number zero.
2347            * - The number of sectors on disk.
2348            * - The number of free sectors on disk.
2349            *
2350            * Other records contain:
2351            * - Filename (an ascii string of upto 10 chars).
2352            * - Filetype: 1=D/F, 2=D/V, 3=I/F, 4=I/V, 5=Prog, 0=end of directory.
2353            *   If the file is protected, this number is negative (-1=D/F, etc).
2354            * - File size in sectors (including the FDR itself).
2355            * - File record length (0 for programs).
2356            *---------------------------------
2357             
2358            *---------------------------------
2359            * Open disk directory pseudo-file
2360            *---------------------------------                                      
2361            *
2362  5588 D02F OPNDIR  MOVB    @-1026(R15),R0          get file type from PAB
2362  558A FBFE  
2363  558C 0240         ANDI    R0,>1E00                mask irrelavant bits (rel/seq)
2363  558E 1E00  
2364  5590 0280         CI      R0,>0C00                is it int/fix in output mode?
2364  5592 0C00  
2365  5594 1303         JEQ     H221                    yes
2366  5596 06A0 H223    BL      @RETERR                 return with error
2366  5598 4974  
2367  559A 4000         DATA    >4000                   bad attributes
2368  559C 06A0 H221    BL      @PABR2B                 get 2 bytes from PAB into R0
2368  559E 4840  
2369  55A0 0004         DATA    4                       rec length
2370  55A2 0980         SRL     R0,8                    make it a word
2371  55A4 1303         JEQ     H222                    >00= default: set it to 38
2372  55A6 0280         CI      R0,>0026                is it 38?
2372  55A8 0026  
2373  55AA 16F5         JNE     H223                    no: return with bad attributes error
2374  55AC 0200 H222    LI      R0,>2600                set rec len to 38
2374  55AE 2600  
2375  55B0 0429         BLWP    @>005A(R9)              set VDP to write
2375  55B2 005A  
2376  55B4 0103         DATA    >0103                   address in R8 (from PABR2B)
2377  55B6 DBC0         MOVB    R0,@-2(R15)             write rec len to PAB
2377  55B8 FFFE  
2378            *                                       
2379  55BA 04C7         CLR     R7                      
2380  55BC 06A0         BL      @FNDRV                  find matching drive in file control blocks
2380  55BE 5776  
2381  55C0 55C8         DATA    H224                    go there if not found
2382  55C2 06A0 ERRR10  BL      @ERROR5                 update data then return with error
2382  55C4 4948  
2383  55C6 E000         DATA    >E000                   file error
2384  55C8 C1C7 H224    MOV     R7,R7                   did we find a free slot?
2385  55CA 1603         JNE     H225                    yes
2386  55CC 06A0         BL      @RETERR                 no: return with error
2386  55CE 4974  
2387  55D0 8000         DATA    >8000                   memory full
2388  55D2 0429 H225    BLWP    @>005A(R9)              set VDP to write
2388  55D4 005A  
2389  55D6 00E3         DATA    >00E3                   address in R7
2390  55D8 DBC3         MOVB    R3,@-2(R15)             write drive #
2390  55DA FFFE  
2391  55DC 06C3         SWPB    R3                      
2392  55DE DBC3         MOVB    R3,@-2(R15)             and a space as filename (illegal, indicates dir)
2392  55E0 FFFE  
2393  55E2 0460         B       @RTURN1                 return to caller
2393  55E4 434C  
2394            *
2395            *---------------------------------
2396            * Close disk directory
2397            *---------------------------------                                      
2398  55E6 06A0 CLSDIR  BL      @FNDRV                  find matching drive in file control blocks
2398  55E8 5776  
2399  55EA 55C2         DATA    ERRR10                  go there if not found: return with file error
2400  55EC 04C0         CLR     R0                      
2401  55EE 0429         BLWP    @>005A(R9)              set VDP to write
2401  55F0 005A  
2402  55F2 0103         DATA    >0103                   address in R8
2403  55F4 DBC0         MOVB    R0,@-2(R15)             clear drive #
2403  55F6 FFFE  
2404  55F8 0460         B       @RTURN1                 return to caller
2404  55FA 434C  
2405            *
2406            *---------------------------------
2407            * Read a record from disk directory
2408            *---------------------------------                                      
2409            *
2410  55FC 06A0 RDDIR   BL      @FNDRV                  find matching drive in file control blocks
2410  55FE 5776  
2411  5600 55C2         DATA    ERRR10                  go ther it not found: return with file error
2412  5602 0588         INC     R8                      
2413  5604 C148         MOV     R8,R5                   save ptr to FDR
2414  5606 06A0         BL      @PABR2B                 get 2 bytes from PAB into R0
2414  5608 4840  
2415  560A 0006         DATA    6                       record #
2416  560C C080         MOV     R0,R2                   save it
2417  560E 0582         INC     R2                      
2418  5610 0429         BLWP    @>005A(R9)              set VDP to write
2418  5612 005A  
2419  5614 0103         DATA    >0103                   address in R8
2420  5616 DBC2         MOVB    R2,@-2(R15)             write record number in FDR
2420  5618 FFFE  
2421  561A 06C2         SWPB    R2                      after first char of filename!
2422  561C DBC2         MOVB    R2,@-2(R15)                     
2422  561E FFFE  
2423  5620 0A10         SLA     R0,1                    since two byte per file ptr
2424  5622 D000         MOVB    R0,R0                   is rec # greater than 128?
2425  5624 1303         JEQ     H226                    no
2426  5626 06A0         BL      @ERROR5                 yes: update data then return with error
2426  5628 4948  
2427  562A A000         DATA    >A000                   past eof
2428  562C 0702 H226    SETO    R2                      code for read
2429  562E C100         MOV     R0,R4                   record #
2430  5630 133B         JEQ     H227                    0=disk parameters
2431  5632 0204         LI      R4,1                    sector #1
2431  5634 0001  
2432  5636 06A0         BL      @CALSUB                 call subroutine
2432  5638 432E  
2433  563A 4A24         DATA    RWSEC                   read sector into buffer in R5
2434  563C C205         MOV     R5,R8                   buffer ptr
2435  563E 0225         AI      R5,255                  point to data buffer area in this ctrl block
2435  5640 00FF  
2436  5642 0640         DECT    R0                      don't count record 0
2437  5644 A200         A       R0,R8                   point to desired file ptr
2438  5646 06A0         BL      @VDPR2B                 get two byte from VDP at R8 into R0
2438  5648 484C  
2439  564A C100         MOV     R0,R4                   sector where that FDR is to be found
2440  564C 1328         JEQ     H228                    no more
2441  564E 06A0         BL      @CALSUB                 call subroutine
2441  5650 432E  
2442  5652 4A24         DATA    RWSEC                   read FDR sector into data buffer area
2443  5654 06A0         BL      @FDR2B1                 get 2 bytes from FDR into R0
2443  5656 4846  
2444  5658 010E         DATA    270                     # of sect/file
2445  565A C180         MOV     R0,R6                   save it to output file size
2446  565C 0586         INC     R6                      include the FDR itself
2447  565E D0EF         MOVB    @-1026(R15),R3          ignore eof offset
2447  5660 FBFE  
2448  5662 0202         LI      R2,>0A00                10 chars per filename
2448  5664 0A00  
2449  5666 D0EF         MOVB    @-1026(R15),R3          get rec length
2449  5668 FBFE  
2450  566A 0983         SRL     R3,8                    make it a word
2451  566C 0648         DECT    R8                      point to status byte in FDR
2452  566E 0429         BLWP    @>005A(R9)              set VDP to read
2452  5670 005A  
2453  5672 0102         DATA    >0102                   address in R8
2454  5674 D02F         MOVB    @-1026(R15),R0          get file status byte
2454  5676 FBFE  
2455  5678 C1C0         MOV     R0,R7                   
2456  567A 0240         ANDI    R0,>0800                keep only write protected bit
2456  567C 0800  
2457  567E 51C0         SZCB    R0,R7                   clear write protected bit (if it was set)
2458  5680 0987         SRL     R7,8                    make it a word
2459  5682 0587         INC     R7                      types are numbered from 1
2460  5684 0287         CI      R7,>0002                is it a program file?
2460  5686 0002  
2461  5688 1602         JNE     H229                    no
2462  568A 0227         AI      R7,3                    yes: make it type 5
2462  568C 0003  
2463  568E 0287 H229    CI      R7,>0008                is it var?
2463  5690 0008  
2464  5692 1A02         JL      H230                    no
2465  5694 0227         AI      R7,-127                 yes: add 1 and clear var bit
2465  5696 FF81  
2466  5698 0A40 H230    SLA     R0,4                    write protect bit will be >80
2467  569A E1C0         SOC     R0,R7                   add it to file type
2468  569C 1004         JMP     H231                    
2469            *                                       
2470  569E 04C2 H228    CLR     R2                      no more files: filename size = 0
2471  56A0 04C6         CLR     R6                      file size = 0
2472  56A2 04C3         CLR     R3                      rec length = 0
2473  56A4 04C7         CLR     R7                      type = 0
2474  56A6 100F H231    JMP     H232                    output that
2475            *                                       
2476  56A8 0225 H227    AI      R5,255                  disk info: point to data buffer area in ctrl block
2476  56AA 00FF  
2477  56AC 06A0         BL      @CALSUB                 call subroutine
2477  56AE 432E  
2478  56B0 4A24         DATA    RWSEC                   read sector 0
2479  56B2 06A0         BL      @FDR2B1                 get 2 bytes from FDR into R0
2479  56B4 4846  
2480  56B6 010A         DATA    266                     # of sectors on disk
2481  56B8 C180         MOV     R0,R6                   duplicate it
2482  56BA 0646         DECT    R6                      minus directory itself (sect 0 + 1)
2483  56BC 06A0         BL      @CFSVIB                 count free sectors in bitmap, result in R3
2483  56BE 573C  
2484  56C0 04C7         CLR     R7                      filetype is not used
2485  56C2 0202         LI      R2,>0A00                diskname is 10 chars
2485  56C4 0A00  
2486            *                                       
2487  56C6 06A0 H232    BL      @PABR2B                 get 2 bytes from PAB into R0
2487  56C8 4840  
2488  56CA 0002         DATA    2                       APEDSK99: error in source listing (was R2)
2489  56CC C200         MOV     R0,R8                   duplicate it
2490  56CE 0588         INC     R8                      skip first byte
2491  56D0 0982         SRL     R2,8                    filename length (or diskname)
2492  56D2 1316         JEQ     H233                    0: skip filename copying
2493  56D4 04C1         CLR     R1                      
2494  56D6 0429 H234    BLWP    @>005A(R9)              set VDP to read
2494  56D8 005A  
2495  56DA 00A2         DATA    >00A2                   address in R5 (FDR ptr)
2496  56DC D06F         MOVB    @-1026(R15),R1          get 1 char from filename in FDR
2496  56DE FBFE  
2497  56E0 0281         CI      R1,>2000                is it a space?
2497  56E2 2000  
2498  56E4 1309         JEQ     H235                    yes: end of name
2499  56E6 0429         BLWP    @>005A(R9)              no: set VDP to write
2499  56E8 005A  
2500  56EA 0103         DATA    >0103                   address in R8 (PAB data buffer ptr)
2501  56EC DBC1         MOVB    R1,@-2(R15)             copy char in PAB data buffer
2501  56EE FFFE  
2502  56F0 0585         INC     R5                      increment source ptr
2503  56F2 0588         INC     R8                      increment destination ptr
2504  56F4 0602         DEC     R2                      next char
2505  56F6 16EF         JNE     H234                    
2506  56F8 0502 H235    NEG     R2                      number of trailing spaces
2507  56FA 0222         AI      R2,10                   number of chars in filename
2507  56FC 000A  
2508  56FE 06C2         SWPB    R2                      
2509  5700 0429 H233    BLWP    @>005A(R9)              set VDP to write
2509  5702 005A  
2510  5704 0003         DATA    >0003                   address in R0 (beg of PAB data buffer)
2511  5706 DBC2         MOVB    R2,@-2(R15)             write string length byte
2511  5708 FFFE  
2512            *                                       
2513  570A 0429         BLWP    @>005A(R9)              set VDP to write
2513  570C 005A  
2514  570E 0103         DATA    >0103                   address in R8
2515  5710 C047         MOV     R7,R1                   file type + protection
2516  5712 06A0         BL      @INT2FP                 make it a float number
2516  5714 57BA  
2517  5716 C046         MOV     R6,R1                   file size in sectors, including FDR
2518  5718 06A0         BL      @INT2FP                 make it a float number
2518  571A 57BA  
2519  571C C043         MOV     R3,R1                   record length
2520  571E 06A0         BL      @INT2FP                 make it a float number
2520  5720 57BA  
2521  5722 C229         MOV     @>0054(R9),R8           get PAB ptr
2521  5724 0054  
2522  5726 0228         AI      R8,5                    point to character count
2522  5728 0005  
2523  572A 0200         LI      R0,>2600                always 38 bytes
2523  572C 2600  
2524  572E 0429         BLWP    @>005A(R9)              set VDP to write
2524  5730 005A  
2525  5732 0103         DATA    >0103                   address in R8
2526  5734 DBC0         MOVB    R0,@-2(R15)             write # of characters in record
2526  5736 FFFE  
2527  5738 0460         B       @RTURN1                 return to caller
2527  573A 434C  
2528            *                                       
2529  573C 0228 CFSVIB  AI      R8,46                   count free sectors in VIB bitmap
2529  573E 002E  
2530  5740 0202         LI      R2,200                  bitmap size
2530  5742 00C8  
2531  5744 04C3         CLR     R3                      free sectors counter
2532  5746 0429         BLWP    @>005A(R9)              set VDP to read
2532  5748 005A  
2533  574A 0102         DATA    >0102                   address in R8
2534  574C D06F H236    MOVB    @-1026(R15),R1          get a byte from bitmap
2534  574E FBFE  
2535  5750 0221         AI      R1,256                  
2535  5752 0100  
2536  5754 0981         SRL     R1,8                    
2537  5756 130C         JEQ     H237                    was >FF: no free sectors, next byte
2538  5758 0601         DEC     R1                      was it >00?
2539  575A 1603         JNE     H238                    no: count bits
2540  575C 0223         AI      R3,8                    yes: 8 more free sectors
2540  575E 0008  
2541  5760 1007         JMP     H237                    next byte
2542  5762 0200 H238    LI      R0,8                    8 bits per byte
2542  5764 0008  
2543  5766 0911 H239    SRL     R1,1                    test a bit
2544  5768 1801         JOC     H240                    was 1: sector is used
2545  576A 0583         INC     R3                      was 0: one more free sector
2546  576C 0600 H240    DEC     R0                      next bit in byte
2547  576E 16FB         JNE     H239                    more to come
2548  5770 0602 H237    DEC     R2                      next bitmap byte
2549  5772 16EC         JNE     H236                    more to come
2550  5774 045B         B       *R11                    
2551            *                                       
2552  5776 C2BB FNDRV   MOV     *R11+,R10               find drive in file control blocks
2553  5778 C14B         MOV     R11,R5                  save 2 returns
2554  577A C229         MOV     @>0056(R9),R8           top of mem word in VDP buffers header
2554  577C 0056  
2555  577E 0228         AI      R8,3                    point to max # of files
2555  5780 0003  
2556  5782 0429         BLWP    @>005A(R9)              set VDP to read
2556  5784 005A  
2557  5786 0102         DATA    >0102                   address in R8
2558  5788 D0AF         MOVB    @-1026(R15),R2          get # of files
2558  578A FBFE  
2559  578C 0882         SRA     R2,8                    make it a word
2560  578E 0228         AI      R8,6                    point to drive # in file ctrl block
2560  5790 0006  
2561  5792 0203         LI      R3,>0020                filename begin with space (illegal: flag for dir)
2561  5794 0020  
2562  5796 D0C6         MOVB    R6,R3                   APEDSK99: error in original disassembly (was R5)
2563  5798 06A0 H241    BL      @VDPR2B                 read 2 bytes from VDP at R8 into R0
2563  579A 484C  
2564  579C 8003         C       R3,R0                   match with that control block?
2565  579E 1309         JEQ     H242                    yes
2566  57A0 0240         ANDI    R0,>00FF                keep only first char of filename
2566  57A2 00FF  
2567  57A4 1601         JNE     H243                    valid filename: a FDR is loaded here
2568  57A6 C1C8         MOV     R8,R7                   this space is free: save ptr
2569  57A8 0228 H243    AI      R8,518                  point to next file control block
2569  57AA 0206  
2570  57AC 0602         DEC     R2                      next file
2571  57AE 16F4         JNE     H241                    more to come
2572  57B0 045A         B       *R10                    not found: return to address passed in data word
2573  57B2 0588 H242    INC     R8                      drive matches: point to FDR
2574  57B4 CA48         MOV     R8,@>0056(R9)           save ptr
2574  57B6 0056  
2575  57B8 0455         B       *R5                     return to caller after data word
2576            *
2577            *--------------------------------------
2578            * Floating point format
2579            * ---------------------
2580            * Float numbers are 8 bytes long: EE 12 34 56 78 9A BC
2581            * EE is the exponent in radix 100 (not in radix 10 as usual!). It is biased
2582            * by 64: >40=0, 41=1 (i.e *100), >42=2 (i.e * 10,000) >3F= -1 (i.e /100), etc
2583            *
2584            * 12 ... BC are the mantissa in binary coded decimal: each byte encodes two
2585            * decimal digits from 00 to 99
2586            *
2587            * For negative numbers, the first word is negated
2588            * For zero, the first word is >0000 the others are irrelevant
2589            *
2590            * Examples: 40 08 00 00 00 00 00 00 is 8.0
2591            *           41 02 37 00 00 00 00 00 is 255.0 (>37 hex = 55 decimal)
2592            *           BF F8 00 00 00 00 00 00 is -8.0
2593            *           43 01 02 03 04 05 06 07 is 1020304.050607
2594            *--------------------------------------                                 
2595            *
2596  57BA 0202 INT2FP  LI      R2,>0800                write an integer in floating point format
2596  57BC 0800  
2597  57BE DBC2         MOVB    R2,@-2(R15)             size=8
2597  57C0 FFFE  
2598  57C2 C141         MOV     R1,R5                   integer is in R1: save it for sign processing
2599  57C4 0241         ANDI    R1,>7FFF                clear sign bit
2599  57C6 7FFF  
2600  57C8 0281         CI      R1,100                  is it less than 100?
2600  57CA 0064  
2601  57CC 1A07         JL      H244                    yes
2602  57CE 04C0         CLR     R0                      100 or over
2603  57D0 0204         LI      R4,100                  
2603  57D2 0064  
2604  57D4 3C04         DIV     R4,R0                   divide by 100
2605  57D6 0260         ORI     R0,>4100                add exponent 2 to hundreths
2605  57D8 4100  
2606  57DA 1005         JMP     H245                    
2607            *                                       
2608  57DC C001 H244    MOV     R1,R0                   is it 0?
2609  57DE 1302         JEQ     H246                    yes: exponent is 0
2610  57E0 0260         ORI     R0,>4000                no: add exponent 1
2610  57E2 4000  
2611  57E4 04C1 H246    CLR     R1                      next digits will be 0
2612            *                                       
2613  57E6 C145 H245    MOV     R5,R5                   test sign bit
2614  57E8 1101         JLT     H247                    negative
2615  57EA 1001         JMP     H248                    positive or zero
2616  57EC 0500 H247    NEG     R0                      negate first word
2617  57EE DBC0 H248    MOVB    R0,@-2(R15)             write exponent to VDP at preset address
2617  57F0 FFFE  
2618  57F2 06C0         SWPB    R0                      
2619  57F4 DBC0         MOVB    R0,@-2(R15)             write first first 2 digits (or hundreths)
2619  57F6 FFFE  
2620  57F8 06C1         SWPB    R1                      
2621  57FA DBC1         MOVB    R1,@-2(R15)             write last 2 digits (if any)
2621  57FC FFFE  
2622  57FE 0202         LI      R2,5                    the remaining bytes are all 0 with integers
2622  5800 0005  
2623  5802 DBC2 H249    MOVB    R2,@-2(R15)             write 0 to VDP
2623  5804 FFFE  
2624  5806 0602         DEC     R2                      next byte
2625  5808 16FC         JNE     H249                    more to do
2626  580A 045B         B       *R11                    
2627            *
2628            *---------------------------------------
2629            * Subprogram >10: sector R/W
2630            * --------------
2631            * >834A: (n/a)      <--- sector #
2632            * >834C: drive #
2633            * >834D: R/W code (write if >00)
2634            * >834E: VDP buffer
2635            * >8350: sector #   <--- error code
2636            *---------------------------------------                                        
2637            *
2638  580C C1CB ESUB01  MOV     R11,R7                  
2639  580E 06A0         BL      @PRPFDO                 prepare disk operations
2639  5810 43FA  
2640  5812 CA69         MOV     @>0050(R9),@>004A(R9)   copy sector #
2640  5814 0050  
2640  5816 004A  
2641  5818 0460         B       @SECRW1                 
2641  581A 4184  
2642            *
2643            *---------------------------------------
2644            * Subprogram >11: format disk
2645            * --------------                                        
2646            *
2647  581C C1CB ESUB02  MOV     R11,R7                  
2648  581E 06A0         BL      @PRPFDO                 prepare disk operations
2648  5820 43FA  
2649  5822 0460         B       @FMTDSK                 
2649  5824 4202  
2650            *
2651            *---------------------------------------
2652            * Subprogram >12: file (un)protect
2653            * --------------
2654            * >834C: drive #
2655            * >834D: protect code (>00 unprotect)
2656            * >834E: ptr to filename
2657            * >8350: (n/a)      <--- error code
2658            *---------------------------------------                                
2659            *
2660  5826 C1CB ESUB03  MOV     R11,R7                  
2661  5828 06A0         BL      @PRPFDO                 prepare disk operations
2661  582A 43FA  
2662  582C D029         MOVB    @>004D(R9),R0           get protection code
2662  582E 004D  
2663  5830 0240         ANDI    R0,>0800                keep the bit that will be needed
2663  5832 0800  
2664  5834 0429         BLWP    @>005A(R9)              save R0 on stack
2664  5836 005A  
2665  5838 8000         DATA    >8000                   
2666  583A C029         MOV     @>004E(R9),R0           get pointer to filename
2666  583C 004E  
2667  583E 06A0         BL      @CALSUB                 call subroutine
2667  5840 432E  
2668  5842 5928         DATA    RFDRVB                  load FDR in VDP buffer
2669  5844 0429         BLWP    @>005A(R9)              retrieve old R0, in R2
2669  5846 005A  
2670  5848 2001         DATA    >2001                   
2671  584A 06A0         BL      @FDR2B1                 read two bytes in R0 from top of FDR + offset
2671  584C 4846  
2672  584E 000C         DATA    12                      file status byte
2673  5850 0240         ANDI    R0,>F700                clear protection flag
2673  5852 F700  
2674  5854 F002         SOCB    R2,R0                   set it if needed
2675  5856 0429         BLWP    @>005A(R9)              set VDP for write
2675  5858 005A  
2676  585A 0103         DATA    >0103                   address in R8
2677  585C DBC0         MOVB    R0,@-2(R15)             write back file status to FDR
2677  585E FFFE  
2678            *                                       
2679  5860 C229 UWFLVB  MOV     @>0056(R9),R8           FDR address in VDP mem
2679  5862 0056  
2680  5864 0429         BLWP    @>005A(R9)              set VDP for read
2680  5866 005A  
2681  5868 0102         DATA    >0102                   address in R8
2682  586A D02F         MOVB    @-1026(R15),R0          get drive # in ctrl block
2682  586C FBFE  
2683  586E 0260         ORI     R0,>8000                flag it
2683  5870 8000  
2684  5872 0429         BLWP    @>005A(R9)              set VDP for write
2684  5874 005A  
2685  5876 0103         DATA    >0103                   address in R8
2686  5878 DBC0         MOVB    R0,@-2(R15)             write it back
2686  587A FFFE  
2687  587C 0460         B       @UPDFDR                 update FDR, load VIB
2687  587E 454C  
2688            *
2689            *---------------------------------
2690            * Subprogram >13: file rename
2691            * --------------
2692            * >834C: drive #
2693            * >834E: ptr to new name
2694            * >8350: ptr to old name <--- error code
2695            *---------------------------------                                      
2696            *
2697  5880 C1CB ESUB04  MOV     R11,R7                  
2698  5882 06A0         BL      @PRPFDO                 prepare disk operations
2698  5884 43FA  
2699  5886 C029         MOV     @>004E(R9),R0           get ptr to new filename
2699  5888 004E  
2700  588A 0429         BLWP    @>005A(R9)              save R0 on stack
2700  588C 005A  
2701  588E 8000         DATA    >8000                   
2702  5890 C029         MOV     @>0050(R9),R0           get ptr to old filename
2702  5892 0050  
2703  5894 06A0         BL      @CALSUB                 call subroutine
2703  5896 432E  
2704  5898 5928         DATA    RFDRVB                  put FDR in VDP buffer
2705  589A 06A0         BL      @RMFPTR                 remove FDR ptr from sector 1
2705  589C 47B0  
2706  589E 06A0         BL      @FDR2B1                 get 2 bytes from FDR
2706  58A0 4846  
2707  58A2 000C         DATA    12                      file status byte
2708  58A4 0240         ANDI    R0,>0800                protected?
2708  58A6 0800  
2709  58A8 1303         JEQ     H250                    no
2710  58AA 06A0         BL      @ERROR5                 yes: return with error
2710  58AC 4948  
2711  58AE 2000         DATA    >2000                   write protected
2712  58B0 06A0 H250    BL      @FDR2B1                 get 2 bytes from FDR
2712  58B2 4846  
2713  58B4 FFFC         DATA    -4                      sector # of FDR
2714  58B6 C040         MOV     R0,R1                   
2715  58B8 0429         BLWP    @>005A(R9)              retrieve R0 from stack
2715  58BA 005A  
2716  58BC 8001         DATA    >8001                   ptr to new filename
2717  58BE 0429         BLWP    @>005A(R9)              save R1 on stack
2717  58C0 005A  
2718  58C2 4000         DATA    >4000                   sector # of FDR
2719  58C4 06A0         BL      @UFNCB                  write drive # and filename in compare buffer
2719  58C6 5B4A  
2720  58C8 06A0         BL      @CALSUB                 call subroutine
2720  58CA 432E  
2721  58CC 4B0E         DATA    FFDRFN                  find FDR from filename
2722  58CE C104         MOV     R4,R4                   found?
2723  58D0 1338         JEQ     H251                    yes: return with file error (name already exist)
2724  58D2 06A0         BL      @INSFDR                 insert a FDR in sector 1
2724  58D4 47E0  
2725  58D6 0429         BLWP    @>005A(R9)              retrieve sect # of FDR in R4
2725  58D8 005A  
2726  58DA 0801         DATA    >0801                   
2727  58DC 0429         BLWP    @>005A(R9)              set VDP to write
2727  58DE 005A  
2728  58E0 0103         DATA    >0103                   address in R8
2729  58E2 DBC4         MOVB    R4,@-2(R15)             write sector # of FDR
2729  58E4 FFFE  
2730  58E6 06C4         SWPB    R4                      
2731  58E8 DBC4         MOVB    R4,@-2(R15)                     
2731  58EA FFFE  
2732  58EC 06C4         SWPB    R4                      sector #
2733  58EE 0702         SETO    R2                      code for read
2734  58F0 04C5         CLR     R5                      buffer offset: VDP at >8356
2735  58F2 06A0         BL      @CALSUB                 call subroutine
2735  58F4 432E  
2736  58F6 4A20         DATA    RDFDR1                  read FDR
2737  58F8 C045         MOV     R5,R1                   
2738  58FA C029         MOV     @>0058(R9),R0                   
2738  58FC 0058  
2739  58FE 0220         AI      R0,257                  
2739  5900 0101  
2740  5902 0601         DEC     R1                      
2741  5904 06A0         BL      @CFNFDR                 copy filename in compare buffer to FDR
2741  5906 5B60  
2742  5908 04C2         CLR     R2                      code for write
2743  590A 06A0         BL      @CALSUB                 call subroutine
2743  590C 432E  
2744  590E 4A24         DATA    RWSEC                   write FDR (with new name in it)
2745  5910 06A0         BL      @CALSUB                 call subroutine
2745  5912 432E  
2746  5914 4A0C         DATA    WRSEC1                  write sector 1 (with new FDR ptr in it)
2747  5916 C069         MOV     @>0056(R9),R1           FDR ptr
2747  5918 0056  
2748  591A 0429         BLWP    @>005A(R9)              prepare VDP to write
2748  591C 005A  
2749  591E 0023         DATA    >0023                   address in R1
2750  5920 DBC4         MOVB    R4,@-2(R15)             clear first char of FDR in buffer
2750  5922 FFFE  
2751  5924 0460         B       @RTURN1                 return to caller
2751  5926 434C  
2752            *                               
2753  5928 04C6 RFDRVB  CLR     R6                      put FDR in VDP buffer
2754  592A D1A9         MOVB    @>004C(R9),R6           get drive #
2754  592C 004C  
2755  592E 06A0         BL      @UFNCB                  update filename compare buffer
2755  5930 5B4A  
2756  5932 06A0         BL      @CALSUB                 call subroutine
2756  5934 432E  
2757  5936 4A9A         DATA    FFDRVB                  look if FDR already in VDP buffer
2758  5938 06A0         BL      @CALSUB                 call subroutine
2758  593A 432E  
2759  593C 4ADE         DATA    FFDROD                  file FDR on disk
2760  593E C104         MOV     R4,R4                   found?
2761  5940 1303         JEQ     H252                    yes
2762  5942 06A0 H251    BL      @RETERR                 no: return with error code in >8350
2762  5944 4974  
2763  5946 E000         DATA    >E000                   file error
2764  5948 0460 H252    B       @RTURN1                 return to caller
2764  594A 434C  
2765            *
2766            *-------------------------------------
2767            * Subprogram >14: file raw read
2768            * --------------
2769            * >834C: drive #                          <--- >00
2770            * >834D: # of sectors (>00=get file info) <--- sectors read
2771            * >834E: ptr to filename
2772            * >8350: file info buffer (>83xx)         <--- error code
2773            *                              |
2774            * >83xx  : VDP buffer       <--'
2775            * >83xx+2: first sector # (total # of sect when get file info)
2776            * >83xx+4: status flag
2777            * >83xx+5: recs/sector
2778            * >83xx+6: eof offset
2779            * >83xx+7: rec size
2780            * >83xx+8: # of recs
2781            *-------------------------------------                                  
2782            *
2783  594C C1CB ESUB05  MOV     R11,R7                  
2784  594E 06A0         BL      @PRPFDO                 prepare disk operations
2784  5950 43FA  
2785  5952 06A0         BL      @RFNPTR                 load filename and ptrs
2785  5954 5B82  
2786  5956 06A0         BL      @FFFDR                  find file FDR, load some info
2786  5958 5BA8  
2787  595A C082         MOV     R2,R2                   # of sectors to read
2788  595C 131E         JEQ     H253                    >00: get file info
2789  595E 6003         S       R3,R0                   sectors in file - first sector to read
2790  5960 1502         JGT     H254                    in file
2791  5962 04C2         CLR     R2                      past eof
2792  5964 1017         JMP     H255                    
2793  5966 8002 H254    C       R2,R0                   sectors past first one vs sectors to load
2794  5968 1A01         JL      H256                    
2795  596A C080         MOV     R0,R2                   load what's left
2796  596C 0429 H256    BLWP    @>005A(R9)                      
2796  596E 005A  
2797  5970 2000         DATA    >2000                   save R2
2798  5972 0429 H257    BLWP    @>005A(R9)                      
2798  5974 005A  
2799  5976 3100         DATA    >3100                   save R2, R3, R7
2800  5978 06A0         BL      @CALSUB                 call subroutine
2800  597A 432E  
2801  597C 4600         DATA    RDOFSC                  read sector from offset in file
2802  597E 0429         BLWP    @>005A(R9)                      
2802  5980 005A  
2803  5982 3101         DATA    >3101                   retrieve R2, R3, R7
2804  5984 0583         INC     R3                      next sector
2805  5986 0227         AI      R7,256                  increment VDP buffer ptr by 256 bytes
2805  5988 0100  
2806  598A 0602         DEC     R2                      more to do?
2807  598C 16F2         JNE     H257                    yes
2808  598E 0429 H258    BLWP    @>005A(R9)                      
2808  5990 005A  
2809  5992 2001         DATA    >2001                   retrieve R2 (# of sectors read)
2810  5994 CA42 H255    MOV     R2,@>004C(R9)           update # of sectors in parameters
2810  5996 004C  
2811  5998 100A         JMP     H259                    
2812            *                                       
2813  599A CD00 H253    MOV     R0,*R4+                 get file info: sectors in file
2814  599C 0648         DECT    R8                      
2815  599E 05C2         INCT    R2                      copy 2 bytes (status + recs/sector)
2816  59A0 06A0         BL      @VDP2SP                 from VDP at R8 to file info structure
2816  59A2 5BDC  
2817  59A4 0202         LI      R2,4                    copy 4 bytes
2817  59A6 0004  
2818  59A8 A202         A       R2,R8                   
2819  59AA 06A0         BL      @VDP2SP                 eof offset, rec len, # of recs (or # of sect)
2819  59AC 5BDC  
2820  59AE 06A0 H259    BL      @CALSUB                 call subroutine
2820  59B0 432E  
2821  59B2 454C         DATA    UPDFDR                  updata FDR (+ data) if needed, read VIB
2822  59B4 04E9         CLR     @>0050(R9)              clear error flag
2822  59B6 0050  
2823  59B8 0460         B       @RTURN1                 return to caller
2823  59BA 434C  
2824            *
2825            *--------------------------------------
2826            * Subprogram >15: file raw write
2827            * --------------
2828            * >834C: drive #                                  <--- >00
2829            * >834D: # of sectors (>00=create file from info) <--- # of sectors written
2830            * >834E: ptr to filename
2831            * >8350: file info buffer (>83xx)                 <--- error code
2832            *                              |
2833            * >83xx  : VDP buffer       <--'
2834            * >83xx+2: first sector # (total # of sectors when creating file)
2835            * >83xx+4: status flag
2836            * >83xx+5: recs/sector
2837            * >83xx+6: eof offset
2838            * >83xx+7: rec size
2839            * >83xx+8: # of recs
2840            *--------------------------------------                                 
2841            *
2842  59BC C1CB ESUB06  MOV     R11,R7                  
2843  59BE 06A0         BL      @PRPFDO                 prepare disk operations
2843  59C0 43FA  
2844  59C2 06A0         BL      @RFNPTR                 load drive + filename, + a few info
2844  59C4 5B82  
2845  59C6 1314         JEQ     H260                    sectors to write=0: create file
2846  59C8 06A0         BL      @FFFDR                  find file FDR
2846  59CA 5BA8  
2847  59CC 0429         BLWP    @>005A(R9)                      
2847  59CE 005A  
2848  59D0 2000         DATA    >2000                   save R2 (# of sectors to write)
2849  59D2 0429 H261    BLWP    @>005A(R9)                      
2849  59D4 005A  
2850  59D6 3100         DATA    >3100                   save R2, R3, R7
2851  59D8 06A0         BL      @CALSUB                 call subroutine
2851  59DA 432E  
2852  59DC 4620         DATA    WROFSC                  write sector from offset in file
2853  59DE 0429         BLWP    @>005A(R9)                      
2853  59E0 005A  
2854  59E2 3101         DATA    >3101                   retrieve R2, R3, R7
2855  59E4 0583         INC     R3                      next sector
2856  59E6 0227         AI      R7,256                  increment VDP ptr by 256 bytes
2856  59E8 0100  
2857  59EA 0602         DEC     R2                      more to do?
2858  59EC 16F2         JNE     H261                    yes
2859  59EE 10CF         JMP     H258                    update # of sectors written, in param. Then return
2860            *                               
2861  59F0 06A0 H260    BL      @CALSUB                 create file
2861  59F2 432E  
2862  59F4 4A9A         DATA    FFDRVB                  find file FDR in VDP buffers
2863  59F6 06A0         BL      @CALSUB                 call subroutine
2863  59F8 432E  
2864  59FA 4ADE         DATA    FFDROD                  find file FDR on disk
2865  59FC 06A0         BL      @CALSUB                 call subroutine
2865  59FE 432E  
2866  5A00 446C         DATA    CRFIL2                  create file
2867  5A02 0429         BLWP    @>005A(R9)                      
2867  5A04 005A  
2868  5A06 0801         DATA    >0801                   retrieve R4 (file info ptr)
2869  5A08 C229         MOV     @>0056(R9),R8           FDR ptr
2869  5A0A 0056  
2870  5A0C 05C4         INCT    R4                      skip 2 bytes
2871  5A0E C0F4         MOV     *R4+,R3                 # of sector to create
2872  5A10 0228         AI      R8,10                   skip filename
2872  5A12 000A  
2873  5A14 06A0         BL      @SP2VDP                 write 2 bytes in VDP at R8+2
2873  5A16 5BEC  
2874  5A18 0002         DATA    2                       i.e. status + recs/sector
2875  5A1A 06A0         BL      @SP2VDP                 write 4 bytes in VDP at new R8+4
2875  5A1C 5BEC  
2876  5A1E 0004         DATA    4                       i.e. eof offset, rec len, # of recs (or # of
2877  5A20 0603         DEC     R3                      offset = # of sectors-1 (starts from 0)
2878  5A22 1103         JLT     H262                    create an empty file, FDR only
2879  5A24 06A0         BL      @CALSUB                 
2879  5A26 432E  
2880  5A28 4636         DATA    APSCTS                  append enough sectors to reach offset
2881  5A2A 0460 H262    B       @UWFLVB                 modify FDR, write it, load VIB, return
2881  5A2C 5860  
2882            *
2883            *---------------------------------------
2884            * Subprogram FILES: number of files
2885            *---------------------------------------                                        
2886  5A2E C1CB ESUB08  MOV     R11,R7                  
2887  5A30 06A0         BL      @PRPFDO                 prepare disk operation
2887  5A32 43FA  
2888  5A34 C229         MOV     @>002C(R9),R8           ptr to next basic token
2888  5A36 002C  
2889  5A38 0228         AI      R8,7                    skip FILES
2889  5A3A 0007  
2890  5A3C 06A0         BL      @VDPR2B                 get next two bytes in R0
2890  5A3E 484C  
2891  5A40 0280         CI      R0,>C801                >C8=unquoted string, size=1 char
2891  5A42 C801  
2892  5A44 161C         JNE     H263                    return (with error) if different
2893  5A46 05C8         INCT    R8                      increment pointer
2894  5A48 06A0         BL      @VDPR2B                 get next two bytes
2894  5A4A 484C  
2895  5A4C 06C0         SWPB    R0                      
2896  5A4E 0220         AI      R0,>49D0                substact >B630: # of files >B6=closed parenthesis
2896  5A50 49D0  
2897  5A52 0280         CI      R0,>0009                only 9 files allowed in Basic !
2897  5A54 0009  
2898  5A56 1B13         JH      H263                    return with error if more
2899  5A58 06C0         SWPB    R0                      
2900  5A5A DA40         MOVB    R0,@>004C(R9)           put new # of files in scratch-pad memory
2900  5A5C 004C  
2901  5A5E 06A0         BL      @CALSUB                 call subroutine
2901  5A60 432E  
2902  5A62 5A88         DATA    PESB07                  subprogram >16 (private entry point)
2903  5A64 DA69         MOVB    @>0050(R9),@>0050(R9)   test result
2903  5A66 0050  
2903  5A68 0050  
2904  5A6A 1609         JNE     H263                    error
2905  5A6C C229         MOV     @>002C(R9),R8           ok: get ptr to Basic token
2905  5A6E 002C  
2906  5A70 0228         AI      R8,12                   skip the whole statement
2906  5A72 000C  
2907  5A74 CA48         MOV     R8,@>002C(R9)           update ptr
2907  5A76 002C  
2908  5A78 5A69         SZCB    @>0042(R9),@>0042(R9)   clear current token
2908  5A7A 0042  
2908  5A7C 0042  
2909  5A7E 0460 H263    B       @RTURN1                 return to caller (i.e. Basic)
2909  5A80 434C  
2910            *
2911            *---------------------------------------
2912            * Subprogram >16: number of files
2913            * --------------
2914            * >834C: # of files
2915            * >8350: (n/a)      <--- error code
2916            *---------------------------------------                                        
2917            *
2918  5A82 C1CB ESUB07  MOV     R11,R7                  entry point from assembly
2919  5A84 06A0         BL      @PRPFDO                 prepare disk operations
2919  5A86 43FA  
2920  5A88 04C0 PESB07  CLR     R0                      entry point from call files
2921  5A8A D029         MOVB    @>004C(R9),R0           get # of files
2921  5A8C 004C  
2922  5A8E 1359         JEQ     H264                    return with error
2923  5A90 C229         MOV     @>0056(R9),R8           ptr to end of buffer word
2923  5A92 0056  
2924  5A94 0228         AI      R8,3                    point to # of files byte
2924  5A96 0003  
2925  5A98 04C3         CLR     R3                      
2926  5A9A 0429         BLWP    @>005A(R9)              set VDP to read
2926  5A9C 005A  
2927  5A9E 0102         DATA    >0102                   address in R8
2928  5AA0 D0EF         MOVB    @-1026(R15),R3          get current # of files
2928  5AA2 FBFE  
2929  5AA4 0205         LI      R5,518                  size of 1 file control block
2929  5AA6 0206  
2930  5AA8 90C0         CB      R0,R3                   compare required with current
2931  5AAA 1348         JEQ     H265                    same: return with no error
2932  5AAC 122B         JLE     H266                    less
2933  5AAE C180         MOV     R0,R6                   more files needed
2934  5AB0 0280         CI      R0,>1000                maximum is 16
2934  5AB2 1000  
2935  5AB4 1B46         JH      H264                    return with error
2936  5AB6 6003         S       R3,R0                   how many to add
2937  5AB8 0980         SRL     R0,8                    make it a word
2938  5ABA 3805         MPY     R5,R0                   # of bytes to add
2939  5ABC C101         MOV     R1,R4                   result in R0:R1
2940  5ABE 0504         NEG     R4                      
2941  5AC0 C0A9         MOV     @>0070(R9),R2           highest free address in VDP mem
2941  5AC2 0070  
2942  5AC4 C002         MOV     R2,R0                   
2943  5AC6 6001         S       R1,R0                   what it would become
2944  5AC8 0280         CI      R0,>0800                is there room enough for VDP?
2944  5ACA 0800  
2945  5ACC 113A         JLT     H264                    no: return with error
2946  5ACE C040         MOV     R0,R1                   ok: new base
2947  5AD0 0582 H267    INC     R2                      increment source ptr
2948  5AD2 0580         INC     R0                      increment destination ptr
2949  5AD4 0429         BLWP    @>005A(R9)              set VDP to read
2949  5AD6 005A  
2950  5AD8 0042         DATA    >0042                   address in R2
2951  5ADA D0EF         MOVB    @-1026(R15),R3          get a byte
2951  5ADC FBFE  
2952  5ADE 0429         BLWP    @>005A(R9)              set VDP to write
2952  5AE0 005A  
2953  5AE2 0003         DATA    >0003                   address in R0
2954  5AE4 DBC3         MOVB    R3,@-2(R15)             copy a byte
2954  5AE6 FFFE  
2955  5AE8 8202         C       R2,R8                   did we copy the whole header?
2956  5AEA 16F2         JNE     H267                    not yet
2957  5AEC 0429         BLWP    @>005A(R9)              set VDP to write
2957  5AEE 005A  
2958  5AF0 0003         DATA    >0003                   address in R0
2959  5AF2 DBC6         MOVB    R6,@-2(R15)             new # of files
2959  5AF4 FFFE  
2960  5AF6 04C6         CLR     R6                      
2961  5AF8 6080         S       R0,R2                   
2962  5AFA DBC6 H268    MOVB    R6,@-2(R15)             clear byte
2962  5AFC FFFE  
2963  5AFE 0602         DEC     R2                      
2964  5B00 16FC         JNE     H268                    
2965  5B02 101A         JMP     H269                    
2966            *                                       
2967  5B04 0429 H266    BLWP    @>005A(R9)              less files needed
2967  5B06 005A  
2968  5B08 0103         DATA    >0103                   set VDP to write to address in R8
2969  5B0A DBC0         MOVB    R0,@-2(R15)             new # of files in buffer header
2969  5B0C FFFE  
2970  5B0E 60C0         S       R0,R3                   how many to remove
2971  5B10 0983         SRL     R3,8                    make it a word
2972  5B12 38C5         MPY     R5,R3                   # of bytes to remove
2973  5B14 C044         MOV     R4,R1                   result in R3:R4
2974  5B16 A048         A       R8,R1                   new address for buffer header
2975  5B18 C0A9         MOV     @>0070(R9),R2           highest free address in VDP mem
2975  5B1A 0070  
2976  5B1C 0429 H270    BLWP    @>005A(R9)              set VDP to read
2976  5B1E 005A  
2977  5B20 0102         DATA    >0102                   address in R8
2978  5B22 D02F         MOVB    @-1026(R15),R0          read a byte
2978  5B24 FBFE  
2979  5B26 0429         BLWP    @>005A(R9)              set VDP to write
2979  5B28 005A  
2980  5B2A 0023         DATA    >0023                   address in R1
2981  5B2C DBC0         MOVB    R0,@-2(R15)             write byte back
2981  5B2E FFFE  
2982  5B30 0601         DEC     R1                      decrement destination ptr
2983  5B32 0608         DEC     R8                      decrement source ptr
2984  5B34 8088         C       R8,R2                   did we copy the whole header?
2985  5B36 16F2         JNE     H270                    not yet
2986            *                                       
2987  5B38 CA41 H269    MOV     R1,@>0070(R9)           new first free address                                  
2987  5B3A 0070  
2988  5B3C 04E9 H265    CLR     @>0050(R9)              clear error flag
2988  5B3E 0050  
2989  5B40 1002         JMP     H272                    
2990  5B42 0729 H264    SETO    @>0050(R9)              set error flag
2990  5B44 0050  
2991  5B46 0460 H272    B       @RTURN1                 return to caller
2991  5B48 434C  
2992            *                                       
2993  5B4A 04E9 UFNCB   CLR     @>0054(R9)              write drive # and filename in compare buffer
2993  5B4C 0054  
2994  5B4E C069         MOV     @>0058(R9),R1           
2994  5B50 0058  
2995  5B52 0221         AI      R1,256                  ptr to filename compare buffer
2995  5B54 0100  
2996  5B56 0429         BLWP    @>005A(R9)              set VDP to write
2996  5B58 005A  
2997  5B5A 0023         DATA    >0023                   address in R1
2998  5B5C DBC6         MOVB    R6,@-2(R15)             write drive #
2998  5B5E FFFE  
2999  5B60 0202 CFNFDR  LI      R2,10                   filename must be exactly 10 chars
2999  5B62 000A  
3000  5B64 0581 H273    INC     R1                      next char in compare buffer
3001  5B66 0429         BLWP    @>005A(R9)              set VDP to read
3001  5B68 005A  
3002  5B6A 0002         DATA    >0002                   address in R0
3003  5B6C D0EF         MOVB    @-1026(R15),R3          get 1 char from filename
3003  5B6E FBFE  
3004  5B70 0580         INC     R0                      next char in provided filename
3005  5B72 0429         BLWP    @>005A(R9)              set VDP to write
3005  5B74 005A  
3006  5B76 0023         DATA    >0023                   address in R1
3007  5B78 DBC3         MOVB    R3,@-2(R15)             write 1 char to compare buffer
3007  5B7A FFFE  
3008  5B7C 0602         DEC     R2                      
3009  5B7E 16F2         JNE     H273                    next char
3010  5B80 045B         B       *R11                    
3011            *                                       
3012  5B82 C28B RFNPTR  MOV     R11,R10                 load compare buffer and ptrs
3013  5B84 04C6         CLR     R6                      
3014  5B86 D1A9         MOVB    @>004C(R9),R6           drive #
3014  5B88 004C  
3015  5B8A C029         MOV     @>004E(R9),R0           ptr to filename
3015  5B8C 004E  
3016  5B8E 06A0         BL      @UFNCB                  write them in compare buffer
3016  5B90 5B4A  
3017  5B92 D129         MOVB    @>0050(R9),R4           file info structure ptr
3017  5B94 0050  
3018  5B96 0984         SRL     R4,8                    
3019  5B98 A109         A       R9,R4                   make it a PAB address
3020  5B9A D029         MOVB    @>004D(R9),R0           # of sectors (>00=get file info)
3020  5B9C 004D  
3021  5B9E 0429         BLWP    @>005A(R9)                      
3021  5BA0 005A  
3022  5BA2 0800         DATA    >0800                   save R4
3023  5BA4 0980         SRL     R0,8                    
3024  5BA6 045A         B       *R10                    EQ set for get file info
3025            *                                       
3026  5BA8 0429 FFFDR   BLWP    @>005A(R9)              find file FDR
3026  5BAA 005A  
3027  5BAC 8010         DATA    >8010                   save R0 + R11
3028  5BAE 06A0         BL      @CALSUB                 call subroutine
3028  5BB0 432E  
3029  5BB2 4A9A         DATA    FFDRVB                  find file FDR in VDP buffers
3030  5BB4 06A0         BL      @CALSUB                 call subroutine
3030  5BB6 432E  
3031  5BB8 4ADE         DATA    FFDROD                  find FDR on disk
3032  5BBA C104         MOV     R4,R4                   found ?
3033  5BBC 1303         JEQ     H274                    yes
3034  5BBE 06A0         BL      @ERROR5                 no: return with error
3034  5BC0 4948  
3035  5BC2 E000         DATA    >E000                   file error
3036  5BC4 06A0 H274    BL      @FDR2B1                 get two bytes from FDR into R0
3036  5BC6 4846  
3037  5BC8 000E         DATA    14                      # of sectors in file
3038  5BCA 0429         BLWP    @>005A(R9)                      
3038  5BCC 005A  
3039  5BCE 2011         DATA    >2011                   retrieve R0 in R2 (# of sect to read), and R11
3040  5BD0 0429         BLWP    @>005A(R9)                      
3040  5BD2 005A  
3041  5BD4 0801         DATA    >0801                   retrieve R4 (ptr to file info structure)
3042  5BD6 C1F4         MOV     *R4+,R7                 VDP buffer
3043  5BD8 C0D4         MOV     *R4,R3                  first sector
3044  5BDA 045B         B       *R11                    
3045            *                                       
3046  5BDC 0429 VDP2SP  BLWP    @>005A(R9)              copy VDP bytes to scratch-pad
3046  5BDE 005A  
3047  5BE0 0102         DATA    >0102                   read from VDP at R8
3048  5BE2 DD2F H275    MOVB    @-1026(R15),*R4+        read bytes into scratch-pad at R4
3048  5BE4 FBFE  
3049  5BE6 0602         DEC     R2                      # of byte in R2
3050  5BE8 16FC         JNE     H275                    next byte
3051  5BEA 045B         B       *R11                    
3052            *                                       
3053  5BEC C0BB SP2VDP  MOV     *R11+,R2                copy scratch-pad bytes to VDP
3054  5BEE A202         A       R2,R8                   
3055  5BF0 0429         BLWP    @>005A(R9)              set VDP to write
3055  5BF2 005A  
3056  5BF4 0103         DATA    >0103                   address in R8 + offset in data word
3057  5BF6 DBF4 H276    MOVB    *R4+,@-2(R15)           write byte from scratch-pad at R4
3057  5BF8 FFFE  
3058  5BFA 0602         DEC     R2                      # of bytes in R2, was in data word
3059  5BFC 16FC         JNE     H276                    next byte
3060  5BFE 045B         B       *R11    
3061            *
3062            * APEDSK99 CALL subprograms
3063            *
3064            * parameter is single digit -> 0x00
3065  5C00 0206 PDSK    LI      R6,>0100                Protect ACOMND 
3065  5C02 0100  
3066  5C04 102C         JMP     ACLPRP                  generic prep
3067  5C06 0206 UDSK    LI      R6,>0200                Unprotect ACOMND 
3067  5C08 0200  
3068  5C0A 1029         JMP     ACLPRP                  generic prep
3069  5C0C 0206 LDSK    LI      R6,>0300                Show Files on DSKx ACOMND 
3069  5C0E 0300  
3070  5C10 1026         JMP     ACLPRP                  generic prep
3071            * parameters are single digit + character string -> 1x00; ! >1300 IS RESERVED (BL NTPDT+1) ! 
3072  5C12 0206 MDSK    LI      R6,>1000                Change DSK ACOMND
3072  5C14 1000  
3073  5C16 1023         JMP     ACLPRP                  generic prep
3074  5C18 0206 NDSK    LI      R6,>1100                create new blank SS/SD DOAD image
3074  5C1A 1100  
3075  5C1C 1020         JMP     ACLPRP
3076            * parameter is a charachter string -> 2x00
3077  5C1E 0206 RDSK    LI      R6,>2000                Remove DOAD from SD card ACOMND 
3077  5C20 2000  
3078  5C22 101D         JMP     ACLPRP                  generic prep
3079  5C24 0206 FGET    LI      R6,>2100                get DOAD from FTP server ACOMND
3079  5C26 2100  
3080  5C28 101A         JMP     ACLPRP                  generic prep
3081  5C2A 0206 FPUT    LI      R6,>2200                save DOAD to FTP server ACOMND 
3081  5C2C 2200  
3082  5C2E 1017         JMP     ACLPRP                  generic prep
3083  5C30 0206 ADSR    LI      R6,>2300                load DSR and reset ACOMND
3083  5C32 2300  
3084  5C34 1014         JMP     ACLPRP                  generic prep
3085  5C36 0206 NDIR    LI      R6,>2400                change root folder
3085  5C38 2400  
3086  5C3A 1011         JMP     ACLPRP                  generic prep
3087            * no parameters ->3x00
3088  5C3C 0206 SDSK    LI      R6,>3000                Show DSKx mapping ACOMND
3088  5C3E 3000  
3089  5C40 100E         JMP     ACLPRP                  generic prep
3090  5C42 0206 SDIR    LI      R6,>3100                Show SD dir ACOMND
3090  5C44 3100  
3091  5C46 100B         JMP     ACLPRP                  generic prep
3092  5C48 0206 AHLP    LI      R6,>3200                display APEDSK99 CALL()'s help screen
3092  5C4A 3200  
3093  5C4C 1008         JMP     ACLPRP                  generic prep
3094  5C4E 0206 ALOW    LI      R6,>3300                load proper lowercase character set
3094  5C50 3300  
3095  5C52 1005         JMP     ACLPRP                  generic prep
3096  5C54 0206 ARST    LI      R6,>3400                reset APEDSK99 ACOMND
3096  5C56 3400  
3097  5C58 1002         JMP     ACLPRP                  generic prep
3098  5C5A 0206 TIME    LI      R6,>3500                show NTP time and date
3098  5C5C 3500  
3099            *
3100            * Generic prep and return to TI BASIC for APEDSK99 CALL's
3101            *
3102  5C5E C1CB ACLPRP  MOV     R11,R7                  save return-to-TI BASIC address
3103  5C60 06A0         BL      @PRPFDO                 prepare TI Controller DSR operations
3103  5C62 43FA  
3104            *
3105  5C64 C229         MOV     @>002C(R9),R8           ptr to next basic token
3105  5C66 002C  
3106  5C68 0228         AI      R8,4                    skip length byte and 3 chars of CALL name
3106  5C6A 0004  
3107  5C6C 06A0         BL      @VDPR2B                 get CALL last char and "(" or "0" in R0
3107  5C6E 484C  
3108  5C70 0A80         SLA     R0,8                    only interested in LSB
3109  5C72 130C         JEQ     NOPARM                  0 = no parameters? SDSK / SDIR / AHLP / ALOW / ARST / TIME (and special guest LDSK)
3110            *
3111  5C74 0228         AI      R8,2                    adjust token pointer
3111  5C76 0002  
3112  5C78 06A0         BL      @VDPR2B                 get next two bytes in R0
3112  5C7A 484C  
3113  5C7C 0280         CI      R0,>C801                >C8=unquoted string, size=1 char?
3113  5C7E C801  
3114  5C80 1330         JEQ     USTRNG                  yes: PDSK / UDSK / LDSK / MDSK / NDSK
3115            *
3116  5C82 0280         CI      R0,>C701                >C7=quoted string, minimum 1 character?
3116  5C84 C701  
3117  5C86 147B         JHE     QSTRNG                  yes: RDSK / FGET / FPUT / ADSR / NDIR
3118            *
3119  5C88 0460 ACLERR  B       @RTURN1                 expect the unexpected                           
3119  5C8A 434C  
3120            *
3121            * SDSK / SDIR / AHLP / ALOW / ARST / TIME (and special guest LDSK)
3122            *
3123  5C8C 0286 NOPARM  CI      R6,>0300                LDSK without parameters is handy (re-use last used DSK#)
3123  5C8E 0300  
3124  5C90 1303         JEQ     NOPRM2
3125  5C92 0286         CI      R6,>3000                catch other CALL's without parameters -> error
3125  5C94 3000  
3126  5C96 1AF8         JL      ACLERR
3127            *
3128  5C98 D820 NOPRM2  MOVB    @LSTDRV,@CALLBF         get last drive accessed for LDSK without parameters
3128  5C9A 5FC7  
3128  5C9C 5FC8  
3129  5C9E D806         MOVB    R6,@ACOMND              execute LDSK / ALOW / ARST / TIME
3129  5CA0 5FE8  
3130  5CA2 0286         CI      R6,>3300                ALOW / ARST / TIME ?    
3130  5CA4 3300  
3131  5CA6 1A3D         JL      LDSK2                   no; SDSK / SDIR / AHLP use LDSK display routine
3132            *
3133  5CA8 0208 QNOPRM  LI      R8,9                    current CALL length
3133  5CAA 0009  
3134  5CAC 0286         CI      R6,>3300                ALOW?
3134  5CAE 3300  
3135  5CB0 1307         JEQ     ALOW2                   yes; get some real characters
3136  5CB2 0286         CI      R6,>0300                LDSK()?
3136  5CB4 0300  
3137  5CB6 1602         JNE     H9901                   nope; exit with CALL lenght 9 for SDSK / SDIR / AHLP
3138  5CB8 0228         AI      R8,3                    yep;  exit with CALL length 12 for LDSK
3138  5CBA 0003  
3139            *
3140  5CBC 0460 H9901   B       @ACLBAS 
3140  5CBE 5DCA  
3141            *
3142  5CC0 9820 ALOW2   CB      @INT2FP+2,@CALLST
3142  5CC2 57BC  
3142  5CC4 5FC6  
3143  5CC6 13FA         JEQ     H9901                   >08; no char definition file found
3144            *
3145  5CC8 C0A0         MOV     @PATTBL,R2              get start of <SPACE> pattern table entry (default >0400 for TI BASIC)
3145  5CCA 402A  
3146  5CCC 06A0         BL      @VDPWRI                 set VPD address
3146  5CCE 430C  
3147            *                       
3148  5CD0 06A0 H9902   BL      @DISSTS                 use existing display routine to write 4 definitions at a time
3148  5CD2 5E20  
3149  5CD4 9820         CB      @K004,@CALLST           check Arduino ALOW return code
3149  5CD6 432A  
3149  5CD8 5FC6  
3150  5CDA 13F0         JEQ     H9901                   we're done
3151  5CDC C802         MOV     R2,@RDINT               generates interrupt for next lot
3151  5CDE 5FEA  
3152  5CE0 10F7         JMP     H9902                   again
3153            *
3154            * PDSK / UDSK / LDSK / MDSK / NDSK
3155            *
3156  5CE2 0286 USTRNG  CI      R6,>2000                only PDSK / UDSK / LDSK / MDSK / NDSK?
3156  5CE4 2000  
3157  5CE6 14D0         JHE     ACLERR                  no -> sneaky other commands don't belong here
3158  5CE8 05C8         INCT    R8                      increment pointer
3159  5CEA 06A0         BL      @VDPR2B                 get next two bytes              
3159  5CEC 484C  
3160            *
3161  5CEE 06C0         SWPB    R0
3162  5CF0 0220         AI      R0,>49D0                add 2's complement of >B630: MSB = >B3 / "," or >B6 / ")", LSB= # of files 
3162  5CF2 49D0  
3163  5CF4 1502         JGT     H9903                   >B6
3164  5CF6 0220         AI      R0,768                  >B3, adjust R0 to positive range
3164  5CF8 0300  
3165            *
3166  5CFA 13C6 H9903   JEQ     ACLERR                  DSK0 not valid, * INCORRECT COMMAND
3167  5CFC 0280         CI      R0,3                    only 3 DSK's allowed
3167  5CFE 0003  
3168  5D00 1BC3         JH      ACLERR                  DSK4+, * INCORRECT COMMAND
3169            *
3170  5D02 06C0         SWPB    R0
3171  5D04 D800         MOVB    R0,@CALLBF              save DSKx
3171  5D06 5FC8  
3172  5D08 D800         MOVB    R0,@LSTDRV              remember last drive accessed for LDSK without parameter
3172  5D0A 5FC7  
3173            *
3174  5D0C 0286         CI      R6,>1000                MDSK or NDSK?
3174  5D0E 1000  
3175  5D10 1433         JHE     MNDSK2                  yep
3176            *
3177  5D12 D806         MOVB    R6,@ACOMND              send PDSK / UDSK / LDSK command to Arduino
3177  5D14 5FE8  
3178            
3179  5D16 0286         CI      R6,>0300                LDSK?
3179  5D18 0300  
3180  5D1A 1303         JEQ     LDSK2                   yep
3181            *
3182  5D1C 0208 PUDSK2  LI      R8,12                   CALL length
3182  5D1E 000C  
3183  5D20 1054         JMP     ACLBAS                  return to BASIC         
3184            *                       
3185  5D22 9820 LDSK2   CB      @K002,@CALLST
3185  5D24 4328  
3185  5D26 5FC6  
3186  5D28 13BF         JEQ     QNOPRM                  LDSK: >00; no DOAD mapped
3187            *
3188  5D2A 04C2 NXTSCR  CLR     R2                      clear screen; position 0
3189  5D2C 06A0         BL      @VDPWRI
3189  5D2E 430C  
3190            *
3191  5D30 0200         LI      R0,>8000                space + TI BASIC bias
3191  5D32 8000  
3192  5D34 06A0         BL      @VDPRPW
3192  5D36 4254  
3193  5D38 02C0         DATA    704                     704 positions to clear
3194            *
3195  5D3A 0202         LI      R2,32                   start 2nd screen line; 1st is lost due to BASIC scroll
3195  5D3C 0020  
3196  5D3E 06A0 H9904   BL      @VDPWRI                 
3196  5D40 430C  
3197            *       
3198  5D42 9820         CB      @K004,@CALLST           check Arduino LDSK / SDSK / SDIR / AHLP return code
3198  5D44 432A  
3198  5D46 5FC6  
3199  5D48 13AF         JEQ     QNOPRM                  "More" (>F0); blank DSK or done last file / help txt
3200            *
3201  5D4A 06A0         BL      @DISSTS                 LDSK / SDSK / SDIR / AHLP output to screen
3201  5D4C 5E20  
3202            *
3203  5D4E 0222         AI      R2,32                   next screen position
3203  5D50 0020  
3204  5D52 0282         CI      R2,640                  end of display area?
3204  5D54 0280  
3205  5D56 1303         JEQ     NXTPRP                  yes; show "more" symbol
3206            *
3207  5D58 05A0         INC     @RDINT                  generates interrupt for next file / help txt
3207  5D5A 5FEA  
3208  5D5C 10F0         JMP     H9904   
3209            *       
3210  5D5E 0202 NXTPRP  LI      R2,702
3210  5D60 02BE  
3211  5D62 06A0         BL      @VDPWRI
3211  5D64 430C  
3212  5D66 0205         LI      R5,>9E00                show ">", more file / help txt to display
3212  5D68 9E00  
3213  5D6A DBC5         MOVB    R5,@-2(R15)
3213  5D6C FFFE  
3214            *
3215  5D6E 06A0         BL      @CHKKEY
3215  5D70 5E32  
3216            *
3217  5D72 05A0         INC     @RDINT                  generates interrupt for next file / help txt
3217  5D74 5FEA  
3218  5D76 10D9         JMP     NXTSCR
3219            *
3220            * MDSK / NDSK / RDSK / FGET / FPUT / ADSR / NDIR
3221            *
3222  5D78 05C8 MNDSK2  INCT    R8                      increment pointer
3223  5D7A 06A0         BL      @VDPR2B                 get next two digits
3223  5D7C 484C  
3224            *
3225  5D7E 0286 QSTRNG  CI      R6,>1000                further check on RDSK / FGET / FPUT / ADSR
3225  5D80 1000  
3226  5D82 1A82         JL      ACLERR                  no -> sneaky PDSK / UDSK don't belong here      
3227  5D84 0220         AI      R0,>3900                add 2's complement of >C700 =  only keep # of characters
3227  5D86 3900  
3228  5D88 1315         JEQ     H9906                   0 characters / empty string -> * INCORRECT COMMAND
3229  5D8A 0280         CI      R0,8                    max 8 characters?
3229  5D8C 0008  
3230  5D8E 1B12         JH      H9906                   no -> * INCORRECT COMMAND
3231            *
3232  5D90 C100         MOV     R0,R4                   save # of characters
3233  5D92 0205         LI      R5,CALLBF+2             pointer to DOAD / DSR name      
3233  5D94 5FCA  
3234  5D96 05C8         INCT    R8                      increment pointer
3235  5D98 C088         MOV     R8,R2                   for VDPRD, address must be in R2
3236  5D9A 06A0         BL      @VDPRD                  set VDP READ address
3236  5D9C 4316  
3237  5D9E DD6F H9905   MOVB    @-1026(R15),*R5+        get character and save in CALL buffer
3237  5DA0 FBFE  
3238  5DA2 0600         DEC     R0                      one less to go
3239  5DA4 16FC         JNE     H9905   
3240  5DA6 D560         MOVB    @K002,*R5               mark end of string with >00 (Arduino check for < 8 characters)
3240  5DA8 4328  
3241            *
3242  5DAA D02F         MOVB    @-1026(R15),R0          get next token
3242  5DAC FBFE  
3243  5DAE 0280         CI      R0,>B600                is it a ")" ?
3243  5DB0 B600  
3244  5DB2 1302         JEQ     H9907
3245  5DB4 0460 H9906   B       @ACLERR                 * INCORRECT COMMAND
3245  5DB6 5C88  
3246            *
3247  5DB8 0208 H9907   LI      R8,13                   prep RDSK / FGET / FPUT / ADSR CALL length ( CALL_XXXX("") )
3247  5DBA 000D  
3248  5DBC A204         A       R4,R8                   add # of characters in string
3249                    
3250  5DBE 0286         CI      R6,>1100                MDSK or NDSK?
3250  5DC0 1100  
3251  5DC2 1B01         JH      H9908                   no; jump and execute RDSK / FGET / FPUT / ADSR
3252  5DC4 05C8         INCT    R8                      adjust MDSK and NDSK CALL length
3253            *
3254  5DC6 D806 H9908   MOVB    R6,@ACOMND              command to Arduino
3254  5DC8 5FE8  
3255            *
3256  5DCA 9820 ACLBAS  CB      @CALLST,@K004           "More" or "AllGood" received from Arduino?      
3256  5DCC 5FC6  
3256  5DCE 432A  
3257  5DD0 141A         JHE     H9909                   yep
3258            *       
3259  5DD2 0205         LI      R5,GPLINT               no; GPL routine
3259  5DD4 006A  
3260  5DD6 06A0         BL      @GPLXML                 
3260  5DD8 5EC4  
3261  5DDA 56CD         DATA    SCROLL                  scroll screen
3262  5DDC 0202         LI      R2,736                  screen starting position for (error) message
3262  5DDE 02E0  
3263  5DE0 06A0         BL      @VDPWRI                 set VDP address
3263  5DE2 430C  
3264  5DE4 06A0         BL      @DISSTS                 show (error) message
3264  5DE6 5E20  
3265  5DE8 0205         LI      R5,GPLINT               GPL routine
3265  5DEA 006A  
3266  5DEC 06A0         BL      @GPLXML 
3266  5DEE 5EC4  
3267  5DF0 56CD         DATA    SCROLL                  scroll screen
3268            *
3269  5DF2 9820         CB      @CALLST,@K007           error?
3269  5DF4 5FC6  
3269  5DF6 4329  
3270  5DF8 1B06         JH      H9909                   no; be silent   
3271            *
3272  5DFA 0205         LI      R5,GPLINT               yes: let's make some noise
3272  5DFC 006A  
3273  5DFE 06A0         BL      @GPLXML
3273  5E00 5EC4  
3274  5E02 03D6         DATA    HONK                    GPL routine"bad tone"
3275  5E04 1004         JMP     H9910
3276            *
3277  5E06 0286 H9909   CI      R6,>3500                TIME() ?
3277  5E08 3500  
3278  5E0A 1601         JNE     H9910                   no, end the party
3279  5E0C 1027         JMP     TIME2                   yes; see if we can assign date/time to NTP$ 
3280            *
3281  5E0E 04E9 H9910   CLR     @>0050(R9)              clear error flag                
3281  5E10 0050  
3282  5E12 AA48         A       R8, @>002C(R9)          add call length to token pointer                
3282  5E14 002C  
3283  5E16 5A69         SZCB    @>0042(R9),@>0042(R9)   clear current token
3283  5E18 0042  
3283  5E1A 0042  
3284  5E1C 0460         B       @RTURN1                 return to caller (i.e. TI-BASIC)
3284  5E1E 434C  
3285            *       
3286            * Display data, status messages and errors
3287            *
3288  5E20 0205 DISSTS  LI      R5,CALLBF               start of file name buffer
3288  5E22 5FC8  
3289  5E24 0206         LI      R6,32                   32 bytes / 1 screen row of data to display
3289  5E26 0020  
3290  5E28 DBF5 H9911   MOVB    *R5+,@-2(R15)           store character in VDP screen memory
3290  5E2A FFFE  
3291  5E2C 0606         DEC     R6
3292  5E2E 16FC         JNE     H9911
3293  5E30 045B         B       *R11
3294            *
3295            * Quick key test to display next screen after ">"
3296            * Keyboard column 0 (= space enter <nc> fctn shift ctrl <nc>)
3297            * Code copy from Thierry's TI's Tech Pages site
3298            *
3299  5E32 C10C CHKKEY  MOV     R12,R4                  save R12
3300  5E34 04C1         CLR     R1                      test column 0
3301  5E36 020C         LI      R12,>0024               address for column selection
3301  5E38 0024  
3302  5E3A 30C1 H9912   LDCR    R1,3                    select column
3303  5E3C 1FF2         TB      -14                     test R12 address >0008
3304  5E3E 1607         JNE     H9913                   <SPACE>
3305  5E40 1FF3         TB      -13                     test R12 address >000A
3306  5E42 13FB         JEQ     H9912                   no key; test again
3307            *
3308  5E44 D820         MOVB    @K004,@CALLST           signal ENTER to SDIR() command
3308  5E46 432A  
3308  5E48 5FC6  
3309  5E4A 020B         LI      R11,QNOPRM              leave without clearing screen
3309  5E4C 5CA8  
3310            *
3311  5E4E C304 H9913   MOV     R4,R12                  restore R12
3312  5E50 0A24         SLA     R4,2                    debounce delay
3313  5E52 0604 H9914   DEC     R4                      key debounce
3314  5E54 16FE         JNE     H9914                   debounce some more
3315            *
3316  5E56 045B         B       *R11                    we got one; return for next screen
3317            *
3318            * prep for calling XML >16 and update BASIC variable NTP$               
3319            *
3320  5E58 4E54 VARINF  TEXT    'NTP$'
3320  5E5A 5024  
3321  5E5C 0204 TIME2   LI      R4,VARINF               variable name for XML >16 in FAC
3321  5E5E 5E58  
3322  5E60 C149         MOV     R9,R5                   get scratchpad start address
3323  5E62 D974 H9915   MOVB    *R4+,@>004A(R5)         variable name in FAC
3323  5E64 004A  
3324  5E66 0585         INC     R5
3325  5E68 0284         CI      R4,VARINF+4             done all chars?
3325  5E6A 5E5C  
3326  5E6C 16FA         JNE     H9915                   
3327            *
3328  5E6E 0205         LI      R5,>0400                variable length for XML >16 in @>8359
3328  5E70 0400  
3329  5E72 DA45         MOVB    R5,@>0059(R9)           
3329  5E74 0059  
3330  5E76 04E9         CLR     @>0089(R9)      
3330  5E78 0089  
3331            *
3332  5E7A 0205         LI      R5,XML16                ROM routine: find NTP$ in VDP symbol table (returns to GPL interpreter)
3332  5E7C 15D6  
3333  5E7E 06A0         BL      @GPLXML
3333  5E80 5EC4  
3334  5E82 2244         DATA    XMLRTN                  GPL "RTN", escaping GPL interpreter
3335            *
3336  5E84 9A60         CB      @VARINF,@>004A(R9)      found NTP$ in VDP symbol table?
3336  5E86 5E58  
3336  5E88 004A  
3337  5E8A 1318         JEQ     H9917                   no symbol table pointer; back to BASIC
3338            *
3339  5E8C 06A0         BL      @XML14                  ROM routine: get NTP$ VDP address and string length (returns through RT)
3339  5E8E 164E  
3340  5E90 02A9         STWP    R9                      restore scratchpad pointer
3341  5E92 0229         AI      R9,-224
3341  5E94 FF20  
3342            *       
3343  5E96 C169         MOV     @>0050(R9),R5           get string length
3343  5E98 0050  
3344  5E9A 0285         CI      R5,16                   16 chars?
3344  5E9C 0010  
3345  5E9E 160E         JNE     H9917                   no NTP$ assignment for you
3346            *
3347  5EA0 C0A0         MOV     @>834E,R2               yes
3347  5EA2 834E  
3348  5EA4 06A0         BL      @VDPWRI                 set VDP write address
3348  5EA6 430C  
3349  5EA8 0205         LI      R5,CALLBF               CALL TIME data still in buffer
3349  5EAA 5FC8  
3350  5EAC D0B5 H9916   MOVB    *R5+,R2                 read character
3351  5EAE 0222         AI      R2,>A000                remove TI BASIC bias
3351  5EB0 A000  
3352  5EB2 DBC2         MOVB    R2,@-2(R15)             save to NTP$ value space
3352  5EB4 FFFE  
3353  5EB6 0285         CI      R5,CALLBF+16            done all 16 chars?
3353  5EB8 5FD8  
3354  5EBA 16F8         JNE     H9916                   no; one more
3355            *
3356  5EBC 0460 H9917   B       @H9910                  yes; back to BASIC
3356  5EBE 5E0E  
3357            *
3358            * execute GROM or XML routine (SCROLL, "bad sound" / HONK and XML >16)
3359            * DSR and GPL interpreter use same workspace (>83E0) so we need to save a few things
3360            *
3361  5EC0 0000 SAVGRA  BSS     2                       save current GROM address so we can return to BASIC
3362  5EC2 0000 SAVR11  BSS     2                       GPL interpreter uses R11
3363            *
3364  5EC4 D820 GPLXML  MOVB    @>9802,@SAVGRA          save current GROM address
3364  5EC6 9802  
3364  5EC8 5EC0  
3365  5ECA 1000         NOP
3366  5ECC D820         MOVB    @>9802,@SAVGRA+1
3366  5ECE 9802  
3366  5ED0 5EC1  
3367  5ED2 0620         DEC     @SAVGRA                 GRMWA returns address + 1; decrease for correct address
3367  5ED4 5EC0  
3368            *
3369  5ED6 D83B         MOVB    *R11+,@>9C02            set GPL routine address
3369  5ED8 9C02  
3370  5EDA 1000         NOP
3371  5EDC D83B         MOVB    *R11+,@>9C02
3371  5EDE 9C02  
3372  5EE0 C80B         MOV     R11,@SAVR11             save final DSR return address
3372  5EE2 5EC2  
3373            *
3374  5EE4 020B         LI      R11,GXRTN               DSR return address after GPL routine
3374  5EE6 5F00  
3375  5EE8 C80B         MOV     R11,@RTN5C              @>4028 is where XML >5C returns to
3375  5EEA 4028  
3376            *
3377  5EEC 05E0         INCT    @>8373                  increase stack pointer
3377  5EEE 8373  
3378  5EF0 06C9         SWPB    R9                      
3379  5EF2 D260         MOVB    @>8373,R9
3379  5EF4 8373  
3380  5EF6 06C9         SWPB    R9                      complete stack pointer in R9
3381  5EF8 020B         LI      R11,XML5C               GROM pointer to >0F5C (= XML >5C)
3381  5EFA 105C  
3382  5EFC C64B         MOV     R11,*R9                 save GROM pointer on stack
3383            *
3384  5EFE 0455         B       *R5                     execute GROM/ROM routine, return through GPL interpreter
3385            *
3386  5F00 D820 GXRTN   MOVB    @SAVGRA,@>9C02          and ... we're back; restore saved GROM address
3386  5F02 5EC0  
3386  5F04 9C02  
3387  5F06 1000         NOP
3388  5F08 D820         MOVB    @SAVGRA+1,@>9C02
3388  5F0A 5EC1  
3388  5F0C 9C02  
3389            *
3390  5F0E 02A9         STWP    R9                      restore scratchpad pointer
3391  5F10 0229         AI      R9,-224
3391  5F12 FF20  
3392            *
3393  5F14 C2E0         MOV     @SAVR11,R11             restore R11
3393  5F16 5EC2  
3394  5F18 045B         B       *R11                    return to instruction after BL @GPLEXEC DATA statement
3395            *               
3396            * update FAT time/date for current DOAD after DSR Write / Format / Save
3397            *
3398  5F1A D820 NTPDT   MOVB    @NTPFAT+1,@ACOMND       "DSK NTP date/time update" command to Arduino           
3398  5F1C 4027  
3398  5F1E 5FE8  
3399  5F20 045B         B       *R11                    return to Format / Close
3400            *
3401            *----------------------------------------------------------------------------------
3402            * >5F22 - >5FB3: 145 free bytes remaining
3403            * >5FC2 - >5FD3 is DSK1-3 parameters storage
3404            * >5FD4 is the CALL() status byte
3405            * >5FD6 - >5FE7 is buffer storage for APEDSK99 CALL's
3406            * >5FE8 is the Arduino Command Register (TI BASIC CALL support)
3407            * Word >5FEA maps to the read counter (R6, to generate interrupts when reading data) 
3408            * Bytes >5FEE maps to the CRU emulation write register
3409            * Bytes >5FF0 to >5FFE map to the FDC emulation registers
3410            *-----------------------------------------------------------------------------------                                    
3411            *
3412  5F22 0000         END
3412            


 Assembly Complete - Errors: 0,  Warnings: 0


 ------ Symbol Listing ------

 ACLBAS ABS:5DCA ACLBAS
 ACLERR ABS:5C88 ACLERR
 ACLPRP ABS:5C5E ACLPRP
 ACOMND ABS:5FE8 ACOMND
 ADDSEC ABS:46DA ADDSEC
 ADSR   ABS:5C30 ADSR
 AFDRPT ABS:529E AFDRPT
 AFPGPF ABS:51B4 AFPGPF
 AHLP   ABS:5C48 AHLP
 ALOW   ABS:5C4E ALOW
 ALOW2  ABS:5CC0 ALOW2
 APSCTS ABS:4636 APSCTS
 ARST   ABS:5C54 ARST
 CALLBF ABS:5FC8 CALLBF
 CALLST ABS:5FC6 CALLST
 CALSUB ABS:432E CALSUB
 CFNFDR ABS:5B60 CFNFDR
 CFSVIB ABS:573C CFSVIB
 CHKKEY ABS:5E32 CHKKEY
 CLOSE  ABS:4FA6 CLOSE
 CLRFBT ABS:4558 CLRFBT
 CLSDIR ABS:55E6 CLSDIR
 CMPFN  ABS:4812 CMPFN
 CPCKFN ABS:48EA CPCKFN
 CRFIL1 ABS:4466 CRFIL1
 CRFIL2 ABS:446C CRFIL2
 CRFIL3 ABS:4478 CRFIL3
 CRUWRI ABS:5FEE CRUWRI
 DECDCI ABS:4B8C DECDCI
 DELETE ABS:4744 DELETE
 DISSTS ABS:5E20 DISSTS
 DSDRVS ABS:432C DSDRVS
 DSKPRM ABS:5FB4 DSKPRM
 DSR01  ABS:40EE DSR01
 DSR02  ABS:40F6 DSR02
 DSR03  ABS:4100 DSR03
 DSR04  ABS:410A DSR04
 ECUSTM ABS:4366 ECUSTM
 EDSR01 ABS:4D22 EDSR01
 EDSR02 ABS:4D30 EDSR02
 EDSR03 ABS:4D36 EDSR03
 EDSR04 ABS:4D3C EDSR04
 EPWRUP ABS:4114 EPWRUP
 ERROR1 ABS:42CA ERROR1
 ERROR3 ABS:41FC ERROR3
 ERROR4 ABS:4268 ERROR4
 ERROR5 ABS:4948 ERROR5
 ERROR6 ABS:4AFE ERROR6
 ERROR7 ABS:48EE ERROR7
 ERROR8 ABS:4D8E ERROR8
 ERROR9 ABS:4DAA ERROR9
 ERRR10 ABS:55C2 ERRR10
 ESUB01 ABS:580C ESUB01
 ESUB02 ABS:581C ESUB02
 ESUB03 ABS:5826 ESUB03
 ESUB04 ABS:5880 ESUB04
 ESUB05 ABS:594C ESUB05
 ESUB06 ABS:59BC ESUB06
 ESUB07 ABS:5A82 ESUB07
 ESUB08 ABS:5A2E ESUB08
 FDR2B1 ABS:4846 FDR2B1
 FDR2B2 ABS:484A FDR2B2
 FDSKDR ABS:4860 FDSKDR
 FFDRDK ABS:4AE2 FFDRDK
 FFDRFN ABS:4B0E FFDRFN
 FFDROD ABS:4ADE FFDROD
 FFDRVB ABS:4A9A FFDRVB
 FFDRVP ABS:51A4 FFDRVP
 FFFDR  ABS:5BA8 FFFDR
 FFFDRV ABS:4A7A FFFDRV
 FFSBM  ABS:4C92 FFSBM
 FFSBMP ABS:4BCC FFSBMP
 FFSVIB ABS:45B0 FFSVIB
 FGET   ABS:5C24 FGET
 FMTDSK ABS:4202 FMTDSK
 FNDFDR ABS:4AD8 FNDFDR
 FNDRV  ABS:5776 FNDRV
 FPUT   ABS:5C2A FPUT
 FRSCB1 ABS:4C98 FRSCB1
 FSCTOF ABS:4720 FSCTOF
 GPLINT ABS:006A GPLINT
 GPLXML ABS:5EC4 GPLXML
 GXRTN  ABS:5F00 GXRTN
 H001   ABS:413A H001
 H005   ABS:419E H005
 H013   ABS:41A2 H013
 H014   ABS:41D0 H014
 H015   ABS:41B0 H015
 H016   ABS:41BE H016
 H019   ABS:41CC H019
 H024   ABS:41E6 H024
 H027   ABS:4206 H027
 H036   ABS:421E H036
 H037   ABS:422E H037
 H038   ABS:423C H038
 H044   ABS:4256 H044
 H055   ABS:4278 H055
 H056   ABS:4296 H056
 H057   ABS:428E H057
 H058   ABS:4294 H058
 H061   ABS:42B8 H061
 H064   ABS:42DC H064
 H066   ABS:42E2 H066
 H068   ABS:4306 H068
 H069   ABS:431A H069
 H070   ABS:43AE H070
 H071   ABS:43DC H071
 H072   ABS:438A H072
 H073   ABS:43D8 H073
 H074   ABS:43B4 H074
 H075   ABS:43F0 H075
 H076   ABS:441A H076
 H077   ABS:4502 H077
 H078   ABS:448E H078
 H079   ABS:44E6 H079
 H080   ABS:4518 H080
 H081   ABS:4542 H081
 H082   ABS:4522 H082
 H083   ABS:4534 H083
 H084   ABS:4548 H084
 H085   ABS:4580 H085
 H086   ABS:45AC H086
 H087   ABS:45CE H087
 H088   ABS:45FC H088
 H089   ABS:45D8 H089
 H090   ABS:4610 H090
 H091   ABS:461A H091
 H092   ABS:46CE H092
 H093   ABS:4646 H093
 H094   ABS:466C H094
 H095   ABS:465A H095
 H096   ABS:46A2 H096
 H097   ABS:46B0 H097
 H098   ABS:46AE H098
 H099   ABS:46A6 H099
 H100   ABS:46BE H100
 H101   ABS:46D6 H101
 H102   ABS:471E H102
 H103   ABS:4734 H103
 H104   ABS:4740 H104
 H105   ABS:472A H105
 H106   ABS:475C H106
 H107   ABS:477E H107
 H108   ABS:4772 H108
 H109   ABS:47C2 H109
 H110   ABS:47F2 H110
 H111   ABS:481A H111
 H112   ABS:483E H112
 H113   ABS:4878 H113
 H114   ABS:4882 H114
 H115   ABS:48E0 H115
 H116   ABS:488A H116
 H118   ABS:48D8 H118
 H119   ABS:48F4 H119
 H120   ABS:4902 H120
 H121   ABS:493E H121
 H122   ABS:490E H122
 H123   ABS:4972 H123
 H124   ABS:4994 H124
 H125   ABS:4998 H125
 H126   ABS:49FE H126
 H127   ABS:49D0 H127
 H128   ABS:49E4 H128
 H129   ABS:49F4 H129
 H130   ABS:4A72 H130
 H131   ABS:4A54 H131
 H132   ABS:4A6A H132
 H133   ABS:4A64 H133
 H134   ABS:4AB4 H134
 H135   ABS:4AD4 H135
 H136   ABS:4A96 H136
 H137   ABS:4B04 H137
 H138   ABS:4AEA H138
 H139   ABS:4B1A H139
 H140   ABS:4B80 H140
 H141   ABS:4B7C H141
 H142   ABS:4B86 H142
 H143   ABS:4BE0 H143
 H144   ABS:4BF2 H144
 H145   ABS:4C02 H145
 H146   ABS:4C0E H146
 H147   ABS:4C3E H147
 H148   ABS:4C34 H148
 H149   ABS:4C88 H149
 H150   ABS:4C46 H150
 H151   ABS:4C6C H151
 H152   ABS:4CC4 H152
 H153   ABS:4CD8 H153
 H154   ABS:4CD2 H154
 H155   ABS:4CD4 H155
 H156   ABS:4CDA H156
 H157   ABS:4D02 H157
 H158   ABS:4D0A H158
 H159   ABS:4D46 H159
 H160   ABS:4D40 H160
 H161   ABS:4D6C H161
 H162   ABS:4DB0 H162
 H163   ABS:4DC6 H163
 H164   ABS:4E7A H164
 H165   ABS:4DD2 H165
 H166   ABS:4E04 H166
 H167   ABS:4E1C H167
 H168   ABS:4E20 H168
 H169   ABS:4E76 H169
 H170   ABS:4EA2 H170
 H171   ABS:4E9E H171
 H172   ABS:4EC6 H172
 H173   ABS:4EF4 H173
 H174   ABS:4F4C H174
 H175   ABS:4F72 H175
 H176   ABS:4F76 H176
 H177   ABS:4FC0 H177
 H178   ABS:4FDA H178
 H179   ABS:4FBC H179
 H180   ABS:4FD2 H180
 H181   ABS:4FCC H181
 H182   ABS:4FFC H182
 H183   ABS:5032 H183
 H184   ABS:5016 H184
 H185   ABS:5040 H185
 H186   ABS:5064 H186
 H187   ABS:506C H187
 H188   ABS:5090 H188
 H189   ABS:50D6 H189
 H190   ABS:50CE H190
 H191   ABS:517C H191
 H192   ABS:50E0 H192
 H193   ABS:50F6 H193
 H194   ABS:510C H194
 H195   ABS:51F0 H195
 H196   ABS:5210 H196
 H197   ABS:5216 H197
 H198   ABS:5272 H198
 H199   ABS:5282 H199
 H200   ABS:536A H200
 H201   ABS:539E H201
 H202   ABS:53AC H202
 H203   ABS:53B2 H203
 H204   ABS:53F0 H204
 H205   ABS:5412 H205
 H206   ABS:53F4 H206
 H207   ABS:541E H207
 H208   ABS:5440 H208
 H209   ABS:5450 H209
 H210   ABS:54C6 H210
 H211   ABS:54F2 H211
 H212   ABS:5572 H212
 H213   ABS:555E H213
 H214   ABS:5500 H214
 H215   ABS:550C H215
 H216   ABS:552E H216
 H217   ABS:5518 H217
 H218   ABS:555A H218
 H219   ABS:5540 H219
 H220   ABS:556E H220
 H221   ABS:559C H221
 H222   ABS:55AC H222
 H223   ABS:5596 H223
 H224   ABS:55C8 H224
 H225   ABS:55D2 H225
 H226   ABS:562C H226
 H227   ABS:56A8 H227
 H228   ABS:569E H228
 H229   ABS:568E H229
 H230   ABS:5698 H230
 H231   ABS:56A6 H231
 H232   ABS:56C6 H232
 H233   ABS:5700 H233
 H234   ABS:56D6 H234
 H235   ABS:56F8 H235
 H236   ABS:574C H236
 H237   ABS:5770 H237
 H238   ABS:5762 H238
 H239   ABS:5766 H239
 H240   ABS:576C H240
 H241   ABS:5798 H241
 H242   ABS:57B2 H242
 H243   ABS:57A8 H243
 H244   ABS:57DC H244
 H245   ABS:57E6 H245
 H246   ABS:57E4 H246
 H247   ABS:57EC H247
 H248   ABS:57EE H248
 H249   ABS:5802 H249
 H250   ABS:58B0 H250
 H251   ABS:5942 H251
 H252   ABS:5948 H252
 H253   ABS:599A H253
 H254   ABS:5966 H254
 H255   ABS:5994 H255
 H256   ABS:596C H256
 H257   ABS:5972 H257
 H258   ABS:598E H258
 H259   ABS:59AE H259
 H260   ABS:59F0 H260
 H261   ABS:59D2 H261
 H262   ABS:5A2A H262
 H263   ABS:5A7E H263
 H264   ABS:5B42 H264
 H265   ABS:5B3C H265
 H266   ABS:5B04 H266
 H267   ABS:5AD0 H267
 H268   ABS:5AFA H268
 H269   ABS:5B38 H269
 H270   ABS:5B1C H270
 H272   ABS:5B46 H272
 H273   ABS:5B64 H273
 H274   ABS:5BC4 H274
 H275   ABS:5BE2 H275
 H276   ABS:5BF6 H276
 H9901  ABS:5CBC H9901
 H9902  ABS:5CD0 H9902
 H9903  ABS:5CFA H9903
 H9904  ABS:5D3E H9904
 H9905  ABS:5D9E H9905
 H9906  ABS:5DB4 H9906
 H9907  ABS:5DB8 H9907
 H9908  ABS:5DC6 H9908
 H9909  ABS:5E06 H9909
 H9910  ABS:5E0E H9910
 H9911  ABS:5E28 H9911
 H9912  ABS:5E3A H9912
 H9913  ABS:5E4E H9913
 H9914  ABS:5E52 H9914
 H9915  ABS:5E62 H9915
 H9916  ABS:5EAC H9916
 H9917  ABS:5EBC H9917
 HONK   ABS:03D6 HONK
 INSFDR ABS:47E0 INSFDR
 INT2FP ABS:57BA INT2FP
 K001   ABS:4182 K001
 K002   ABS:4328 K002
 K004   ABS:432A K004
 K005   ABS:432B K005
 K007   ABS:4329 K007
 K013   ABS:42DA K013
 K014   ABS:4946 K014
 LASTRK ABS:42E8 LASTRK
 LDSK   ABS:5C0C LDSK
 LDSK2  ABS:5D22 LDSK2
 LOAD   ABS:53A2 LOAD
 LSTDRV ABS:5FC7 LSTDRV
 MDSK   ABS:5C12 MDSK
 MNDSK2 ABS:5D78 MNDSK2
 NDIR   ABS:5C36 NDIR
 NDSK   ABS:5C18 NDSK
 NOCRU  ABS:4180 NOCRU
 NOPARM ABS:5C8C NOPARM
 NOPRM2 ABS:5C98 NOPRM2
 NTPDT  ABS:5F1A NTPDT
 NTPFAT ABS:4026 NTPFAT
 NXTPRP ABS:5D5E NXTPRP
 NXTSCR ABS:5D2A NXTSCR
 OPCVEC ABS:4D74 OPCVEC
 OPEN   ABS:4D94 OPEN
 OPNDIR ABS:5588 OPNDIR
 PABR2B ABS:4840 PABR2B
 PATTBL ABS:402A PATTBL
 PDSK   ABS:5C00 PDSK
 PESB07 ABS:5A88 PESB07
 PRFDRS ABS:4F54 PRFDRS
 PRPFDO ABS:43FA PRPFDO
 PRPRTN ABS:43FC PRPRTN
 PUDSK2 ABS:5D1C PUDSK2
 PWRUP  ABS:40E8 PWRUP
 QNOPRM ABS:5CA8 QNOPRM
 QSTRNG ABS:5D7E QSTRNG
 R0     ABS:0000 R0
 R1     ABS:0001 R1
 R10    ABS:000A R10
 R11    ABS:000B R11
 R12    ABS:000C R12
 R13    ABS:000D R13
 R14    ABS:000E R14
 R15    ABS:000F R15
 R2     ABS:0002 R2
 R3     ABS:0003 R3
 R4     ABS:0004 R4
 R5     ABS:0005 R5
 R6     ABS:0006 R6
 R7     ABS:0007 R7
 R8     ABS:0008 R8
 R9     ABS:0009 R9
 RBANB  ABS:5494 RBANB
 RCOFCB ABS:5324 RCOFCB
 RDATA  ABS:5FF6 RDATA
 RDDIR  ABS:55FC RDDIR
 RDFDR1 ABS:4A20 RDFDR1
 RDFDR2 ABS:4A1C RDFDR2
 RDINT  ABS:5FEA RDINT
 RDOFSC ABS:4600 RDOFSC
 RDSEC1 ABS:4A0A RDSEC1
 RDSK   ABS:5C1E RDSK
 READ   ABS:4FB0 READ
 RETERR ABS:4974 RETERR
 RFDRST ABS:51D0 RFDRST
 RFDRVB ABS:5928 RFDRVB
 RFNPTR ABS:5B82 RFNPTR
 RMFPTR ABS:47B0 RMFPTR
 RNFISE ABS:522E RNFISE
 RRFDR  ABS:524A RRFDR
 RRNPAB ABS:51E4 RRNPAB
 RRSEC  ABS:5036 RRSEC
 RSTAT  ABS:5FF0 RSTAT
 RSTDRV ABS:429C RSTDRV
 RTN5C  ABS:4028 RTN5C
 RTURN1 ABS:434C RTURN1
 RVRVDP ABS:43B2 RVRVDP
 RWIND1 ABS:534E RWIND1
 RWIND2 ABS:537C RWIND2
 RWSEC  ABS:4A24 RWSEC
 RWSECA ABS:4A26 RWSECA
 RWSECB ABS:4A28 RWSECB
 RWVIB  ABS:49A8 RWVIB
 SAVE   ABS:5444 SAVE
 SAVGRA ABS:5EC0 SAVGRA
 SAVR11 ABS:5EC2 SAVR11
 SCROLL ABS:56CD SCROLL
 SDIR   ABS:5C42 SDIR
 SDSK   ABS:5C3C SDSK
 SECRW1 ABS:4184 SECRW1
 SELDRV ABS:426E SELDRV
 SNDCMD ABS:42E0 SNDCMD
 SP2VDP ABS:5BEC SP2VDP
 STATUS ABS:54C8 STATUS
 SUB01  ABS:4010 SUB01
 SUB02  ABS:4016 SUB02
 SUB03  ABS:401C SUB03
 SUB04  ABS:4022 SUB04
 SUB05  ABS:402C SUB05
 SUB06  ABS:4032 SUB06
 SUB07  ABS:4038 SUB07
 SUB08  ABS:403E SUB08
 SUB09  ABS:4048 SUB09
 SUB10  ABS:4052 SUB10
 SUB11  ABS:405C SUB11
 SUB12  ABS:4066 SUB12
 SUB13  ABS:4070 SUB13
 SUB14  ABS:407A SUB14
 SUB15  ABS:4084 SUB15
 SUB16  ABS:408E SUB16
 SUB17  ABS:4098 SUB17
 SUB18  ABS:40A2 SUB18
 SUB19  ABS:40AC SUB19
 SUB20  ABS:40B6 SUB20
 SUB21  ABS:40C0 SUB21
 SUB22  ABS:40CA SUB22
 SUB23  ABS:40D4 SUB23
 SUB24  ABS:40DE SUB24
 SVDPRD ABS:43E8 SVDPRD
 SVDPWR ABS:43DE SVDPWR
 SVRVDP ABS:4386 SVRVDP
 TIME   ABS:5C5A TIME
 TIME2  ABS:5E5C TIME2
 UCOFCB ABS:52C2 UCOFCB
 UDSK   ABS:5C06 UDSK
 UFNCB  ABS:5B4A UFNCB
 UPDBF  ABS:456C UPDBF
 UPDCLI ABS:4BA8 UPDCLI
 UPDFCB ABS:4F7E UPDFCB
 UPDFDR ABS:454C UPDFDR
 URFFDR ABS:52EE URFFDR
 USTRNG ABS:5CE2 USTRNG
 UWFLVB ABS:5860 UWFLVB
 VARINF ABS:5E58 VARINF
 VDP2SP ABS:5BDC VDP2SP
 VDPR2B ABS:484C VDPR2B
 VDPRD  ABS:4316 VDPRD
 VDPRPW ABS:4254 VDPRPW
 VDPWRI ABS:430C VDPWRI
 VECRTN ABS:437E VECRTN
 WCOMND ABS:5FF8 WCOMND
 WDATA  ABS:5FFE WDATA
 WFDRPB ABS:5012 WFDRPB
 WRFDR  ABS:4A16 WRFDR
 WRITE  ABS:509A WRITE
 WROFSC ABS:4620 WROFSC
 WRSEC1 ABS:4A0C WRSEC1
 WSECTR ABS:5FFC WSECTR
 WTCPT1 ABS:4260 WTCPT1
 XML14  ABS:164E XML14
 XML16  ABS:15D6 XML16
 XML5C  ABS:105C XML5C
 XMLRTN ABS:2244 XMLRTN
