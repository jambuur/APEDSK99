Asm994a TMS99000 Assembler - v3.010

                * Asm994a Generated Register Equates
                *
      0000 0000 R0      EQU     0 
      0000 0001 R1      EQU     1 
      0000 0002 R2      EQU     2 
      0000 0003 R3      EQU     3 
      0000 0004 R4      EQU     4 
      0000 0005 R5      EQU     5 
      0000 0006 R6      EQU     6 
      0000 0007 R7      EQU     7 
      0000 0008 R8      EQU     8 
      0000 0009 R9      EQU     9 
      0000 000A R10     EQU     10
      0000 000B R11     EQU     11
      0000 000C R12     EQU     12
      0000 000D R13     EQU     13
      0000 000E R14     EQU     14
      0000 000F R15     EQU     15
                *
   1            *===============================================================================================================
   2            * TI DISK CONTROLLER ROM   >4000-5FFF
   3            * 
   4            * initial commented disassembly by Thierry Nouspikel
   5            * (see http://www.unige.ch/medecine/nouspikel/ti99/titechpages.htm)
   6            *
   7            * and
   8            * 
   9            * Monty Schmidt's book: TI Technical Drive
  10            *
  11            * adapted for APEDSK99 by Jochen Buur
  12            * github.com/jambuur/APEDSK99
  13            *
  14            * v12r: support for Double Density / 80 tracks (max 1440 AU's)
  15            *================================================================================================================
  16  0000 5FB4 DSKPRM  EQU     >5FB4                   per DSKx: Mbyte #sectors, Lbyte #sectors, #sectors/track, #tracks, #sides
  17  0000 5FC6 CALLST  EQU     >5FC6                   CALL() execution status: finished, still active, error
  18  0000 5FC8 CALLBF  EQU     >5FC8                   2-way buffer for TI BASIC CALL's (1 screen line, 32 characters)
  19  0000 5FE8 ACOMND  EQU     >5FE8                   APEDSK99-specific Command register
  20  0000 5FEA RDINT   EQU     >5FEA                   issue read interrupt (R6 counter) 
  21  0000 5FEE CRUWRI  EQU     >5FEE                   emulated 8 CRU output bits
  22  0000 5FF0 RSTAT   EQU     >5FF0                   read FD1771 Status register
  23  0000 5FF6 RDATA   EQU     >5FF6                   read FD1771 Data register
  24  0000 5FF8 WCOMND  EQU     >5FF8                   write FD1771 Command register
  25  0000 5FFC WSECTR  EQU     >5FFC                   write FD1771 Sector register
  26  0000 5FFE WDATA   EQU     >5FFE                   write FD1771 Data register
  27            *
  28  0000 164E XML14   EQU     >164E                   ROM address for XML >14
  29  0000 15D6 XML16   EQU     >15D6                   ROM address for XML >16
  30            *
  31            *!!! CHECK GROM ADDRESS CONTENTS, NEEDS TO BE >0F5C; UNCOMMENT RELEVANT LINE (different GROM 0 versions)
  32            *
  33            *XML5C  EQU     >1039                   GROM address for XML >5C; GROM v2.2 consoles
  34            *XML5C  EQU     >1058                   GROM address for XML >5C; GROM - Heiner Martin version
  35  0000 105C XML5C   EQU     >105C                   GROM address for XML >5C; GROM - different pointers to character blocks
  36            *
  37  0000 006A GPLINT  EQU     >006A                   jump to GROM interpreter for SCROLL / HONK
  38  0000 2244 XMLRTN  EQU     >2244                   jump to GROM interpreter for RTN (after executing XML >14 / >16 routine)
  39  0000 56CD SCROLL  EQU     >56CD                   GROM address for scroll routine
  40            *
  41            *!!! CHECK GROM ADDRESS CONTENTS, NEEDS TO BE >BF58; UNCOMMENT RELEVANT LINE (different GROM 0 versions)
  42            *
  43            *HONK   EQU     >03AF                   GROM address for "bad tone"; GROM v2.2 consoles
  44            *HONK   EQU     >03D3                   GROM address for "bad tone"; GROM - Heiner Martin version
  45  0000 03D6 HONK    EQU     >03D6                   GROM address for "bad tone"; GROM - different pointers to character blocks
  46            *
  47                    AORG    >4000
  48            *
  49  4000 AA           BYTE    >AA                     standard header mark
  50  4001 02           BYTE    >02                     version 2
  51  4002 0000         DATA    >0000                   no programs
  52  4004 40D2         DATA    PWRUP                   power-up chain ptr
  53  4006 0000         DATA    >0000                   programs chain ptr (none)
  54  4008 40D8         DATA    DSR01                   DSR chain ptr
  55  400A 4010         DATA    SUB01                   subprograms chain ptr
  56  400C 0000         DATA    >0000                   ISR chain ptr (none)
  57  400E 0000         DATA    >0000                   
  58            *                                       
  59  4010 4016 SUB01   DATA    SUB02                   link to next subprogram
  60  4012 57F6         DATA    ESUB01                  address of that one
  61  4014 0110         DATA    >0110                   subprogram name: >10 (sector R/W)
  62  4016 401C SUB02   DATA    SUB03                   
  63  4018 5806         DATA    ESUB02                  
  64  401A 0111         DATA    >0111                   subprogram >11 (format disk)
  65  401C 4022 SUB03   DATA    SUB04                   
  66  401E 5810         DATA    ESUB03                  
  67  4020 0112         DATA    >0112                   subprogram >12 (file un/protect)
  68  4022 402A SUB04   DATA    SUB05                   
  69  4024 586A         DATA    ESUB04                  
  70  4026 0113 NTPFAT  DATA    >0113                   subprogram >13 (file rename); doubles as FAT update flag
  71            *
  72  4028 0000 RTN5C   DATA    >0000                   save GPL return address (needs to be @>4028 for XML >5C!)
  73            *
  74  402A 4030 SUB05   DATA    SUB06                   
  75  402C 5936         DATA    ESUB05                  
  76  402E 0114         DATA    >0114                   subprogram >14 (file direct input)              
  77  4030 4036 SUB06   DATA    SUB07                   
  78  4032 59A6         DATA    ESUB06                  
  79  4034 0115         DATA    >0115                   subprogram >15 (file direct output)
  80  4036 403C SUB07   DATA    SUB08                   
  81  4038 5A6C         DATA    ESUB07                  
  82  403A 0116         DATA    >0116                   subprogram >16 (number of files)
  83  403C 4046 SUB08   DATA    SUB09                   
  84  403E 5A18         DATA    ESUB08                  
  85  4040 05           BYTE    >05                     
  86  4041 4649         TEXT    'FILES'                 same as >16, called from Basic
  86  4043 4C45  
  86  4045 53    
  87            *
  88  4046 4050 SUB09   DATA    SUB10
  89  4048 5BEA         DATA    PDSK
  90  404A 04           BYTE    >04
  91  404B 5044         TEXT    'PDSK'                  Protect DSKx (apply adhesive tab)
  91  404D 534B  
  92  404F 0000         EVEN
  93  4050 405A SUB10   DATA    SUB11                   
  94  4052 5BF0         DATA    UDSK
  95  4054 04           BYTE    >04
  96  4055 5544         TEXT    'UDSK'                  Un-protect DSKx (remove adhesive tab)
  96  4057 534B  
  97  4059 0000         EVEN
  98  405A 4064 SUB11   DATA    SUB12
  99  405C 5BFC         DATA    MDSK
 100  405E 04           BYTE    >04
 101  405F 4D44         TEXT    'MDSK'                  Map DOAD to DSKx
 101  4061 534B  
 102  4063 0000         EVEN
 103  4064 406E SUB12   DATA    SUB13
 104  4066 5BF6         DATA    LDSK
 105  4068 04           BYTE    >04
 106  4069 4C44         TEXT    'LDSK'                  List files on DSKx
 106  406B 534B  
 107  406D 0000         EVEN
 108  406E 4078 SUB13   DATA    SUB14
 109  4070 5C08         DATA    RDSK
 110  4072 04           BYTE    >04
 111  4073 5244         TEXT    'RDSK'                  Remove DOAD from SD card
 111  4075 534B  
 112  4077 0000         EVEN
 113  4078 4082 SUB14   DATA    SUB15
 114  407A 5C20         DATA    SDSK
 115  407C 04           BYTE    >04
 116  407D 5344         TEXT    'SDSK'                  Show DOAD mapping for DSKx
 116  407F 534B  
 117  4081 0000         EVEN
 118  4082 408C SUB15   DATA    SUB16
 119  4084 5C26         DATA    SDIR
 120  4086 04           BYTE    >04
 121  4087 5344         TEXT    'SDIR'                  List DOAD files on SD card
 121  4089 4952  
 122  408B 0000         EVEN
 123  408C 4096 SUB16   DATA    SUB17
 124  408E 5C2C         DATA    AHLP
 125  4090 04           BYTE    >04
 126  4091 4148         TEXT    'AHLP'                  APEDSK99 CALL help screen
 126  4093 4C50  
 127  4095 0000         EVEN
 128  4096 40A0 SUB17   DATA    SUB18
 129  4098 5C38         DATA    TIME
 130  409A 04           BYTE    >04
 131  409B 5449         TEXT    'TIME'                  NTP date/time display / assign to NTP$
 131  409D 4D45  
 132  409F 0000         EVEN
 133  40A0 40AA SUB18   DATA    SUB19
 134  40A2 5C32         DATA    ARST
 135  40A4 04           BYTE    >04
 136  40A5 4152         TEXT    'ARST'                  APEDSK99 Reset
 136  40A7 5354  
 137  40A9 0000         EVEN
 138  40AA 40B4 SUB19   DATA    SUB20
 139  40AC 5C0E         DATA    FGET
 140  40AE 04           BYTE    >04
 141  40AF 4647         TEXT    'FGET'                  Load DOAD from FTP server
 141  40B1 4554  
 142  40B3 0000         EVEN
 143  40B4 40BE SUB20   DATA    SUB21
 144  40B6 5C14         DATA    FPUT
 145  40B8 04           BYTE    >04
 146  40B9 4650         TEXT    'FPUT'                  Save DOAD to FTP server
 146  40BB 5554  
 147  40BD 0000         EVEN
 148  40BE 40C8 SUB21   DATA    SUB22
 149  40C0 5C1A         DATA    ADSR
 150  40C2 04           BYTE    >04
 151  40C3 4144         TEXT    'ADSR'                  APEDSK99 load DSR
 151  40C5 5352  
 152  40C7 0000         EVEN
 153  40C8 0000 SUB22   DATA    >0000
 154  40CA 5C02         DATA    NDSK
 155  40CC 04           BYTE    >04
 156  40CD 4E44         TEXT    'NDSK'
 156  40CF 534B  
 157  40D1 0000         EVEN
 158            *
 159  40D2 0000 PWRUP   DATA    >0000                   power-up chain (no more)
 160  40D4 40FE         DATA    EPWRUP                  address of power-up routine
 161  40D6 0000         DATA    >0000                   no name
 162                                                    
 163  40D8 40E0 DSR01   DATA    DSR02                   DSR chain
 164  40DA 4D0C         DATA    EDSR01                  address of DSR
 165  40DC 03           BYTE    >03                     name size
 166  40DD 4453         TEXT    'DSK'                   DSR name
 166  40DF 4B    
 167  40E0 40EA DSR02   DATA    DSR03                   
 168  40E2 4D1A         DATA    EDSR02                  
 169  40E4 04           BYTE    >04                     
 170  40E5 4453         TEXT    'DSK1'                  
 170  40E7 4B31  
 171  40E9 0000         EVEN                            
 172  40EA 40F4 DSR03   DATA    DSR04                   
 173  40EC 4D20         DATA    EDSR03                  
 174  40EE 04           BYTE    >04                     
 175  40EF 4453         TEXT    'DSK2'                  
 175  40F1 4B32  
 176  40F3 0000         EVEN                            
 177  40F4 0000 DSR04   DATA    >0000                   no more
 178  40F6 4D26         DATA    EDSR04                  
 179  40F8 04           BYTE    >04                     
 180  40F9 4453         TEXT    'DSK3'                  
 180  40FB 4B33  
 181  40FD 0000         EVEN            
 182            *
 183            *=====================================
 184            * Power-up routine
 185            *=====================================                                          
 186            *
 187  40FE 028C EPWRUP  CI      R12,>1000               Dhr. F.G. Kaal check: are we powering up 1st CRU (>1000) peripheral?
 187  4100 1000  
 188  4102 1633         JNE     NOCRU                   nope; return
 189            *
 190  4104 C1CB         MOV     R11,R7                  yes; save return address
 191  4106 02A9         STWP    R9                      get workspace (should be >83E0)
 192  4108 0229         AI      R9,-224                 point to top of scratch-pad mem (>8300)
 192  410A FF20  
 193  410C C0A9         MOV     @>0070(R9),R2           highest free address in vdp mem (>8370)
 193  410E 0070  
 194  4110 C002         MOV     R2,R0                   save it
 195  4112 0222         AI      R2,-2088                we'll need >828 bytes
 195  4114 F7D8  
 196  4116 CA42         MOV     R2,@>0070(R9)           update address
 196  4118 0070  
 197  411A 0582         INC     R2
 198  411C 06A0         BL      @VDPWRI                 set VDP address
 198  411E 42F6  
 199  4120 0201         LI      R1,2088                 
 199  4122 0828  
 200  4124 04EF H001    CLR     @-2(R15)                clear these >828 bytes
 200  4126 FFFE  
 201  4128 0601         DEC     R1                      
 202  412A 16FC         JNE     H001                    
 203  412C 06A0         BL      @VDPWRI                 set VDP address (same)
 203  412E 42F6  
 204  4130 0203         LI      R3,>AA03                        
 204  4132 AA03  
 205  4134 DBC3         MOVB    R3,@-2(R15)             write buffer ID mark
 205  4136 FFFE  
 206  4138 1000         NOP                             
 207  413A DBC0         MOVB    R0,@-2(R15)             write old highest free address
 207  413C FFFE  
 208  413E 06C0         SWPB    R0
 209  4140 DBC0         MOVB    R0,@-2(R15)
 209  4142 FFFE  
 210  4144 1000         NOP                             
 211  4146 DBCC         MOVB    R12,@-2(R15)            write CRU address (>1000 for APEDSK99)
 211  4148 FFFE  
 212  414A 06C3         SWPB    R3                      
 213  414C DBC3         MOVB    R3,@-2(R15)             write number of files (3)
 213  414E FFFE  
 214  4150 06A0         BL      @PRPRTN                 preparation routine
 214  4152 43E6  
 215  4154 06A0         BL      @CALSUB                 call subroutine
 215  4156 4318  
 216  4158 4286         DATA    RSTDRV                  reset all drives
 217  415A 04E9         CLR     @>0054(R9)              name length = 0 for power-up
 217  415C 0054  
 218  415E 0429         BLWP    @>005A(R9)              retrieve R7 (saved by PRPRTN)
 218  4160 005A  
 219  4162 0011         DATA    >0011                   put it into R11
 220  4164 CA60         MOV     @K001,@>006C(R9)        ???
 220  4166 416C  
 220  4168 006C  
 221  416A 045B NOCRU   B       *R11                    return
 222            *                               
 223  416C 0404 K001    DATA    >0404                   
 224            *
 225            *---------------------------------------
 226            * Sector read/write
 227            *---------------------------------------                                        
 228            *
 229  416E DA60 SECRW1  MOVB    @K002,@>0050(R9)        APEDSK99: no error
 229  4170 4312  
 229  4172 0050  
 230  4174 06A0         BL      @SELDRV                 select drive
 230  4176 4258  
 231            *
 232  4178 C069         MOV     @>004A(R9),R1           sector #
 232  417A 004A  
 233  417C 0281         CI      R1,>05A0                APEDSK99: max 1440 (DS/DD/40T or DS/SD/80T)?
 233  417E 05A0  
 234  4180 1A03         JL      H005                    APEDSK99: yes; sector# within range
 235  4182 06A0         BL      @ERROR1                 APEDSK99: no -> "device error"
 235  4184 42B4  
 236  4186 0600         DATA    >0600   
 237            
 238  4188 C801 H005    MOV     R1,@WSECTR              APEDSK99: sector# to FD1771 write sector register (16bits)
 238  418A 5FFC  
 239            *
 240  418C C0A9 H013    MOV     @>004E(R9),R2           data buffer address
 240  418E 004E  
 241  4190 D029         MOVB    @>004D(R9),R0           read or write ?
 241  4192 004D  
 242  4194 1312         JEQ     H014                    write
 243  4196 06A0         BL      @VDPWRI                 read FD = write to VDP buffer
 243  4198 42F6  
 244  419A 0206 H015    LI      R6,256                  APEDSK99: re-arranged H015 to sync reading sector bytes
 244  419C 0100  
 245  419E C806         MOV     R6,@RDINT               APEDSK99: interrupt Arduino for read operation 
 245  41A0 5FEA  
 246  41A2 06A0         BL      @SNDCMD                 send command
 246  41A4 42CA  
 247  41A6 8800         DATA    >8800                   APEDSK99: read sector
 248            *
 249  41A8 D020 H016    MOVB    @RDATA,R0               get 1 byte from FDC
 249  41AA 5FF6  
 250  41AC DBC0         MOVB    R0,@-2(R15)             save it to VDP
 250  41AE FFFE  
 251  41B0 0620         DEC     @RDINT                  APEDSK99: interrupt Arduino for read operation
 251  41B2 5FEA  
 252  41B4 16F9         JNE     H016                    next byte
 253            *
 254  41B6 0460 H019    B       @RTURN1                 return
 254  41B8 4336  
 255            
 256            *       
 257  41BA 06A0 H014    BL      @VDPRD                  write to FD = read from VDP buffer
 257  41BC 4300  
 258  41BE 0206         LI      R6,256                  256 bytes to write
 258  41C0 0100  
 259            *
 260            * APEDSK99: the first byte to be written needs to be in the data register before the write command is given
 261            *
 262  41C2 D02F         MOVB    @-1026(R15),R0          APEDSK99: get a byte from data buffer
 262  41C4 FBFE  
 263  41C6 D800         MOVB    R0,@WDATA               APEDSK99: write first byte to data register
 263  41C8 5FFE  
 264  41CA 06A0         BL      @SNDCMD                 send command
 264  41CC 42CA  
 265  41CE A800         DATA    >A800                   APEDSK99: write sector
 266            *
 267  41D0 D02F H024    MOVB    @-1026(R15),R0          get a byte from data buffer
 267  41D2 FBFE  
 268  41D4 D800         MOVB    R0,@WDATA               pass it to data register
 268  41D6 5FFE  
 269  41D8 0606         DEC     R6                      
 270  41DA 16FA         JNE     H024                    next byte
 271            *
 272  41DC 06A0         BL      @WTCPT1                 APEDSK99: check for Write Protect
 272  41DE 424A  
 273  41E0 0A20         SLA     R0,2                    APEDSK99: WP bit in Carry
 274  41E2 1801         JOC     ERROR3                  write protect: error 34
 275  41E4 10E8         JMP     H019                    APEDSK99: no need to verify             
 276            *                                       
 277  41E6 06A0 ERROR3  BL      @ERROR1                 error 34 (Write Protect)
 277  41E8 42B4  
 278  41EA 3400         DATA    >3400                   
 279            *
 280            *--------------------------------------------------------------------
 281            * Format disk - APEDSK99: we don't do any physical formatting anymore
 282            *--------------------------------------------------------------------
 283            *
 284  41EC 04E9 FMTDSK  CLR     @>004A(R9)              called by subprogram >11
 284  41EE 004A  
 285            *                                       
 286  41F0 5A60 H027    SZCB    @K004,@>004C(R9)        clear DSR version flags
 286  41F2 4314  
 286  41F4 004C  
 287            *
 288  41F6 06A0         BL      @SELDRV                 select drive
 288  41F8 4258  
 289            *
 290  41FA D029         MOVB    @>004D(R9),R0           APEDSK99: get # of tracks
 290  41FC 004D  
 291  41FE 9829         CB      @>0051(R9),@K005        APEDSK99: double sided?
 291  4200 0051  
 291  4202 4315  
 292  4204 1601         JNE     H036                    APEDSK99: single-side
 293            *
 294  4206 0A10         SLA     R0,1                    times two (since 2 sides)
 295            *
 296  4208 0980 H036    SRL     R0,8                    APEDSK99: make it a byte
 297  420A 0206         LI      R6,9                    APEDSK99: start with single density
 297  420C 0009  
 298  420E 9829         CB      @>0050(R9),@K005        APEDSK99: double density required?
 298  4210 0050  
 298  4212 4315  
 299  4214 1601         JNE     H037                    APEDSK99: no, leave R6 alone
 300  4216 0A16         SLA     R6,1                    APEDSK99: yes, R6*2
 301            *               
 302  4218 3806 H037    MPY     R6,R0                   APEDSK99: #sectors/track * #tracks
 303  421A 0281         CI      R1,>05A0                APEDSK99: >1440 sectors?
 303  421C 05A0  
 304  421E 1203         JLE     H038                    APEDSK99: nope; continue
 305  4220 06A0         BL      @ERROR1                 APEDSK99: yes; "device error"
 305  4222 42B4  
 306  4224 0600         DATA    >0600   
 307            *
 308  4226 CA41 H038    MOV     R1,@>004A(R9)           pass total # of sectors per disk
 308  4228 004A  
 309  422A 06C6         SWPB    R6
 310  422C DA46         MOVB    R6,@>004D(R9)           APEDSK99: pass # of sectors per track
 310  422E 004D  
 311  4230 DA60         MOVB    @K002,@>0050(R9)        no error
 311  4232 4312  
 311  4234 0050  
 312            *
 313  4236 06A0         BL      @NTPDT                  APEDSK99: update DOAD FAT time/date
 313  4238 5DF2  
 314            *
 315  423A 0460         B       @RTURN1                 return
 315  423C 4336  
 316            *                                       
 317                                                    
 318  423E C1BB VDPRPW  MOV     *R11+,R6                VDP repeated write
 319  4240 DBC0 H044    MOVB    R0,@-2(R15)
 319  4242 FFFE  
 320  4244 0606         DEC     R6                      byte in R0
 321  4246 16FC         JNE     H044                    number of repeats in data word
 322  4248 045B         B       *R11                    
 323            *
 324  424A D020 WTCPT1  MOVB    @RSTAT,R0               get status. APEDSK99: Not Ready >80 / Write Protect >40
 324  424C 5FF0  
 325  424E 1101         JLT     ERROR4                  drive not ready. APEDSK99: Not Ready set when DOAD file is unavailable
 326  4250 045B         B       *R11                    
 327            *
 328  4252 06A0 ERROR4  BL      @ERROR1                 exit with error code 6, reseting all drives
 328  4254 42B4  
 329  4256 0600         DATA    >0600                   
 330            *                                       
 331  4258 C1CB SELDRV  MOV     R11,R7                  select a drive
 332  425A C0A9         MOV     @>0058(R9),R2
 332  425C 0058  
 333  425E 0222         AI      R2,-10                  point to drive info
 333  4260 FFF6  
 334  4262 04C0 H055    CLR     R0                      
 335  4264 D029         MOVB    @>004C(R9),R0           get drive #
 335  4266 004C  
 336  4268 130B         JEQ     H056                    can't be >00: error #7
 337  426A 0280         CI      R0,>0300                        
 337  426C 0300  
 338  426E 1B08         JH      H056                    drive number can't be higher than 3: error #7
 339  4270 06A0         BL      @VDPWRI                 set VDP to write, address in R2
 339  4272 42F6  
 340  4274 DBC0         MOVB    R0,@-2(R15)             modify last drive accessed              
 340  4276 FFFE  
 341            *
 342  4278 0A10 H057    SLA     R0,1                    APEDSK99: bit 0 is side select, 1-3 is drive #
 343  427A D800         MOVB    R0,@CRUWRI              APEDSK99: select drive
 343  427C 5FEE  
 344  427E 0457 H058    B       *R7                     
 345            *                                       
 346  4280 06A0 H056    BL      @ERROR1                 exit with error #7
 346  4282 42B4  
 347  4284 0700         DATA    >0700                   
 348            *                                       
 349  4286 5820 RSTDRV  SZCB    @DSDRVS,@CRUWRI         APEDSK99: reset all drives including side
 349  4288 4316  
 349  428A 5FEE  
 350  428C D820         MOVB    @K013,@WCOMND           send Force Interrupt with no interrupt flag set
 350  428E 42C4  
 350  4290 5FF8  
 351  4292 C0A9         MOV     @>0058(R9),R2           ptr to VIB buffer
 351  4294 0058  
 352  4296 0222         AI      R2,-10                  now points to drive info buffer
 352  4298 FFF6  
 353  429A 06A0         BL      @VDPWRI                 set VDP to write to address in R2
 353  429C 42F6  
 354  429E 0200         LI      R0,4                    
 354  42A0 0004  
 355  42A2 DBC0 H061    MOVB    R0,@-2(R15)             write four >00 (i.e. clear drive info)
 355  42A4 FFFE  
 356  42A6 0600         DEC     R0                      
 357  42A8 16FC         JNE     H061                    
 358  42AA DA60         MOVB    @K002,@>0050(R9)        no error
 358  42AC 4312  
 358  42AE 0050  
 359  42B0 0460         B       @RTURN1                 get return address from stack
 359  42B2 4336  
 360            *                                       
 361  42B4 C01B ERROR1  MOV     *R11,R0                 exit with error
 362  42B6 DA40         MOVB    R0,@>0050(R9)           place err code in >8350
 362  42B8 0050  
 363  42BA 0280         CI      R0,>0600                check if device error
 363  42BC 0600  
 364  42BE 1603         JNE     H064                    no: exit
 365  42C0 06A0         BL      @SNDCMD                 yes: reset drives
 365  42C2 42CA  
 366            *
 367  42C4 0000 K013    DATA    >0000                   APEDSK99: send Restore command
 368            *
 369  42C6 0460 H064    B       @RTURN1                 return to caller (address from stack)
 369  42C8 4336  
 370            *                               
 371  42CA C03B SNDCMD  MOV     *R11+,R0                send command to FDC from data word
 372  42CC D800 H066    MOVB    R0,@WCOMND              send command
 372  42CE 5FF8  
 373  42D0 045B         B       *R11                    
 374            *                                       
 375  42D2 04C0 LASTRK  CLR     R0                      get last track # for this drive
 376  42D4 D029         MOVB    @>004C(R9),R0           get drive #
 376  42D6 004C  
 377  42D8 130B         JEQ     H068                    can't be 0
 378  42DA 06C0         SWPB    R0                      
 379  42DC 0280         CI      R0,3                    
 379  42DE 0003  
 380  42E0 1B07         JH      H068                    can't be higher than 3
 381  42E2 C0A9         MOV     @>0058(R9),R2                   
 381  42E4 0058  
 382  42E6 0222         AI      R2,-10                  point to last drive accessed
 382  42E8 FFF6  
 383  42EA A080         A       R0,R2                   point to last track for this drive
 384  42EC 0460         B       @VDPRD                  prepare VDP to read from address in R2
 384  42EE 4300  
 385            *                                       
 386  42F0 06A0 H068    BL      @ERROR1                 exit with error code 7
 386  42F2 42B4  
 387  42F4 0700         DATA    >0700                   
 388            *                                       
 389  42F6 0262 VDPWRI  ORI     R2,>4000                set VDP address to write
 389  42F8 4000  
 390  42FA 0242         ANDI    R2,>7FFF                not to a register
 390  42FC 7FFF  
 391  42FE 1002         JMP     H069                    
 392  4300 0242 VDPRD   ANDI    R2,>3FFF                set VDP address to read
 392  4302 3FFF  
 393  4304 06C2 H069    SWPB    R2                      
 394  4306 D7C2         MOVB    R2,*R15                 write address
 395  4308 06C2         SWPB    R2                      
 396  430A D7C2         MOVB    R2,*R15                 
 397  430C 0242         ANDI    R2,>3FFF                        
 397  430E 3FFF  
 398  4310 045B         B       *R11                    
 399            *                                       
 400  4312 00   K002    BYTE    >00                     
 401  4313 09   K007    BYTE    >09                                             
 402  4314 F0   K004    BYTE    >F0                     
 403  4315 02   K005    BYTE    2
 404  4316 0F   DSDRVS  BYTE    >0F                     APEDSK99: deselect all drives + side (reset CRUWRI bits 7,6,5 and 4)                    
 405            *
 406  4317 0000         EVEN
 407            *                               
 408  4318 0669 CALSUB  DECT    @>0066(R9)              call subroutine, return address in stack
 408  431A 0066  
 409  431C C2A9         MOV     @>0066(R9),R10
 409  431E 0066  
 410  4320 0429         BLWP    @>005A(R9)              set VDP to write to address in R10
 410  4322 005A  
 411  4324 0143         DATA    >0143                   
 412  4326 C2BB         MOV     *R11+,R10               get next data word
 413  4328 06CB         SWPB    R11                     write return address to VDP
 414  432A DBCB         MOVB    R11,@-2(R15)                    
 414  432C FFFE  
 415  432E 06CB         SWPB    R11                     
 416  4330 DBCB         MOVB    R11,@-2(R15)                    
 416  4332 FFFE  
 417  4334 045A         B       *R10                    branch to address in data word
 418            *                               
 419  4336 C2E9 RTURN1  MOV     @>0066(R9),R11          get return address from VDP stack
 419  4338 0066  
 420  433A 0429         BLWP    @>005A(R9)              
 420  433C 005A  
 421  433E 0162         DATA    >0162                   set VDP to read from address in R11
 422  4340 D2EF         MOVB    @-1026(R15),R11                 
 422  4342 FBFE  
 423  4344 06CB         SWPB    R11                     
 424  4346 D2EF         MOVB    @-1026(R15),R11                 
 424  4348 FBFE  
 425  434A 05E9         INCT    @>0066(R9)                      
 425  434C 0066  
 426  434E 045B         B       *R11                    
 427            *
 428            *---------------------------------------
 429            * Custom routines, dealing with VDP memory
 430            * Format is >pppr where r is routine number (0-3)
 431            * and ppp contains parameters
 432            * The workspace it >8300. Called by BLWP @>005A(9).
 433            *---------------------------------------                                        
 434            *
 435  4350 C28D ECUSTM  MOV     R13,R10                 save wregs ptr
 436  4352 C23E         MOV     *R14+,R8                get next data word
 437  4354 C248         MOV     R8,R9                   save it
 438  4356 0949         SRL     R9,4                    keep parameter
 439  4358 0248         ANDI    R8,3                    four possible operations
 439  435A 0003  
 440  435C A208         A       R8,R8                   make it a word ptr
 441  435E C2ED         MOV     @>001E(R13),R11         get old R15, i.e. VDP port (>8C02)
 441  4360 001E  
 442  4362 C228         MOV     @VECRTN(R8),R8          get vector for operation
 442  4364 4368  
 443  4366 0458         B       *R8                     branch to it
 444            *                                       
 445  4368 4370 VECRTN  DATA    SVRVDP                  save registers to VDP stack
 446  436A 439C         DATA    RVRVDP                  retrieve registers
 447  436C 43D2         DATA    SVDPRD                  set VDP address to read
 448  436E 43C8         DATA    SVDPWR                  set VDP address to write
 449            *                                       
 450  4370 022A SVRVDP  AI      R10,22                  0: save registers in VDP mem
 450  4372 0016  
 451  4374 0919 H072    SRL     R9,1                    start with R12
 452  4376 1710         JNC     H070                    bits in >ppp tell which register to save (R0-R11)
 453  4378 064C         DECT    R12                     previous address in VDP stack (grows down)
 454  437A C21A         MOV     *R10,R8                 get register contents
 455  437C 06CC         SWPB    R12                     set VDP address to write
 456  437E D6CC         MOVB    R12,*R11                R12 is >8366: VDP stack ptr
 457  4380 06CC         SWPB    R12                     
 458  4382 026C         ORI     R12,>4000                       
 458  4384 4000  
 459  4386 D6CC         MOVB    R12,*R11                        
 460  4388 06C8         SWPB    R8                      save register to VDP mem
 461  438A DAC8         MOVB    R8,@-2(R11)                     
 461  438C FFFE  
 462  438E 06C8         SWPB    R8                      
 463  4390 DAC8         MOVB    R8,@-2(R11)                     
 463  4392 FFFE  
 464  4394 C249         MOV     R9,R9                   more to come?
 465  4396 1317         JEQ     H071                    no:return
 466  4398 064A H070    DECT    R10                     point to previous register
 467  439A 10EC         JMP     H072                    
 468            *                               
 469  439C 0A49 RVRVDP  SLA     R9,4                    1: retrieve registers from VDP mem
 470  439E 0A19 H074    SLA     R9,1                    each bit tells whether to load
 471  43A0 1710         JNC     H073                    don't retrieve that one
 472  43A2 06CC         SWPB    R12                     set VDP address to read
 473  43A4 D6CC         MOVB    R12,*R11                R12 is >8366: VDP stack ptr
 474  43A6 06CC         SWPB    R12                     
 475  43A8 024C         ANDI    R12,>3FFF                       
 475  43AA 3FFF  
 476  43AC D6CC         MOVB    R12,*R11                        
 477  43AE 1000         NOP                             
 478  43B0 D22B         MOVB    @-1026(R11),R8          get a 2-byte value from VDP
 478  43B2 FBFE  
 479  43B4 06C8         SWPB    R8                      
 480  43B6 D22B         MOVB    @-1026(R11),R8                  
 480  43B8 FBFE  
 481  43BA C688         MOV     R8,*R10                 save it to register
 482  43BC 05CC         INCT    R12                     increment ptr (stack grows downwards)
 483  43BE C249         MOV     R9,R9                   more to come?
 484  43C0 1302         JEQ     H071                    no: return
 485  43C2 05CA H073    INCT    R10                     next register
 486  43C4 10EC         JMP     H074                    
 487  43C6 0380 H071    RTWP                            
 488            *                                       
 489  43C8 A24D SVDPWR  A       R13,R9                  2: set VDP for a write
 490  43CA C219         MOV     *R9,R8                  
 491  43CC 0268         ORI     R8,>4000                get address from reg in >..p2 (*2)
 491  43CE 4000  
 492  43D0 1004         JMP     H075                    
 493            *                                       
 494  43D2 A24D SVDPRD  A       R13,R9                  3: set VDP for a read
 495  43D4 C219         MOV     *R9,R8
 496  43D6 0248         ANDI    R8,>3FFF                get register from reg in >..p3 (*2)
 496  43D8 3FFF  
 497  43DA 06C8 H075    SWPB    R8                      set VDP address
 498  43DC D6C8         MOVB    R8,*R11                 
 499  43DE 06C8         SWPB    R8                      
 500  43E0 D6C8         MOVB    R8,*R11                 
 501  43E2 0380         RTWP                            
 502            *
 503            *---------------------------------------
 504            * Preparation subroutine
 505            * Sets up the 4 custom subroutines
 506            * Gets a few pointers to VDP buffers
 507            *  >8358: copy of VIB  >8366: VDP stack ptr (grows down from drive info)
 508            *  >8354: PAB          >8356: ptr to end-of-buffer
 509            *---------------------------------------                                        
 510            *
 511  43E4 05C7 PRPFDO  INCT    R7                      stop scanning upon return
 512  43E6 C28B PRPRTN  MOV     R11,R10                 save return address
 513  43E8 02A9         STWP    R9                      get workspace (should be >83E0)
 514  43EA 0229         AI      R9,-224                 top of scratch/pad mem (>8300)
 514  43EC FF20  
 515  43EE 0200         LI      R0,ECUSTM               entry to 4 custom routines
 515  43F0 4350  
 516  43F2 CA40         MOV     R0,@>005C(R9)           put it in >835C
 516  43F4 005C  
 517  43F6 C009         MOV     R9,R0                   
 518  43F8 0220         AI      R0,>004E                workspace for these four (>834E)
 518  43FA 004E  
 519  43FC CA40         MOV     R0,@>005A(R9)           put it in >835A
 519  43FE 005A  
 520            *                                       
 521  4400 C229         MOV     @>0070(R9),R8           highest free address in VDP mem
 521  4402 0070  
 522  4404 05C8 H076    INCT    R8                      point to end-of-buffer word
 523  4406 06A0         BL      @VDPR2B                 read 2 bytes from VDP address R8, into R0
 523  4408 4836  
 524  440A C088         MOV     R8,R2                   save current R8
 525  440C C200         MOV     R0,R8                   get end-of-buffer word
 526  440E 0228         AI      R8,-266                 yes: point to volume information block
 526  4410 FEF6  
 527  4412 CA48         MOV     R8,@>0058(R9)           save it in >8358
 527  4414 0058  
 528  4416 0228         AI      R8,-10                  point to disk drive info (drive #, last tracks)
 528  4418 FFF6  
 529  441A CA48         MOV     R8,@>0066(R9)           save in >8366: VDP stack ptr (DECT before writing)
 529  441C 0066  
 530  441E 0429         BLWP    @>005A(R9)              save R7 (return address)
 530  4420 005A  
 531  4422 0100         DATA    >0100                   
 532  4424 C1E9         MOV     @>0056(R9),R7           ptr to PAB: end of DSR name
 532  4426 0056  
 533  4428 C0C7         MOV     R7,R3                   save it
 534  442A 61E9         S       @>0054(R9),R7           start of DSR name
 534  442C 0054  
 535  442E CA42         MOV     R2,@>0056(R9)           >8356: ptr to end-of-buffer word in VDP mem
 535  4430 0056  
 536  4432 0607         DEC     R7                      point to name length byte
 537  4434 04C2         CLR     R2                      
 538  4436 0429         BLWP    @>005A(R9)              set VDP to read from address in R2
 538  4438 005A  
 539  443A 00E2         DATA    >00E2                   
 540  443C D0AF         MOVB    @-1026(R15),R2          get name length byte
 540  443E FBFE  
 541  4440 06C2         SWPB    R2                      make it a word
 542  4442 60A9         S       @>0054(R9),R2           minus DSR name size: lenght of .parameters
 542  4444 0054  
 543  4446 0227         AI      R7,-9                   point to top of PAB
 543  4448 FFF7  
 544  444A CA47         MOV     R7,@>0054(R9)           save it in >8354
 544  444C 0054  
 545  444E 045A         B       *R10                    
 546            *                               
 547  4450 06A0 CRFIL1  BL      @CALSUB                 create file
 547  4452 4318  
 548  4454 4AC2         DATA    FNDFDR                  find a FDR in disk
 549  4456 C104 CRFIL2  MOV     R4,R4                   found?
 550  4458 1604         JNE     CRFIL3                  no
 551  445A 06A0         BL      @CALSUB                 yes: delete old file
 551  445C 4318  
 552  445E 459A         DATA    FFSVIB                  free file sector in VIB bitmap
 553  4460 1045         JMP     H077                    clear its FDR
 554            *                               
 555  4462 06A0 CRFIL3  BL      @INSFDR                 new file: insert a FDR in sector 1
 555  4464 47CA  
 556  4466 0701         SETO    R1                      
 557  4468 06A0         BL      @CALSUB                 call subroutine
 557  446A 4318  
 558  446C 4BB6         DATA    FFSBMP                  find a free sector in VIB bitmap
 559  446E C000         MOV     R0,R0                   found?
 560  4470 1603         JNE     H078                    yes: # in R0
 561  4472 06A0         BL      @ERROR5                 no: update data, then return with error
 561  4474 4932  
 562  4476 8000         DATA    >8000                   memory full
 563            *                               
 564  4478 0429 H078    BLWP    @>005A(R9)              set VDP to write
 564  447A 005A  
 565  447C 0103         DATA    >0103                   address in R8
 566  447E DBC0         MOVB    R0,@-2(R15)             write sector # for FDR in sector 1
 566  4480 FFFE  
 567  4482 06C0         SWPB    R0                      
 568  4484 DBC0         MOVB    R0,@-2(R15)                     
 568  4486 FFFE  
 569  4488 06C0         SWPB    R0                      
 570  448A C069         MOV     @>0056(R9),R1           ptr to FDR in VDP buffers
 570  448C 0056  
 571  448E 0221         AI      R1,-4                   ptr to sector # for FDR
 571  4490 FFFC  
 572  4492 0429         BLWP    @>005A(R9)              set VDP to write
 572  4494 005A  
 573  4496 0023         DATA    >0023                   address in R1
 574  4498 DBC0         MOVB    R0,@-2(R15)             write sector # for FDR in VDP buffer
 574  449A FFFE  
 575  449C 06C0         SWPB    R0                      
 576  449E DBC0         MOVB    R0,@-2(R15)                     
 576  44A0 FFFE  
 577  44A2 0221         AI      R1,3                    ptr to drive #
 577  44A4 0003  
 578  44A6 0429         BLWP    @>005A(R9)              set VDP to write
 578  44A8 005A  
 579  44AA 0023         DATA    >0023                   address in R1
 580  44AC DBC6         MOVB    R6,@-2(R15)             write drive # before FDR in VDP buffer
 580  44AE FFFE  
 581  44B0 04C2         CLR     R2                      code for write
 582  44B2 0581         INC     R1                      
 583  44B4 06A0         BL      @CALSUB                 call subroutine
 583  44B6 4318  
 584  44B8 49F6         DATA    WRSEC1                  write sector 1
 585  44BA C169         MOV     @>0058(R9),R5           ptr to VIB in VDP buffers
 585  44BC 0058  
 586  44BE 04C4         CLR     R4                      sector 0
 587  44C0 06A0         BL      @CALSUB                 call subroutine
 587  44C2 4318  
 588  44C4 4A0E         DATA    RWSEC                   write VIB to sector 0
 589  44C6 C0C5         MOV     R5,R3                   copy filename from compare buffer to FDR
 590  44C8 0223         AI      R3,257                  ptr to file compare buffer
 590  44CA 0101  
 591  44CC 0202         LI      R2,10                   10 chars per filename
 591  44CE 000A  
 592  44D0 0429 H079    BLWP    @>005A(R9)              set VDP to read
 592  44D2 005A  
 593  44D4 0062         DATA    >0062                   address in R3
 594  44D6 D02F         MOVB    @-1026(R15),R0          get 1 char
 594  44D8 FBFE  
 595  44DA 0583         INC     R3                      increment source ptr
 596  44DC 0429         BLWP    @>005A(R9)              set VDP to write
 596  44DE 005A  
 597  44E0 0023         DATA    >0023                   address in R1
 598  44E2 DBC0         MOVB    R0,@-2(R15)             copy 1 char
 598  44E4 FFFE  
 599  44E6 0581         INC     R1                      increment destination ptr
 600  44E8 0602         DEC     R2                      # of chars in R2
 601  44EA 16F2         JNE     H079                    next
 602            *
 603  44EC 06A0 H077    BL      @NTPDT                  APEDSK99: update DOAD FAT time/date
 603  44EE 5DF2  
 604            *
 605  44F0 C069         MOV     @>0056(R9),R1           FDR ptr
 605  44F2 0056  
 606  44F4 0221         AI      R1,10                   skip filename
 606  44F6 000A  
 607  44F8 0202         LI      R2,246                  remaining bytes in FDR
 607  44FA 00F6  
 608  44FC 0429         BLWP    @>005A(R9)              set VDP to write
 608  44FE 005A  
 609  4500 0023         DATA    >0023                   address in R1
 610  4502 DBC2 H080    MOVB    R2,@-2(R15)             write >00
 610  4504 FFFE  
 611  4506 0602         DEC     R2                      clear remainder of new FDR
 612  4508 16FC         JNE     H080                    next byte
 613  450A 1010         JMP     H081                    write FDR to disk return to caller
 614            *                                       
 615  450C C169 H082    MOV     @>0056(R9),R5           check if FDR must be updated
 615  450E 0056  
 616  4510 0429         BLWP    @>005A(R9)              set VDP to read
 616  4512 005A  
 617  4514 00A2         DATA    >00A2                   address in R5
 618  4516 D12F         MOVB    @-1026(R15),R4          get filename in file ctrl block
 618  4518 FBFE  
 619  451A 1101         JLT     H083                    flag: FDR was modified, update it
 620  451C 100A         JMP     H084                    
 621  451E 0244 H083    ANDI    R4,>7F00                clear flag bit
 621  4520 7F00  
 622  4522 0429         BLWP    @>005A(R9)              st VDP to write
 622  4524 005A  
 623  4526 00A3         DATA    >00A3                   address in R5
 624  4528 DBC4         MOVB    R4,@-2(R15)             write back filename without flag bit
 624  452A FFFE  
 625  452C 04C2 H081    CLR     R2                      code for write
 626  452E 0460         B       @WRFDR                  write FDR to disk
 626  4530 4A00  
 627  4532 0460 H084    B       @RTURN1                 return to caller
 627  4534 4336  
 628            *                               
 629  4536 06A0 UPDFDR  BL      @CALSUB                 update FDR + data
 629  4538 4318  
 630  453A 4556         DATA    UPDBF                   update data buffer if necessary
 631  453C 06A0         BL      @CALSUB                 call subroutine
 631  453E 4318  
 632  4540 450C         DATA    H082                    update FDR if necessary
 633  4542 C169 CLRFBT  MOV     @>0056(R9),R5                   
 633  4544 0056  
 634  4546 04C6         CLR     R6                      
 635  4548 0429         BLWP    @>005A(R9)              set VDP to write
 635  454A 005A  
 636  454C 00A3         DATA    >00A3                   address in R5
 637  454E DBC6         MOVB    R6,@-2(R15)             clr first byte of filename in FDR
 637  4550 FFFE  
 638  4552 0460         B       @RWVIB                  
 638  4554 4992  
 639            *                                       
 640  4556 C129 UPDBF   MOV     @>0056(R9),R4           check if data buffer must be updated
 640  4558 0056  
 641  455A 0604         DEC     R4                      
 642  455C 0429         BLWP    @>005A(R9)              set VDP to read
 642  455E 005A  
 643  4560 0082         DATA    >0082                   address in R4
 644  4562 D06F         MOVB    @-1026(R15),R1          get drive #
 644  4564 FBFE  
 645  4566 1101         JLT     H085                    flag: must be updated
 646  4568 1016         JMP     H086                    no need to update: return
 647  456A 0241 H085    ANDI    R1,>7F00                erase flag
 647  456C 7F00  
 648  456E 0429         BLWP    @>005A(R9)              set VDP to write
 648  4570 005A  
 649  4572 0083         DATA    >0083                   address in R4
 650  4574 DBC1         MOVB    R1,@-2(R15)             write back drive # without flag
 650  4576 FFFE  
 651  4578 0224         AI      R4,-5                   point to current logical record offset
 651  457A FFFB  
 652  457C 0429         BLWP    @>005A(R9)              set VDP to read
 652  457E 005A  
 653  4580 0082         DATA    >0082                   address in R4
 654  4582 D0EF         MOVB    @-1026(R15),R3          get current logical record offset
 654  4584 FBFE  
 655  4586 06C3         SWPB    R3                      
 656  4588 D0EF         MOVB    @-1026(R15),R3                  
 656  458A FBFE  
 657  458C 06C3         SWPB    R3                      
 658  458E C1C4         MOV     R4,R7                   
 659  4590 0227         AI      R7,262                  point to data buffer area
 659  4592 0106  
 660  4594 103A         JMP     WROFSC                  
 661  4596 0460 H086    B       @RTURN1                 return to caller
 661  4598 4336  
 662            *                               
 663  459A C0A9 FFSVIB  MOV     @>0056(R9),R2           free file sectors in VIB bitmap
 663  459C 0056  
 664  459E 0222         AI      R2,12                   
 664  45A0 000C  
 665  45A2 0429         BLWP    @>005A(R9)              set VDP to read
 665  45A4 005A  
 666  45A6 0042         DATA    >0042                   address in R2
 667  45A8 D02F         MOVB    @-1026(R15),R0          get file status byte from FDR
 667  45AA FBFE  
 668  45AC 0240         ANDI    R0,>0800                write protected?
 668  45AE 0800  
 669  45B0 1303         JEQ     H087                    no
 670  45B2 06A0         BL      @ERROR5                 update data if needed, the return with error
 670  45B4 4932  
 671  45B6 2000         DATA    >2000                   write protected
 672            *                                       
 673  45B8 C229 H087    MOV     @>0056(R9),R8           get ptr to FDR
 673  45BA 0056  
 674  45BC 0228         AI      R8,28                   point to clusters list
 674  45BE 001C  
 675  45C0 0704         SETO    R4                      previous offset
 676  45C2 06A0 H089    BL      @DECDCI                 decode cluster info: sector in R1, offset in R2
 676  45C4 4B76  
 677  45C6 0228         AI      R8,3                    next cluster ptr
 677  45C8 0003  
 678  45CA C041         MOV     R1,R1                   
 679  45CC 130C         JEQ     H088                    sector 0 = no more clusters
 680  45CE C002         MOV     R2,R0                   total offset
 681  45D0 6084         S       R4,R2                   minus previous cluster offset = cluster size
 682  45D2 C100         MOV     R0,R4                   new previous cluster offset
 683  45D4 06A0         BL      @CALSUB                 call subroutine
 683  45D6 4318  
 684  45D8 4C82         DATA    FRSCB1                  free sectors in bitmap (from R1, # in R2)
 685  45DA C048         MOV     R8,R1                   
 686  45DC 6069         S       @>0056(R9),R1                   
 686  45DE 0056  
 687  45E0 0281         CI      R1,>0100                end of FDR reached?
 687  45E2 0100  
 688  45E4 16EE         JNE     H089                    not yet
 689  45E6 0460 H088    B       @RTURN1                 return to caller
 689  45E8 4336  
 690            *                                       
 691  45EA 06A0 RDOFSC  BL      @FDR2B1                 read a sector from offset in file
 691  45EC 4830  
 692  45EE 000E         DATA    14                      get # of sectors
 693  45F0 80C0         C       R0,R3                   is desired sector in file?
 694  45F2 1B03         JH      H090                    yes
 695  45F4 06A0         BL      @ERROR5                 no: update data, then return with error
 695  45F6 4932  
 696  45F8 A000         DATA    >A000                   past end-of-file
 697  45FA 06A0 H090    BL      @CALSUB                 call subroutine
 697  45FC 4318  
 698  45FE 470A         DATA    FSCTOF                  find sector from cluster list
 699  4600 A101         A       R1,R4                   put sector in R4
 700  4602 0702         SETO    R2                      code for read
 701  4604 C147 H091    MOV     R7,R5                   buffer ptr
 702  4606 0460         B       @RWSEC                  read/write sector
 702  4608 4A0E  
 703            *                                       
 704  460A 0429 WROFSC  BLWP    @>005A(R9)              write sector to offset in file offset in R3
 704  460C 005A  
 705  460E 8100         DATA    >8100                   save R0 and R7
 706  4610 06A0         BL      @CALSUB                 call subroutine
 706  4612 4318  
 707  4614 4620         DATA    APSCTS                  append enough sectors to reach that offset
 708  4616 0429         BLWP    @>005A(R9)              retrieve R0 and R7
 708  4618 005A  
 709  461A 8101         DATA    >8101                   
 710  461C 04C2         CLR     R2                      code for write
 711  461E 10F2         JMP     H091                    write sector
 712            *                               
 713  4620 06A0 APSCTS  BL      @FDR2B1                 append sector(s) to a file to get offset in R3
 713  4622 4830  
 714  4624 000E         DATA    14                      get # of sect from FDR
 715            *                                       
 716  4626 80C0         C       R0,R3                   is desired sector in file?
 717  4628 1B47         JH      H092                    yes: find it and return
 718  462A C000         MOV     R0,R0                   
 719  462C 1301         JEQ     H093                    empty file
 720  462E 0600         DEC     R0                      last sector #
 721  4630 C143 H093    MOV     R3,R5                   save desired sector offset
 722  4632 C0C0         MOV     R0,R3                   last sector in file
 723  4634 06A0         BL      @CALSUB                 call subroutine
 723  4636 4318  
 724  4638 470A         DATA    FSCTOF                  find sector # from offset in file
 725  463A 0429         BLWP    @>005A(R9)              save R1 (sector #)
 725  463C 005A  
 726  463E 4000         DATA    >4000                   
 727  4640 A044         A       R4,R1                   # of last sector in cluster
 728  4642 C105         MOV     R5,R4                   offset of desired sector
 729  4644 06A0 H095    BL      @CALSUB                 call subroutine
 729  4646 4318  
 730  4648 4BB6         DATA    FFSBMP                  find free sector in bitmap, starting from R1
 731  464A C000         MOV     R0,R0                   found?
 732  464C 1604         JNE     H094                    yes: # in R0
 733  464E C142         MOV     R2,R5                   no: save # of sectors
 734  4650 06A0         BL      @ADDSEC                 update FDR
 734  4652 46C4  
 735  4654 101B         JMP     H096                    return with memory full
 736            *                                       
 737  4656 C041 H094    MOV     R1,R1                   
 738  4658 1320         JEQ     H097                    empty cluster
 739  465A 0581         INC     R1                      one more sector in cluster
 740  465C 8040         C       R0,R1                   same as the one found in bitmap?
 741  465E 131C         JEQ     H098                    yes: just increase cluster size
 742  4660 0429         BLWP    @>005A(R9)              no: retrieve R1 (sector #)
 742  4662 005A  
 743  4664 4001         DATA    >4001                   
 744  4666 0429         BLWP    @>005A(R9)              save R0 + R2
 744  4668 005A  
 745  466A A000         DATA    >A000                   
 746  466C 06A0         BL      @UPDCLI                 update current cluster info
 746  466E 4B92  
 747  4670 0429         BLWP    @>005A(R9)              retrieve R0 + R2
 747  4672 005A  
 748  4674 A001         DATA    >A001                   
 749  4676 0228         AI      R8,3                    ptr to next cluster info
 749  4678 0003  
 750  467A C048         MOV     R8,R1                   
 751  467C 6069         S       @>0056(R9),R1           current FDR size
 751  467E 0056  
 752  4680 0281         CI      R1,>0100                room enough?
 752  4682 0100  
 753  4684 1605         JNE     H099                    yes
 754  4686 06A0         BL      @CALSUB                 no: call subroutine
 754  4688 4318  
 755  468A 4C7C         DATA    FFSBM                   free sector in bitmap
 756  468C 0460 H096    B       @ERROR6                 return with memory full
 756  468E 4AE8  
 757            *                                       
 758  4690 C040 H099    MOV     R0,R1                   new sector #
 759  4692 0429         BLWP    @>005A(R9)              save R1
 759  4694 005A  
 760  4696 4000         DATA    >4000                   
 761  4698 1007 H098    JMP     H100                    make a new cluster
 762            *                                       
 763  469A 0429 H097    BLWP    @>005A(R9)              retrieve R1
 763  469C 005A  
 764  469E 4001         DATA    >4001                   
 765  46A0 0429         BLWP    @>005A(R9)              save R0
 765  46A2 005A  
 766  46A4 8000         DATA    >8000                   
 767  46A6 0702         SETO    R2                      empty file: start from offset 0
 768  46A8 C040 H100    MOV     R0,R1                   sector #
 769  46AA 0582         INC     R2                      increment cluster size
 770  46AC 8102         C       R2,R4                   enough?
 771  46AE 16CA         JNE     H095                    no: get one more sector
 772  46B0 C144         MOV     R4,R5                   
 773  46B2 06A0         BL      @ADDSEC                 add sector to FDR
 773  46B4 46C4  
 774  46B6 1004         JMP     H101                    done
 775            *                               
 776  46B8 06A0 H092    BL      @CALSUB                 call subroutine
 776  46BA 4318  
 777  46BC 470A         DATA    FSCTOF                  find a sector from offset in file
 778  46BE A101         A       R1,R4                   last sector in cluster
 779  46C0 0460 H101    B       @RTURN1                 return to caller
 779  46C2 4336  
 780            *                                       
 781  46C4 C28B ADDSEC  MOV     R11,R10                 add sector to FDR
 782  46C6 C101         MOV     R1,R4                   
 783  46C8 0429         BLWP    @>005A(R9)              retrieve R1
 783  46CA 005A  
 784  46CC 4001         DATA    >4001                   
 785  46CE C041         MOV     R1,R1                   sector #
 786  46D0 131B         JEQ     H102                    none: return
 787  46D2 06A0         BL      @UPDCLI                 write info for R1 cluster
 787  46D4 4B92  
 788  46D6 C0A9         MOV     @>0056(R9),R2           pointer to FDR
 788  46D8 0056  
 789  46DA 0429         BLWP    @>005A(R9)              set VDP to read
 789  46DC 005A  
 790  46DE 0042         DATA    >0042                   address in R2
 791  46E0 D06F         MOVB    @-1026(R15),R1          first char of filename
 791  46E2 FBFE  
 792  46E4 0261         ORI     R1,>8000                flag
 792  46E6 8000  
 793  46E8 0429         BLWP    @>005A(R9)              set VDP to write
 793  46EA 005A  
 794  46EC 0043         DATA    >0043                   address in R2
 795  46EE DBC1         MOVB    R1,@-2(R15)                     
 795  46F0 FFFE  
 796  46F2 0222         AI      R2,14                   ptr to # of sectors
 796  46F4 000E  
 797  46F6 0585         INC     R5                      new # of sectors
 798  46F8 0429         BLWP    @>005A(R9)              set VDP to write
 798  46FA 005A  
 799  46FC 0043         DATA    >0043                   address in R2
 800  46FE DBC5         MOVB    R5,@-2(R15)             update # of sectors
 800  4700 FFFE  
 801  4702 06C5         SWPB    R5                      
 802  4704 DBC5         MOVB    R5,@-2(R15)                     
 802  4706 FFFE  
 803  4708 045A H102    B       *R10                    
 804            *                                       
 805  470A C229 FSCTOF  MOV     @>0056(R9),R8           find sector from offset in file
 805  470C 0056  
 806  470E 0228         AI      R8,28                   cluster list
 806  4710 001C  
 807  4712 C103         MOV     R3,R4                   desired sector offset is in R3
 808  4714 06A0 H105    BL      @DECDCI                 decode info: sector in R1, offset in R2
 808  4716 4B76  
 809  4718 80C2         C       R2,R3                   reached yet?
 810  471A 1101         JLT     H103                    no
 811  471C 1006         JMP     H104                    yes: return
 812  471E 0228 H103    AI      R8,3                    point to next cluster info
 812  4720 0003  
 813  4722 C103         MOV     R3,R4                   
 814  4724 6102         S       R2,R4                   
 815  4726 0604         DEC     R4                      size of the desired cluster (if it's the next)
 816  4728 10F5         JMP     H105                    keep trying
 817  472A 0460 H104    B       @RTURN1                 return to caller
 817  472C 4336  
 818            *
 819            *---------------------------------
 820            * Opcode 7: Delete
 821            * ----------------
 822            * PAB 0: >07
 823            *     1:            <--- error code
 824            *   2-3:
 825            *     4:
 826            *     5:
 827            *   6-7:
 828            *     8:
 829            *---------------------------------                                      
 830            *
 831  472E 06A0 DELETE  BL      @CALSUB                 delete file
 831  4730 4318  
 832  4732 4A64         DATA    FFFDRV                  find file FDR in VDP buffers
 833  4734 C104         MOV     R4,R4                   found?
 834  4736 1307         JEQ     H106                    yes
 835  4738 06A0         BL      @CALSUB                 no: call subroutine
 835  473A 4318  
 836  473C 4ACC         DATA    FFDRDK                  find FDR on disk
 837  473E C104         MOV     R4,R4                   found?
 838  4740 1313         JEQ     H107                    yes
 839  4742 0460         B       @RTURN1                 no: return to caller
 839  4744 4336  
 840            *                                       
 841  4746 0581 H106    INC     R1                      FDR found, point to it
 842  4748 CA41         MOV     R1,@>0056(R9)           save it for other routines
 842  474A 0056  
 843  474C 06A0         BL      @CALSUB                 call subroutine
 843  474E 4318  
 844  4750 49F4         DATA    RDSEC1                  read sector 1
 845  4752 06A0         BL      @FDR2B1                 read 2 bytes from VDP at >8356+offset
 845  4754 4830  
 846  4756 FFFC         DATA    -4                      i.e. get sector # of FRD in R0
 847  4758 C0C0         MOV     R0,R3                   save it for later
 848  475A C205         MOV     R5,R8                   ptr to top of sector 1
 849  475C 06A0 H108    BL      @VDPR2B                 read 2 bytes from VDP at R8 into R0
 849  475E 4836  
 850  4760 05C8         INCT    R8                      next FDR ptr in sector 1
 851  4762 80C0         C       R0,R3                   is this the one we want?
 852  4764 16FB         JNE     H108                    not yet
 853  4766 0648         DECT    R8                      yes: point back to it
 854            *
 855  4768 06A0 H107    BL      @NTPDT                  APEDSK99: update DOAD FAT time/date
 855  476A 5DF2  
 856            *
 857  476C 0429         BLWP    @>005A(R9)              save R8
 857  476E 005A  
 858  4770 0080         DATA    >0080                   
 859  4772 06A0         BL      @CALSUB                 call subroutine
 859  4774 4318  
 860  4776 459A         DATA    FFSVIB                  free file sectors in VIB bitmap
 861  4778 0429         BLWP    @>005A(R9)              retrieve R8
 861  477A 005A  
 862  477C 0081         DATA    >0081                   
 863  477E 06A0         BL      @RMFPTR                 remove FDR ptr from sector 1
 863  4780 479A  
 864  4782 04C2         CLR     R2                      code for write
 865  4784 06A0         BL      @CALSUB                 call subroutine
 865  4786 4318  
 866  4788 49F6         DATA    WRSEC1                  write sector 1
 867  478A 06A0         BL      @FDR2B1                 get 2 bytes from VDP at >8356+offset in R0
 867  478C 4830  
 868  478E FFFC         DATA    -4                      i.e. sector # of FDR
 869  4790 06A0         BL      @CALSUB                 call subroutine
 869  4792 4318  
 870  4794 4C7C         DATA    FFSBM                   free sector in R0 in VIB bitmap
 871  4796 0460         B       @CLRFBT                 clear 1rst byte of filename in VDP
 871  4798 4542  
 872            *
 873            * Sector 1 contains an alphabetically sorted list of FDR pointers
 874            * Each pointer is 2 bytes long and contains the sector # of this FDR
 875            * The list must end with a >0000 mark. Thus there can be 127 files at most
 876            *
 877  479A C169 RMFPTR  MOV     @>0056(R9),R5           remove FDR ptr from sector 1
 877  479C 0056  
 878  479E 0225         AI      R5,256                  
 878  47A0 0100  
 879  47A2 C0C5         MOV     R5,R3                   pointer to data buffer
 880  47A4 0223         AI      R3,256                  point to next ctrl block
 880  47A6 0100  
 881  47A8 C088         MOV     R8,R2                   shift up FDR list, erasing FDR pointed by R8
 882  47AA 05C2         INCT    R2                      point to next FDR ptr in sector 1
 883  47AC 0429 H109    BLWP    @>005A(R9)              set VDP to read
 883  47AE 005A  
 884  47B0 0042         DATA    >0042                   address in R2
 885  47B2 D02F         MOVB    @-1026(R15),R0          get 1 byte
 885  47B4 FBFE  
 886  47B6 0582         INC     R2                      inc source ptr
 887  47B8 0429         BLWP    @>005A(R9)              set VDP to write
 887  47BA 005A  
 888  47BC 0103         DATA    >0103                   address in R8
 889  47BE DBC0         MOVB    R0,@-2(R15)             copy 1 byte
 889  47C0 FFFE  
 890  47C2 0588         INC     R8                      inc dest pointer
 891  47C4 80C2         C       R2,R3                   done?
 892  47C6 16F2         JNE     H109                    not yet
 893  47C8 045B         B       *R11                    
 894            *                                       
 895  47CA C28B INSFDR  MOV     R11,R10                 insert a FDR in sector 1
 896  47CC C048         MOV     R8,R1                   
 897  47CE 06A0         BL      @FDR2B1                 get 2 bytes from VDP at >8356+offset
 897  47D0 4830  
 898  47D2 01FC         DATA    508                     i.e. last FDR slot in sector 1 (list ends with 0)
 899  47D4 C000         MOV     R0,R0                   
 900  47D6 1302         JEQ     H110                    
 901  47D8 0460         B       @ERROR6                 memory full error
 901  47DA 4AE8  
 902  47DC 0608 H110    DEC     R8                      previous byte
 903  47DE 0429         BLWP    @>005A(R9)              set VDP to read
 903  47E0 005A  
 904  47E2 0102         DATA    >0102                   address in R8
 905  47E4 D02F         MOVB    @-1026(R15),R0          get 1 byte
 905  47E6 FBFE  
 906  47E8 05C8         INCT    R8                      
 907  47EA 0429         BLWP    @>005A(R9)              set VDP to write
 907  47EC 005A  
 908  47EE 0103         DATA    >0103                   address in R8
 909  47F0 DBC0         MOVB    R0,@-2(R15)             copy byte two bytes further down
 909  47F2 FFFE  
 910  47F4 0648         DECT    R8                      
 911  47F6 8048         C       R8,R1                   done ?
 912  47F8 16F1         JNE     H110                    not yet
 913  47FA 045A         B       *R10                    
 914            *                               
 915  47FC C0A9 CMPFN   MOV     @>0058(R9),R2           compare filenames
 915  47FE 0058  
 916  4800 0222         AI      R2,256                  
 916  4802 0100  
 917  4804 0429 H111    BLWP    @>005A(R9)              set VDP to read
 917  4806 005A  
 918  4808 0022         DATA    >0022                   address in R1 (ptr to filename)
 919  480A D02F         MOVB    @-1026(R15),R0          get 1 char
 919  480C FBFE  
 920  480E 0240         ANDI    R0,>7FFF                clear flag (on drive #)
 920  4810 7FFF  
 921  4812 0429         BLWP    @>005A(R9)              set VDP to read
 921  4814 005A  
 922  4816 0042         DATA    >0042                   address in R2 (filename compare buffer)
 923  4818 D0EF         MOVB    @-1026(R15),R3          get 1 char
 923  481A FBFE  
 924  481C 90C0         CB      R0,R3                   compare chars
 925  481E 1604         JNE     H112                    mismatch
 926  4820 0581         INC     R1                      match: increment pointers
 927  4822 0582         INC     R2                      
 928  4824 0604         DEC     R4                      
 929  4826 16EE         JNE     H111                    next char
 930  4828 045B H112    B       *R11                    if complete match: ret with EQ set
 931            *                                       
 932  482A C229 PABR2B  MOV     @>0054(R9),R8           get two bytes from PAB
 932  482C 0054  
 933  482E 1002         JMP     FDR2B2                  
 934            *                                       
 935  4830 C229 FDR2B1  MOV     @>0056(R9),R8           get two bytes from FDR
 935  4832 0056  
 936  4834 A23B FDR2B2  A       *R11+,R8                offset in data word
 937            *                                       
 938  4836 0429 VDPR2B  BLWP    @>005A(R9)              get two byte from VDP at R8
 938  4838 005A  
 939  483A 0102         DATA    >0102                   set VDP to read at R8
 940  483C D02F         MOVB    @-1026(R15),R0          get two bytes of data
 940  483E FBFE  
 941  4840 06C0         SWPB    R0                      
 942  4842 D02F         MOVB    @-1026(R15),R0                  
 942  4844 FBFE  
 943  4846 0B80         SRC     R0,8                    why not swpb ?
 944  4848 045B         B       *R11                    
 945            *                       
 946  484A C069 FDSKDR  MOV     @>0058(R9),R1           find disk from name (ptr in R3)
 946  484C 0058  
 947  484E 0221         AI      R1,256                  
 947  4850 0100  
 948  4852 06A0         BL      @CPCKFN                 copy filename from VDP at R3 to compare buffer
 948  4854 48D4  
 949  4856 0429         BLWP    @>005A(R9)              save R2 + R3
 949  4858 005A  
 950  485A 3000         DATA    >3000                   
 951  485C C000         MOV     R0,R0                   last char copied
 952  485E 1101         JLT     H113                    flagged
 953  4860 1005         JMP     H114                    
 954  4862 C180 H113    MOV     R0,R6                   
 955  4864 0246         ANDI    R6,>0300                        
 955  4866 0300  
 956  4868 1337         JEQ     ERROR7                  return with file error
 957  486A 102F         JMP     H115                    return to caller
 958  486C 04C6 H114    CLR     R6                      don't read any drive
 959  486E 06A0         BL      @CALSUB                 call subroutine
 959  4870 4318  
 960  4872 4992         DATA    RWVIB                   save current VIB
 961  4874 0226 H116    AI      R6,>0100                next drive
 961  4876 0100  
 962  4878 0707         SETO    R7                      error flags
 963  487A 0702         SETO    R2                      code for read
 964  487C 04C4         CLR     R4                      sector 0
 965  487E 06A0         BL      @CALSUB                 call subroutine
 965  4880 4318  
 966  4882 4A10         DATA    RWSECA                  read sector 0
 967  4884 C1C7         MOV     R7,R7                   ok?
 968  4886 161D         JNE     H118                    no: try next drive
 969  4888 0204         LI      R4,10                   yes: diskname size
 969  488A 000A  
 970  488C C069         MOV     @>0058(R9),R1           VIB ptr
 970  488E 0058  
 971  4890 0429         BLWP    @>005A(R9)              save R1-R3
 971  4892 005A  
 972  4894 7000         DATA    >7000                   
 973  4896 06A0         BL      @CMPFN                  compare names (ptr in R1 + compare buffer)
 973  4898 47FC  
 974  489A 0429         BLWP    @>005A(R9)                      
 974  489C 005A  
 975  489E 7001         DATA    >7001                   retrieve R1-R3
 976  48A0 C104         MOV     R4,R4                   name matched?
 977  48A2 160F         JNE     H118                    no: try next drive
 978  48A4 C006         MOV     R6,R0                   drive #
 979  48A6 0260         ORI     R0,>8000                add update flag
 979  48A8 8000  
 980  48AA 0429         BLWP    @>005A(R9)              set VDP to write
 980  48AC 005A  
 981  48AE 0063         DATA    >0063                   address in R3
 982  48B0 DBC0         MOVB    R0,@-2(R15)             copy drive+flag before diskname in source
 982  48B2 FFFE  
 983  48B4 0605         DEC     R5                      before sector 0 copy
 984  48B6 0429         BLWP    @>005A(R9)              set VDP to write
 984  48B8 005A  
 985  48BA 00A3         DATA    >00A3                   address in R5
 986  48BC DBC6         MOVB    R6,@-2(R15)             copy drive # before VIB
 986  48BE FFFE  
 987  48C0 1004         JMP     H115                    done
 988            *                               
 989  48C2 0286 H118    CI      R6,>0300                did we do all drives?
 989  48C4 0300  
 990  48C6 16D6         JNE     H116                    no: try next on
 991  48C8 1007         JMP     ERROR7                  return with file error
 992            *                                       
 993  48CA 0429 H115    BLWP    @>005A(R9)              retrieve R2 + R3
 993  48CC 005A  
 994  48CE 3001         DATA    >3001                   
 995  48D0 0460         B       @RTURN1                 return to caller
 995  48D2 4336  
 996            *                               
 997  48D4 0602 CPCKFN  DEC     R2                      
 998  48D6 1B03         JH      H119                    
 999  48D8 06A0 ERROR7  BL      @RETERR                 return with error
 999  48DA 495E  
1000  48DC E000         DATA    >E000                   file error
1001            *                                       
1002  48DE 0200 H119    LI      R0,>2000                copy (+check) filename in VDP from R3 to R1 (space)
1002  48E0 2000  
1003  48E2 0429         BLWP    @>005A(R9)              set VDP to write
1003  48E4 005A  
1004  48E6 0023         DATA    >0023                   address in R1
1005  48E8 0208         LI      R8,10                   10 chars per filename
1005  48EA 000A  
1006  48EC DBC0 H120    MOVB    R0,@-2(R15)             fill filename with spaces
1006  48EE FFFE  
1007  48F0 0608         DEC     R8                      
1008  48F2 16FC         JNE     H120                    
1009  48F4 0208         LI      R8,11                   11 chars countring drive #
1009  48F6 000B  
1010  48F8 0583 H122    INC     R3                      increment source ptr
1011  48FA 0429         BLWP    @>005A(R9)              set VDP to read
1011  48FC 005A  
1012  48FE 0062         DATA    >0062                   address in R3
1013  4900 D02F         MOVB    @-1026(R15),R0          get a char
1013  4902 FBFE  
1014  4904 13E9         JEQ     ERROR7                  >00: return with file error
1015  4906 1110         JLT     H121                    flag bit set
1016  4908 0280         CI      R0,>2E00                        
1016  490A 2E00  
1017  490C 130D         JEQ     H121                    '.'
1018  490E 0608         DEC     R8                      
1019  4910 13E3         JEQ     ERROR7                  name to long: return with file error
1020  4912 0280         CI      R0,>2000                        
1020  4914 2000  
1021  4916 13E0         JEQ     ERROR7                  name can't contain spaces: file error again
1022  4918 0429         BLWP    @>005A(R9)              set VDP to write
1022  491A 005A  
1023  491C 0023         DATA    >0023                   address in R1
1024  491E DBC0         MOVB    R0,@-2(R15)             copy 1 char
1024  4920 FFFE  
1025  4922 0581         INC     R1                      increment destination pointer
1026  4924 0602         DEC     R2                      more?
1027  4926 16E8         JNE     H122                    yes
1028  4928 0288 H121    CI      R8,>000B                name can't be 0 chars long
1028  492A 000B  
1029  492C 13D5         JEQ     ERROR7                  else return with file error
1030  492E 045B         B       *R11                    
1031            *                                       
1032  4930 AA00 K014    DATA    >AA00                   
1033            *                               
1034  4932 C00B ERROR5  MOV     R11,R0                  update data, then error
1035  4934 C0E9         MOV     @>0056(R9),R3           
1035  4936 0056  
1036  4938 0603         DEC     R3                      see what >8356 is pointing at
1037  493A 0429         BLWP    @>005A(R9)              set VDP to read
1037  493C 005A  
1038  493E 0062         DATA    >0062                   address in R3
1039  4940 D0AF         MOVB    @-1026(R15),R2          get 1 byte
1039  4942 FBFE  
1040  4944 9802         CB      R2,@K014                is it >AA (disk buffer area mark)
1040  4946 4930  
1041  4948 1309         JEQ     H123                    yes: announce error (code in data word)
1042  494A 0429         BLWP    @>005A(R9)              no: >8356 points to a FDR. Save R0
1042  494C 005A  
1043  494E 8000         DATA    >8000                   
1044  4950 06A0         BL      @CALSUB                 call subroutine
1044  4952 4318  
1045  4954 4536         DATA    UPDFDR                  update FRD and data buffer if needed
1046  4956 0429         BLWP    @>005A(R9)              retrieve R0
1046  4958 005A  
1047  495A 8001         DATA    >8001                   
1048  495C C2C0 H123    MOV     R0,R11                  
1049            *                               
1050  495E C069 RETERR  MOV     @>0054(R9),R1           annouce error
1050  4960 0054  
1051  4962 130D         JEQ     H124                    no PAB
1052  4964 0581         INC     R1                      for DSRs: ptr to status byte
1053  4966 0429         BLWP    @>005A(R9)              set VDP to read
1053  4968 005A  
1054  496A 0022         DATA    >0022                   address in R2
1055  496C D0AF         MOVB    @-1026(R15),R2          get file status byte
1055  496E FBFE  
1056  4970 E0BB         SOC     *R11+,R2                add error code
1057  4972 0429         BLWP    @>005A(R9)              set VDP to write
1057  4974 005A  
1058  4976 0023         DATA    >0023                   address in R2
1059  4978 DBC2         MOVB    R2,@-2(R15)             write back status byte
1059  497A FFFE  
1060  497C 1002         JMP     H125                    
1061  497E CA7B H124    MOV     *R11+,@>0050(R9)        for subs: error code in >8350
1061  4980 0050  
1062  4982 C229 H125    MOV     @>0058(R9),R8           get stack ptr
1062  4984 0058  
1063  4986 0228         AI      R8,-12                  point back to initial caller
1063  4988 FFF4  
1064  498A CA48         MOV     R8,@>0066(R9)           update pointer
1064  498C 0066  
1065  498E 0460         B       @RTURN1                 return to caller
1065  4990 4336  
1066            *                               
1067  4992 0429 RWVIB   BLWP    @>005A(R9)              read VIB (drive # in R6)
1067  4994 005A  
1068  4996 3000         DATA    >3000                   save R2 + R3
1069  4998 C169         MOV     @>0058(R9),R5           pointer to VIB in ctrl block
1069  499A 0058  
1070  499C 0605         DEC     R5                      ptr to drive #
1071  499E 0429         BLWP    @>005A(R9)              set VDP for read
1071  49A0 005A  
1072  49A2 00A2         DATA    >00A2                   address in R5
1073  49A4 D0AF         MOVB    @-1026(R15),R2          get drive #
1073  49A6 FBFE  
1074  49A8 C0C2         MOV     R2,R3                   
1075  49AA 04C4         CLR     R4                      sector 0 for VIB
1076  49AC 0242         ANDI    R2,>0300                clear flag (>80 = update data)
1076  49AE 0300  
1077  49B0 9182         CB      R2,R6                   wanted drive?
1078  49B2 131A         JEQ     H126                    yes: return
1079  49B4 C0C3         MOV     R3,R3                   no: shall we update VIB?
1080  49B6 1101         JLT     H127                    yes
1081  49B8 100A         JMP     H128                    no
1082  49BA 0429 H127    BLWP    @>005A(R9)              set VDP to write
1082  49BC 005A  
1083  49BE 00A3         DATA    >00A3                   address in R5
1084  49C0 DBC4         MOVB    R4,@-2(R15)             clr drive #
1084  49C2 FFFE  
1085  49C4 0585         INC     R5                      point back to VIB buffer
1086  49C6 06A0         BL      @CALSUB                 call subroutine
1086  49C8 4318  
1087  49CA 4A12         DATA    RWSECB                  write sector 0 to old drive (in R2)
1088  49CC 0605         DEC     R5                      point to drive #
1089  49CE 0702 H128    SETO    R2                      flag for read
1090  49D0 D086         MOVB    R6,R2                   APEDSK99: error in original disassembly (was R5)
1091  49D2 1305         JEQ     H129                    none
1092  49D4 0585         INC     R5                      point at VIB buffer
1093  49D6 06A0         BL      @CALSUB                 call subroutine
1093  49D8 4318  
1094  49DA 4A10         DATA    RWSECA                  read sector (in R4) to buffer (in R5)
1095  49DC 0605         DEC     R5                      point at drive #
1096  49DE 0429 H129    BLWP    @>005A(R9)              set VDP to write
1096  49E0 005A  
1097  49E2 00A3         DATA    >00A3                   address in R5
1098  49E4 DBC6         MOVB    R6,@-2(R15)             write drive # in control block, before FDR
1098  49E6 FFFE  
1099  49E8 0585 H126    INC     R5                      point back to FDR
1100  49EA 0429         BLWP    @>005A(R9)                      
1100  49EC 005A  
1101  49EE 3001         DATA    >3001                   retrieve R2 + R3 from stack
1102  49F0 0460         B       @RTURN1                 branch to address on stack
1102  49F2 4336  
1103            *                               
1104  49F4 0702 RDSEC1  SETO    R2                      read sector 1
1105  49F6 0204 WRSEC1  LI      R4,1
1105  49F8 0001  
1106  49FA 0205         LI      R5,>0100                into data buffer area of current ctrl block
1106  49FC 0100  
1107  49FE 1005         JMP     RDFDR1                  
1108            *                               
1109  4A00 06A0 WRFDR   BL      @FDR2B1                 read FDR
1109  4A02 4830  
1110  4A04 FFFC         DATA    -4                      get sector # of FDR from control block
1111            *                               
1112  4A06 C100 RDFDR2  MOV     R0,R4                   sector read/write
1113  4A08 04C5         CLR     R5
1114  4A0A A169 RDFDR1  A       @>0056(R9),R5           point to FDR or data buffer
1114  4A0C 0056  
1115  4A0E 04C7 RWSEC   CLR     R7                      
1116  4A10 D086 RWSECA  MOVB    R6,R2                   add drive # for r/w flag
1117  4A12 0429 RWSECB  BLWP    @>005A(R9)              save R0-R8
1117  4A14 005A  
1118  4A16 FF80         DATA    >FF80                   
1119  4A18 CA44         MOV     R4,@>004A(R9)           sector #
1119  4A1A 004A  
1120  4A1C CA42         MOV     R2,@>004C(R9)           drive | r/w flag
1120  4A1E 004C  
1121  4A20 CA45         MOV     R5,@>004E(R9)           buffer ptr
1121  4A22 004E  
1122  4A24 06A0         BL      @CALSUB                 call subroutine
1122  4A26 4318  
1123  4A28 416E         DATA    SECRW1                  sector read/write
1124  4A2A 0429         BLWP    @>005A(R9)              retrieve R0-R8
1124  4A2C 005A  
1125  4A2E FF81         DATA    >FF81                   
1126  4A30 D1E9         MOVB    @>0050(R9),R7           get error code | flags
1126  4A32 0050  
1127  4A34 06C7         SWPB    R7                      
1128  4A36 1312         JEQ     H130                    
1129  4A38 C1C7         MOV     R7,R7                   
1130  4A3A 1501         JGT     H131                    
1131  4A3C 100B         JMP     H132                    
1132  4A3E 0247 H131    ANDI    R7,>00FF                        
1132  4A40 00FF  
1133  4A42 0287         CI      R7,>0034                        
1133  4A44 0034  
1134  4A46 1603         JNE     H133                    
1135  4A48 06A0         BL      @ERROR5                 
1135  4A4A 4932  
1136  4A4C 2000         DATA    >2000                   write protected
1137  4A4E 06A0 H133    BL      @ERROR5                 
1137  4A50 4932  
1138  4A52 C000         DATA    >C000                   device error
1139  4A54 DA69 H132    MOVB    @>004D(R9),@>004D(R9)   read or write?
1139  4A56 004D  
1139  4A58 004D  
1140  4A5A 13F1         JEQ     H131                    write
1141  4A5C 0247 H130    ANDI    R7,>00FF                        
1141  4A5E 00FF  
1142  4A60 0460         B       @RTURN1                 return to caller
1142  4A62 4336  
1143            *                               
1144  4A64 C069 FFFDRV  MOV     @>0058(R9),R1           save filename in compare buffer and find its FDR
1144  4A66 0058  
1145  4A68 0221         AI      R1,256                  
1145  4A6A 0100  
1146  4A6C 0429         BLWP    @>005A(R9)              set VDP to write
1146  4A6E 005A  
1147  4A70 0023         DATA    >0023                   address in R1: filename compare buffer
1148  4A72 DBC6         MOVB    R6,@-2(R15)             write drive #
1148  4A74 FFFE  
1149  4A76 0581         INC     R1                      
1150  4A78 06A0         BL      @CPCKFN                 copy (+ check) filename from R3 to R1
1150  4A7A 48D4  
1151  4A7C C082         MOV     R2,R2                   all chars copied (or was there a . or a >00
1152  4A7E 1302         JEQ     FFDRVB                  
1153  4A80 0460 H136    B       @ERROR7                 return with file error
1153  4A82 48D8  
1154            *                                       
1155  4A84 C069 FFDRVB  MOV     @>0056(R9),R1           find filename in buffered FDRs
1155  4A86 0056  
1156  4A88 0221         AI      R1,3                    
1156  4A8A 0003  
1157  4A8C 0429         BLWP    @>005A(R9)              set VDP to read
1157  4A8E 005A  
1158  4A90 0022         DATA    >0022                   address in R1
1159  4A92 D0AF         MOVB    @-1026(R15),R2          get # of files
1159  4A94 FBFE  
1160  4A96 0982         SRL     R2,8                    make it a word
1161  4A98 C0C2         MOV     R2,R3                   save it
1162  4A9A 0221         AI      R1,6                    ptr to drive #
1162  4A9C 0006  
1163  4A9E 0204 H134    LI      R4,11                   compare 11 bytes (drive + filename)
1163  4AA0 000B  
1164  4AA2 0429         BLWP    @>005A(R9)              save R1-R3
1164  4AA4 005A  
1165  4AA6 7000         DATA    >7000                   
1166  4AA8 06A0         BL      @CMPFN                  compare with name in compare buffer
1166  4AAA 47FC  
1167  4AAC 0429         BLWP    @>005A(R9)              retrieve R1-R3
1167  4AAE 005A  
1168  4AB0 7001         DATA    >7001                   
1169  4AB2 C104         MOV     R4,R4                   fully compared?
1170  4AB4 1304         JEQ     H135                    yes: done
1171  4AB6 0221         AI      R1,518                  move to next FDR in VDP mem
1171  4AB8 0206  
1172  4ABA 0602         DEC     R2                      
1173  4ABC 16F0         JNE     H134                    next file
1174  4ABE 0460 H135    B       @RTURN1                 return to caller (R4=0 if successfull)
1174  4AC0 4336  
1175            *                               
1176  4AC2 06A0 FNDFDR  BL      @CALSUB                 
1176  4AC4 4318  
1177  4AC6 4A64         DATA    FFFDRV                  save name in comp buffer, find FDR in VDP buffers
1178            *                                       
1179  4AC8 C104 FFDROD  MOV     R4,R4                   find FDR on disk (from filename)
1180  4ACA 13DA         JEQ     H136                    file error
1181  4ACC C169 FFDRDK  MOV     @>0056(R9),R5           ptr to top of disk buffer in VDP mem
1181  4ACE 0056  
1182  4AD0 0225         AI      R5,10                   ptr to drive # in first file control block
1182  4AD2 000A  
1183  4AD4 0429 H138    BLWP    @>005A(R9)              set VDP to read
1183  4AD6 005A  
1184  4AD8 00A2         DATA    >00A2                   address in R5
1185  4ADA D0AF         MOVB    @-1026(R15),R2          get drive #
1185  4ADC FBFE  
1186  4ADE 1307         JEQ     H137                    free control block found
1187  4AE0 0225         AI      R5,518                  ptr to file control block
1187  4AE2 0206  
1188  4AE4 0603         DEC     R3                      
1189  4AE6 16F6         JNE     H138                    more files ?
1190  4AE8 06A0 ERROR6  BL      @ERROR5                 no:
1190  4AEA 4932  
1191  4AEC 8000         DATA    >8000                   memory full
1192            *                               
1193  4AEE CA45 H137    MOV     R5,@>0056(R9)           save ptr to free ctrl block (drive #)
1193  4AF0 0056  
1194  4AF2 06A0         BL      @CALSUB                 call subroutine
1194  4AF4 4318  
1195  4AF6 49F4         DATA    RDSEC1                  read sector 1
1196  4AF8 C229 FFDRFN  MOV     @>0056(R9),R8           entry point if sector 1 already read
1196  4AFA 0056  
1197  4AFC 0228         AI      R8,382                  point to middle of sector 1
1197  4AFE 017E  
1198  4B00 0202         LI      R2,64                   distance: start with 1/4 sector
1198  4B02 0040  
1199  4B04 0704 H139    SETO    R4                      
1200  4B06 06A0         BL      @VDPR2B                 read 2 bytes in R0 from VDP address in R8
1200  4B08 4836  
1201  4B0A C000         MOV     R0,R0                   
1202  4B0C 132E         JEQ     H140                    no file here: move up
1203  4B0E 0429         BLWP    @>005A(R9)              save R2
1203  4B10 005A  
1204  4B12 2000         DATA    >2000                   
1205  4B14 0702         SETO    R2                      code for read
1206  4B16 06A0         BL      @CALSUB                 call subroutine
1206  4B18 4318  
1207  4B1A 4A06         DATA    RDFDR2                  read FDR, sector # in R0
1208  4B1C C045         MOV     R5,R1                   RDFDR2 sets R5 as FDR ptr
1209  4B1E 0225         AI      R5,-4                   point to sector # of FDR in ctrl block
1209  4B20 FFFC  
1210  4B22 0429         BLWP    @>005A(R9)              set VDP to write
1210  4B24 005A  
1211  4B26 00A3         DATA    >00A3                   address in R5
1212  4B28 DBC4         MOVB    R4,@-2(R15)             RDFDR2 puts sector # in R4
1212  4B2A FFFE  
1213  4B2C 06C4         SWPB    R4                      copy it to ctrl block
1214  4B2E DBC4         MOVB    R4,@-2(R15)                     
1214  4B30 FFFE  
1215  4B32 C141         MOV     R1,R5                   FDR ptr
1216  4B34 0601         DEC     R1                      now point to drive #
1217  4B36 0429         BLWP    @>005A(R9)              set VDP to write
1217  4B38 005A  
1218  4B3A 0023         DATA    >0023                   address in R1
1219  4B3C DBC6         MOVB    R6,@-2(R15)             save drive #
1219  4B3E FFFE  
1220  4B40 0204         LI      R4,11                   size to compare (drive # + filename)
1220  4B42 000B  
1221  4B44 06A0         BL      @CMPFN                  compare filenames
1221  4B46 47FC  
1222  4B48 0429         BLWP    @>005A(R9)              retrieve R2
1222  4B4A 005A  
1223  4B4C 2001         DATA    >2001                   
1224  4B4E 130B         JEQ     H141                    compared ok: return
1225  4B50 0429         BLWP    @>005A(R9)              set VDP to write
1225  4B52 005A  
1226  4B54 00A3         DATA    >00A3                   address in R5
1227  4B56 DBC4         MOVB    R4,@-2(R15)             remaining chars to compare
1227  4B58 FFFE  
1228  4B5A 80C0         C       R0,R3                   what kind of mismatch occured?
1229  4B5C 1B06         JH      H140                    too far down the alphabet
1230  4B5E A202         A       R2,R8                   too far up: move half-way down
1231  4B60 C082         MOV     R2,R2                   
1232  4B62 1606         JNE     H142                    then divide distance by 2
1233  4B64 05C8         INCT    R8                      already checked: reset EQ
1234  4B66 0460 H141    B       @RTURN1                 return (from stack)
1234  4B68 4336  
1235            *                               
1236  4B6A 6202 H140    S       R2,R8                   move half-way up
1237  4B6C C082         MOV     R2,R2                   
1238  4B6E 13FB         JEQ     H141                    can't: already checked
1239  4B70 0922 H142    SRL     R2,2                    divide distance by 2
1240  4B72 A082         A       R2,R2                   but keep it even
1241  4B74 10C7         JMP     H139                    
1242            *
1243            * The cluster info list is located in the FDR, bytes >1C to >FF
1244            * A cluster info consists in 3 bytes, i.e 6 nibbles
1245            * 3 nibbles specify the beginning sector for that cluster, and
1246            * 3 nibbles specify the total file offset in sectors, including this cluster.
1247            * The nibbles are arranged as EG SB OF, to be combined as BEG OFS
1248            *
1249  4B76 C28B DECDCI  MOV     R11,R10                 decode cluster info
1250  4B78 06A0         BL      @VDPR2B                 read 2 bytes VDP at R8 in R0
1250  4B7A 4836  
1251  4B7C 06C0         SWPB    R0                      
1252  4B7E D0AF         MOVB    @-1026(R15),R2          get third byte from cluster list
1252  4B80 FBFE  
1253  4B82 C040         MOV     R0,R1                   
1254  4B84 0241         ANDI    R1,>0FFF                start sector in R1
1254  4B86 0FFF  
1255  4B88 4001         SZC     R1,R0                   remove it from R0
1256  4B8A 0982         SRL     R2,8                    
1257  4B8C E080         SOC     R0,R2                   combine offset nibbles
1258  4B8E 0BC2         SRC     R2,12                   offset in R2
1259  4B90 045A         B       *R10                    
1260            *                               
1261  4B92 0B42 UPDCLI  SRC     R2,4                    write info for 1 cluster
1262  4B94 C002         MOV     R2,R0                   
1263  4B96 0240         ANDI    R0,>F000                sector in R1, offset in R2
1263  4B98 F000  
1264  4B9A E040         SOC     R0,R1                   copy nibble 3 of offset before nibble 1 of sector
1265  4B9C 0429         BLWP    @>005A(R9)              set VDP to write
1265  4B9E 005A  
1266  4BA0 0103         DATA    >0103                   address in R8
1267  4BA2 06C1         SWPB    R1                      write cluster info
1268  4BA4 DBC1         MOVB    R1,@-2(R15)             as 3 bytes
1268  4BA6 FFFE  
1269  4BA8 06C1         SWPB    R1                      
1270  4BAA DBC1         MOVB    R1,@-2(R15)                     
1270  4BAC FFFE  
1271  4BAE 06C2         SWPB    R2                      
1272  4BB0 DBC2         MOVB    R2,@-2(R15)                     
1272  4BB2 FFFE  
1273  4BB4 045B         B       *R11                    
1274            *
1275            * The sector bitmap is located in the VIB (i.e. sector 0) at bytes >38 to >FF
1276            * In each byte a bit defines a sector, from right to left: "0"=free, "1"=used                                   
1277            *
1278  4BB6 0429 FFSBMP  BLWP    @>005A(R9)              find a free sector in bitmap
1278  4BB8 005A  
1279  4BBA 7800         DATA    >7800                   
1280  4BBC 06A0         BL      @CALSUB                 call subroutine
1280  4BBE 4318  
1281  4BC0 4992         DATA    RWVIB                   load VIB for drive in R6
1282  4BC2 C041         MOV     R1,R1                   first sector specified in R1 ?
1283  4BC4 1602         JNE     H143                    yes
1284  4BC6 0201         LI      R1,33                   no: start with sector 34
1284  4BC8 0021  
1285  4BCA 0581 H143    INC     R1                      
1286  4BCC C001         MOV     R1,R0                   
1287  4BCE 0931         SRL     R1,3                    div by 8 since 8 sect/byte in bitmap
1288  4BD0 0202         LI      R2,>00FF                        
1288  4BD2 00FF  
1289  4BD4 0240         ANDI    R0,>0007                bit number in bitmap byte
1289  4BD6 0007  
1290  4BD8 1301         JEQ     H144                    
1291  4BDA 0A02         SLA     R2,0                    get that bit
1292  4BDC C0C1 H144    MOV     R1,R3                   byte #
1293  4BDE A0C5         A       R5,R3                   add VIB ptr
1294  4BE0 0223         AI      R3,56                   ptr to sector in bitmap
1294  4BE2 0038  
1295  4BE4 0281         CI      R1,>00C8                end of VIB?
1295  4BE6 00C8  
1296  4BE8 1101         JLT     H145                    no
1297  4BEA 04C1         CLR     R1                      yes: top of bitmap
1298  4BEC A045 H145    A       R5,R1                   
1299  4BEE 0221         AI      R1,56                   make another bitmap ptr
1299  4BF0 0038  
1300  4BF2 0429         BLWP    @>005A(R9)              set VDP to read
1300  4BF4 005A  
1301  4BF6 0022         DATA    >0022                   address in R1
1302  4BF8 0700 H146    SETO    R0                      
1303  4BFA D02F         MOVB    @-1026(R15),R0          get bitmap byte
1303  4BFC FBFE  
1304  4BFE C100         MOV     R0,R4                   save it
1305  4C00 E002         SOC     R2,R0                   mask previous sectors
1306  4C02 04C2         CLR     R2                      
1307  4C04 0580         INC     R0                      get 1 more sector
1308  4C06 1610         JNE     H147                    ok
1309  4C08 0581         INC     R1                      byte full: try next
1310  4C0A C001         MOV     R1,R0                   
1311  4C0C 0220         AI      R0,-256                 won't change if byte # became >100
1311  4C0E FF00  
1312  4C10 8140         C       R0,R5                   still in VIB?
1313  4C12 1605         JNE     H148                    yes
1314  4C14 0221         AI      R1,-200                 no: to top of bitmap
1314  4C16 FF38  
1315  4C18 0429         BLWP    @>005A(R9)              set VDP to read
1315  4C1A 005A  
1316  4C1C 0022         DATA    >0022                   address in R1
1317  4C1E 80C1 H148    C       R1,R3                   are we back to where we started?
1318  4C20 16EB         JNE     H146                    no: seach that byte for a free sector
1319  4C22 C004         MOV     R4,R0                   get original byte
1320  4C24 0580         INC     R0                      try sectors just before ours (no mask this time)
1321  4C26 1325         JEQ     H149                    full: return with EQ
1322  4C28 0600 H147    DEC     R0                      restore original byte
1323  4C2A C080         MOV     R0,R2                   
1324  4C2C 04C0         CLR     R0                      bit counter
1325  4C2E 06C2         SWPB    R2                      
1326  4C30 0580 H150    INC     R0                      increment bit count
1327  4C32 0B12         SRC     R2,1                    find first 0 bit from the right
1328  4C34 18FD         JOC     H150                    not yet
1329  4C36 0202         LI      R2,>0080                        
1329  4C38 0080  
1330  4C3A 0A02         SLA     R2,0                    make a mask for that bit
1331  4C3C 0600         DEC     R0                      bit # (0-7)
1332  4C3E E102         SOC     R2,R4                   mark sector as used in bitmap byte
1333  4C40 0429         BLWP    @>005A(R9)              set VDP to write
1333  4C42 005A  
1334  4C44 0023         DATA    >0023                   address in R1
1335  4C46 DBC4         MOVB    R4,@-2(R15)             update bitmap
1335  4C48 FFFE  
1336  4C4A 0221         AI      R1,-56                  
1336  4C4C FFC8  
1337  4C4E 6045         S       R5,R1                   byte # in bitmap
1338  4C50 0A31         SLA     R1,3                    times 8 (8 sect per byte)
1339  4C52 E040         SOC     R0,R1                   add bit #: = sector #
1340  4C54 C001         MOV     R1,R0                   save it
1341            *                               
1342  4C56 0605 H151    DEC     R5                      point to drive #
1343  4C58 0429         BLWP    @>005A(R9)              set VDP to read
1343  4C5A 005A  
1344  4C5C 00A2         DATA    >00A2                   address in R5
1345  4C5E D06F         MOVB    @-1026(R15),R1          get drive #
1345  4C60 FBFE  
1346  4C62 0261         ORI     R1,>8000                add flag: update VIB
1346  4C64 8000  
1347  4C66 0429         BLWP    @>005A(R9)              set VDP to write
1347  4C68 005A  
1348  4C6A 00A3         DATA    >00A3                   address in R5
1349  4C6C DBC1         MOVB    R1,@-2(R15)             write back flagged drive #
1349  4C6E FFFE  
1350  4C70 0585         INC     R5                      point to VIB (& return with NEQ)
1351  4C72 0429 H149    BLWP    @>005A(R9)              retrieve R1-R4
1351  4C74 005A  
1352  4C76 7801         DATA    >7801                   
1353  4C78 0460         B       @RTURN1                 return to caller
1353  4C7A 4336  
1354            *                               
1355  4C7C C040 FFSBM   MOV     R0,R1                   free sector(s) in bitmap
1356  4C7E 0202         LI      R2,1                    1 sector only
1356  4C80 0001  
1357  4C82 0429 FRSCB1  BLWP    @>005A(R9)              entry point if more than 1 sector
1357  4C84 005A  
1358  4C86 7800         DATA    >7800                   save R1-R4
1359  4C88 06A0         BL      @CALSUB                 call subroutine
1359  4C8A 4318  
1360  4C8C 4992         DATA    RWVIB                   load VIB for drive in R6
1361  4C8E C001         MOV     R1,R0                   sector #
1362  4C90 0240         ANDI    R0,>0007                bit in bitmap byte (8 per byte)
1362  4C92 0007  
1363  4C94 0931         SRL     R1,3                    byte in bitmap
1364  4C96 A045         A       R5,R1                   add VIB buffer
1365  4C98 0221         AI      R1,56                   add bitmap offset in VIB
1365  4C9A 0038  
1366  4C9C C0C0         MOV     R0,R3                   
1367  4C9E 0500         NEG     R0                      
1368  4CA0 0220         AI      R0,8                    change 0-7 into 8-1
1368  4CA2 0008  
1369  4CA4 0204         LI      R4,>00FF                mask to erase
1369  4CA6 00FF  
1370  4CA8 8002         C       R2,R0                   how many to erase?
1371  4CAA 1101         JLT     H152                    less than in that byte
1372  4CAC 100A         JMP     H153                    
1373            *                               
1374  4CAE 0200 H152    LI      R0,8                    free sectors in first byte
1374  4CB0 0008  
1375  4CB2 6002         S       R2,R0                   
1376  4CB4 0B04         SRC     R4,0                    adjust mask
1377  4CB6 C003         MOV     R3,R0                   original bit # of starting sector
1378  4CB8 1301         JEQ     H154                    
1379  4CBA 0A04         SLA     R4,0                    don't erase before starting sector
1380  4CBC 1000 H154    JMP     H155                    
1381            *                               
1382  4CBE 06C4 H155    SWPB    R4                      
1383  4CC0 1019         JMP     H158                    goto erase last byte
1384            *                                       
1385  4CC2 0B04 H153    SRC     R4,0                    adjust mask
1386  4CC4 6080 H156    S       R0,R2                   that many will be freed
1387  4CC6 0429         BLWP    @>005A(R9)              set VDP to read
1387  4CC8 005A  
1388  4CCA 0022         DATA    >0022                   address in R1
1389  4CCC D02F         MOVB    @-1026(R15),R0          get bitmap byte
1389  4CCE FBFE  
1390  4CD0 4004         SZC     R4,R0                   mark sectors as free
1391  4CD2 0429         BLWP    @>005A(R9)              set VDP to write
1391  4CD4 005A  
1392  4CD6 0023         DATA    >0023                   address in R1
1393  4CD8 DBC0         MOVB    R0,@-2(R15)             write it back
1393  4CDA FFFE  
1394  4CDC 0204         LI      R4,>FF00                clear full byte
1394  4CDE FF00  
1395  4CE0 0581         INC     R1                      next byte
1396  4CE2 0200         LI      R0,8                    i.e. 8 sectors
1396  4CE4 0008  
1397  4CE6 8002         C       R2,R0                   how many more sectors?
1398  4CE8 1101         JLT     H157                    less than 8
1399  4CEA 10EC         JMP     H156                    8 or more: next byte
1400            *                                       
1401  4CEC C002 H157    MOV     R2,R0                   remaining sectors
1402  4CEE 0204         LI      R4,>00FF                        
1402  4CF0 00FF  
1403  4CF2 0A04         SLA     R4,0                    coin mask
1404  4CF4 0429 H158    BLWP    @>005A(R9)              set VDP to read
1404  4CF6 005A  
1405  4CF8 0022         DATA    >0022                   address in R1
1406  4CFA D02F         MOVB    @-1026(R15),R0          get bitmap byte
1406  4CFC FBFE  
1407  4CFE 4004         SZC     R4,R0                   mark sectors as free
1408  4D00 0429         BLWP    @>005A(R9)              set VDP to write
1408  4D02 005A  
1409  4D04 0023         DATA    >0023                   address in R1
1410  4D06 DBC0         MOVB    R0,@-2(R15)             write it back
1410  4D08 FFFE  
1411  4D0A 10A5         JMP     H151                    done: flag drive # and return
1412            *
1413            *===================================
1414            * DSR entry points
1415            *===================================                                    
1416            *
1417  4D0C C1CB EDSR01  MOV     R11,R7                  DSK
1418  4D0E 06A0         BL      @PRPFDO                 --- prepare file operations
1418  4D10 43E4  
1419  4D12 06A0         BL      @CALSUB                 call subroutine
1419  4D14 4318  
1420  4D16 484A         DATA    FDSKDR                  find disk in drive (name ptr in R3)
1421  4D18 100B         JMP     H159                    
1422            *                                       
1423  4D1A 0206 EDSR02  LI      R6,>0100                DSK1
1423  4D1C 0100  
1424  4D1E 1005         JMP     H160                    ----
1425            *                                       
1426  4D20 0206 EDSR03  LI      R6,>0200                DSK2
1426  4D22 0200  
1427  4D24 1002         JMP     H160                    ----
1428            *                                       
1429  4D26 0206 EDSR04  LI      R6,>0300                DSK3
1429  4D28 0300  
1430            *                                       
1431  4D2A C1CB H160    MOV     R11,R7                  save return address
1432  4D2C 06A0         BL      @PRPFDO                 prepare file operations
1432  4D2E 43E4  
1433  4D30 C029 H159    MOV     @>0054(R9),R0           PAB ptr
1433  4D32 0054  
1434  4D34 0429         BLWP    @>005A(R9)              set VDP to read
1434  4D36 005A  
1435  4D38 0002         DATA    >0002                   address in R0
1436  4D3A D06F         MOVB    @-1026(R15),R1          get opcode
1436  4D3C FBFE  
1437  4D3E 0981         SRL     R1,8                    
1438  4D40 0281         CI      R1,>0009                check range
1438  4D42 0009  
1439  4D44 1B19         JH      ERROR8                  illegal opcode
1440  4D46 0282         CI      R2,>0001                filename lenght (including . )
1440  4D48 0001  
1441  4D4A 1605         JNE     H161                    no filename: dir
1442  4D4C 0221         AI      R1,10                   only allow open, close and read
1442  4D4E 000A  
1443  4D50 0281         CI      R1,>000C                        
1443  4D52 000C  
1444  4D54 1B11         JH      ERROR8                  others are illegal
1445  4D56 A041 H161    A       R1,R1                   make it a word ptr
1446  4D58 C061         MOV     @OPCVEC(R1),R1          get vector
1446  4D5A 4D5E  
1447  4D5C 0451         B       *R1                     branch to it
1448            *                                       
1449  4D5E 4D7E OPCVEC  DATA    OPEN                    open
1450  4D60 4F90         DATA    CLOSE                   close
1451  4D62 4F9A         DATA    READ                    read
1452  4D64 5084         DATA    WRITE                   write
1453  4D66 5338         DATA    RWIND1                  rewind
1454  4D68 538C         DATA    LOAD                    load
1455  4D6A 542E         DATA    SAVE                    save
1456  4D6C 472E         DATA    DELETE                  delete
1457  4D6E 495E         DATA    RETERR                  scratch record: return with bad attribute error
1458  4D70 54B2         DATA    STATUS                  status
1459            *                                       
1460  4D72 5572         DATA    OPNDIR                  open directory
1461  4D74 55D0         DATA    CLSDIR                  close directory
1462  4D76 55E6         DATA    RDDIR                   read directory
1463            *                                       
1464  4D78 06A0 ERROR8  BL      @ERROR5                 return with error
1464  4D7A 4932  
1465  4D7C 6000         DATA    >6000                   illegal opcode
1466            *
1467            *---------------------------------
1468            * Opcode 0: Open
1469            * --------------
1470            * PAB 0: >00
1471            *     1: file type  <--- error code
1472            *   2-3:
1473            *     4: record length
1474            *     5:
1475            *   6-7: # of records (if output)
1476            *     8:
1477            *---------------------------------                                      
1478            *
1479  4D7E 04C0 OPEN    CLR     R0                      
1480  4D80 D02F         MOVB    @-1026(R15),R0          get file attributes
1480  4D82 FBFE  
1481  4D84 0429         BLWP    @>005A(R9)                      
1481  4D86 005A  
1482  4D88 8000         DATA    >8000                   save R0
1483  4D8A 0240         ANDI    R0,>1600                keep fix/var and access mode
1483  4D8C 1600  
1484  4D8E 0280         CI      R0,>0600                        
1484  4D90 0600  
1485  4D92 1603         JNE     H162                    
1486  4D94 06A0 ERROR9  BL      @ERROR5                 dis/fix, open as append: return with error
1486  4D96 4932  
1487  4D98 4000         DATA    >4000                   bad attribute
1488            *                                       
1489  4D9A 120A H162    JLE     H163                    
1490  4D9C C040         MOV     R0,R1                   var
1491  4D9E 06A0         BL      @PABR2B                 get 2 bytes from PAB into R0
1491  4DA0 482A  
1492  4DA2 0004         DATA    4                       rec len and char count
1493  4DA4 0280         CI      R0,>FF00                is rec len 255?
1493  4DA6 FF00  
1494  4DA8 14F5         JHE     ERROR9                  yes: bad attribute
1495  4DAA C001         MOV     R1,R0                   retrieve attributes
1496  4DAC 0240         ANDI    R0,>0600                keep only access mode
1496  4DAE 0600  
1497            *                                       
1498  4DB0 0280 H163    CI      R0,>0200                is it output?
1498  4DB2 0200  
1499  4DB4 1657         JNE     H164                    no
1500  4DB6 06A0         BL      @CALSUB                 call subroutine
1500  4DB8 4318  
1501  4DBA 4450         DATA    CRFIL1                  create file
1502  4DBC 06A0 H165    BL      @PRFDRS                 coin status byte in FDR style
1502  4DBE 4F3E  
1503  4DC0 0429         BLWP    @>005A(R9)              set VDP to write
1503  4DC2 005A  
1504  4DC4 0083         DATA    >0083                   address in R4: status byte in FDR buffer
1505  4DC6 DBC2         MOVB    R2,@-2(R15)             write file status in FDR
1505  4DC8 FFFE  
1506  4DCA C0E9         MOV     @>0054(R9),R3           PAB ptr
1506  4DCC 0054  
1507  4DCE 0223         AI      R3,4                    ptr to rec len
1507  4DD0 0004  
1508  4DD2 04C5         CLR     R5                      
1509  4DD4 0429         BLWP    @>005A(R9)              set VDP to read
1509  4DD6 005A  
1510  4DD8 0062         DATA    >0062                   address in R3
1511  4DDA D16F         MOVB    @-1026(R15),R5          get record length
1511  4DDC FBFE  
1512  4DDE 1607         JNE     H166                    
1513  4DE0 0205         LI      R5,>5000                >00: default it 80
1513  4DE2 5000  
1514  4DE4 0429         BLWP    @>005A(R9)              set VDP to write
1514  4DE6 005A  
1515  4DE8 0063         DATA    >0063                   address in R3
1516  4DEA DBC5         MOVB    R5,@-2(R15)             write default rec len
1516  4DEC FFFE  
1517  4DEE 0224 H166    AI      R4,5                    point to rec len byte in FDR
1517  4DF0 0005  
1518  4DF2 0429         BLWP    @>005A(R9)              set VDP to write
1518  4DF4 005A  
1519  4DF6 0083         DATA    >0083                   address in R4
1520  4DF8 DBC5         MOVB    R5,@-2(R15)             write rec len in FDR buffer
1520  4DFA FFFE  
1521  4DFC 0201         LI      R1,256                  256 bytes/sector
1521  4DFE 0100  
1522  4E00 C082         MOV     R2,R2                   var or dis?
1523  4E02 1101         JLT     H167                    var
1524  4E04 1002         JMP     H168                    dis
1525  4E06 A141 H167    A       R1,R5                   var: rec len +1
1526  4E08 0601         DEC     R1                      254 bytes only (needs size byte)
1527  4E0A 06C5 H168    SWPB    R5                      make it a word
1528  4E0C 04C0         CLR     R0                      
1529  4E0E 3C05         DIV     R5,R0                   how many times in 254/255 bytes?
1530  4E10 0224         AI      R4,-4                   point to # of rec/sect in FDR
1530  4E12 FFFC  
1531  4E14 C040         MOV     R0,R1                   save result for later
1532  4E16 06C0         SWPB    R0                      
1533  4E18 0429         BLWP    @>005A(R9)              set VDP to write
1533  4E1A 005A  
1534  4E1C 0083         DATA    >0083                   address in R4
1535  4E1E DBC0         MOVB    R0,@-2(R15)             write # of rec/sect in FDR
1535  4E20 FFFE  
1536  4E22 C229         MOV     @>0056(R9),R8           point to filename in FDR
1536  4E24 0056  
1537  4E26 0429         BLWP    @>005A(R9)              set VDP to read
1537  4E28 005A  
1538  4E2A 0102         DATA    >0102                   address in R8
1539  4E2C D02F         MOVB    @-1026(R15),R0          get first char
1539  4E2E FBFE  
1540  4E30 0260         ORI     R0,>8000                flag it: update FDR before leaving
1540  4E32 8000  
1541  4E34 0429         BLWP    @>005A(R9)              set VDP to write
1541  4E36 005A  
1542  4E38 0103         DATA    >0103                   address in R8
1543  4E3A DBC0         MOVB    R0,@-2(R15)             write it back
1543  4E3C FFFE  
1544  4E3E 0429         BLWP    @>005A(R9)                      
1544  4E40 005A  
1545  4E42 8001         DATA    >8001                   retrieve R0 (access mode)
1546  4E44 06A0         BL      @PABR2B                 get 2 bytes from PAB into R0
1546  4E46 482A  
1547  4E48 0006         DATA    6                       required size in records
1548  4E4A C100         MOV     R0,R4                   
1549  4E4C 1309         JEQ     H169                    no size specified
1550  4E4E 11A2         JLT     ERROR9                  return with bad attribute error
1551  4E50 A101         A       R1,R4                   round up to record size
1552  4E52 0604         DEC     R4                      
1553  4E54 04C3         CLR     R3                      
1554  4E56 3CC1         DIV     R1,R3                   how many sectors will this be?
1555  4E58 0603         DEC     R3                      offset start from 0
1556  4E5A 06A0         BL      @CALSUB                 call subroutine
1556  4E5C 4318  
1557  4E5E 4620         DATA    APSCTS                  add sectors to FDR to match offset in R3
1558  4E60 0460 H169    B       @RWIND2                 initialise file control block and return to caller
1558  4E62 5366  
1559            *                                       
1560  4E64 0429 H164    BLWP    @>005A(R9)              not output
1560  4E66 005A  
1561  4E68 8000         DATA    >8000                   save R0
1562  4E6A 06A0         BL      @CALSUB                 call subroutine
1562  4E6C 4318  
1563  4E6E 4AC2         DATA    FNDFDR                  find FDR on disk
1564  4E70 0429         BLWP    @>005A(R9)                      
1564  4E72 005A  
1565  4E74 8001         DATA    >8001                   retrieve R0 (access mode)
1566  4E76 C104         MOV     R4,R4                   found FDR?
1567  4E78 1309         JEQ     H170                    yes
1568  4E7A 0280         CI      R0,>0400                no: is file open as input?
1568  4E7C 0400  
1569  4E7E 1304         JEQ     H171                    yes: must exist
1570  4E80 06A0         BL      @CALSUB                 no: call subroutine
1570  4E82 4318  
1571  4E84 4462         DATA    CRFIL3                  create file
1572  4E86 109A         JMP     H165                    
1573            *                                       
1574  4E88 0460 H171    B       @ERROR9                 return with bad attribute error
1574  4E8A 4D94  
1575            *                                       
1576  4E8C C1C0 H170    MOV     R0,R7                   save access mode
1577  4E8E 06A0         BL      @PRFDRS                 prepare status byte for FDR
1577  4E90 4F3E  
1578  4E92 0429         BLWP    @>005A(R9)              set VDP to read
1578  4E94 005A  
1579  4E96 0082         DATA    >0082                   address in R4 (status byte in FDR)
1580  4E98 D02F         MOVB    @-1026(R15),R0          get current file status
1580  4E9A FBFE  
1581  4E9C C0C0         MOV     R0,R3                   save it
1582  4E9E 0243         ANDI    R3,>0800                is file write protected?
1582  4EA0 0800  
1583  4EA2 1306         JEQ     H172                    no
1584  4EA4 0287         CI      R7,>0400                yes: is it open as input?
1584  4EA6 0400  
1585  4EA8 1303         JEQ     H172                    no
1586  4EAA 06A0         BL      @ERROR5                 yes: return with error
1586  4EAC 4932  
1587  4EAE 2000         DATA    >2000                   write protected
1588            *                                       
1589  4EB0 0240 H172    ANDI    R0,>8300                keep only file type bits (V/F, D/I, Prg/Data)
1589  4EB2 8300  
1590  4EB4 2802         XOR     R2,R0                   compare with new (coined by PRFDRS)
1591  4EB6 16E8         JNE     H171                    different: bad attribute
1592  4EB8 C0E9         MOV     @>0054(R9),R3           PAB ptr
1592  4EBA 0054  
1593  4EBC 0223         AI      R3,4                    ptr to rec len in PAB
1593  4EBE 0004  
1594  4EC0 0224         AI      R4,5                    ptr to rec len in FDR
1594  4EC2 0005  
1595  4EC4 0429         BLWP    @>005A(R9)              set VDP to read
1595  4EC6 005A  
1596  4EC8 0082         DATA    >0082                   address in R4
1597  4ECA D02F         MOVB    @-1026(R15),R0          get rec len from FDR
1597  4ECC FBFE  
1598  4ECE 0429         BLWP    @>005A(R9)              set VDP to read
1598  4ED0 005A  
1599  4ED2 0062         DATA    >0062                   address in R3
1600  4ED4 D0AF         MOVB    @-1026(R15),R2          get rec len from PAB
1600  4ED6 FBFE  
1601  4ED8 1302         JEQ     H173                    0 = keep current one
1602  4EDA 9080         CB      R0,R2                   are they identical?
1603  4EDC 16D5         JNE     H171                    no: bad attribute
1604  4EDE 0429 H173    BLWP    @>005A(R9)              set VDP to write
1604  4EE0 005A  
1605  4EE2 0063         DATA    >0063                   address in R3
1606  4EE4 DBC0         MOVB    R0,@-2(R15)             update rec len in PAB (in case it was 0)
1606  4EE6 FFFE  
1607  4EE8 0429         BLWP    @>005A(R9)              retrieve R0 (open mode)
1607  4EEA 005A  
1608  4EEC 8001         DATA    >8001                   
1609  4EEE 0240         ANDI    R0,>0600                keep only access mode
1609  4EF0 0600  
1610  4EF2 04C2         CLR     R2                      
1611  4EF4 0703         SETO    R3                      
1612  4EF6 0280         CI      R0,>0600                is it append
1612  4EF8 0600  
1613  4EFA 161D         JNE     H174                    no
1614  4EFC C129         MOV     @>0056(R9),R4           yes: get FDR ptr
1614  4EFE 0056  
1615  4F00 C1C4         MOV     R4,R7                   save it
1616  4F02 0224         AI      R4,14                   ptr to # of sectors
1616  4F04 000E  
1617  4F06 0429         BLWP    @>005A(R9)              set VDP to read
1617  4F08 005A  
1618  4F0A 0082         DATA    >0082                   address in R4
1619  4F0C D0EF         MOVB    @-1026(R15),R3          get # of sectors in file
1619  4F0E FBFE  
1620  4F10 06C3         SWPB    R3                      
1621  4F12 D0EF         MOVB    @-1026(R15),R3                  
1621  4F14 FBFE  
1622  4F16 06C3         SWPB    R3                      
1623  4F18 D0AF         MOVB    @-1026(R15),R2          get eof offset
1623  4F1A FBFE  
1624  4F1C 0603         DEC     R3                      offset starts from 0
1625  4F1E 110B         JLT     H174                    file is empty (0 sectors)
1626  4F20 0429         BLWP    @>005A(R9)                      
1626  4F22 005A  
1627  4F24 3000         DATA    >3000                   save R2 + R3
1628  4F26 0227         AI      R7,256                  ptr to data buffer area for this file
1628  4F28 0100  
1629  4F2A 06A0         BL      @CALSUB                 call subroutine
1629  4F2C 4318  
1630  4F2E 45EA         DATA    RDOFSC                  read a sector, from offset in R3
1631  4F30 0429         BLWP    @>005A(R9)                      
1631  4F32 005A  
1632  4F34 3001         DATA    >3001                   retrieve R2 + R3
1633  4F36 06A0 H174    BL      @UPDFCB                 update current record offset in file ctrl block
1633  4F38 4F68  
1634  4F3A 0460         B       @RTURN1                 return to caller
1634  4F3C 4336  
1635            *                                       
1636  4F3E 0429 PRFDRS  BLWP    @>005A(R9)              prepare file status byte for FDR
1636  4F40 005A  
1637  4F42 8001         DATA    >8001                   access mode in R0
1638  4F44 0429         BLWP    @>005A(R9)                      
1638  4F46 005A  
1639  4F48 8000         DATA    >8000                   save it back
1640  4F4A 0202         LI      R2,2                    int in FDR status byte
1640  4F4C 0002  
1641  4F4E C129         MOV     @>0056(R9),R4           FDR pointer
1641  4F50 0056  
1642  4F52 0A40         SLA     R0,4                    fix or var?
1643  4F54 1703         JNC     H175                    fix
1644  4F56 0202         LI      R2,>0082                int var in FDR
1644  4F58 0082  
1645  4F5A C000         MOV     R0,R0                   dis or int?
1646  4F5C 1101 H175    JLT     H176                    int
1647  4F5E 0642         DECT    R2                      dis: remove the int from FDR status
1648  4F60 0224 H176    AI      R4,12                   point at file status byte in FDR
1648  4F62 000C  
1649  4F64 06C2         SWPB    R2                      
1650  4F66 045B         B       *R11                    
1651            *                                       
1652  4F68 C129 UPDFCB  MOV     @>0056(R9),R4           update sect + rec offsets in file control block
1652  4F6A 0056  
1653  4F6C 0224         AI      R4,-6                   
1653  4F6E FFFA  
1654  4F70 0429         BLWP    @>005A(R9)              set VDP to write
1654  4F72 005A  
1655  4F74 0083         DATA    >0083                   address in R4
1656  4F76 DBC3         MOVB    R3,@-2(R15)             write current sect offset
1656  4F78 FFFE  
1657  4F7A 06C3         SWPB    R3                      
1658  4F7C DBC3         MOVB    R3,@-2(R15)                     
1658  4F7E FFFE  
1659  4F80 0224         AI      R4,4                    point to logical rec offset (for var files)
1659  4F82 0004  
1660  4F84 0429         BLWP    @>005A(R9)              set VDP to write
1660  4F86 005A  
1661  4F88 0083         DATA    >0083                   address in R4
1662  4F8A DBC2         MOVB    R2,@-2(R15)             write record offset
1662  4F8C FFFE  
1663  4F8E 045B         B       *R11                    
1664            *
1665            *----------------------------------
1666            * Opcode 1: Close
1667            * --------------
1668            * PAB 0: >01
1669            *     1:           <--- error code
1670            *   2-3:
1671            *     4:
1672            *     5:
1673            *   6-7:
1674            *     8:
1675            *----------------------------------                                     
1676            *
1677  4F90 06A0 CLOSE   BL      @CALSUB                 call subroutine
1677  4F92 4318  
1678  4F94 518E         DATA    FFDRVP                  find file FDR
1679  4F96 0460         B       @UPDFDR                 update FDR + data area, get VIB, return to caller
1679  4F98 4536  
1680            *
1681            *----------------------------------
1682            * Opcode 2: Read
1683            * --------------
1684            * PAB 0: >02
1685            *     1: file type <--- error code
1686            *   2-3: data buffer address in VDP mem
1687            *     4:
1688            *     5: bytes read
1689            *   6-7: record #
1690            *     8:
1691            *
1692            * Logical records organisation whithin sectors
1693            *
1694            * Fixed records (e.g. rec length = 6)
1695            * 11 11 11 11 11 11 22 22 22 22 22 22 33 33 33 33 33 33 xx xx xx
1696            * Where 11=data for record 1, 22=record 2, 33=record 3, xx=junk bytes
1697            *
1698            * Variable records:
1699            * sz 11 11 11 11 11 11 11 sz 22 22 22 22 22 sz 33 33 FF xx xx xx
1700            * Where sz=record size, 11,22,33=record data, FF=end-of-sector mark, xx=junk
1701            *----------------------------------                                     
1702            *
1703  4F9A 06A0 READ    BL      @CALSUB                 call subroutine
1703  4F9C 4318  
1704  4F9E 518E         DATA    FFDRVP                  find FDR in VDP buffers, get status from PAB
1705  4FA0 0240         ANDI    R0,>0200                what type of access?
1705  4FA2 0200  
1706  4FA4 1302         JEQ     H177                    update or input: ok
1707  4FA6 0460 H179    B       @ERROR8                 append or output: error illegal opcode
1707  4FA8 4D78  
1708  4FAA 06A0 H177    BL      @RFDRST                 get status byte in R0, from FDR
1708  4FAC 51BA  
1709  4FAE 110A         JLT     H178                    var
1710  4FB0 06A0         BL      @RRNPAB                 fix: get rec # compare to # of recs/file
1710  4FB2 51CE  
1711  4FB4 1A03         JL      H180                    ok: in file
1712  4FB6 06A0 H181    BL      @ERROR5                 update data and return with error
1712  4FB8 4932  
1713  4FBA A000         DATA    >A000                   eof reached
1714  4FBC 06A0 H180    BL      @CALSUB                 call subroutine
1714  4FBE 4318  
1715  4FC0 5234         DATA    RRFDR                   load record from disk into FDR data buffer area
1716  4FC2 1011         JMP     H182                    
1717            *                                       
1718  4FC4 06A0 H178    BL      @CALSUB                 var: call subroutine
1718  4FC6 4318  
1719  4FC8 5020         DATA    RRSEC                   load proper sector, point to rec in it
1720  4FCA 10F5         JMP     H181                    skipped if ok: return with eof reached
1721            *                                       
1722  4FCC 0582         INC     R2                      next byte in data buffer
1723  4FCE A004         A       R4,R0                   add rec size to offset
1724  4FD0 0580         INC     R0                      room for end-of-sector mark
1725  4FD2 C169         MOV     @>0056(R9),R5           FDR ptr
1725  4FD4 0056  
1726  4FD6 0645         DECT    R5                      point to var record offset in sector
1727  4FD8 06C0         SWPB    R0                      
1728  4FDA 0429         BLWP    @>005A(R9)              set VDP to write
1728  4FDC 005A  
1729  4FDE 00A3         DATA    >00A3                   address in R5
1730  4FE0 DBC0         MOVB    R0,@-2(R15)             update var record offset in sector
1730  4FE2 FFFE  
1731  4FE4 C004         MOV     R4,R0                   save # of bytes to be read
1732  4FE6 C129 H182    MOV     @>0054(R9),R4           PAB ptr
1732  4FE8 0054  
1733  4FEA 0224         AI      R4,5                    point to char count
1733  4FEC 0005  
1734  4FEE 06C0         SWPB    R0                      
1735  4FF0 0429         BLWP    @>005A(R9)              set VDP to write
1735  4FF2 005A  
1736  4FF4 0083         DATA    >0083                   address in R4
1737  4FF6 DBC0         MOVB    R0,@-2(R15)             write # of char to be read
1737  4FF8 FFFE  
1738  4FFA 06C0         SWPB    R0                      make it a word
1739            *                                       
1740  4FFC C000 WFDRPB  MOV     R0,R0                   check it
1741  4FFE 130E         JEQ     H183                    none: return
1742  5000 0429 H184    BLWP    @>005A(R9)              set VDP to read
1742  5002 005A  
1743  5004 0042         DATA    >0042                   address in R2
1744  5006 D0EF         MOVB    @-1026(R15),R3          read 1 byte from FDR data buffer area
1744  5008 FBFE  
1745  500A 0582         INC     R2                      increment source ptr
1746  500C 0429         BLWP    @>005A(R9)              set VDP to write
1746  500E 005A  
1747  5010 0023         DATA    >0023                   address in R1
1748  5012 DBC3         MOVB    R3,@-2(R15)             write the byte in PAB data buffer
1748  5014 FFFE  
1749  5016 0581         INC     R1                      increment destination ptr
1750  5018 0600         DEC     R0                      more to read?
1751  501A 16F2         JNE     H184                    yes
1752  501C 0460 H183    B       @RTURN1                 return to caller
1752  501E 4336  
1753            *                                       
1754  5020 06A0 RRSEC   BL      @RCOFCB                 load sector, point to record in it
1754  5022 530E  
1755  5024 C0C3         MOV     R3,R3                   sector offset
1756  5026 1101         JLT     H185                    -1: top of file
1757  5028 1012         JMP     H186                    in file
1758  502A C003 H185    MOV     R3,R0                   
1759  502C 0580         INC     R0                      next sector
1760  502E 8080         C       R0,R2                   compare to # of sect/file
1761  5030 13F5         JEQ     H183                    end-of-file reached: return to caller (JMP to err)
1762  5032 06A0         BL      @CALSUB                 call subroutine
1762  5034 4318  
1763  5036 4556         DATA    UPDBF                   update data buffer, if needed
1764  5038 C0C0         MOV     R0,R3                   desired offset
1765  503A 04C5         CLR     R5                      
1766  503C 06A0         BL      @UCOFCB                 update sect + rec offsets in control block
1766  503E 52AC  
1767  5040 0227         AI      R7,256                  point to data buffer area (R7 set by UCOFCB)
1767  5042 0100  
1768  5044 06A0         BL      @CALSUB                 call subroutine
1768  5046 4318  
1769  5048 45EA         DATA    RDOFSC                  read a sector, from offset in file (in R3)
1770  504A 04C0         CLR     R0                      
1771  504C 1004         JMP     H187                    
1772            *                                       
1773  504E C000 H186    MOV     R0,R0                   in file: test var rec offset (from RCOFCB)
1774  5050 1602         JNE     H187                    inside sector
1775  5052 8080         C       R0,R2                   at beg of sector
1776  5054 13E3         JEQ     H183                    file is empty: return
1777  5056 C080 H187    MOV     R0,R2                   FDR data buffer will be added to R2 by AFDRPT
1778  5058 06A0         BL      @CALSUB                 call subroutine
1778  505A 4318  
1779  505C 5288         DATA    AFDRPT                  R2=byte in FDR data buf, R1=top of PAB data buf
1780  505E 0429         BLWP    @>005A(R9)              set VDP to read
1780  5060 005A  
1781  5062 0042         DATA    >0042                   address in R2
1782  5064 D12F         MOVB    @-1026(R15),R4          get first byte (rec length)
1782  5066 FBFE  
1783  5068 0984         SRL     R4,8                    make it a word
1784  506A C000         MOV     R0,R0                   var rec offset
1785  506C 1306         JEQ     H188                    
1786  506E 0284         CI      R4,>00FF                is it >FF (end of sector mark) ?
1786  5070 00FF  
1787  5072 1603         JNE     H188                    no
1788  5074 06A0         BL      @RCOFCB                 yes: get sect + rec offsets from control block
1788  5076 530E  
1789  5078 10D8         JMP     H185                    try again with next sector
1790            *                                       
1791  507A 0429 H188    BLWP    @>005A(R9)                      
1791  507C 005A  
1792  507E 0011         DATA    >0011                   retrieve return address from stack in R11
1793  5080 05CB         INCT    R11                     skip the JMP to eof reached error
1794  5082 045B         B       *R11                    
1795            *
1796            *------------------------------------
1797            * Opcode 3: Write
1798            * --------------
1799            * PAB 0: >03
1800            *     1: file type <--- error code
1801            *   2-3: data buffer address in VDP mem
1802            *     4:
1803            *     5: bytes to write
1804            *   6-7: record #
1805            *     8:
1806            *------------------------------------                                   
1807            *
1808  5084 06A0 WRITE   BL      @CALSUB                 call subroutine
1808  5086 4318  
1809  5088 518E         DATA    FFDRVP                  find FDR in VDP buffers
1810  508A 0240         ANDI    R0,>0600                keep only access mode
1810  508C 0600  
1811  508E 0280         CI      R0,>0400                is it input
1811  5090 0400  
1812  5092 1389         JEQ     H179                    yes: return with error illegal opcode
1813  5094 06A0         BL      @RFDRST                 get file status byte from FDR
1813  5096 51BA  
1814  5098 1113         JLT     H189                    var                     
1815  509A 06A0         BL      @RRNPAB                 fix: get rec # from PAB, sect # in R0
1815  509C 51CE  
1816  509E 1A0C         JL      H190                    less that total rec/file
1817  50A0 0429         BLWP    @>005A(R9)              past eof: expand file
1817  50A2 005A  
1818  50A4 D800         DATA    >D800                   save R0, R1, R3, R4
1819  50A6 C0C0         MOV     R0,R3                   desired sector offset
1820  50A8 06A0         BL      @CALSUB                 call subroutine
1820  50AA 4318  
1821  50AC 4620         DATA    APSCTS                  append enough sectors to reach offset in R3
1822  50AE 0429         BLWP    @>005A(R9)                      
1822  50B0 005A  
1823  50B2 D801         DATA    >D801                   restore R0, R1, R3, R4
1824  50B4 06A0         BL      @URFFDR                 update # of rec/file in FDR
1824  50B6 52D8  
1825            *                                       
1826  50B8 06A0 H190    BL      @CALSUB                 in file: call subroutine
1826  50BA 4318  
1827  50BC 5234         DATA    RRFDR                   fetch rec from disk into FDR data buffer area
1828  50BE 1053         JMP     H191                    set update data flag, write data, return
1829            *                                       
1830  50C0 06A0 H189    BL      @RCOFCB                 var: R2=sect/file R3=sect offset R0=rec offset
1830  50C2 530E  
1831  50C4 C0C3         MOV     R3,R3                   sector offset in file
1832  50C6 1101         JLT     H192                    -1: top of file
1833  50C8 100B         JMP     H193                    in file
1834  50CA 0429 H192    BLWP    @>005A(R9)              next sector loop
1834  50CC 005A  
1835  50CE 3000         DATA    >3000                   save R2 + R3
1836  50D0 06A0         BL      @CALSUB                 call subroutine
1836  50D2 4318  
1837  50D4 4556         DATA    UPDBF                   update data buffer if needed
1838  50D6 0429         BLWP    @>005A(R9)                      
1838  50D8 005A  
1839  50DA 3001         DATA    >3001                   retrieve R2 + R3
1840  50DC 0583         INC     R3                      next sector
1841  50DE 04C0         CLR     R0                      init char offset in sector
1842            *                                       
1843  50E0 8083 H193    C       R3,R2                   did we reach last sector?
1844  50E2 1609         JNE     H194                    no
1845  50E4 0429         BLWP    @>005A(R9)              yes: expand file
1845  50E6 005A  
1846  50E8 9000         DATA    >9000                   save R0 + R4
1847  50EA 06A0         BL      @CALSUB                 call subroutine
1847  50EC 4318  
1848  50EE 4620         DATA    APSCTS                  get last sector then append sectors to reach R3
1849  50F0 0429         BLWP    @>005A(R9)                      
1849  50F2 005A  
1850  50F4 9001         DATA    >9001                   retrieve R0 + R4
1851            *                                       
1852  50F6 C169 H194    MOV     @>0054(R9),R5           PAB ptr
1852  50F8 0054  
1853  50FA 0225         AI      R5,5                    point to char count
1853  50FC 0005  
1854  50FE 0429         BLWP    @>005A(R9)              set VDP to read
1854  5100 005A  
1855  5102 00A2         DATA    >00A2                   address in R5
1856  5104 D12F         MOVB    @-1026(R15),R4          get # of chars to write
1856  5106 FBFE  
1857  5108 0984         SRL     R4,8                    make it a word
1858  510A C144         MOV     R4,R5                   
1859  510C A140         A       R0,R5                   add current char offset in sector
1860  510E 0585         INC     R5                      make room for size byte
1861  5110 0285         CI      R5,>00FF                past end of sector?
1861  5112 00FF  
1862  5114 1BDA         JH      H192                    yes: not enough room, try next sector
1863  5116 0702         SETO    R2                      ok: rec will fit in sector
1864  5118 C069         MOV     @>0056(R9),R1           FDR ptr
1864  511A 0056  
1865  511C A045         A       R5,R1                   past-last-byte offset
1866  511E 0221         AI      R1,256                  ptr to data buffer area
1866  5120 0100  
1867  5122 0429         BLWP    @>005A(R9)              set VDP to write
1867  5124 005A  
1868  5126 0023         DATA    >0023                   address in R1
1869  5128 DBC2         MOVB    R2,@-2(R15)             write end-of-sect mark to FDR data buffer area
1869  512A FFFE  
1870  512C 0429         BLWP    @>005A(R9)                      
1870  512E 005A  
1871  5130 8000         DATA    >8000                   save R0 (current byte offset in sector)
1872  5132 C003         MOV     R3,R0                   
1873  5134 06A0         BL      @UCOFCB                 update sect + rec offsets in control block
1873  5136 52AC  
1874  5138 0221         AI      R1,18                   point to eof offset in FDR (R1 modified by UCOFCB)
1874  513A 0012  
1875  513C 0429         BLWP    @>005A(R9)              set VDP to write
1875  513E 005A  
1876  5140 0023         DATA    >0023                   address in R1
1877  5142 DBC5         MOVB    R5,@-2(R15)             update eof offset in last sector, in FDR
1877  5144 FFFE  
1878  5146 06A0         BL      @URFFDR                 update # of rec/file in FDR
1878  5148 52D8  
1879  514A 0429         BLWP    @>005A(R9)                      
1879  514C 005A  
1880  514E 2001         DATA    >2001                   retrieve old R0 in R2 (current byte offset)
1881  5150 C004         MOV     R4,R0                   record size
1882  5152 06A0         BL      @CALSUB                 call subroutine
1882  5154 4318  
1883  5156 5288         DATA    AFDRPT                  get FDR data buffer in R2, PAB data buffer in R1
1884  5158 06C4         SWPB    R4                      
1885  515A 0429         BLWP    @>005A(R9)              set VDP to write
1885  515C 005A  
1886  515E 0043         DATA    >0043                   address in R2
1887  5160 DBC4         MOVB    R4,@-2(R15)             write size byte to FDR data buffer
1887  5162 FFFE  
1888  5164 0582         INC     R2                      increment dest pointer
1889            *                                       
1890  5166 C0C2 H191    MOV     R2,R3                   invert source and dest
1891  5168 C081         MOV     R1,R2                   so we can use the same read-write loop
1892  516A C043         MOV     R3,R1                   than the read opcode
1893  516C C129         MOV     @>0056(R9),R4           FDR ptr
1893  516E 0056  
1894  5170 0604         DEC     R4                      pointer to drive # for that file
1895  5172 0429         BLWP    @>005A(R9)              set VDP to read
1895  5174 005A  
1896  5176 0082         DATA    >0082                   address in R4
1897  5178 D16F         MOVB    @-1026(R15),R5          get drive #
1897  517A FBFE  
1898  517C 0265         ORI     R5,>8000                add update data area flag
1898  517E 8000  
1899  5180 0429         BLWP    @>005A(R9)              set VDP to write
1899  5182 005A  
1900  5184 0083         DATA    >0083                   address in R4
1901  5186 DBC5         MOVB    R5,@-2(R15)             write back flagged byte
1901  5188 FFFE  
1902  518A 0460         B       @WFDRPB                 to read-write loop
1902  518C 4FFC  
1903            *                                       
1904  518E 06A0 FFDRVP  BL      @CALSUB                 find FDR in VDP buffer
1904  5190 4318  
1905  5192 4A64         DATA    FFFDRV                  find file FDR
1906  5194 C104         MOV     R4,R4                   found?
1907  5196 1303         JEQ     AFPGPF                  yes
1908  5198 06A0         BL      @ERROR5                 no: return with error
1908  519A 4932  
1909  519C E000         DATA    >E000                   file error
1910  519E 0581 AFPGPF  INC     R1                      point to filename in FDR
1911  51A0 CA41         MOV     R1,@>0056(R9)           new FDR ptr
1911  51A2 0056  
1912  51A4 C129         MOV     @>0054(R9),R4           get PAB ptr
1912  51A6 0054  
1913  51A8 0584         INC     R4                      point to status byte
1914  51AA 04C0         CLR     R0                      
1915  51AC 0429         BLWP    @>005A(R9)              set VDP to read
1915  51AE 005A  
1916  51B0 0082         DATA    >0082                   address in R4
1917  51B2 D02F         MOVB    @-1026(R15),R0          get file status
1917  51B4 FBFE  
1918  51B6 0460         B       @RTURN1                 return to caller
1918  51B8 4336  
1919            *                                       
1920  51BA C129 RFDRST  MOV     @>0056(R9),R4           get status byte from FDR
1920  51BC 0056  
1921  51BE 0224         AI      R4,12                   point to status byte
1921  51C0 000C  
1922  51C2 0429         BLWP    @>005A(R9)              set VDP to read
1922  51C4 005A  
1923  51C6 0082         DATA    >0082                   address in R4
1924  51C8 D02F         MOVB    @-1026(R15),R0          read status byte
1924  51CA FBFE  
1925  51CC 045B         B       *R11                    
1926            *                                       
1927  51CE D16F RRNPAB  MOVB    @-1026(R15),R5          get record # from PAB, check if valid
1927  51D0 FBFE  
1928  51D2 0985         SRL     R5,8                    
1929  51D4 1602         JNE     H195                    get # of rec/sector from FDR
1930  51D6 0205         LI      R5,256                  0: default to 256
1930  51D8 0100  
1931  51DA C0E9 H195    MOV     @>0054(R9),R3           PAB ptr
1931  51DC 0054  
1932  51DE 0223         AI      R3,6                    point to rec #
1932  51E0 0006  
1933  51E2 0429         BLWP    @>005A(R9)              set VDP to read
1933  51E4 005A  
1934  51E6 0062         DATA    >0062                   address in R3
1935  51E8 D06F         MOVB    @-1026(R15),R1          get record # from PAB
1935  51EA FBFE  
1936  51EC 06C1         SWPB    R1                      
1937  51EE D06F         MOVB    @-1026(R15),R1                  
1937  51F0 FBFE  
1938  51F2 06C1         SWPB    R1                      
1939  51F4 C001         MOV     R1,R0                   save it
1940  51F6 1101         JLT     H196                    too big
1941  51F8 1003         JMP     H197                    ok
1942  51FA 06A0 H196    BL      @ERROR5                 update data then return with error
1942  51FC 4932  
1943  51FE 8000         DATA    >8000                   memory full
1944  5200 0580 H197    INC     R0                      next record
1945  5202 0429         BLWP    @>005A(R9)              set VDP to write
1945  5204 005A  
1946  5206 0063         DATA    >0063                   address in R3
1947  5208 DBC0         MOVB    R0,@-2(R15)             write back # of future record
1947  520A FFFE  
1948  520C 06C0         SWPB    R0                      
1949  520E DBC0         MOVB    R0,@-2(R15)                     
1949  5210 FFFE  
1950  5212 04C0         CLR     R0                      
1951  5214 C0C1         MOV     R1,R3                   save # of desired rec
1952  5216 3C05         DIV     R5,R0                   divide by # of rec/sector = sect # in R0
1953  5218 C0A9 RNFISE  MOV     @>0056(R9),R2           FDR ptr
1953  521A 0056  
1954  521C 0222         AI      R2,18                   point to total # of rec (# of sectors for var)
1954  521E 0012  
1955  5220 0429         BLWP    @>005A(R9)              set VDP to read
1955  5222 005A  
1956  5224 0042         DATA    >0042                   address in R2
1957  5226 D0AF         MOVB    @-1026(R15),R2          get total # of recs/file (sect/file for var)
1957  5228 FBFE  
1958  522A 06C2         SWPB    R2                      
1959  522C D0AF         MOVB    @-1026(R15),R2          remember: bytes are swapped
1959  522E FBFE  
1960  5230 8083         C       R3,R2                   compare with desired record (ignored by var)
1961  5232 045B         B       *R11                    
1962            *                                       
1963  5234 0429 RRFDR   BLWP    @>005A(R9)              fetch record into FDR data buffer area
1963  5236 005A  
1964  5238 4000         DATA    >4000                   save R1
1965  523A 0224         AI      R4,-18                  ptr to top of control block
1965  523C FFEE  
1966  523E 0429         BLWP    @>005A(R9)              set VDP to read
1966  5240 005A  
1967  5242 0082         DATA    >0082                   address in R4
1968  5244 D16F         MOVB    @-1026(R15),R5          get current sector offset in file
1968  5246 FBFE  
1969  5248 06C5         SWPB    R5                      
1970  524A D16F         MOVB    @-1026(R15),R5                  
1970  524C FBFE  
1971  524E 0B85         SRC     R5,8                    
1972  5250 1105         JLT     H198                    -1: top of file
1973  5252 8005         C       R5,R0                   compare with desired offset (from RRNPAB)
1974  5254 130B         JEQ     H199                    same
1975  5256 06A0         BL      @CALSUB                 call subroutine
1975  5258 4318  
1976  525A 4556         DATA    UPDBF                   update data buffer if needed
1977  525C C0C0 H198    MOV     R0,R3                   desired sector offset in file
1978  525E 06A0         BL      @UCOFCB                 update sect + rec offsets in control block
1978  5260 52AC  
1979  5262 0227         AI      R7,256                  point to data buffer area (R7 set by UCOFCB)
1979  5264 0100  
1980  5266 06A0         BL      @CALSUB                 call subroutine
1980  5268 4318  
1981  526A 45EA         DATA    RDOFSC                  read a sector from offset in file (in R3)
1982  526C 0429 H199    BLWP    @>005A(R9)                      
1982  526E 005A  
1983  5270 4001         DATA    >4001                   retrieve R1
1984  5272 C0E9         MOV     @>0056(R9),R3           FDR ptr
1984  5274 0056  
1985  5276 0223         AI      R3,17                   point to record length
1985  5278 0011  
1986  527A 0429         BLWP    @>005A(R9)              set VDP to read
1986  527C 005A  
1987  527E 0062         DATA    >0062                   address in R3
1988  5280 D02F         MOVB    @-1026(R15),R0          get rec length in bytes
1988  5282 FBFE  
1989  5284 0980         SRL     R0,8                    make it a word
1990  5286 3840         MPY     R0,R1                   calc file offset in bytes
1991  5288 A0A9 AFDRPT  A       @>0056(R9),R2           add FDR ptr
1991  528A 0056  
1992  528C 0222         AI      R2,256                  point inside data buffer area
1992  528E 0100  
1993  5290 C0E9         MOV     @>0054(R9),R3           PAB ptr
1993  5292 0054  
1994  5294 05C3         INCT    R3                      point to data buffer address
1995  5296 0429         BLWP    @>005A(R9)              set VDP to read
1995  5298 005A  
1996  529A 0062         DATA    >0062                   address in R3
1997  529C D06F         MOVB    @-1026(R15),R1          get PAB data buffer address
1997  529E FBFE  
1998  52A0 06C1         SWPB    R1                      
1999  52A2 D06F         MOVB    @-1026(R15),R1                  
1999  52A4 FBFE  
2000  52A6 06C1         SWPB    R1                      
2001  52A8 0460         B       @RTURN1                 return
2001  52AA 4336  
2002            *                               
2003  52AC C1E9 UCOFCB  MOV     @>0056(R9),R7           update sect + rec offsets in control block
2003  52AE 0056  
2004  52B0 C047         MOV     R7,R1                   FDR ptr
2005  52B2 0221         AI      R1,-6                   top of file control block
2005  52B4 FFFA  
2006  52B6 0429         BLWP    @>005A(R9)              set VDP to write
2006  52B8 005A  
2007  52BA 0023         DATA    >0023                   address in R1
2008  52BC DBC0         MOVB    R0,@-2(R15)             current sector offset in file
2008  52BE FFFE  
2009  52C0 06C0         SWPB    R0                      
2010  52C2 DBC0         MOVB    R0,@-2(R15)                     
2010  52C4 FFFE  
2011  52C6 0221         AI      R1,4                    point to var rec offset in sector
2011  52C8 0004  
2012  52CA 06C5         SWPB    R5                      
2013  52CC 0429         BLWP    @>005A(R9)              set VDP to write
2013  52CE 005A  
2014  52D0 0023         DATA    >0023                   address in R1
2015  52D2 DBC5         MOVB    R5,@-2(R15)             first free byte in current sector
2015  52D4 FFFE  
2016  52D6 045B         B       *R11                    
2017            *                                       
2018  52D8 C0A9 URFFDR  MOV     @>0056(R9),R2           update # of rec/file in FDR
2018  52DA 0056  
2019  52DC 0429         BLWP    @>005A(R9)              set VDP to read
2019  52DE 005A  
2020  52E0 0042         DATA    >0042                   address in R2 (FDR ptr)
2021  52E2 D2AF         MOVB    @-1026(R15),R10         get first char of filename
2021  52E4 FBFE  
2022  52E6 026A         ORI     R10,>8000               set was modified flag
2022  52E8 8000  
2023  52EA 0429         BLWP    @>005A(R9)              set VDP to write
2023  52EC 005A  
2024  52EE 0043         DATA    >0043                   address in R2
2025  52F0 DBCA         MOVB    R10,@-2(R15)            write flagged char back
2025  52F2 FFFE  
2026  52F4 0222         AI      R2,18                   point to # of recs/file in FDR
2026  52F6 0012  
2027  52F8 0583         INC     R3                      one more
2028  52FA 0429         BLWP    @>005A(R9)              set VDP to write
2028  52FC 005A  
2029  52FE 0043         DATA    >0043                   address in R2
2030  5300 06C3         SWPB    R3                      update # of recs/file
2031  5302 DBC3         MOVB    R3,@-2(R15)                     
2031  5304 FFFE  
2032  5306 06C3         SWPB    R3                      
2033  5308 DBC3         MOVB    R3,@-2(R15)                     
2033  530A FFFE  
2034  530C 045B         B       *R11                    
2035            *                                       
2036  530E C229 RCOFCB  MOV     @>0056(R9),R8           get rec offset, compare sect with total
2036  5310 0056  
2037  5312 C108         MOV     R8,R4                   FDR ptr
2038  5314 0224         AI      R4,256                  point to data buffer area
2038  5316 0100  
2039  5318 0648         DECT    R8                      point to var record offset
2040  531A 0429         BLWP    @>005A(R9)              set VDP to read
2040  531C 005A  
2041  531E 0102         DATA    >0102                   address in R8
2042  5320 D0AF         MOVB    @-1026(R15),R2          get var rec offset in current sector
2042  5322 FBFE  
2043  5324 0982         SRL     R2,8                    make it a word
2044  5326 C28B         MOV     R11,R10                 save return point
2045  5328 06A0         BL      @FDR2B2                 get 2 bytes from FDR (at R8-4) into R0
2045  532A 4834  
2046  532C FFFC         DATA    -4                      current sector offset in file
2047  532E C0C0         MOV     R0,R3                   save it
2048  5330 C2CA         MOV     R10,R11                 restore return point
2049  5332 C002         MOV     R2,R0                   var record offset
2050  5334 0460         B       @RNFISE                 get # of sect/file from FDR, return
2050  5336 5218  
2051            *
2052            *------------------------------------
2053            * Opcode 4: Rewind
2054            * --------------
2055            * PAB 0: >04
2056            *     1: file type <--- error code
2057            *   2-3:
2058            *     4:
2059            *     5:
2060            *   6-7: record #  <--- >0000 if sequential
2061            *     8:
2062            *------------------------------------                                   
2063            *
2064  5338 06A0 RWIND1  BL      @CALSUB                 call subroutine
2064  533A 4318  
2065  533C 518E         DATA    FFDRVP                  find FDR in VDP buffers, read status from PAB
2066  533E 0429         BLWP    @>005A(R9)                      
2066  5340 005A  
2067  5342 8000         DATA    >8000                   save R0 (status from PAB)
2068  5344 0240         ANDI    R0,>0600                keep only access mode
2068  5346 0600  
2069  5348 1305         JEQ     H200                    update is ok
2070  534A 0280         CI      R0,>0400                is it input?
2070  534C 0400  
2071  534E 1302         JEQ     H200                    yes: ok
2072  5350 0460         B       @ERROR8                 output or append: return with illegal opcode
2072  5352 4D78  
2073  5354 06A0 H200    BL      @CALSUB                 call subroutine
2073  5356 4318  
2074  5358 4556         DATA    UPDBF                   update data buffer if needed
2075  535A 0429         BLWP    @>005A(R9)                      
2075  535C 005A  
2076  535E 8001         DATA    >8001                   retrieve R0 (status from PAB)
2077  5360 0240         ANDI    R0,>0100                sequential or reloc?
2077  5362 0100  
2078  5364 1611         JNE     H201                    reloc: don't do anything, return
2079            *                                       
2080  5366 04C2 RWIND2  CLR     R2                      rewind file: record offset = 0
2081  5368 0703         SETO    R3                      current record = -1 (none)
2082  536A 06A0         BL      @UPDFCB                 update file control block
2082  536C 4F68  
2083  536E 04C0         CLR     R0                      record 0
2084  5370 C229         MOV     @>0054(R9),R8           get PAB ptr
2084  5372 0054  
2085  5374 0228         AI      R8,6                    point to record #
2085  5376 0006  
2086  5378 0429         BLWP    @>005A(R9)              set VDP to write
2086  537A 005A  
2087  537C 0103         DATA    >0103                   address in R8
2088  537E DBC0         MOVB    R0,@-2(R15)             write record #
2088  5380 FFFE  
2089  5382 1000         NOP                             
2090  5384 DBC0         MOVB    R0,@-2(R15)                     
2090  5386 FFFE  
2091  5388 0460 H201    B       @RTURN1                 return to caller
2091  538A 4336  
2092            *
2093            *------------------------------------
2094            * Opcode 5: Load
2095            * --------------
2096            * PAB 0: >05
2097            *     1: file type  <--- error code
2098            *   2-3: data buffer address in VDP mem
2099            *     4:
2100            *     5:
2101            *   6-7: maximum # of bytes (size of buffer)
2102            *     8:
2103            *------------------------------------                                   
2104            *
2105  538C 06A0 LOAD    BL      @CALSUB                 call subroutine
2105  538E 4318  
2106  5390 4AC2         DATA    FNDFDR                  find FDR on disk
2107  5392 C104         MOV     R4,R4                   found?
2108  5394 1303         JEQ     H203                    yes
2109  5396 06A0 H202    BL      @ERROR5                 no: return with error
2109  5398 4932  
2110  539A E000         DATA    >E000                   file error
2111  539C 06A0 H203    BL      @FDR2B1                 get 2 bytes from FDR into R0
2111  539E 4830  
2112  53A0 000C         DATA    12                      file status byte
2113  53A2 0240         ANDI    R0,>0100                is it program?
2113  53A4 0100  
2114  53A6 13F7         JEQ     H202                    no: file error
2115  53A8 05C8         INCT    R8                      point to # of sect/file in FDR
2116  53AA 0429         BLWP    @>005A(R9)              set VDP to read
2116  53AC 005A  
2117  53AE 0102         DATA    >0102                   address in R8
2118  53B0 D06F         MOVB    @-1026(R15),R1          get # of sectors in file
2118  53B2 FBFE  
2119  53B4 06C1         SWPB    R1                      
2120  53B6 D06F         MOVB    @-1026(R15),R1                  
2120  53B8 FBFE  
2121  53BA 0B81         SRC     R1,8                    
2122  53BC 13EC         JEQ     H202                    0=empty file: return with file error
2123  53BE 06A0         BL      @RBANB                  get data buffer address in R7, # of sectors in R2
2123  53C0 547E  
2124  53C2 05C8         INCT    R8                      point to eof offset in FDR
2125  53C4 04C4         CLR     R4                      
2126  53C6 0429         BLWP    @>005A(R9)              set VDP to read
2126  53C8 005A  
2127  53CA 0102         DATA    >0102                   address in R8
2128  53CC D12F         MOVB    @-1026(R15),R4          get # of bytes in last sector
2128  53CE FBFE  
2129  53D0 8081         C       R1,R2                   compare # of sect with max in PAB
2130  53D2 1BE1         JH      H202                    file is too big: return with file error
2131  53D4 1602         JNE     H204                    file is smaller
2132  53D6 8100         C       R0,R4                   same # of sect: check bytes in last sector
2133  53D8 1ADE         JL      H202                    file is too big: file error
2134  53DA 04C3 H204    CLR     R3                      sector offset in file
2135  53DC 06C4         SWPB    R4                      
2136  53DE 0601 H206    DEC     R1                      next sector
2137  53E0 130D         JEQ     H205                    done
2138  53E2 0429         BLWP    @>005A(R9)                      
2138  53E4 005A  
2139  53E6 D900         DATA    >D900                   save R0, R1, R3, R4, R7
2140  53E8 06A0         BL      @CALSUB                 call subroutine
2140  53EA 4318  
2141  53EC 45EA         DATA    RDOFSC                  read a sector from offset in R3
2142  53EE 0429         BLWP    @>005A(R9)              restore R0, R1, R3, R4, R7
2142  53F0 005A  
2143  53F2 D901         DATA    >D901                   
2144  53F4 0583         INC     R3                      next sector
2145  53F6 0227         AI      R7,256                  256 bytes further in PAB buffer
2145  53F8 0100  
2146  53FA 10F1         JMP     H206                    keep going
2147            *                                       
2148  53FC C104 H205    MOV     R4,R4                   
2149  53FE 1604         JNE     H207                    
2150  5400 06A0         BL      @CALSUB                 call subroutine
2150  5402 4318  
2151  5404 45EA         DATA    RDOFSC                  read a sector from offset in R3
2152  5406 1011         JMP     H208                    done
2153            *                                       
2154  5408 C147 H207    MOV     R7,R5                   save PAB data buffer ptr
2155  540A C1E9         MOV     @>0056(R9),R7           FDR ptr
2155  540C 0056  
2156  540E 0227         AI      R7,256                  point to FDR data area
2156  5410 0100  
2157  5412 0429         BLWP    @>005A(R9)                      
2157  5414 005A  
2158  5416 0D00         DATA    >0D00                   save R4, R5, R7
2159  5418 06A0         BL      @CALSUB                 call subroutine
2159  541A 4318  
2160  541C 45EA         DATA    RDOFSC                  read a sector from offset in R3
2161  541E 0429         BLWP    @>005A(R9)              restore R4 in R0, R5 in R1, R7 in R2
2161  5420 005A  
2162  5422 E001         DATA    >E001                   
2163  5424 06A0         BL      @CALSUB                 call subroutine
2163  5426 4318  
2164  5428 4FFC         DATA    WFDRPB                  write bytes from FDR data buffer to PAB data buf
2165  542A 0460 H208    B       @UPDFDR                 update FDR, data buffer, VIB and return to caller
2165  542C 4536  
2166            *
2167            *------------------------------------
2168            * Opcode 6: Save
2169            * --------------
2170            * PAB 0: >06
2171            *     1: file type  <--- error code
2172            *   2-3: data buffer address in VDP mem
2173            *     4:
2174            *     5:
2175            *   6-7: # of bytes to save
2176            *     8:
2177            *------------------------------------                                   
2178            *
2179  542E 06A0 SAVE    BL      @CALSUB                 call subroutine
2179  5430 4318  
2180  5432 4450         DATA    CRFIL1                  create file
2181  5434 06A0         BL      @RBANB                  get PAB buffer ptr + # of bytes
2181  5436 547E  
2182  5438 04C3         CLR     R3                      sector offset 0
2183  543A 0429 H209    BLWP    @>005A(R9)                      
2183  543C 005A  
2184  543E B100         DATA    >B100                   save R0, R2, R3, R7
2185  5440 06A0         BL      @CALSUB                 call subroutine
2185  5442 4318  
2186  5444 460A         DATA    WROFSC                  write sector to offset in R3
2187  5446 0429         BLWP    @>005A(R9)                      
2187  5448 005A  
2188  544A B101         DATA    >B101                   retrieve R0, R2, R3, R7
2189  544C 0583         INC     R3                      next sector
2190  544E 0227         AI      R7,256                  256 bytes further in PAB data buffer
2190  5450 0100  
2191  5452 0602         DEC     R2                      next sector
2192  5454 16F2         JNE     H209                    more to do
2193            *                                       
2194  5456 C069         MOV     @>0056(R9),R1           FDR ptr
2194  5458 0056  
2195  545A 0221         AI      R1,12                   point to file status byte
2195  545C 000C  
2196  545E 0202         LI      R2,>0100                value for program file
2196  5460 0100  
2197  5462 0429         BLWP    @>005A(R9)              set VDP to write
2197  5464 005A  
2198  5466 0023         DATA    >0023                   address in R1
2199  5468 DBC2         MOVB    R2,@-2(R15)             write file status byte in FDR
2199  546A FFFE  
2200  546C 0221         AI      R1,4                    point to eof offset byte in FDR
2200  546E 0004  
2201  5470 0429         BLWP    @>005A(R9)              set VDP to write
2201  5472 005A  
2202  5474 0023         DATA    >0023                   address in R1
2203  5476 DBC0         MOVB    R0,@-2(R15)             # of bytes in last sector
2203  5478 FFFE  
2204  547A 0460         B       @UPDFDR                 update FDR, data buffer, VIB then return to caller
2204  547C 4536  
2205            *                                       
2206  547E C029 RBANB   MOV     @>0054(R9),R0           get buffer address + # of bytes
2206  5480 0054  
2207  5482 05C0         INCT    R0                      data buffer in PAB
2208  5484 0429         BLWP    @>005A(R9)              set VDP to read
2208  5486 005A  
2209  5488 0002         DATA    >0002                   address in R0
2210  548A D1EF         MOVB    @-1026(R15),R7          get data buffer address
2210  548C FBFE  
2211  548E 06C7         SWPB    R7                      
2212  5490 D1EF         MOVB    @-1026(R15),R7                  
2212  5492 FBFE  
2213  5494 06C7         SWPB    R7                      
2214  5496 0220         AI      R0,4                    point to # of bytes to transfer
2214  5498 0004  
2215  549A 0429         BLWP    @>005A(R9)              set VDP to read
2215  549C 005A  
2216  549E 0002         DATA    >0002                   address in R0
2217  54A0 D0AF         MOVB    @-1026(R15),R2          get # of bytes to be transfered
2217  54A2 FBFE  
2218  54A4 0982         SRL     R2,8                    make it # of sectors (256 bytes each)
2219  54A6 04C0         CLR     R0                      
2220  54A8 D02F         MOVB    @-1026(R15),R0          see if one more is needed
2220  54AA FBFE  
2221  54AC 1301         JEQ     H210                    no
2222  54AE 0582         INC     R2                      yes: one more sector
2223  54B0 045B H210    B       *R11                    
2224            *
2225            *-------------------------------------
2226            * Opcode 9: Status
2227            * --------------
2228            * PAB 0: >09
2229            *     1:
2230            *   2-3:
2231            *     4:
2232            *     5:
2233            *   6-7: record #
2234            *     8:           <--- file status
2235            *
2236            * Status bits, returned in PAB byte 8:
2237            * >80: file not found
2238            * >40: file is protected
2239            * >20:
2240            * >10: internal (else display or program)
2241            * >08: program file
2242            * >04: variable (else fixed or program)
2243            * >02: memory full
2244            * >01: end-of-file reached
2245            *-------------------------------------                                  
2246            *
2247  54B2 06A0 STATUS  BL      @CALSUB                 call subroutine
2247  54B4 4318  
2248  54B6 4A64         DATA    FFFDRV                  save filename in comp buf, then find FDR in VDP
2249  54B8 C104         MOV     R4,R4                   found?
2250  54BA 1310         JEQ     H211                    yes
2251            *                                       
2252  54BC 06A0         BL      @CALSUB                 no: call subroutine
2252  54BE 4318  
2253  54C0 4ACC         DATA    FFDRDK                  find FDR on disk
2254  54C2 0200         LI      R0,>8000                value for file not found
2254  54C4 8000  
2255  54C6 C104         MOV     R4,R4                   found?
2256  54C8 1649         JNE     H212                    no: return with that value
2257  54CA C069         MOV     @>0056(R9),R1           yes: ptr to FDR
2257  54CC 0056  
2258  54CE 04C2         CLR     R2                      
2259  54D0 0429         BLWP    @>005A(R9)              set VDP to write
2259  54D2 005A  
2260  54D4 0023         DATA    >0023                   address in R1
2261  54D6 DBC2         MOVB    R2,@-2(R15)             invalidate that FDR (file not open)
2261  54D8 FFFE  
2262  54DA 1036         JMP     H213                    transfer FDR status to PAB status byte
2263            *                                       
2264  54DC 06A0 H211    BL      @CALSUB                 file is open: call subroutine
2264  54DE 4318  
2265  54E0 519E         DATA    AFPGPF                  adjust FDR ptr, get PAB file type into R4
2266  54E2 06A0         BL      @RFDRST                 get status byte from FDR
2266  54E4 51BA  
2267  54E6 1101         JLT     H214                    var
2268  54E8 1006         JMP     H215                    fix
2269            *                                       
2270  54EA 06A0 H214    BL      @CALSUB                 var: call subroutine
2270  54EC 4318  
2271  54EE 5020         DATA    RRSEC                   load wanted sector, point to wanted rec in buffer
2272  54F0 1013         JMP     H216                    out of range
2273  54F2 04C2         CLR     R2                      ok: clear flag
2274  54F4 1029         JMP     H213                    copy status byte from FDR into PAB, return
2275            *                                       
2276  54F6 D16F H215    MOVB    @-1026(R15),R5          fix: get rec/sect byte
2276  54F8 FBFE  
2277  54FA 0985         SRL     R5,8                    make it a word
2278  54FC 1602         JNE     H217                    
2279  54FE 0205         LI      R5,>0100                00 (program files) means 256
2279  5500 0100  
2280  5502 06A0 H217    BL      @PABR2B                 get 2 bytes from PAB into R0
2280  5504 482A  
2281  5506 0006         DATA    6                       # of wanted record
2282  5508 C0C0         MOV     R0,R3                   save it
2283  550A 111C         JLT     H218                    too big: set memory full bit in PAB status byte
2284  550C 06A0         BL      @RNFISE                 get # recs/file into R2, comp with R3
2284  550E 5218  
2285  5510 04C2         CLR     R2                      
2286  5512 1A1A         JL      H213                    in file: copy file type bits, return
2287  5514 3C85         DIV     R5,R2                   how many sectors do we need?
2288  5516 C0C2         MOV     R2,R3                   save result
2289            *                                       
2290  5518 06A0 H216    BL      @FDR2B1                 get 2 bytes from FDR into R0
2290  551A 4830  
2291  551C 000E         DATA    14                      # of sectors/file
2292  551E 0583         INC     R3                      plus 1 sector for FDR
2293  5520 0202         LI      R2,>0100                value for eof reached in PAB status
2293  5522 0100  
2294  5524 60C0         S       R0,R3                   are there enough sectors in file for these recs?
2295  5526 1501         JGT     H219                    
2296  5528 100F         JMP     H213                    yes: we reached the eof
2297  552A 06A0 H219    BL      @CALSUB                 call subroutine
2297  552C 4318  
2298  552E 4992         DATA    RWVIB                   load VIB (sector 0)
2299  5530 C103         MOV     R3,R4                   number of sectors that will be needed
2300  5532 C205         MOV     R5,R8                   VIB ptr
2301  5534 0228         AI      R8,10                   skip 10 bytes (required by CFSVIB)
2301  5536 000A  
2302  5538 06A0         BL      @CFSVIB                 count free sectors in bitmap, into R3
2302  553A 5726  
2303  553C 0202         LI      R2,>0100                value for eof reached
2303  553E 0100  
2304  5540 8103         C       R3,R4                   are there that many free sectors?
2305  5542 1402         JHE     H213                    yes
2306  5544 0202 H218    LI      R2,>0200                value for memory full
2306  5546 0200  
2307            *                                       
2308  5548 06A0 H213    BL      @FDR2B1                 get 2 bytes from FDR into R0
2308  554A 4830  
2309  554C 000C         DATA    12                      file status byte
2310  554E 0240         ANDI    R0,>8F00                mask irrelevant bits
2310  5550 8F00  
2311  5552 1502         JGT     H220                    
2312  5554 0260         ORI     R0,>0080                var: put var bit in PAB status style
2312  5556 0080  
2313  5558 0A30 H220    SLA     R0,3                    get rid of var bit in FDR style
2314  555A F002         SOCB    R2,R0                   add eof and mem full bits
2315            *                                       
2316  555C C069 H212    MOV     @>0054(R9),R1           PAB ptr
2316  555E 0054  
2317  5560 0221         AI      R1,8                    point to bias/status return byte
2317  5562 0008  
2318  5564 0429         BLWP    @>005A(R9)              set VDP to write
2318  5566 005A  
2319  5568 0023         DATA    >0023                   address in R1
2320  556A DBC0         MOVB    R0,@-2(R15)             write file status to PAB
2320  556C FFFE  
2321  556E 0460         B       @RTURN1                 return to caller
2321  5570 4336  
2322            *
2323            *---------------------------------
2324            * Disk directory access
2325            * ---------------------
2326            * The directory is accessed by omiting the filename in the DSR name: "DSK1."
2327            * It must be opened for input only, as an Int/Fix 38 file.
2328            * It consists in upto 128 records, the first one contains the disk informations,
2329            * the others the informations for upto 127 files (in alphabetical order).
2330            * Each record consists in an ascii string and three floating point numbers.
2331            *
2332            * Record 0 contains:
2333            * - Diskname (an ascii string of upto 10 chars).
2334            * - The number zero.
2335            * - The number of sectors on disk.
2336            * - The number of free sectors on disk.
2337            *
2338            * Other records contain:
2339            * - Filename (an ascii string of upto 10 chars).
2340            * - Filetype: 1=D/F, 2=D/V, 3=I/F, 4=I/V, 5=Prog, 0=end of directory.
2341            *   If the file is protected, this number is negative (-1=D/F, etc).
2342            * - File size in sectors (including the FDR itself).
2343            * - File record length (0 for programs).
2344            *---------------------------------
2345             
2346            *---------------------------------
2347            * Open disk directory pseudo-file
2348            *---------------------------------                                      
2349            *
2350  5572 D02F OPNDIR  MOVB    @-1026(R15),R0          get file type from PAB
2350  5574 FBFE  
2351  5576 0240         ANDI    R0,>1E00                mask irrelavant bits (rel/seq)
2351  5578 1E00  
2352  557A 0280         CI      R0,>0C00                is it int/fix in output mode?
2352  557C 0C00  
2353  557E 1303         JEQ     H221                    yes
2354  5580 06A0 H223    BL      @RETERR                 return with error
2354  5582 495E  
2355  5584 4000         DATA    >4000                   bad attributes
2356  5586 06A0 H221    BL      @PABR2B                 get 2 bytes from PAB into R0
2356  5588 482A  
2357  558A 0004         DATA    4                       rec length
2358  558C 0980         SRL     R0,8                    make it a word
2359  558E 1303         JEQ     H222                    >00= default: set it to 38
2360  5590 0280         CI      R0,>0026                is it 38?
2360  5592 0026  
2361  5594 16F5         JNE     H223                    no: return with bad attributes error
2362  5596 0200 H222    LI      R0,>2600                set rec len to 38
2362  5598 2600  
2363  559A 0429         BLWP    @>005A(R9)              set VDP to write
2363  559C 005A  
2364  559E 0103         DATA    >0103                   address in R8 (from PABR2B)
2365  55A0 DBC0         MOVB    R0,@-2(R15)             write rec len to PAB
2365  55A2 FFFE  
2366            *                                       
2367  55A4 04C7         CLR     R7                      
2368  55A6 06A0         BL      @FNDRV                  find matching drive in file control blocks
2368  55A8 5760  
2369  55AA 55B2         DATA    H224                    go there if not found
2370  55AC 06A0 ERRR10  BL      @ERROR5                 update data then return with error
2370  55AE 4932  
2371  55B0 E000         DATA    >E000                   file error
2372  55B2 C1C7 H224    MOV     R7,R7                   did we find a free slot?
2373  55B4 1603         JNE     H225                    yes
2374  55B6 06A0         BL      @RETERR                 no: return with error
2374  55B8 495E  
2375  55BA 8000         DATA    >8000                   memory full
2376  55BC 0429 H225    BLWP    @>005A(R9)              set VDP to write
2376  55BE 005A  
2377  55C0 00E3         DATA    >00E3                   address in R7
2378  55C2 DBC3         MOVB    R3,@-2(R15)             write drive #
2378  55C4 FFFE  
2379  55C6 06C3         SWPB    R3                      
2380  55C8 DBC3         MOVB    R3,@-2(R15)             and a space as filename (illegal, indicates dir)
2380  55CA FFFE  
2381  55CC 0460         B       @RTURN1                 return to caller
2381  55CE 4336  
2382            *
2383            *---------------------------------
2384            * Close disk directory
2385            *---------------------------------                                      
2386  55D0 06A0 CLSDIR  BL      @FNDRV                  find matching drive in file control blocks
2386  55D2 5760  
2387  55D4 55AC         DATA    ERRR10                  go there if not found: return with file error
2388  55D6 04C0         CLR     R0                      
2389  55D8 0429         BLWP    @>005A(R9)              set VDP to write
2389  55DA 005A  
2390  55DC 0103         DATA    >0103                   address in R8
2391  55DE DBC0         MOVB    R0,@-2(R15)             clear drive #
2391  55E0 FFFE  
2392  55E2 0460         B       @RTURN1                 return to caller
2392  55E4 4336  
2393            *
2394            *---------------------------------
2395            * Read a record from disk directory
2396            *---------------------------------                                      
2397            *
2398  55E6 06A0 RDDIR   BL      @FNDRV                  find matching drive in file control blocks
2398  55E8 5760  
2399  55EA 55AC         DATA    ERRR10                  go ther it not found: return with file error
2400  55EC 0588         INC     R8                      
2401  55EE C148         MOV     R8,R5                   save ptr to FDR
2402  55F0 06A0         BL      @PABR2B                 get 2 bytes from PAB into R0
2402  55F2 482A  
2403  55F4 0006         DATA    6                       record #
2404  55F6 C080         MOV     R0,R2                   save it
2405  55F8 0582         INC     R2                      
2406  55FA 0429         BLWP    @>005A(R9)              set VDP to write
2406  55FC 005A  
2407  55FE 0103         DATA    >0103                   address in R8
2408  5600 DBC2         MOVB    R2,@-2(R15)             write record number in FDR
2408  5602 FFFE  
2409  5604 06C2         SWPB    R2                      after first char of filename!
2410  5606 DBC2         MOVB    R2,@-2(R15)                     
2410  5608 FFFE  
2411  560A 0A10         SLA     R0,1                    since two byte per file ptr
2412  560C D000         MOVB    R0,R0                   is rec # greater than 128?
2413  560E 1303         JEQ     H226                    no
2414  5610 06A0         BL      @ERROR5                 yes: update data then return with error
2414  5612 4932  
2415  5614 A000         DATA    >A000                   past eof
2416  5616 0702 H226    SETO    R2                      code for read
2417  5618 C100         MOV     R0,R4                   record #
2418  561A 133B         JEQ     H227                    0=disk parameters
2419  561C 0204         LI      R4,1                    sector #1
2419  561E 0001  
2420  5620 06A0         BL      @CALSUB                 call subroutine
2420  5622 4318  
2421  5624 4A0E         DATA    RWSEC                   read sector into buffer in R5
2422  5626 C205         MOV     R5,R8                   buffer ptr
2423  5628 0225         AI      R5,255                  point to data buffer area in this ctrl block
2423  562A 00FF  
2424  562C 0640         DECT    R0                      don't count record 0
2425  562E A200         A       R0,R8                   point to desired file ptr
2426  5630 06A0         BL      @VDPR2B                 get two byte from VDP at R8 into R0
2426  5632 4836  
2427  5634 C100         MOV     R0,R4                   sector where that FDR is to be found
2428  5636 1328         JEQ     H228                    no more
2429  5638 06A0         BL      @CALSUB                 call subroutine
2429  563A 4318  
2430  563C 4A0E         DATA    RWSEC                   read FDR sector into data buffer area
2431  563E 06A0         BL      @FDR2B1                 get 2 bytes from FDR into R0
2431  5640 4830  
2432  5642 010E         DATA    270                     # of sect/file
2433  5644 C180         MOV     R0,R6                   save it to output file size
2434  5646 0586         INC     R6                      include the FDR itself
2435  5648 D0EF         MOVB    @-1026(R15),R3          ignore eof offset
2435  564A FBFE  
2436  564C 0202         LI      R2,>0A00                10 chars per filename
2436  564E 0A00  
2437  5650 D0EF         MOVB    @-1026(R15),R3          get rec length
2437  5652 FBFE  
2438  5654 0983         SRL     R3,8                    make it a word
2439  5656 0648         DECT    R8                      point to status byte in FDR
2440  5658 0429         BLWP    @>005A(R9)              set VDP to read
2440  565A 005A  
2441  565C 0102         DATA    >0102                   address in R8
2442  565E D02F         MOVB    @-1026(R15),R0          get file status byte
2442  5660 FBFE  
2443  5662 C1C0         MOV     R0,R7                   
2444  5664 0240         ANDI    R0,>0800                keep only write protected bit
2444  5666 0800  
2445  5668 51C0         SZCB    R0,R7                   clear write protected bit (if it was set)
2446  566A 0987         SRL     R7,8                    make it a word
2447  566C 0587         INC     R7                      types are numbered from 1
2448  566E 0287         CI      R7,>0002                is it a program file?
2448  5670 0002  
2449  5672 1602         JNE     H229                    no
2450  5674 0227         AI      R7,3                    yes: make it type 5
2450  5676 0003  
2451  5678 0287 H229    CI      R7,>0008                is it var?
2451  567A 0008  
2452  567C 1A02         JL      H230                    no
2453  567E 0227         AI      R7,-127                 yes: add 1 and clear var bit
2453  5680 FF81  
2454  5682 0A40 H230    SLA     R0,4                    write protect bit will be >80
2455  5684 E1C0         SOC     R0,R7                   add it to file type
2456  5686 1004         JMP     H231                    
2457            *                                       
2458  5688 04C2 H228    CLR     R2                      no more files: filename size = 0
2459  568A 04C6         CLR     R6                      file size = 0
2460  568C 04C3         CLR     R3                      rec length = 0
2461  568E 04C7         CLR     R7                      type = 0
2462  5690 100F H231    JMP     H232                    output that
2463            *                                       
2464  5692 0225 H227    AI      R5,255                  disk info: point to data buffer area in ctrl block
2464  5694 00FF  
2465  5696 06A0         BL      @CALSUB                 call subroutine
2465  5698 4318  
2466  569A 4A0E         DATA    RWSEC                   read sector 0
2467  569C 06A0         BL      @FDR2B1                 get 2 bytes from FDR into R0
2467  569E 4830  
2468  56A0 010A         DATA    266                     # of sectors on disk
2469  56A2 C180         MOV     R0,R6                   duplicate it
2470  56A4 0646         DECT    R6                      minus directory itself (sect 0 + 1)
2471  56A6 06A0         BL      @CFSVIB                 count free sectors in bitmap, result in R3
2471  56A8 5726  
2472  56AA 04C7         CLR     R7                      filetype is not used
2473  56AC 0202         LI      R2,>0A00                diskname is 10 chars
2473  56AE 0A00  
2474            *                                       
2475  56B0 06A0 H232    BL      @PABR2B                 get 2 bytes from PAB into R0
2475  56B2 482A  
2476  56B4 0002         DATA    2                       APEDSK99: error in source listing (was R2)
2477  56B6 C200         MOV     R0,R8                   duplicate it
2478  56B8 0588         INC     R8                      skip first byte
2479  56BA 0982         SRL     R2,8                    filename length (or diskname)
2480  56BC 1316         JEQ     H233                    0: skip filename copying
2481  56BE 04C1         CLR     R1                      
2482  56C0 0429 H234    BLWP    @>005A(R9)              set VDP to read
2482  56C2 005A  
2483  56C4 00A2         DATA    >00A2                   address in R5 (FDR ptr)
2484  56C6 D06F         MOVB    @-1026(R15),R1          get 1 char from filename in FDR
2484  56C8 FBFE  
2485  56CA 0281         CI      R1,>2000                is it a space?
2485  56CC 2000  
2486  56CE 1309         JEQ     H235                    yes: end of name
2487  56D0 0429         BLWP    @>005A(R9)              no: set VDP to write
2487  56D2 005A  
2488  56D4 0103         DATA    >0103                   address in R8 (PAB data buffer ptr)
2489  56D6 DBC1         MOVB    R1,@-2(R15)             copy char in PAB data buffer
2489  56D8 FFFE  
2490  56DA 0585         INC     R5                      increment source ptr
2491  56DC 0588         INC     R8                      increment destination ptr
2492  56DE 0602         DEC     R2                      next char
2493  56E0 16EF         JNE     H234                    
2494  56E2 0502 H235    NEG     R2                      number of trailing spaces
2495  56E4 0222         AI      R2,10                   number of chars in filename
2495  56E6 000A  
2496  56E8 06C2         SWPB    R2                      
2497  56EA 0429 H233    BLWP    @>005A(R9)              set VDP to write
2497  56EC 005A  
2498  56EE 0003         DATA    >0003                   address in R0 (beg of PAB data buffer)
2499  56F0 DBC2         MOVB    R2,@-2(R15)             write string length byte
2499  56F2 FFFE  
2500            *                                       
2501  56F4 0429         BLWP    @>005A(R9)              set VDP to write
2501  56F6 005A  
2502  56F8 0103         DATA    >0103                   address in R8
2503  56FA C047         MOV     R7,R1                   file type + protection
2504  56FC 06A0         BL      @INT2FP                 make it a float number
2504  56FE 57A4  
2505  5700 C046         MOV     R6,R1                   file size in sectors, including FDR
2506  5702 06A0         BL      @INT2FP                 make it a float number
2506  5704 57A4  
2507  5706 C043         MOV     R3,R1                   record length
2508  5708 06A0         BL      @INT2FP                 make it a float number
2508  570A 57A4  
2509  570C C229         MOV     @>0054(R9),R8           get PAB ptr
2509  570E 0054  
2510  5710 0228         AI      R8,5                    point to character count
2510  5712 0005  
2511  5714 0200         LI      R0,>2600                always 38 bytes
2511  5716 2600  
2512  5718 0429         BLWP    @>005A(R9)              set VDP to write
2512  571A 005A  
2513  571C 0103         DATA    >0103                   address in R8
2514  571E DBC0         MOVB    R0,@-2(R15)             write # of characters in record
2514  5720 FFFE  
2515  5722 0460         B       @RTURN1                 return to caller
2515  5724 4336  
2516            *                                       
2517  5726 0228 CFSVIB  AI      R8,46                   count free sectors in VIB bitmap
2517  5728 002E  
2518  572A 0202         LI      R2,200                  bitmap size
2518  572C 00C8  
2519  572E 04C3         CLR     R3                      free sectors counter
2520  5730 0429         BLWP    @>005A(R9)              set VDP to read
2520  5732 005A  
2521  5734 0102         DATA    >0102                   address in R8
2522  5736 D06F H236    MOVB    @-1026(R15),R1          get a byte from bitmap
2522  5738 FBFE  
2523  573A 0221         AI      R1,256                  
2523  573C 0100  
2524  573E 0981         SRL     R1,8                    
2525  5740 130C         JEQ     H237                    was >FF: no free sectors, next byte
2526  5742 0601         DEC     R1                      was it >00?
2527  5744 1603         JNE     H238                    no: count bits
2528  5746 0223         AI      R3,8                    yes: 8 more free sectors
2528  5748 0008  
2529  574A 1007         JMP     H237                    next byte
2530  574C 0200 H238    LI      R0,8                    8 bits per byte
2530  574E 0008  
2531  5750 0911 H239    SRL     R1,1                    test a bit
2532  5752 1801         JOC     H240                    was 1: sector is used
2533  5754 0583         INC     R3                      was 0: one more free sector
2534  5756 0600 H240    DEC     R0                      next bit in byte
2535  5758 16FB         JNE     H239                    more to come
2536  575A 0602 H237    DEC     R2                      next bitmap byte
2537  575C 16EC         JNE     H236                    more to come
2538  575E 045B         B       *R11                    
2539            *                                       
2540  5760 C2BB FNDRV   MOV     *R11+,R10               find drive in file control blocks
2541  5762 C14B         MOV     R11,R5                  save 2 returns
2542  5764 C229         MOV     @>0056(R9),R8           top of mem word in VDP buffers header
2542  5766 0056  
2543  5768 0228         AI      R8,3                    point to max # of files
2543  576A 0003  
2544  576C 0429         BLWP    @>005A(R9)              set VDP to read
2544  576E 005A  
2545  5770 0102         DATA    >0102                   address in R8
2546  5772 D0AF         MOVB    @-1026(R15),R2          get # of files
2546  5774 FBFE  
2547  5776 0882         SRA     R2,8                    make it a word
2548  5778 0228         AI      R8,6                    point to drive # in file ctrl block
2548  577A 0006  
2549  577C 0203         LI      R3,>0020                filename begin with space (illegal: flag for dir)
2549  577E 0020  
2550  5780 D0C6         MOVB    R6,R3                   APEDSK99: error in original disassembly (was R5)
2551  5782 06A0 H241    BL      @VDPR2B                 read 2 bytes from VDP at R8 into R0
2551  5784 4836  
2552  5786 8003         C       R3,R0                   match with that control block?
2553  5788 1309         JEQ     H242                    yes
2554  578A 0240         ANDI    R0,>00FF                keep only first char of filename
2554  578C 00FF  
2555  578E 1601         JNE     H243                    valid filename: a FDR is loaded here
2556  5790 C1C8         MOV     R8,R7                   this space is free: save ptr
2557  5792 0228 H243    AI      R8,518                  point to next file control block
2557  5794 0206  
2558  5796 0602         DEC     R2                      next file
2559  5798 16F4         JNE     H241                    more to come
2560  579A 045A         B       *R10                    not found: return to address passed in data word
2561  579C 0588 H242    INC     R8                      drive matches: point to FDR
2562  579E CA48         MOV     R8,@>0056(R9)           save ptr
2562  57A0 0056  
2563  57A2 0455         B       *R5                     return to caller after data word
2564            *
2565            *--------------------------------------
2566            * Floating point format
2567            * ---------------------
2568            * Float numbers are 8 bytes long: EE 12 34 56 78 9A BC
2569            * EE is the exponent in radix 100 (not in radix 10 as usual!). It is biased
2570            * by 64: >40=0, 41=1 (i.e *100), >42=2 (i.e * 10,000) >3F= -1 (i.e /100), etc
2571            *
2572            * 12 ... BC are the mantissa in binary coded decimal: each byte encodes two
2573            * decimal digits from 00 to 99
2574            *
2575            * For negative numbers, the first word is negated
2576            * For zero, the first word is >0000 the others are irrelevant
2577            *
2578            * Examples: 40 08 00 00 00 00 00 00 is 8.0
2579            *           41 02 37 00 00 00 00 00 is 255.0 (>37 hex = 55 decimal)
2580            *           BF F8 00 00 00 00 00 00 is -8.0
2581            *           43 01 02 03 04 05 06 07 is 1020304.050607
2582            *--------------------------------------                                 
2583            *
2584  57A4 0202 INT2FP  LI      R2,>0800                write an integer in floating point format
2584  57A6 0800  
2585  57A8 DBC2         MOVB    R2,@-2(R15)             size=8
2585  57AA FFFE  
2586  57AC C141         MOV     R1,R5                   integer is in R1: save it for sign processing
2587  57AE 0241         ANDI    R1,>7FFF                clear sign bit
2587  57B0 7FFF  
2588  57B2 0281         CI      R1,100                  is it less than 100?
2588  57B4 0064  
2589  57B6 1A07         JL      H244                    yes
2590  57B8 04C0         CLR     R0                      100 or over
2591  57BA 0204         LI      R4,100                  
2591  57BC 0064  
2592  57BE 3C04         DIV     R4,R0                   divide by 100
2593  57C0 0260         ORI     R0,>4100                add exponent 2 to hundreths
2593  57C2 4100  
2594  57C4 1005         JMP     H245                    
2595            *                                       
2596  57C6 C001 H244    MOV     R1,R0                   is it 0?
2597  57C8 1302         JEQ     H246                    yes: exponent is 0
2598  57CA 0260         ORI     R0,>4000                no: add exponent 1
2598  57CC 4000  
2599  57CE 04C1 H246    CLR     R1                      next digits will be 0
2600            *                                       
2601  57D0 C145 H245    MOV     R5,R5                   test sign bit
2602  57D2 1101         JLT     H247                    negative
2603  57D4 1001         JMP     H248                    positive or zero
2604  57D6 0500 H247    NEG     R0                      negate first word
2605  57D8 DBC0 H248    MOVB    R0,@-2(R15)             write exponent to VDP at preset address
2605  57DA FFFE  
2606  57DC 06C0         SWPB    R0                      
2607  57DE DBC0         MOVB    R0,@-2(R15)             write first first 2 digits (or hundreths)
2607  57E0 FFFE  
2608  57E2 06C1         SWPB    R1                      
2609  57E4 DBC1         MOVB    R1,@-2(R15)             write last 2 digits (if any)
2609  57E6 FFFE  
2610  57E8 0202         LI      R2,5                    the remaining bytes are all 0 with integers
2610  57EA 0005  
2611  57EC DBC2 H249    MOVB    R2,@-2(R15)             write 0 to VDP
2611  57EE FFFE  
2612  57F0 0602         DEC     R2                      next byte
2613  57F2 16FC         JNE     H249                    more to do
2614  57F4 045B         B       *R11                    
2615            *
2616            *---------------------------------------
2617            * Subprogram >10: sector R/W
2618            * --------------
2619            * >834A: (n/a)      <--- sector #
2620            * >834C: drive #
2621            * >834D: R/W code (write if >00)
2622            * >834E: VDP buffer
2623            * >8350: sector #   <--- error code
2624            *---------------------------------------                                        
2625            *
2626  57F6 C1CB ESUB01  MOV     R11,R7                  
2627  57F8 06A0         BL      @PRPFDO                 prepare disk operations
2627  57FA 43E4  
2628  57FC CA69         MOV     @>0050(R9),@>004A(R9)   copy sector #
2628  57FE 0050  
2628  5800 004A  
2629  5802 0460         B       @SECRW1                 
2629  5804 416E  
2630            *
2631            *---------------------------------------
2632            * Subprogram >11: format disk
2633            * --------------                                        
2634            *
2635  5806 C1CB ESUB02  MOV     R11,R7                  
2636  5808 06A0         BL      @PRPFDO                 prepare disk operations
2636  580A 43E4  
2637  580C 0460         B       @FMTDSK                 
2637  580E 41EC  
2638            *
2639            *---------------------------------------
2640            * Subprogram >12: file (un)protect
2641            * --------------
2642            * >834C: drive #
2643            * >834D: protect code (>00 unprotect)
2644            * >834E: ptr to filename
2645            * >8350: (n/a)      <--- error code
2646            *---------------------------------------                                
2647            *
2648  5810 C1CB ESUB03  MOV     R11,R7                  
2649  5812 06A0         BL      @PRPFDO                 prepare disk operations
2649  5814 43E4  
2650  5816 D029         MOVB    @>004D(R9),R0           get protection code
2650  5818 004D  
2651  581A 0240         ANDI    R0,>0800                keep the bit that will be needed
2651  581C 0800  
2652  581E 0429         BLWP    @>005A(R9)              save R0 on stack
2652  5820 005A  
2653  5822 8000         DATA    >8000                   
2654  5824 C029         MOV     @>004E(R9),R0           get pointer to filename
2654  5826 004E  
2655  5828 06A0         BL      @CALSUB                 call subroutine
2655  582A 4318  
2656  582C 5912         DATA    RFDRVB                  load FDR in VDP buffer
2657  582E 0429         BLWP    @>005A(R9)              retrieve old R0, in R2
2657  5830 005A  
2658  5832 2001         DATA    >2001                   
2659  5834 06A0         BL      @FDR2B1                 read two bytes in R0 from top of FDR + offset
2659  5836 4830  
2660  5838 000C         DATA    12                      file status byte
2661  583A 0240         ANDI    R0,>F700                clear protection flag
2661  583C F700  
2662  583E F002         SOCB    R2,R0                   set it if needed
2663  5840 0429         BLWP    @>005A(R9)              set VDP for write
2663  5842 005A  
2664  5844 0103         DATA    >0103                   address in R8
2665  5846 DBC0         MOVB    R0,@-2(R15)             write back file status to FDR
2665  5848 FFFE  
2666            *                                       
2667  584A C229 UWFLVB  MOV     @>0056(R9),R8           FDR address in VDP mem
2667  584C 0056  
2668  584E 0429         BLWP    @>005A(R9)              set VDP for read
2668  5850 005A  
2669  5852 0102         DATA    >0102                   address in R8
2670  5854 D02F         MOVB    @-1026(R15),R0          get drive # in ctrl block
2670  5856 FBFE  
2671  5858 0260         ORI     R0,>8000                flag it
2671  585A 8000  
2672  585C 0429         BLWP    @>005A(R9)              set VDP for write
2672  585E 005A  
2673  5860 0103         DATA    >0103                   address in R8
2674  5862 DBC0         MOVB    R0,@-2(R15)             write it back
2674  5864 FFFE  
2675  5866 0460         B       @UPDFDR                 update FDR, load VIB
2675  5868 4536  
2676            *
2677            *---------------------------------
2678            * Subprogram >13: file rename
2679            * --------------
2680            * >834C: drive #
2681            * >834E: ptr to new name
2682            * >8350: ptr to old name <--- error code
2683            *---------------------------------                                      
2684            *
2685  586A C1CB ESUB04  MOV     R11,R7                  
2686  586C 06A0         BL      @PRPFDO                 prepare disk operations
2686  586E 43E4  
2687  5870 C029         MOV     @>004E(R9),R0           get ptr to new filename
2687  5872 004E  
2688  5874 0429         BLWP    @>005A(R9)              save R0 on stack
2688  5876 005A  
2689  5878 8000         DATA    >8000                   
2690  587A C029         MOV     @>0050(R9),R0           get ptr to old filename
2690  587C 0050  
2691  587E 06A0         BL      @CALSUB                 call subroutine
2691  5880 4318  
2692  5882 5912         DATA    RFDRVB                  put FDR in VDP buffer
2693  5884 06A0         BL      @RMFPTR                 remove FDR ptr from sector 1
2693  5886 479A  
2694  5888 06A0         BL      @FDR2B1                 get 2 bytes from FDR
2694  588A 4830  
2695  588C 000C         DATA    12                      file status byte
2696  588E 0240         ANDI    R0,>0800                protected?
2696  5890 0800  
2697  5892 1303         JEQ     H250                    no
2698  5894 06A0         BL      @ERROR5                 yes: return with error
2698  5896 4932  
2699  5898 2000         DATA    >2000                   write protected
2700  589A 06A0 H250    BL      @FDR2B1                 get 2 bytes from FDR
2700  589C 4830  
2701  589E FFFC         DATA    -4                      sector # of FDR
2702  58A0 C040         MOV     R0,R1                   
2703  58A2 0429         BLWP    @>005A(R9)              retrieve R0 from stack
2703  58A4 005A  
2704  58A6 8001         DATA    >8001                   ptr to new filename
2705  58A8 0429         BLWP    @>005A(R9)              save R1 on stack
2705  58AA 005A  
2706  58AC 4000         DATA    >4000                   sector # of FDR
2707  58AE 06A0         BL      @UFNCB                  write drive # and filename in compare buffer
2707  58B0 5B34  
2708  58B2 06A0         BL      @CALSUB                 call subroutine
2708  58B4 4318  
2709  58B6 4AF8         DATA    FFDRFN                  find FDR from filename
2710  58B8 C104         MOV     R4,R4                   found?
2711  58BA 1338         JEQ     H251                    yes: return with file error (name already exist)
2712  58BC 06A0         BL      @INSFDR                 insert a FDR in sector 1
2712  58BE 47CA  
2713  58C0 0429         BLWP    @>005A(R9)              retrieve sect # of FDR in R4
2713  58C2 005A  
2714  58C4 0801         DATA    >0801                   
2715  58C6 0429         BLWP    @>005A(R9)              set VDP to write
2715  58C8 005A  
2716  58CA 0103         DATA    >0103                   address in R8
2717  58CC DBC4         MOVB    R4,@-2(R15)             write sector # of FDR
2717  58CE FFFE  
2718  58D0 06C4         SWPB    R4                      
2719  58D2 DBC4         MOVB    R4,@-2(R15)                     
2719  58D4 FFFE  
2720  58D6 06C4         SWPB    R4                      sector #
2721  58D8 0702         SETO    R2                      code for read
2722  58DA 04C5         CLR     R5                      buffer offset: VDP at >8356
2723  58DC 06A0         BL      @CALSUB                 call subroutine
2723  58DE 4318  
2724  58E0 4A0A         DATA    RDFDR1                  read FDR
2725  58E2 C045         MOV     R5,R1                   
2726  58E4 C029         MOV     @>0058(R9),R0                   
2726  58E6 0058  
2727  58E8 0220         AI      R0,257                  
2727  58EA 0101  
2728  58EC 0601         DEC     R1                      
2729  58EE 06A0         BL      @CFNFDR                 copy filename in compare buffer to FDR
2729  58F0 5B4A  
2730  58F2 04C2         CLR     R2                      code for write
2731  58F4 06A0         BL      @CALSUB                 call subroutine
2731  58F6 4318  
2732  58F8 4A0E         DATA    RWSEC                   write FDR (with new name in it)
2733  58FA 06A0         BL      @CALSUB                 call subroutine
2733  58FC 4318  
2734  58FE 49F6         DATA    WRSEC1                  write sector 1 (with new FDR ptr in it)
2735  5900 C069         MOV     @>0056(R9),R1           FDR ptr
2735  5902 0056  
2736  5904 0429         BLWP    @>005A(R9)              prepare VDP to write
2736  5906 005A  
2737  5908 0023         DATA    >0023                   address in R1
2738  590A DBC4         MOVB    R4,@-2(R15)             clear first char of FDR in buffer
2738  590C FFFE  
2739  590E 0460         B       @RTURN1                 return to caller
2739  5910 4336  
2740            *                               
2741  5912 04C6 RFDRVB  CLR     R6                      put FDR in VDP buffer
2742  5914 D1A9         MOVB    @>004C(R9),R6           get drive #
2742  5916 004C  
2743  5918 06A0         BL      @UFNCB                  update filename compare buffer
2743  591A 5B34  
2744  591C 06A0         BL      @CALSUB                 call subroutine
2744  591E 4318  
2745  5920 4A84         DATA    FFDRVB                  look if FDR already in VDP buffer
2746  5922 06A0         BL      @CALSUB                 call subroutine
2746  5924 4318  
2747  5926 4AC8         DATA    FFDROD                  file FDR on disk
2748  5928 C104         MOV     R4,R4                   found?
2749  592A 1303         JEQ     H252                    yes
2750  592C 06A0 H251    BL      @RETERR                 no: return with error code in >8350
2750  592E 495E  
2751  5930 E000         DATA    >E000                   file error
2752  5932 0460 H252    B       @RTURN1                 return to caller
2752  5934 4336  
2753            *
2754            *-------------------------------------
2755            * Subprogram >14: file raw read
2756            * --------------
2757            * >834C: drive #                          <--- >00
2758            * >834D: # of sectors (>00=get file info) <--- sectors read
2759            * >834E: ptr to filename
2760            * >8350: file info buffer (>83xx)         <--- error code
2761            *                              |
2762            * >83xx  : VDP buffer       <--'
2763            * >83xx+2: first sector # (total # of sect when get file info)
2764            * >83xx+4: status flag
2765            * >83xx+5: recs/sector
2766            * >83xx+6: eof offset
2767            * >83xx+7: rec size
2768            * >83xx+8: # of recs
2769            *-------------------------------------                                  
2770            *
2771  5936 C1CB ESUB05  MOV     R11,R7                  
2772  5938 06A0         BL      @PRPFDO                 prepare disk operations
2772  593A 43E4  
2773  593C 06A0         BL      @RFNPTR                 load filename and ptrs
2773  593E 5B6C  
2774  5940 06A0         BL      @FFFDR                  find file FDR, load some info
2774  5942 5B92  
2775  5944 C082         MOV     R2,R2                   # of sectors to read
2776  5946 131E         JEQ     H253                    >00: get file info
2777  5948 6003         S       R3,R0                   sectors in file - first sector to read
2778  594A 1502         JGT     H254                    in file
2779  594C 04C2         CLR     R2                      past eof
2780  594E 1017         JMP     H255                    
2781  5950 8002 H254    C       R2,R0                   sectors past first one vs sectors to load
2782  5952 1A01         JL      H256                    
2783  5954 C080         MOV     R0,R2                   load what's left
2784  5956 0429 H256    BLWP    @>005A(R9)                      
2784  5958 005A  
2785  595A 2000         DATA    >2000                   save R2
2786  595C 0429 H257    BLWP    @>005A(R9)                      
2786  595E 005A  
2787  5960 3100         DATA    >3100                   save R2, R3, R7
2788  5962 06A0         BL      @CALSUB                 call subroutine
2788  5964 4318  
2789  5966 45EA         DATA    RDOFSC                  read sector from offset in file
2790  5968 0429         BLWP    @>005A(R9)                      
2790  596A 005A  
2791  596C 3101         DATA    >3101                   retrieve R2, R3, R7
2792  596E 0583         INC     R3                      next sector
2793  5970 0227         AI      R7,256                  increment VDP buffer ptr by 256 bytes
2793  5972 0100  
2794  5974 0602         DEC     R2                      more to do?
2795  5976 16F2         JNE     H257                    yes
2796  5978 0429 H258    BLWP    @>005A(R9)                      
2796  597A 005A  
2797  597C 2001         DATA    >2001                   retrieve R2 (# of sectors read)
2798  597E CA42 H255    MOV     R2,@>004C(R9)           update # of sectors in parameters
2798  5980 004C  
2799  5982 100A         JMP     H259                    
2800            *                                       
2801  5984 CD00 H253    MOV     R0,*R4+                 get file info: sectors in file
2802  5986 0648         DECT    R8                      
2803  5988 05C2         INCT    R2                      copy 2 bytes (status + recs/sector)
2804  598A 06A0         BL      @VDP2SP                 from VDP at R8 to file info structure
2804  598C 5BC6  
2805  598E 0202         LI      R2,4                    copy 4 bytes
2805  5990 0004  
2806  5992 A202         A       R2,R8                   
2807  5994 06A0         BL      @VDP2SP                 eof offset, rec len, # of recs (or # of sect)
2807  5996 5BC6  
2808  5998 06A0 H259    BL      @CALSUB                 call subroutine
2808  599A 4318  
2809  599C 4536         DATA    UPDFDR                  updata FDR (+ data) if needed, read VIB
2810  599E 04E9         CLR     @>0050(R9)              clear error flag
2810  59A0 0050  
2811  59A2 0460         B       @RTURN1                 return to caller
2811  59A4 4336  
2812            *
2813            *--------------------------------------
2814            * Subprogram >15: file raw write
2815            * --------------
2816            * >834C: drive #                                  <--- >00
2817            * >834D: # of sectors (>00=create file from info) <--- # of sectors written
2818            * >834E: ptr to filename
2819            * >8350: file info buffer (>83xx)                 <--- error code
2820            *                              |
2821            * >83xx  : VDP buffer       <--'
2822            * >83xx+2: first sector # (total # of sectors when creating file)
2823            * >83xx+4: status flag
2824            * >83xx+5: recs/sector
2825            * >83xx+6: eof offset
2826            * >83xx+7: rec size
2827            * >83xx+8: # of recs
2828            *--------------------------------------                                 
2829            *
2830  59A6 C1CB ESUB06  MOV     R11,R7                  
2831  59A8 06A0         BL      @PRPFDO                 prepare disk operations
2831  59AA 43E4  
2832  59AC 06A0         BL      @RFNPTR                 load drive + filename, + a few info
2832  59AE 5B6C  
2833  59B0 1314         JEQ     H260                    sectors to write=0: create file
2834  59B2 06A0         BL      @FFFDR                  find file FDR
2834  59B4 5B92  
2835  59B6 0429         BLWP    @>005A(R9)                      
2835  59B8 005A  
2836  59BA 2000         DATA    >2000                   save R2 (# of sectors to write)
2837  59BC 0429 H261    BLWP    @>005A(R9)                      
2837  59BE 005A  
2838  59C0 3100         DATA    >3100                   save R2, R3, R7
2839  59C2 06A0         BL      @CALSUB                 call subroutine
2839  59C4 4318  
2840  59C6 460A         DATA    WROFSC                  write sector from offset in file
2841  59C8 0429         BLWP    @>005A(R9)                      
2841  59CA 005A  
2842  59CC 3101         DATA    >3101                   retrieve R2, R3, R7
2843  59CE 0583         INC     R3                      next sector
2844  59D0 0227         AI      R7,256                  increment VDP ptr by 256 bytes
2844  59D2 0100  
2845  59D4 0602         DEC     R2                      more to do?
2846  59D6 16F2         JNE     H261                    yes
2847  59D8 10CF         JMP     H258                    update # of sectors written, in param. Then return
2848            *                               
2849  59DA 06A0 H260    BL      @CALSUB                 create file
2849  59DC 4318  
2850  59DE 4A84         DATA    FFDRVB                  find file FDR in VDP buffers
2851  59E0 06A0         BL      @CALSUB                 call subroutine
2851  59E2 4318  
2852  59E4 4AC8         DATA    FFDROD                  find file FDR on disk
2853  59E6 06A0         BL      @CALSUB                 call subroutine
2853  59E8 4318  
2854  59EA 4456         DATA    CRFIL2                  create file
2855  59EC 0429         BLWP    @>005A(R9)                      
2855  59EE 005A  
2856  59F0 0801         DATA    >0801                   retrieve R4 (file info ptr)
2857  59F2 C229         MOV     @>0056(R9),R8           FDR ptr
2857  59F4 0056  
2858  59F6 05C4         INCT    R4                      skip 2 bytes
2859  59F8 C0F4         MOV     *R4+,R3                 # of sector to create
2860  59FA 0228         AI      R8,10                   skip filename
2860  59FC 000A  
2861  59FE 06A0         BL      @SP2VDP                 write 2 bytes in VDP at R8+2
2861  5A00 5BD6  
2862  5A02 0002         DATA    2                       i.e. status + recs/sector
2863  5A04 06A0         BL      @SP2VDP                 write 4 bytes in VDP at new R8+4
2863  5A06 5BD6  
2864  5A08 0004         DATA    4                       i.e. eof offset, rec len, # of recs (or # of
2865  5A0A 0603         DEC     R3                      offset = # of sectors-1 (starts from 0)
2866  5A0C 1103         JLT     H262                    create an empty file, FDR only
2867  5A0E 06A0         BL      @CALSUB                 
2867  5A10 4318  
2868  5A12 4620         DATA    APSCTS                  append enough sectors to reach offset
2869  5A14 0460 H262    B       @UWFLVB                 modify FDR, write it, load VIB, return
2869  5A16 584A  
2870            *
2871            *---------------------------------------
2872            * Subprogram FILES: number of files
2873            *---------------------------------------                                        
2874  5A18 C1CB ESUB08  MOV     R11,R7                  
2875  5A1A 06A0         BL      @PRPFDO                 prepare disk operation
2875  5A1C 43E4  
2876  5A1E C229         MOV     @>002C(R9),R8           ptr to next basic token
2876  5A20 002C  
2877  5A22 0228         AI      R8,7                    skip FILES
2877  5A24 0007  
2878  5A26 06A0         BL      @VDPR2B                 get next two bytes in R0
2878  5A28 4836  
2879  5A2A 0280         CI      R0,>C801                >C8=unquoted string, size=1 char
2879  5A2C C801  
2880  5A2E 161C         JNE     H263                    return (with error) if different
2881  5A30 05C8         INCT    R8                      increment pointer
2882  5A32 06A0         BL      @VDPR2B                 get next two bytes
2882  5A34 4836  
2883  5A36 06C0         SWPB    R0                      
2884  5A38 0220         AI      R0,>49D0                substact >B630: # of files >B6=closed parenthesis
2884  5A3A 49D0  
2885  5A3C 0280         CI      R0,>0009                only 9 files allowed in Basic !
2885  5A3E 0009  
2886  5A40 1B13         JH      H263                    return with error if more
2887  5A42 06C0         SWPB    R0                      
2888  5A44 DA40         MOVB    R0,@>004C(R9)           put new # of files in scratch-pad memory
2888  5A46 004C  
2889  5A48 06A0         BL      @CALSUB                 call subroutine
2889  5A4A 4318  
2890  5A4C 5A72         DATA    PESB07                  subprogram >16 (private entry point)
2891  5A4E DA69         MOVB    @>0050(R9),@>0050(R9)   test result
2891  5A50 0050  
2891  5A52 0050  
2892  5A54 1609         JNE     H263                    error
2893  5A56 C229         MOV     @>002C(R9),R8           ok: get ptr to Basic token
2893  5A58 002C  
2894  5A5A 0228         AI      R8,12                   skip the whole statement
2894  5A5C 000C  
2895  5A5E CA48         MOV     R8,@>002C(R9)           update ptr
2895  5A60 002C  
2896  5A62 5A69         SZCB    @>0042(R9),@>0042(R9)   clear current token
2896  5A64 0042  
2896  5A66 0042  
2897  5A68 0460 H263    B       @RTURN1                 return to caller (i.e. Basic)
2897  5A6A 4336  
2898            *
2899            *---------------------------------------
2900            * Subprogram >16: number of files
2901            * --------------
2902            * >834C: # of files
2903            * >8350: (n/a)      <--- error code
2904            *---------------------------------------                                        
2905            *
2906  5A6C C1CB ESUB07  MOV     R11,R7                  entry point from assembly
2907  5A6E 06A0         BL      @PRPFDO                 prepare disk operations
2907  5A70 43E4  
2908  5A72 04C0 PESB07  CLR     R0                      entry point from call files
2909  5A74 D029         MOVB    @>004C(R9),R0           get # of files
2909  5A76 004C  
2910  5A78 1359         JEQ     H264                    return with error
2911  5A7A C229         MOV     @>0056(R9),R8           ptr to end of buffer word
2911  5A7C 0056  
2912  5A7E 0228         AI      R8,3                    point to # of files byte
2912  5A80 0003  
2913  5A82 04C3         CLR     R3                      
2914  5A84 0429         BLWP    @>005A(R9)              set VDP to read
2914  5A86 005A  
2915  5A88 0102         DATA    >0102                   address in R8
2916  5A8A D0EF         MOVB    @-1026(R15),R3          get current # of files
2916  5A8C FBFE  
2917  5A8E 0205         LI      R5,518                  size of 1 file control block
2917  5A90 0206  
2918  5A92 90C0         CB      R0,R3                   compare required with current
2919  5A94 1348         JEQ     H265                    same: return with no error
2920  5A96 122B         JLE     H266                    less
2921  5A98 C180         MOV     R0,R6                   more files needed
2922  5A9A 0280         CI      R0,>1000                maximum is 16
2922  5A9C 1000  
2923  5A9E 1B46         JH      H264                    return with error
2924  5AA0 6003         S       R3,R0                   how many to add
2925  5AA2 0980         SRL     R0,8                    make it a word
2926  5AA4 3805         MPY     R5,R0                   # of bytes to add
2927  5AA6 C101         MOV     R1,R4                   result in R0:R1
2928  5AA8 0504         NEG     R4                      
2929  5AAA C0A9         MOV     @>0070(R9),R2           highest free address in VDP mem
2929  5AAC 0070  
2930  5AAE C002         MOV     R2,R0                   
2931  5AB0 6001         S       R1,R0                   what it would become
2932  5AB2 0280         CI      R0,>0800                is there room enough for VDP?
2932  5AB4 0800  
2933  5AB6 113A         JLT     H264                    no: return with error
2934  5AB8 C040         MOV     R0,R1                   ok: new base
2935  5ABA 0582 H267    INC     R2                      increment source ptr
2936  5ABC 0580         INC     R0                      increment destination ptr
2937  5ABE 0429         BLWP    @>005A(R9)              set VDP to read
2937  5AC0 005A  
2938  5AC2 0042         DATA    >0042                   address in R2
2939  5AC4 D0EF         MOVB    @-1026(R15),R3          get a byte
2939  5AC6 FBFE  
2940  5AC8 0429         BLWP    @>005A(R9)              set VDP to write
2940  5ACA 005A  
2941  5ACC 0003         DATA    >0003                   address in R0
2942  5ACE DBC3         MOVB    R3,@-2(R15)             copy a byte
2942  5AD0 FFFE  
2943  5AD2 8202         C       R2,R8                   did we copy the whole header?
2944  5AD4 16F2         JNE     H267                    not yet
2945  5AD6 0429         BLWP    @>005A(R9)              set VDP to write
2945  5AD8 005A  
2946  5ADA 0003         DATA    >0003                   address in R0
2947  5ADC DBC6         MOVB    R6,@-2(R15)             new # of files
2947  5ADE FFFE  
2948  5AE0 04C6         CLR     R6                      
2949  5AE2 6080         S       R0,R2                   
2950  5AE4 DBC6 H268    MOVB    R6,@-2(R15)             clear byte
2950  5AE6 FFFE  
2951  5AE8 0602         DEC     R2                      
2952  5AEA 16FC         JNE     H268                    
2953  5AEC 101A         JMP     H269                    
2954            *                                       
2955  5AEE 0429 H266    BLWP    @>005A(R9)              less files needed
2955  5AF0 005A  
2956  5AF2 0103         DATA    >0103                   set VDP to write to address in R8
2957  5AF4 DBC0         MOVB    R0,@-2(R15)             new # of files in buffer header
2957  5AF6 FFFE  
2958  5AF8 60C0         S       R0,R3                   how many to remove
2959  5AFA 0983         SRL     R3,8                    make it a word
2960  5AFC 38C5         MPY     R5,R3                   # of bytes to remove
2961  5AFE C044         MOV     R4,R1                   result in R3:R4
2962  5B00 A048         A       R8,R1                   new address for buffer header
2963  5B02 C0A9         MOV     @>0070(R9),R2           highest free address in VDP mem
2963  5B04 0070  
2964  5B06 0429 H270    BLWP    @>005A(R9)              set VDP to read
2964  5B08 005A  
2965  5B0A 0102         DATA    >0102                   address in R8
2966  5B0C D02F         MOVB    @-1026(R15),R0          read a byte
2966  5B0E FBFE  
2967  5B10 0429         BLWP    @>005A(R9)              set VDP to write
2967  5B12 005A  
2968  5B14 0023         DATA    >0023                   address in R1
2969  5B16 DBC0         MOVB    R0,@-2(R15)             write byte back
2969  5B18 FFFE  
2970  5B1A 0601         DEC     R1                      decrement destination ptr
2971  5B1C 0608         DEC     R8                      decrement source ptr
2972  5B1E 8088         C       R8,R2                   did we copy the whole header?
2973  5B20 16F2         JNE     H270                    not yet
2974            *                                       
2975  5B22 CA41 H269    MOV     R1,@>0070(R9)           new first free address                                  
2975  5B24 0070  
2976  5B26 04E9 H265    CLR     @>0050(R9)              clear error flag
2976  5B28 0050  
2977  5B2A 1002         JMP     H272                    
2978  5B2C 0729 H264    SETO    @>0050(R9)              set error flag
2978  5B2E 0050  
2979  5B30 0460 H272    B       @RTURN1                 return to caller
2979  5B32 4336  
2980            *                                       
2981  5B34 04E9 UFNCB   CLR     @>0054(R9)              write drive # and filename in compare buffer
2981  5B36 0054  
2982  5B38 C069         MOV     @>0058(R9),R1           
2982  5B3A 0058  
2983  5B3C 0221         AI      R1,256                  ptr to filename compare buffer
2983  5B3E 0100  
2984  5B40 0429         BLWP    @>005A(R9)              set VDP to write
2984  5B42 005A  
2985  5B44 0023         DATA    >0023                   address in R1
2986  5B46 DBC6         MOVB    R6,@-2(R15)             write drive #
2986  5B48 FFFE  
2987  5B4A 0202 CFNFDR  LI      R2,10                   filename must be exactly 10 chars
2987  5B4C 000A  
2988  5B4E 0581 H273    INC     R1                      next char in compare buffer
2989  5B50 0429         BLWP    @>005A(R9)              set VDP to read
2989  5B52 005A  
2990  5B54 0002         DATA    >0002                   address in R0
2991  5B56 D0EF         MOVB    @-1026(R15),R3          get 1 char from filename
2991  5B58 FBFE  
2992  5B5A 0580         INC     R0                      next char in provided filename
2993  5B5C 0429         BLWP    @>005A(R9)              set VDP to write
2993  5B5E 005A  
2994  5B60 0023         DATA    >0023                   address in R1
2995  5B62 DBC3         MOVB    R3,@-2(R15)             write 1 char to compare buffer
2995  5B64 FFFE  
2996  5B66 0602         DEC     R2                      
2997  5B68 16F2         JNE     H273                    next char
2998  5B6A 045B         B       *R11                    
2999            *                                       
3000  5B6C C28B RFNPTR  MOV     R11,R10                 load compare buffer and ptrs
3001  5B6E 04C6         CLR     R6                      
3002  5B70 D1A9         MOVB    @>004C(R9),R6           drive #
3002  5B72 004C  
3003  5B74 C029         MOV     @>004E(R9),R0           ptr to filename
3003  5B76 004E  
3004  5B78 06A0         BL      @UFNCB                  write them in compare buffer
3004  5B7A 5B34  
3005  5B7C D129         MOVB    @>0050(R9),R4           file info structure ptr
3005  5B7E 0050  
3006  5B80 0984         SRL     R4,8                    
3007  5B82 A109         A       R9,R4                   make it a PAB address
3008  5B84 D029         MOVB    @>004D(R9),R0           # of sectors (>00=get file info)
3008  5B86 004D  
3009  5B88 0429         BLWP    @>005A(R9)                      
3009  5B8A 005A  
3010  5B8C 0800         DATA    >0800                   save R4
3011  5B8E 0980         SRL     R0,8                    
3012  5B90 045A         B       *R10                    EQ set for get file info
3013            *                                       
3014  5B92 0429 FFFDR   BLWP    @>005A(R9)              find file FDR
3014  5B94 005A  
3015  5B96 8010         DATA    >8010                   save R0 + R11
3016  5B98 06A0         BL      @CALSUB                 call subroutine
3016  5B9A 4318  
3017  5B9C 4A84         DATA    FFDRVB                  find file FDR in VDP buffers
3018  5B9E 06A0         BL      @CALSUB                 call subroutine
3018  5BA0 4318  
3019  5BA2 4AC8         DATA    FFDROD                  find FDR on disk
3020  5BA4 C104         MOV     R4,R4                   found ?
3021  5BA6 1303         JEQ     H274                    yes
3022  5BA8 06A0         BL      @ERROR5                 no: return with error
3022  5BAA 4932  
3023  5BAC E000         DATA    >E000                   file error
3024  5BAE 06A0 H274    BL      @FDR2B1                 get two bytes from FDR into R0
3024  5BB0 4830  
3025  5BB2 000E         DATA    14                      # of sectors in file
3026  5BB4 0429         BLWP    @>005A(R9)                      
3026  5BB6 005A  
3027  5BB8 2011         DATA    >2011                   retrieve R0 in R2 (# of sect to read), and R11
3028  5BBA 0429         BLWP    @>005A(R9)                      
3028  5BBC 005A  
3029  5BBE 0801         DATA    >0801                   retrieve R4 (ptr to file info structure)
3030  5BC0 C1F4         MOV     *R4+,R7                 VDP buffer
3031  5BC2 C0D4         MOV     *R4,R3                  first sector
3032  5BC4 045B         B       *R11                    
3033            *                                       
3034  5BC6 0429 VDP2SP  BLWP    @>005A(R9)              copy VDP bytes to scratch-pad
3034  5BC8 005A  
3035  5BCA 0102         DATA    >0102                   read from VDP at R8
3036  5BCC DD2F H275    MOVB    @-1026(R15),*R4+        read bytes into scratch-pad at R4
3036  5BCE FBFE  
3037  5BD0 0602         DEC     R2                      # of byte in R2
3038  5BD2 16FC         JNE     H275                    next byte
3039  5BD4 045B         B       *R11                    
3040            *                                       
3041  5BD6 C0BB SP2VDP  MOV     *R11+,R2                copy scratch-pad bytes to VDP
3042  5BD8 A202         A       R2,R8                   
3043  5BDA 0429         BLWP    @>005A(R9)              set VDP to write
3043  5BDC 005A  
3044  5BDE 0103         DATA    >0103                   address in R8 + offset in data word
3045  5BE0 DBF4 H276    MOVB    *R4+,@-2(R15)           write byte from scratch-pad at R4
3045  5BE2 FFFE  
3046  5BE4 0602         DEC     R2                      # of bytes in R2, was in data word
3047  5BE6 16FC         JNE     H276                    next byte
3048  5BE8 045B         B       *R11    
3049            *
3050            *----------------------------------------------------------------------------
3051            * APEDSK99 CALL subprograms
3052            *----------------------------------------------------------------------------
3053            * parameter is single digit -> 0x00
3054  5BEA 0206 PDSK    LI      R6,>0100                Protect ACOMND 
3054  5BEC 0100  
3055  5BEE 104F         JMP     ACLPRP                  generic prep
3056  5BF0 0206 UDSK    LI      R6,>0200                Unprotect ACOMND 
3056  5BF2 0200  
3057  5BF4 104C         JMP     ACLPRP                  generic prep
3058  5BF6 0206 LDSK    LI      R6,>0300                Show Files on DSKx ACOMND 
3058  5BF8 0300  
3059  5BFA 1049         JMP     ACLPRP                  generic prep
3060            * parameters are single digit + character string -> 1x00; ! >1300 IS RESERVED (BL NTPDT+1) ! 
3061  5BFC 0206 MDSK    LI      R6,>1000                Change DSK ACOMND
3061  5BFE 1000  
3062  5C00 1046         JMP     ACLPRP                  generic prep
3063  5C02 0206 NDSK    LI      R6,>1100                create new blank SS/SD DOAD image
3063  5C04 1100  
3064  5C06 1043         JMP     ACLPRP
3065            * parameter is a charachter string -> 2x00
3066  5C08 0206 RDSK    LI      R6,>2000                Remove DOAD from SD card ACOMND 
3066  5C0A 2000  
3067  5C0C 1040         JMP     ACLPRP                  generic prep
3068  5C0E 0206 FGET    LI      R6,>2100                get DOAD from FTP server ACOMND
3068  5C10 2100  
3069  5C12 103D         JMP     ACLPRP                  generic prep
3070  5C14 0206 FPUT    LI      R6,>2200                save DOAD to FTP server ACOMND 
3070  5C16 2200  
3071  5C18 103A         JMP     ACLPRP                  generic prep
3072  5C1A 0206 ADSR    LI      R6,>2300                load DSR and reset ACOMND
3072  5C1C 2300  
3073  5C1E 1037         JMP     ACLPRP                  generic prep
3074            * no parameters ->3x00
3075  5C20 0206 SDSK    LI      R6,>3000                Show DSKx mapping ACOMND
3075  5C22 3000  
3076  5C24 1034         JMP     ACLPRP                  generic prep
3077  5C26 0206 SDIR    LI      R6,>3100                Show SD dir ACOMND
3077  5C28 3100  
3078  5C2A 1031         JMP     ACLPRP                  generic prep
3079  5C2C 0206 AHLP    LI      R6,>3200                display APEDSK99 CALL()'s help screen
3079  5C2E 3200  
3080  5C30 102E         JMP     ACLPRP                  generic prep
3081  5C32 0206 ARST    LI      R6,>3300                reset APEDSK99 ACOMND
3081  5C34 3300  
3082  5C36 102B         JMP     ACLPRP                  generic prep
3083  5C38 0206 TIME    LI      R6,>3400                show NTP time and date
3083  5C3A 3400  
3084  5C3C 1028         JMP     ACLPRP                  generic prep
3085            *
3086            *-----------------------------------------------------------------
3087            * Subprogram PDSK / UDSK
3088            * ----------------------------------------------------------------
3089            *
3090  5C3E D806 PUDSK2  MOVB    R6,@ACOMND              send U/P DSK command to Arduino
3090  5C40 5FE8  
3091            *
3092  5C42 0208         LI      R8,12                   CALL length
3092  5C44 000C  
3093  5C46 1050         JMP     ACLBAS                  return to TI-BASIC              
3094            *                       
3095            *---------------------------------------------------------------------------------------
3096            * Subprogram MDSK / RDSK / FGET / FPUT / ADSR
3097            * --------------------------------------------------------------------------------------
3098            *
3099  5C48 05C8 MNDSK2  INCT    R8                      increment pointer
3100  5C4A 06A0         BL      @VDPR2B                 get next two digits
3100  5C4C 4836  
3101            *
3102  5C4E 0220 QTDSTR  AI      R0,>3900                add 2's complement of >C700 =  only keep # of characters
3102  5C50 3900  
3103  5C52 1374         JEQ     ACLERR                  0 characters / empty string -> * INCORRECT COMMAND
3104  5C54 0280         CI      R0,8                    max 8 characters?
3104  5C56 0008  
3105  5C58 1B71         JH      ACLERR                  no -> * INCORRECT COMMAND
3106            *
3107  5C5A C100         MOV     R0,R4                   save # of characters
3108  5C5C 0205         LI      R5,CALLBF+2             pointer to DOAD / DSR name      
3108  5C5E 5FCA  
3109  5C60 05C8         INCT    R8                      increment pointer
3110  5C62 C088         MOV     R8,R2                   for VDPRD, address must be in R2
3111  5C64 06A0         BL      @VDPRD                  set VDP READ address
3111  5C66 4300  
3112  5C68 DD6F H9900   MOVB    @-1026(R15),*R5+        get character and save in CALL buffer
3112  5C6A FBFE  
3113  5C6C 0600         DEC     R0                      one less to go
3114  5C6E 16FC         JNE     H9900   
3115            *
3116  5C70 D02F         MOVB    @-1026(R15),R0          get next token
3116  5C72 FBFE  
3117            *
3118  5C74 0280         CI      R0,>B600                is it a ")" ?
3118  5C76 B600  
3119  5C78 1661         JNE     ACLERR                  * INCORRECT COMMAND
3120            *
3121  5C7A 0208         LI      R8,13                   prep RDSK/FGET/FPUT/ADSR CALL length ( CALL_XXXX("") )
3121  5C7C 000D  
3122  5C7E A204         A       R4,R8                   add # of characters in string
3123                    
3124  5C80 0286         CI      R6,>1100                MDSK() and NDSK?
3124  5C82 1100  
3125  5C84 1B01         JH      H9901                   no; jump and execute RDSK/FGET/FPUT/ADSR
3126  5C86 05C8         INCT    R8                      adjust MDSK() and NDSK() CALL length
3127            *
3128  5C88 D806 H9901   MOVB    R6,@ACOMND              command to Arduino
3128  5C8A 5FE8  
3129            *
3130  5C8C 102D         JMP     ACLBAS                  return to TI-BASIC
3131            *                       
3132            *----------------------------------------------------------------------------
3133            * Generic prep and return to TI BASIC for APEDSK99 CALL's
3134            *----------------------------------------------------------------------------
3135  5C8E C1CB ACLPRP  MOV     R11,R7                  save return-to-TI BASIC address
3136  5C90 06A0         BL      @PRPFDO                 prepare TI Controller DSR operations
3136  5C92 43E4  
3137  5C94 C229         MOV     @>002C(R9),R8           ptr to next basic token
3137  5C96 002C  
3138  5C98 0228         AI      R8,4                    skip length byte and 3 chars of CALL name
3138  5C9A 0004  
3139  5C9C 06A0         BL      @VDPR2B                 get CALL last char and "(" or "0" in R0
3139  5C9E 4836  
3140  5CA0 0A80         SLA     R0,8                    only interested in LSB
3141  5CA2 137B         JEQ     NOPARM                  0 = no parameters? SDSK, SDIR, AHLP, ARST, TIME
3142            *
3143  5CA4 0228         AI      R8,2                    adjust token pointer
3143  5CA6 0002  
3144  5CA8 06A0         BL      @VDPR2B                 get next two bytes in R0
3144  5CAA 4836  
3145  5CAC 0280         CI      R0,>C801                >C8=unquoted string, size=1 char?
3145  5CAE C801  
3146  5CB0 1304         JEQ     UQTSTR                  yes: PDSK, UDSK, LDSK, MDSK, NDSK
3147            *
3148  5CB2 0280         CI      R0,>C701                >C7=quoted string, minimum 1 character?
3148  5CB4 C701  
3149  5CB6 14CB         JHE     QTDSTR                  yes: RDSK, FGET, FPUT, ADSR
3150            *
3151  5CB8 1041         JMP     ACLERR                  expect the unexpected                           
3152            *
3153  5CBA 05C8 UQTSTR  INCT    R8                      continue for PDSK, UDSK, LDSK, MDSK, NDSK; increment pointer
3154  5CBC 06A0         BL      @VDPR2B                 get next two bytes              
3154  5CBE 4836  
3155            *
3156  5CC0 06C0         SWPB    R0
3157  5CC2 0220         AI      R0,>49D0                add 2's complement of >B630: MSB = >B3 / "," or >B6 / ")", LSB= # of files 
3157  5CC4 49D0  
3158  5CC6 1502         JGT     H9902                   >B6
3159  5CC8 0220         AI      R0,768                  >B3, adjust R0 to positive range
3159  5CCA 0300  
3160            *
3161  5CCC 1337 H9902   JEQ     ACLERR                  DSK0 not valid, * INCORRECT COMMAND
3162  5CCE 0280         CI      R0,3                    only 3 DSK's allowed
3162  5CD0 0003  
3163  5CD2 1B34         JH      ACLERR                  if >3 * INCORRECT COMMAND
3164            *
3165  5CD4 06C0         SWPB    R0
3166  5CD6 D800         MOVB    R0,@CALLBF              save DSKx
3166  5CD8 5FC8  
3167            *
3168  5CDA 0286         CI      R6,>0200                PDSK() and UDSK()?
3168  5CDC 0200  
3169  5CDE 12AF         JLE     PUDSK2                  yep
3170  5CE0 0286         CI      R6,>1000                MDSK() and NDSK()?
3170  5CE2 1000  
3171  5CE4 14B1         JHE     MNDSK2                  follow MDSK's lead                      
3172  5CE6 102C         JMP     LDSK2                   must be LDSK
3173            *
3174  5CE8 9820 ACLBAS  CB      @CALLST,@K004           "More" or "AllGood" received from Arduino?      
3174  5CEA 5FC6  
3174  5CEC 4314  
3175  5CEE 141A         JHE     H9904                   yep
3176            *       
3177  5CF0 0205         LI      R5,GPLINT               no; GPL routine
3177  5CF2 006A  
3178  5CF4 06A0         BL      @GPLXML                 
3178  5CF6 5E66  
3179  5CF8 56CD         DATA    SCROLL                  scroll screen
3180  5CFA 0202         LI      R2,738                  screen starting position for (error) message
3180  5CFC 02E2  
3181  5CFE 06A0         BL      @VDPWRI                 set VDP address
3181  5D00 42F6  
3182  5D02 06A0         BL      @DISSTS                 show (error) message
3182  5D04 5DBA  
3183  5D06 0205         LI      R5,GPLINT               GPL routine
3183  5D08 006A  
3184  5D0A 06A0         BL      @GPLXML 
3184  5D0C 5E66  
3185  5D0E 56CD         DATA    SCROLL                  scroll screen
3186            *
3187  5D10 9820         CB      @CALLST,@K007           error?
3187  5D12 5FC6  
3187  5D14 4313  
3188  5D16 1B06         JH      H9904                   no; be silent   
3189            *
3190  5D18 0205 H9903   LI      R5,GPLINT               yes: let's make some noise
3190  5D1A 006A  
3191  5D1C 06A0         BL      @GPLXML
3191  5D1E 5E66  
3192  5D20 03D6         DATA    HONK                    GPL routine"bad tone"
3193  5D22 1005         JMP     H9914
3194            *
3195  5D24 0286 H9904   CI      R6,>3400                TIME() ?
3195  5D26 3400  
3196  5D28 1602         JNE     H9914                   no, end the party
3197  5D2A 0460         B       @TIME2                  yes; see if we can assign date/time to NTP$ 
3197  5D2C 5DFE  
3198            *
3199  5D2E 04E9 H9914   CLR     @>0050(R9)              clear error flag                
3199  5D30 0050  
3200  5D32 AA48         A       R8, @>002C(R9)          add call length to token pointer                
3200  5D34 002C  
3201  5D36 5A69         SZCB    @>0042(R9),@>0042(R9)   clear current token
3201  5D38 0042  
3201  5D3A 0042  
3202  5D3C 0460 ACLERR  B       @RTURN1                 return to caller (i.e. TI-BASIC)
3202  5D3E 4336  
3203            *
3204            *-----------------------------------------------------------------
3205            * Subprogram SDSK / LDSK / SDIR/ AHLP / TIME
3206            * ----------------------------------------------------------------
3207            *
3208  5D40 D806 LDSK2   MOVB    R6,@ACOMND              LDSK/SDSK/SDIR/AHLP command to Arduino
3208  5D42 5FE8  
3209  5D44 9820         CB      @K002,@CALLST
3209  5D46 4312  
3209  5D48 5FC6  
3210  5D4A 132F         JEQ     QTLSSA                  LDSK: >00; no DOAD mapped
3211            *
3212  5D4C 04C2 LDNXTS  CLR     R2                      clear screen; position 0
3213  5D4E 06A0         BL      @VDPWRI
3213  5D50 42F6  
3214            *
3215  5D52 0200         LI      R0,>8000                space + TI BASIC bias
3215  5D54 8000  
3216  5D56 06A0         BL      @VDPRPW
3216  5D58 423E  
3217  5D5A 02C0         DATA    704                     704 positions to clear
3218            *
3219  5D5C 0202         LI      R2,33                   start 2nd screen line; 1st is lost due to TI BASIC scroll
3219  5D5E 0021  
3220  5D60 06A0         BL      @VDPWRI                 
3220  5D62 42F6  
3221            *       
3222  5D64 9820 H9905   CB      @K004,@CALLST           check Arduino LDSK/SDSK/SDIR/AHLP return code
3222  5D66 4314  
3222  5D68 5FC6  
3223  5D6A 131F         JEQ     QTLSSA                  "More" (>F0); blank "floppy" or done last file / help txt
3224            *
3225  5D6C 06A0         BL      @DISSTS                 LDSK/SDSK/SDIR/AHLP output to screen
3225  5D6E 5DBA  
3226            *
3227  5D70 0222         AI      R2,32                   next screen position
3227  5D72 0020  
3228  5D74 0282         CI      R2,641                  end of display area?
3228  5D76 0281  
3229  5D78 1303         JEQ     NXTPRP                  yes; show "more" symbol
3230            *
3231  5D7A C802         MOV     R2,@RDINT               generates interrupt for next file
3231  5D7C 5FEA  
3232  5D7E 10F2         JMP     H9905   
3233            *       
3234  5D80 0202 NXTPRP  LI      R2,703
3234  5D82 02BF  
3235  5D84 06A0         BL      @VDPWRI
3235  5D86 42F6  
3236  5D88 0205         LI      R5,>9E00                ">", more files to display
3236  5D8A 9E00  
3237  5D8C DBC5         MOVB    R5,@-2(R15)
3237  5D8E FFFE  
3238            *
3239  5D90 06A0         BL      @CHKKEY
3239  5D92 5DCC  
3240            *
3241  5D94 C802         MOV     R2,@RDINT               generates interrupt for next file
3241  5D96 5FEA  
3242  5D98 10D9         JMP     LDNXTS
3243            *
3244            *-----------------------------------------------------------------------------------------
3245            * Subprogram ARST / TIME
3246            * ----------------------------------------------------------------------------------------
3247            *
3248  5D9A 0286 NOPARM  CI      R6,>3000                catch PDSK/UDSK/LDSK/MDSK/NDSK/RDSK/FGET/FPUT/ADSR without parameters -> error
3248  5D9C 3000  
3249  5D9E 1ACE         JL      ACLERR
3250  5DA0 0286         CI      R6,>3300                ARST() or TIME() ?      
3250  5DA2 3300  
3251  5DA4 1ACD         JL      LDSK2                   no; SDSK/SDIR/AHLP use LDSK display routine
3252            *
3253  5DA6 D806 ARST2   MOVB    R6,@ACOMND              execute ARST() or TIME()
3253  5DA8 5FE8  
3254            *
3255  5DAA 0208 QTLSSA  LI      R8,9                    current CALL length
3255  5DAC 0009  
3256  5DAE 0286         CI      R6,>0300                LDSK()?
3256  5DB0 0300  
3257  5DB2 1B02         JH      H9906                   nope; exit with CALL lenght 9 for SDSK/SDIR/AHLP
3258  5DB4 0228         AI      R8,3                    yep;  exit with CALL length 12 for LDSK
3258  5DB6 0003  
3259            *
3260  5DB8 1097 H9906   JMP     ACLBAS  
3261            *
3262            * Display data, status messages and errors
3263            *
3264  5DBA 0205 DISSTS  LI      R5,CALLBF               start of file name buffer
3264  5DBC 5FC8  
3265  5DBE 0206         LI      R6,32                   32 bytes / 1 screen row of data to display
3265  5DC0 0020  
3266  5DC2 DBF5 H9907   MOVB    *R5+,@-2(R15)           store character in VDP screen memory
3266  5DC4 FFFE  
3267  5DC6 0606         DEC     R6
3268  5DC8 16FC         JNE     H9907
3269  5DCA 045B         B       *R11
3270            *
3271            * Quick key test to display next screen after ">"
3272            * Keyboard column 0 (= space enter <nc> fctn shift ctrl <nc>)
3273            * Code copy from Thierry's TI's Tech Pages site
3274            *
3275  5DCC C10C CHKKEY  MOV     R12,R4                  save R12
3276  5DCE 04C1         CLR     R1                      test column 0
3277  5DD0 020C         LI      R12,>0024               address for column selection
3277  5DD2 0024  
3278  5DD4 30C1 H9908   LDCR    R1,3                    select column
3279  5DD6 1FF2         TB      -14                     test R12 address >0008
3280  5DD8 1607         JNE     H9909                   <SPACE>
3281  5DDA 1FF3         TB      -13                     test R12 address >000A
3282  5DDC 13FB         JEQ     H9908                   no key; test again
3283            *
3284  5DDE D820         MOVB    @K004,@CALLST           signal ENTER to SDIR() command
3284  5DE0 4314  
3284  5DE2 5FC6  
3285  5DE4 020B         LI      R11,QTLSSA              leave without clearing screen
3285  5DE6 5DAA  
3286            *
3287  5DE8 C304 H9909   MOV     R4,R12                  restore R12
3288  5DEA 0A24         SLA     R4,2                    debounce delay
3289  5DEC 0604 H9910   DEC     R4                      key debounce
3290  5DEE 16FE         JNE     H9910                   debounce some more
3291            *
3292  5DF0 045B         B       *R11                    we got one; return for next screen
3293            *               
3294            * update FAT time/date for current DOAD after DSR Format / Write / Save
3295            *
3296  5DF2 D820 NTPDT   MOVB    @NTPFAT+1,@ACOMND       "DSK NTP date/time update" command to Arduino           
3296  5DF4 4027  
3296  5DF6 5FE8  
3297  5DF8 045B         B       *R11                    return to Format / Close
3298            *       
3299            * prep for calling XML >16 and update BASIC variable NTP$               
3300            *
3301  5DFA 4E54 VARINF  TEXT    'NTP$'
3301  5DFC 5024  
3302  5DFE 0204 TIME2   LI      R4,VARINF               variable name for XML >16 in FAC
3302  5E00 5DFA  
3303  5E02 C149         MOV     R9,R5                   get scratchpad start address
3304  5E04 D974 H9911   MOVB    *R4+,@>004A(R5)         variable name in FAC
3304  5E06 004A  
3305  5E08 0585         INC     R5
3306  5E0A 0284         CI      R4,VARINF+4             done all chars?
3306  5E0C 5DFE  
3307  5E0E 16FA         JNE     H9911                   
3308            *
3309  5E10 0205         LI      R5,>0400                variable length for XML >16 in @>8359
3309  5E12 0400  
3310  5E14 DA45         MOVB    R5,@>0059(R9)           
3310  5E16 0059  
3311  5E18 04E9         CLR     @>0089(R9)      
3311  5E1A 0089  
3312            *
3313  5E1C 0205         LI      R5,XML16                ROM routine: find NTP$ in VDP symbol table (returns to GPL interpreter)
3313  5E1E 15D6  
3314  5E20 06A0         BL      @GPLXML
3314  5E22 5E66  
3315  5E24 2244         DATA    XMLRTN                  GPL "RTN", escaping GPL interpreter
3316            *
3317  5E26 9A60         CB      @VARINF,@>004A(R9)      found NTP$ in VDP symbol table?
3317  5E28 5DFA  
3317  5E2A 004A  
3318  5E2C 1318         JEQ     H9913                   no symbol table pointer; back to BASIC
3319            *
3320  5E2E 06A0         BL      @XML14                  ROM routine: get NTP$ VDP address and string length (returns through RT)
3320  5E30 164E  
3321  5E32 02A9         STWP    R9                      restore scratchpad pointer
3322  5E34 0229         AI      R9,-224
3322  5E36 FF20  
3323            *       
3324  5E38 C169         MOV     @>0050(R9),R5           get string length
3324  5E3A 0050  
3325  5E3C 0285         CI      R5,16                   16 chars?
3325  5E3E 0010  
3326  5E40 160E         JNE     H9913                   no NTP$ assignment for you
3327            *
3328  5E42 C0A0         MOV     @>834E,R2               yes
3328  5E44 834E  
3329  5E46 06A0         BL      @VDPWRI                 set VDP write address
3329  5E48 42F6  
3330  5E4A 0205         LI      R5,CALLBF               CALL TIME data still in buffer
3330  5E4C 5FC8  
3331  5E4E D0B5 H9912   MOVB    *R5+,R2                 read character
3332  5E50 0222         AI      R2,>A000                remove TI BASIC bias
3332  5E52 A000  
3333  5E54 DBC2         MOVB    R2,@-2(R15)             save to NTP$ value space
3333  5E56 FFFE  
3334  5E58 0285         CI      R5,CALLBF+16            done all 16 chars?
3334  5E5A 5FD8  
3335  5E5C 16F8         JNE     H9912                   no; one more
3336            *
3337  5E5E 0460 H9913   B       @H9914                  yes; back to BASIC
3337  5E60 5D2E  
3338            *
3339            * execute GROM or XML routine (SCROLL, "bad sound"/ HONK and XML >16)
3340            * DSR and GPL interpreter use same workspace (>83E0) so we need to save a few things
3341            *
3342  5E62 0000 SAVGRA  BSS     2                       save current GROM address so we can return to BASIC
3343  5E64 0000 SAVR11  BSS     2                       GPL interpreter uses R11
3344            *
3345  5E66 D820 GPLXML  MOVB    @>9802,@SAVGRA          save current GROM address
3345  5E68 9802  
3345  5E6A 5E62  
3346  5E6C 1000         NOP
3347  5E6E D820         MOVB    @>9802,@SAVGRA+1
3347  5E70 9802  
3347  5E72 5E63  
3348  5E74 0620         DEC     @SAVGRA                 GRMWA returns address + 1; decrease for correct address
3348  5E76 5E62  
3349            *
3350  5E78 D83B         MOVB    *R11+,@>9C02            set GPL routine address
3350  5E7A 9C02  
3351  5E7C 1000         NOP
3352  5E7E D83B         MOVB    *R11+,@>9C02
3352  5E80 9C02  
3353  5E82 C80B         MOV     R11,@SAVR11             save final DSR return address
3353  5E84 5E64  
3354            *
3355  5E86 020B         LI      R11,GXRTN               DSR return address after GPL routine
3355  5E88 5EA2  
3356  5E8A C80B         MOV     R11,@RTN5C              @>4028 is where XML >5C returns to
3356  5E8C 4028  
3357            *
3358  5E8E 05E0         INCT    @>8373                  increase stack pointer
3358  5E90 8373  
3359  5E92 06C9         SWPB    R9                      
3360  5E94 D260         MOVB    @>8373,R9
3360  5E96 8373  
3361  5E98 06C9         SWPB    R9                      complete stack pointer in R9
3362  5E9A 020B         LI      R11,XML5C               GROM pointer to >0F5C (= XML >5C)
3362  5E9C 105C  
3363  5E9E C64B         MOV     R11,*R9                 save GROM pointer on stack
3364            *
3365  5EA0 0455         B       *R5                     execute GROM/ROM routine, return through GPL interpreter
3366            *
3367  5EA2 D820 GXRTN   MOVB    @SAVGRA,@>9C02          and ... we're back; restore saved GROM address
3367  5EA4 5E62  
3367  5EA6 9C02  
3368  5EA8 1000         NOP
3369  5EAA D820         MOVB    @SAVGRA+1,@>9C02
3369  5EAC 5E63  
3369  5EAE 9C02  
3370            *
3371  5EB0 02A9         STWP    R9                      restore scratchpad pointer
3372  5EB2 0229         AI      R9,-224
3372  5EB4 FF20  
3373            *
3374  5EB6 C2E0         MOV     @SAVR11,R11             restore R11
3374  5EB8 5E64  
3375  5EBA 045B         B       *R11                    return to instruction after BL @GPLEXEC DATA statement
3376            *
3377            *----------------------------------------------------------------------------------
3378            * >5EBC - >5FB3: 247 free bytes remaining
3379            * >5FC2 - >5FD3 is DSK1-3 parameters storage
3380            * >5FD4 is the CALL() status byte
3381            * >5FD6 - >5FE7 is buffer storage for APEDSK99 CALL's
3382            * >5FE8 is the Arduino Command Register (TI BASIC CALL support)
3383            * Word >5FEA maps to the read counter (R6, to generate interrupts when reading data) 
3384            * Bytes >5FEE maps to the CRU emulation write register
3385            * Bytes >5FF0 to >5FFE map to the FDC emulation registers
3386            *-----------------------------------------------------------------------------------                                    
3387            *
3388  5EBC 0000         END
3388            


 Assembly Complete - Errors: 0,  Warnings: 0


 ------ Symbol Listing ------

 ACLBAS ABS:5CE8 ACLBAS
 ACLERR ABS:5D3C ACLERR
 ACLPRP ABS:5C8E ACLPRP
 ACOMND ABS:5FE8 ACOMND
 ADDSEC ABS:46C4 ADDSEC
 ADSR   ABS:5C1A ADSR
 AFDRPT ABS:5288 AFDRPT
 AFPGPF ABS:519E AFPGPF
 AHLP   ABS:5C2C AHLP
 APSCTS ABS:4620 APSCTS
 ARST   ABS:5C32 ARST
 ARST2  ABS:5DA6 ARST2
 CALLBF ABS:5FC8 CALLBF
 CALLST ABS:5FC6 CALLST
 CALSUB ABS:4318 CALSUB
 CFNFDR ABS:5B4A CFNFDR
 CFSVIB ABS:5726 CFSVIB
 CHKKEY ABS:5DCC CHKKEY
 CLOSE  ABS:4F90 CLOSE
 CLRFBT ABS:4542 CLRFBT
 CLSDIR ABS:55D0 CLSDIR
 CMPFN  ABS:47FC CMPFN
 CPCKFN ABS:48D4 CPCKFN
 CRFIL1 ABS:4450 CRFIL1
 CRFIL2 ABS:4456 CRFIL2
 CRFIL3 ABS:4462 CRFIL3
 CRUWRI ABS:5FEE CRUWRI
 DECDCI ABS:4B76 DECDCI
 DELETE ABS:472E DELETE
 DISSTS ABS:5DBA DISSTS
 DSDRVS ABS:4316 DSDRVS
 DSKPRM ABS:5FB4 DSKPRM
 DSR01  ABS:40D8 DSR01
 DSR02  ABS:40E0 DSR02
 DSR03  ABS:40EA DSR03
 DSR04  ABS:40F4 DSR04
 ECUSTM ABS:4350 ECUSTM
 EDSR01 ABS:4D0C EDSR01
 EDSR02 ABS:4D1A EDSR02
 EDSR03 ABS:4D20 EDSR03
 EDSR04 ABS:4D26 EDSR04
 EPWRUP ABS:40FE EPWRUP
 ERROR1 ABS:42B4 ERROR1
 ERROR3 ABS:41E6 ERROR3
 ERROR4 ABS:4252 ERROR4
 ERROR5 ABS:4932 ERROR5
 ERROR6 ABS:4AE8 ERROR6
 ERROR7 ABS:48D8 ERROR7
 ERROR8 ABS:4D78 ERROR8
 ERROR9 ABS:4D94 ERROR9
 ERRR10 ABS:55AC ERRR10
 ESUB01 ABS:57F6 ESUB01
 ESUB02 ABS:5806 ESUB02
 ESUB03 ABS:5810 ESUB03
 ESUB04 ABS:586A ESUB04
 ESUB05 ABS:5936 ESUB05
 ESUB06 ABS:59A6 ESUB06
 ESUB07 ABS:5A6C ESUB07
 ESUB08 ABS:5A18 ESUB08
 FDR2B1 ABS:4830 FDR2B1
 FDR2B2 ABS:4834 FDR2B2
 FDSKDR ABS:484A FDSKDR
 FFDRDK ABS:4ACC FFDRDK
 FFDRFN ABS:4AF8 FFDRFN
 FFDROD ABS:4AC8 FFDROD
 FFDRVB ABS:4A84 FFDRVB
 FFDRVP ABS:518E FFDRVP
 FFFDR  ABS:5B92 FFFDR
 FFFDRV ABS:4A64 FFFDRV
 FFSBM  ABS:4C7C FFSBM
 FFSBMP ABS:4BB6 FFSBMP
 FFSVIB ABS:459A FFSVIB
 FGET   ABS:5C0E FGET
 FMTDSK ABS:41EC FMTDSK
 FNDFDR ABS:4AC2 FNDFDR
 FNDRV  ABS:5760 FNDRV
 FPUT   ABS:5C14 FPUT
 FRSCB1 ABS:4C82 FRSCB1
 FSCTOF ABS:470A FSCTOF
 GPLINT ABS:006A GPLINT
 GPLXML ABS:5E66 GPLXML
 GXRTN  ABS:5EA2 GXRTN
 H001   ABS:4124 H001
 H005   ABS:4188 H005
 H013   ABS:418C H013
 H014   ABS:41BA H014
 H015   ABS:419A H015
 H016   ABS:41A8 H016
 H019   ABS:41B6 H019
 H024   ABS:41D0 H024
 H027   ABS:41F0 H027
 H036   ABS:4208 H036
 H037   ABS:4218 H037
 H038   ABS:4226 H038
 H044   ABS:4240 H044
 H055   ABS:4262 H055
 H056   ABS:4280 H056
 H057   ABS:4278 H057
 H058   ABS:427E H058
 H061   ABS:42A2 H061
 H064   ABS:42C6 H064
 H066   ABS:42CC H066
 H068   ABS:42F0 H068
 H069   ABS:4304 H069
 H070   ABS:4398 H070
 H071   ABS:43C6 H071
 H072   ABS:4374 H072
 H073   ABS:43C2 H073
 H074   ABS:439E H074
 H075   ABS:43DA H075
 H076   ABS:4404 H076
 H077   ABS:44EC H077
 H078   ABS:4478 H078
 H079   ABS:44D0 H079
 H080   ABS:4502 H080
 H081   ABS:452C H081
 H082   ABS:450C H082
 H083   ABS:451E H083
 H084   ABS:4532 H084
 H085   ABS:456A H085
 H086   ABS:4596 H086
 H087   ABS:45B8 H087
 H088   ABS:45E6 H088
 H089   ABS:45C2 H089
 H090   ABS:45FA H090
 H091   ABS:4604 H091
 H092   ABS:46B8 H092
 H093   ABS:4630 H093
 H094   ABS:4656 H094
 H095   ABS:4644 H095
 H096   ABS:468C H096
 H097   ABS:469A H097
 H098   ABS:4698 H098
 H099   ABS:4690 H099
 H100   ABS:46A8 H100
 H101   ABS:46C0 H101
 H102   ABS:4708 H102
 H103   ABS:471E H103
 H104   ABS:472A H104
 H105   ABS:4714 H105
 H106   ABS:4746 H106
 H107   ABS:4768 H107
 H108   ABS:475C H108
 H109   ABS:47AC H109
 H110   ABS:47DC H110
 H111   ABS:4804 H111
 H112   ABS:4828 H112
 H113   ABS:4862 H113
 H114   ABS:486C H114
 H115   ABS:48CA H115
 H116   ABS:4874 H116
 H118   ABS:48C2 H118
 H119   ABS:48DE H119
 H120   ABS:48EC H120
 H121   ABS:4928 H121
 H122   ABS:48F8 H122
 H123   ABS:495C H123
 H124   ABS:497E H124
 H125   ABS:4982 H125
 H126   ABS:49E8 H126
 H127   ABS:49BA H127
 H128   ABS:49CE H128
 H129   ABS:49DE H129
 H130   ABS:4A5C H130
 H131   ABS:4A3E H131
 H132   ABS:4A54 H132
 H133   ABS:4A4E H133
 H134   ABS:4A9E H134
 H135   ABS:4ABE H135
 H136   ABS:4A80 H136
 H137   ABS:4AEE H137
 H138   ABS:4AD4 H138
 H139   ABS:4B04 H139
 H140   ABS:4B6A H140
 H141   ABS:4B66 H141
 H142   ABS:4B70 H142
 H143   ABS:4BCA H143
 H144   ABS:4BDC H144
 H145   ABS:4BEC H145
 H146   ABS:4BF8 H146
 H147   ABS:4C28 H147
 H148   ABS:4C1E H148
 H149   ABS:4C72 H149
 H150   ABS:4C30 H150
 H151   ABS:4C56 H151
 H152   ABS:4CAE H152
 H153   ABS:4CC2 H153
 H154   ABS:4CBC H154
 H155   ABS:4CBE H155
 H156   ABS:4CC4 H156
 H157   ABS:4CEC H157
 H158   ABS:4CF4 H158
 H159   ABS:4D30 H159
 H160   ABS:4D2A H160
 H161   ABS:4D56 H161
 H162   ABS:4D9A H162
 H163   ABS:4DB0 H163
 H164   ABS:4E64 H164
 H165   ABS:4DBC H165
 H166   ABS:4DEE H166
 H167   ABS:4E06 H167
 H168   ABS:4E0A H168
 H169   ABS:4E60 H169
 H170   ABS:4E8C H170
 H171   ABS:4E88 H171
 H172   ABS:4EB0 H172
 H173   ABS:4EDE H173
 H174   ABS:4F36 H174
 H175   ABS:4F5C H175
 H176   ABS:4F60 H176
 H177   ABS:4FAA H177
 H178   ABS:4FC4 H178
 H179   ABS:4FA6 H179
 H180   ABS:4FBC H180
 H181   ABS:4FB6 H181
 H182   ABS:4FE6 H182
 H183   ABS:501C H183
 H184   ABS:5000 H184
 H185   ABS:502A H185
 H186   ABS:504E H186
 H187   ABS:5056 H187
 H188   ABS:507A H188
 H189   ABS:50C0 H189
 H190   ABS:50B8 H190
 H191   ABS:5166 H191
 H192   ABS:50CA H192
 H193   ABS:50E0 H193
 H194   ABS:50F6 H194
 H195   ABS:51DA H195
 H196   ABS:51FA H196
 H197   ABS:5200 H197
 H198   ABS:525C H198
 H199   ABS:526C H199
 H200   ABS:5354 H200
 H201   ABS:5388 H201
 H202   ABS:5396 H202
 H203   ABS:539C H203
 H204   ABS:53DA H204
 H205   ABS:53FC H205
 H206   ABS:53DE H206
 H207   ABS:5408 H207
 H208   ABS:542A H208
 H209   ABS:543A H209
 H210   ABS:54B0 H210
 H211   ABS:54DC H211
 H212   ABS:555C H212
 H213   ABS:5548 H213
 H214   ABS:54EA H214
 H215   ABS:54F6 H215
 H216   ABS:5518 H216
 H217   ABS:5502 H217
 H218   ABS:5544 H218
 H219   ABS:552A H219
 H220   ABS:5558 H220
 H221   ABS:5586 H221
 H222   ABS:5596 H222
 H223   ABS:5580 H223
 H224   ABS:55B2 H224
 H225   ABS:55BC H225
 H226   ABS:5616 H226
 H227   ABS:5692 H227
 H228   ABS:5688 H228
 H229   ABS:5678 H229
 H230   ABS:5682 H230
 H231   ABS:5690 H231
 H232   ABS:56B0 H232
 H233   ABS:56EA H233
 H234   ABS:56C0 H234
 H235   ABS:56E2 H235
 H236   ABS:5736 H236
 H237   ABS:575A H237
 H238   ABS:574C H238
 H239   ABS:5750 H239
 H240   ABS:5756 H240
 H241   ABS:5782 H241
 H242   ABS:579C H242
 H243   ABS:5792 H243
 H244   ABS:57C6 H244
 H245   ABS:57D0 H245
 H246   ABS:57CE H246
 H247   ABS:57D6 H247
 H248   ABS:57D8 H248
 H249   ABS:57EC H249
 H250   ABS:589A H250
 H251   ABS:592C H251
 H252   ABS:5932 H252
 H253   ABS:5984 H253
 H254   ABS:5950 H254
 H255   ABS:597E H255
 H256   ABS:5956 H256
 H257   ABS:595C H257
 H258   ABS:5978 H258
 H259   ABS:5998 H259
 H260   ABS:59DA H260
 H261   ABS:59BC H261
 H262   ABS:5A14 H262
 H263   ABS:5A68 H263
 H264   ABS:5B2C H264
 H265   ABS:5B26 H265
 H266   ABS:5AEE H266
 H267   ABS:5ABA H267
 H268   ABS:5AE4 H268
 H269   ABS:5B22 H269
 H270   ABS:5B06 H270
 H272   ABS:5B30 H272
 H273   ABS:5B4E H273
 H274   ABS:5BAE H274
 H275   ABS:5BCC H275
 H276   ABS:5BE0 H276
 H9900  ABS:5C68 H9900
 H9901  ABS:5C88 H9901
 H9902  ABS:5CCC H9902
 H9903  ABS:5D18 H9903
 H9904  ABS:5D24 H9904
 H9905  ABS:5D64 H9905
 H9906  ABS:5DB8 H9906
 H9907  ABS:5DC2 H9907
 H9908  ABS:5DD4 H9908
 H9909  ABS:5DE8 H9909
 H9910  ABS:5DEC H9910
 H9911  ABS:5E04 H9911
 H9912  ABS:5E4E H9912
 H9913  ABS:5E5E H9913
 H9914  ABS:5D2E H9914
 HONK   ABS:03D6 HONK
 INSFDR ABS:47CA INSFDR
 INT2FP ABS:57A4 INT2FP
 K001   ABS:416C K001
 K002   ABS:4312 K002
 K004   ABS:4314 K004
 K005   ABS:4315 K005
 K007   ABS:4313 K007
 K013   ABS:42C4 K013
 K014   ABS:4930 K014
 LASTRK ABS:42D2 LASTRK
 LDNXTS ABS:5D4C LDNXTS
 LDSK   ABS:5BF6 LDSK
 LDSK2  ABS:5D40 LDSK2
 LOAD   ABS:538C LOAD
 MDSK   ABS:5BFC MDSK
 MNDSK2 ABS:5C48 MNDSK2
 NDSK   ABS:5C02 NDSK
 NOCRU  ABS:416A NOCRU
 NOPARM ABS:5D9A NOPARM
 NTPDT  ABS:5DF2 NTPDT
 NTPFAT ABS:4026 NTPFAT
 NXTPRP ABS:5D80 NXTPRP
 OPCVEC ABS:4D5E OPCVEC
 OPEN   ABS:4D7E OPEN
 OPNDIR ABS:5572 OPNDIR
 PABR2B ABS:482A PABR2B
 PDSK   ABS:5BEA PDSK
 PESB07 ABS:5A72 PESB07
 PRFDRS ABS:4F3E PRFDRS
 PRPFDO ABS:43E4 PRPFDO
 PRPRTN ABS:43E6 PRPRTN
 PUDSK2 ABS:5C3E PUDSK2
 PWRUP  ABS:40D2 PWRUP
 QTDSTR ABS:5C4E QTDSTR
 QTLSSA ABS:5DAA QTLSSA
 R0     ABS:0000 R0
 R1     ABS:0001 R1
 R10    ABS:000A R10
 R11    ABS:000B R11
 R12    ABS:000C R12
 R13    ABS:000D R13
 R14    ABS:000E R14
 R15    ABS:000F R15
 R2     ABS:0002 R2
 R3     ABS:0003 R3
 R4     ABS:0004 R4
 R5     ABS:0005 R5
 R6     ABS:0006 R6
 R7     ABS:0007 R7
 R8     ABS:0008 R8
 R9     ABS:0009 R9
 RBANB  ABS:547E RBANB
 RCOFCB ABS:530E RCOFCB
 RDATA  ABS:5FF6 RDATA
 RDDIR  ABS:55E6 RDDIR
 RDFDR1 ABS:4A0A RDFDR1
 RDFDR2 ABS:4A06 RDFDR2
 RDINT  ABS:5FEA RDINT
 RDOFSC ABS:45EA RDOFSC
 RDSEC1 ABS:49F4 RDSEC1
 RDSK   ABS:5C08 RDSK
 READ   ABS:4F9A READ
 RETERR ABS:495E RETERR
 RFDRST ABS:51BA RFDRST
 RFDRVB ABS:5912 RFDRVB
 RFNPTR ABS:5B6C RFNPTR
 RMFPTR ABS:479A RMFPTR
 RNFISE ABS:5218 RNFISE
 RRFDR  ABS:5234 RRFDR
 RRNPAB ABS:51CE RRNPAB
 RRSEC  ABS:5020 RRSEC
 RSTAT  ABS:5FF0 RSTAT
 RSTDRV ABS:4286 RSTDRV
 RTN5C  ABS:4028 RTN5C
 RTURN1 ABS:4336 RTURN1
 RVRVDP ABS:439C RVRVDP
 RWIND1 ABS:5338 RWIND1
 RWIND2 ABS:5366 RWIND2
 RWSEC  ABS:4A0E RWSEC
 RWSECA ABS:4A10 RWSECA
 RWSECB ABS:4A12 RWSECB
 RWVIB  ABS:4992 RWVIB
 SAVE   ABS:542E SAVE
 SAVGRA ABS:5E62 SAVGRA
 SAVR11 ABS:5E64 SAVR11
 SCROLL ABS:56CD SCROLL
 SDIR   ABS:5C26 SDIR
 SDSK   ABS:5C20 SDSK
 SECRW1 ABS:416E SECRW1
 SELDRV ABS:4258 SELDRV
 SNDCMD ABS:42CA SNDCMD
 SP2VDP ABS:5BD6 SP2VDP
 STATUS ABS:54B2 STATUS
 SUB01  ABS:4010 SUB01
 SUB02  ABS:4016 SUB02
 SUB03  ABS:401C SUB03
 SUB04  ABS:4022 SUB04
 SUB05  ABS:402A SUB05
 SUB06  ABS:4030 SUB06
 SUB07  ABS:4036 SUB07
 SUB08  ABS:403C SUB08
 SUB09  ABS:4046 SUB09
 SUB10  ABS:4050 SUB10
 SUB11  ABS:405A SUB11
 SUB12  ABS:4064 SUB12
 SUB13  ABS:406E SUB13
 SUB14  ABS:4078 SUB14
 SUB15  ABS:4082 SUB15
 SUB16  ABS:408C SUB16
 SUB17  ABS:4096 SUB17
 SUB18  ABS:40A0 SUB18
 SUB19  ABS:40AA SUB19
 SUB20  ABS:40B4 SUB20
 SUB21  ABS:40BE SUB21
 SUB22  ABS:40C8 SUB22
 SVDPRD ABS:43D2 SVDPRD
 SVDPWR ABS:43C8 SVDPWR
 SVRVDP ABS:4370 SVRVDP
 TIME   ABS:5C38 TIME
 TIME2  ABS:5DFE TIME2
 UCOFCB ABS:52AC UCOFCB
 UDSK   ABS:5BF0 UDSK
 UFNCB  ABS:5B34 UFNCB
 UPDBF  ABS:4556 UPDBF
 UPDCLI ABS:4B92 UPDCLI
 UPDFCB ABS:4F68 UPDFCB
 UPDFDR ABS:4536 UPDFDR
 UQTSTR ABS:5CBA UQTSTR
 URFFDR ABS:52D8 URFFDR
 UWFLVB ABS:584A UWFLVB
 VARINF ABS:5DFA VARINF
 VDP2SP ABS:5BC6 VDP2SP
 VDPR2B ABS:4836 VDPR2B
 VDPRD  ABS:4300 VDPRD
 VDPRPW ABS:423E VDPRPW
 VDPWRI ABS:42F6 VDPWRI
 VECRTN ABS:4368 VECRTN
 WCOMND ABS:5FF8 WCOMND
 WDATA  ABS:5FFE WDATA
 WFDRPB ABS:4FFC WFDRPB
 WRFDR  ABS:4A00 WRFDR
 WRITE  ABS:5084 WRITE
 WROFSC ABS:460A WROFSC
 WRSEC1 ABS:49F6 WRSEC1
 WSECTR ABS:5FFC WSECTR
 WTCPT1 ABS:424A WTCPT1
 XML14  ABS:164E XML14
 XML16  ABS:15D6 XML16
 XML5C  ABS:105C XML5C
 XMLRTN ABS:2244 XMLRTN
